Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 2949)
+++ station_cmd.c	(working copy)
@@ -26,6 +26,11 @@
 #include "sprite.h"
 #include "depot.h"
 #include "pbs.h"
+#include "string.h"
+#include "strings.h"
+#include "newgrf_callbacks.h"
+#include "newgrf.h"
+#include "engine.h" // Cargo IDs???
 
 enum {
 	/* Max stations: 64000 (64 * 1000) */
@@ -35,6 +40,9 @@
 	/* Max roadstops: 64000 (32 * 2000) */
 	ROADSTOP_POOL_BLOCK_SIZE_BITS = 5,       /* In bits, so (1 << 5) == 32 */
 	ROADSTOP_POOL_MAX_BLOCKS      = 2000,
+
+	/* Max station classes */
+	STAT_CLASS_MAX = 32,
 };
 
 /**
@@ -85,6 +93,11 @@
 	}
 }
 
+void MarkWholeStationDirty(Station *st)
+{
+	MarkStationDirty(st);
+}
+
 static void InitializeRoadStop(RoadStop *road_stop, RoadStop *previous, TileIndex tile, StationID index)
 {
 	road_stop->xy = tile;
@@ -281,6 +294,187 @@
 	return NULL;
 }
 
+/**
+ * Marks a StationSegment as deleted.
+ * @param st Station.
+ * @param segid Segment index.
+ */
+static void StationSegmentDelete(Station *st, byte segid)
+{
+	int i = st->num_segments;
+	st->segments[segid].tile = INVALID_TILE;
+	free(st->segments[segid].random_bits);
+
+	while (i > 0 && st->segments[i-1].tile == INVALID_TILE) {
+		i--;
+	}
+
+	if (i == 0) {
+		// All segments are deleted so free the memory.
+		free(st->segments);
+		st->segments = NULL;
+		st->num_segments = 0;
+	} else if (i < st->num_segments) {
+		// Empty segments at end of list, free the unused memory.
+		st->segments = realloc(st->segments, i * sizeof(StationSegment));
+		st->num_segments = i;
+	}
+}
+
+/**
+ * Checks if a StationSegment is still valid by looping on all the tiles of
+ * the segment and checking that each tile is a station tile, in the correct
+ * station and with this segment index. If at least one does, then the segment
+ * is still in use.
+ * @param st Station.
+ * @param segid Segment index.
+ * @return True if the segment is in use.
+ */
+static bool StationSegmentInUse(Station *st, byte segid)
+{
+	StationSegment *segment = &st->segments[segid];
+	int h, w;
+
+	if (segment->direction) {
+		h = segment->length;
+		w = segment->platforms;
+	} else {
+		w = segment->length;
+		h = segment->platforms;
+	}
+
+	BEGIN_TILE_LOOP(t, w, h, segment->tile) {
+		if (IsTileType(t, MP_STATION) && _m[t].m2 == st->index && _m[t].m4 == segid)
+			return true;
+	} END_TILE_LOOP(t, w, h, segment->tile)
+
+	return false;
+}
+
+/**
+ * Returns an unused StationSegment.
+ * platforms and length are only used to calculate the size of the random bit array.
+ * @param st Station.
+ * @param platforms Number of platforms.
+ * @param length Length of platforms.
+ * @return Index of segment.
+ */
+static int StationSegmentAllocate(Station *st, byte platforms, byte length)
+{
+	int i;
+
+	for (i = 0; i < st->num_segments; i++) {
+		if (st->segments[i].tile == INVALID_TILE) {
+			/* Reuse existing deleted segment. */
+			st->segments[i].random_bits = malloc((platforms * length));
+			return i;
+		} else if (!StationSegmentInUse(st, i)) {
+			/* Segments can be overwritten but not deleted. Here we have found
+			 * such a segment, so reuse it. */
+			free(st->segments[i].random_bits);
+			st->segments[i].random_bits = malloc((platforms * length));
+			return i;
+		}
+	}
+
+	st->num_segments++;
+	st->segments = realloc(st->segments, st->num_segments * sizeof(StationSegment));
+	st->segments[i].random_bits = malloc((platforms * length));
+	return i;
+}
+
+static inline byte StationSegmentRandomBitsGet(StationSegment *segment, TileIndex tile)
+{
+	byte x = TileX(tile) - TileX(segment->tile);
+	byte y = TileY(tile) - TileY(segment->tile);
+	byte m = segment->direction ? segment->platforms : segment->length;
+	uint16 pos = x + y * m;
+
+	//return segment->random_bits[pos >> 1] & (0xF << (pos & 1));
+	return segment->random_bits[pos] & 0xF;
+}
+
+void StationSegmentRandomBitsSet(StationSegment *segment, TileIndex tile, byte bits)
+{
+	byte x = TileX(tile) - TileX(segment->tile);
+	byte y = TileY(tile) - TileY(segment->tile);
+	byte m = segment->direction ? segment->platforms : segment->length;
+	uint16 pos = x + y * m;
+
+	assert(bits < 16);
+	//segment->random_bits[pos >> 1] &= ~(0xF << (pos & 1)); // Clear the old bits
+	//segment->random_bits[pos >> 1] |= bits << (pos & 1);
+	segment->random_bits[pos] = bits;
+}
+
+/**
+ * Gets the top left tile of the station.
+ * @param st Station.
+ * @return TileIndex of top left tile.
+ */
+static TileIndex StationGetTopLeft(Station *st)
+{
+	int i;
+	uint minx = INVALID_TILE;
+	uint miny = INVALID_TILE;
+
+	if (st->num_segments == 0)
+		return st->xy;
+
+	for (i = 0; i < st->num_segments; i++) {
+		uint tilex, tiley;
+
+		if (st->segments[i].tile == INVALID_TILE)
+			continue;
+
+		tilex = TileX(st->segments[i].tile);
+		tiley = TileY(st->segments[i].tile);
+
+		if (tilex < minx) minx = tilex;
+		if (tiley < miny) miny = tiley;
+	}
+
+	return TileXY(minx, miny);
+}
+
+/**
+ * Gets the bottom right corner of the station.
+ * @param st Station.
+ * @return TileIndex of bottom right tile.
+ */
+static TileIndex StationGetBottomRight(Station *st)
+{
+	int i;
+	uint maxx = 0;
+	uint maxy = 0;
+
+	if (st->num_segments == 0)
+		return st->xy;
+
+	for (i = 0; i < st->num_segments; i++) {
+		uint tilex, tiley;
+		uint w, h;
+
+		if (st->segments[i].tile == INVALID_TILE)
+			continue;
+
+		tilex = TileX(st->segments[i].tile);
+		tiley = TileY(st->segments[i].tile);
+
+		if (st->segments[i].direction) {
+			h = st->segments[i].length;
+			w = st->segments[i].platforms;
+		} else {
+			w = st->segments[i].length;
+			h = st->segments[i].platforms;
+		}
+
+		if (tilex + w > maxx) maxx = tilex + w;
+		if (tiley + h > maxy) maxy = tiley + h;
+	}
+
+	return TileXY(maxx - 1, maxy - 1);
+}
 
 static int CountMapSquareAround(TileIndex tile, byte type, byte min, byte max)
 {
@@ -468,6 +662,10 @@
 		ge->feeder_profit = 0;
 	}
 
+	st->random_bits = Random();
+	st->num_segments = 0;
+	st->segments = NULL;
+
 	_global_station_sort_dirty = true; // build a new station
 }
 
@@ -935,161 +1133,6 @@
 	}
 }
 
-/** Build railroad station
- * @param x,y starting position of station dragging/placement
- * @param p1 various bitstuffed elements
- * - p1 = (bit  0)    - orientation (p1 & 1)
- * - p1 = (bit  8-15) - number of tracks
- * - p1 = (bit 16-23) - platform length
- * @param p2 various bitstuffed elements
- * - p2 = (bit  0- 3) - railtype (p2 & 0xF)
- * - p2 = (bit  4)    - set for custom station (p2 & 0x10)
- * - p2 = (bit  8-..) - custom station id (p2 >> 8)
- */
-int32 CmdBuildRailroadStation(int x, int y, uint32 flags, uint32 p1, uint32 p2)
-{
-	Station *st;
-	TileIndex tile_org;
-	int w_org, h_org;
-	int32 cost, ret;
-	int est;
-	int plat_len, numtracks;
-	int direction;
-	uint finalvalues[3];
-
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
-	tile_org = TileVirtXY(x, y);
-
-	/* Does the authority allow this? */
-	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile_org)) return CMD_ERROR;
-	if (!ValParamRailtype(p2 & 0xF)) return CMD_ERROR;
-
-	/* unpack parameters */
-	direction = p1 & 1;
-	numtracks = GB(p1,  8, 8);
-	plat_len  = GB(p1, 16, 8);
-	/* w = length, h = num_tracks */
-	if (direction) {
-		h_org = plat_len;
-		w_org = numtracks;
-	} else {
-		w_org = plat_len;
-		h_org = numtracks;
-	}
-
-	if (h_org > _patches.station_spread || w_org > _patches.station_spread) return CMD_ERROR;
-
-	// these values are those that will be stored in train_tile and station_platforms
-	finalvalues[0] = tile_org;
-	finalvalues[1] = w_org;
-	finalvalues[2] = h_org;
-
-	// Make sure the area below consists of clear tiles. (OR tiles belonging to a certain rail station)
-	est = -1;
-	// If DC_EXEC is in flag, do not want to pass it to CheckFlatLandBelow, because of a nice bug
-	//  for detail info, see: https://sourceforge.net/tracker/index.php?func=detail&aid=1029064&group_id=103924&atid=636365
-	if (CmdFailed(ret = CheckFlatLandBelow(tile_org, w_org, h_org, flags&~DC_EXEC, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
-	cost = ret + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len;
-
-	// Make sure there are no similar stations around us.
-	st = GetStationAround(tile_org, w_org, h_org, est);
-	if (st == CHECK_STATIONS_ERR) return CMD_ERROR;
-
-	// See if there is a deleted station close to us.
-	if (st == NULL) {
-		st = GetClosestStationFromTile(tile_org, 8, _current_player);
-		if (st != NULL && st->facilities) st = NULL;
-	}
-
-	if (st != NULL) {
-		// Reuse an existing station.
-		if (st->owner != OWNER_NONE && st->owner != _current_player)
-			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
-
-		if (st->train_tile != 0) {
-			// check if we want to expanding an already existing station?
-			if (_is_old_ai_player || !_patches.join_stations)
-				return_cmd_error(STR_3005_TOO_CLOSE_TO_ANOTHER_RAILROAD);
-			if (!CanExpandRailroadStation(st, finalvalues, direction))
-				return CMD_ERROR;
-		}
-
-		//XXX can't we pack this in the "else" part of the if above?
-		if (!CheckStationSpreadOut(st, tile_org, w_org, h_org))
-			return CMD_ERROR;
-
-	}	else {
-		// Create a new station
-		st = AllocateStation();
-		if (st == NULL)
-			return CMD_ERROR;
-
-		st->town = ClosestTownFromTile(tile_org, (uint)-1);
-		if (_current_player < MAX_PLAYERS && flags&DC_EXEC)
-			SETBIT(st->town->have_ratings, _current_player);
-
-		if (!GenerateStationName(st, tile_org, 0))
-			return CMD_ERROR;
-
-		if (flags & DC_EXEC)
-			StationInitialize(st, tile_org);
-	}
-
-	if (flags & DC_EXEC) {
-		TileIndexDiff tile_delta;
-		byte *layout_ptr;
-		StationID station_index = st->index;
-		StationSpec *statspec;
-
-		// Now really clear the land below the station
-		// It should never return CMD_ERROR.. but you never know ;)
-		//  (a bit strange function name for it, but it really does clear the land, when DC_EXEC is in flags)
-		if (CmdFailed(CheckFlatLandBelow(tile_org, w_org, h_org, flags, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
-
-		st->train_tile = finalvalues[0];
-		if (!st->facilities) st->xy = finalvalues[0];
-		st->facilities |= FACIL_TRAIN;
-		st->owner = _current_player;
-
-		st->trainst_w = finalvalues[1];
-		st->trainst_h = finalvalues[2];
-
-		st->build_date = _date;
-
-		tile_delta = direction ? TileDiffXY(0, 1) : TileDiffXY(1, 0);
-
-		statspec = (p2 & 0x10) != 0 ? GetCustomStation(STAT_CLASS_DFLT, p2 >> 8) : NULL;
-		layout_ptr = alloca(numtracks * plat_len);
-		GetStationLayout(layout_ptr, numtracks, plat_len, statspec);
-
-		do {
-			TileIndex tile = tile_org;
-			int w = plat_len;
-			do {
-
-				ModifyTile(tile,
-					MP_SETTYPE(MP_STATION) | MP_MAPOWNER_CURRENT |
-					MP_MAP2 | MP_MAP5 | MP_MAP3LO | MP_MAP3HI,
-					station_index, /* map2 parameter */
-					p2 & 0xFF,     /* map3lo parameter */
-					p2 >> 8,       /* map3hi parameter */
-					(*layout_ptr++) + direction   /* map5 parameter */
-				);
-
-				tile += tile_delta;
-			} while (--w);
-			tile_org += tile_delta ^ TileDiffXY(1, 1); // perpendicular to tile_delta
-		} while (--numtracks);
-
-		UpdateStationVirtCoordDirty(st);
-		UpdateStationAcceptance(st, false);
-		InvalidateWindow(WC_STATION_LIST, st->owner);
-	}
-
-	return cost;
-}
-
 static bool TileBelongsToRailStation(Station *st, TileIndex tile)
 {
 	return IsTileType(tile, MP_STATION) && _m[tile].m2 == st->index && _m[tile].m5 < 8;
@@ -1147,233 +1190,754 @@
 		tile = 0;
 	}
 
-	st->trainst_w = w;
-	st->trainst_h = h;
-	st->train_tile = tile;
-}
+	st->trainst_w = w;
+	st->trainst_h = h;
+	st->train_tile = tile;
+}
+
+/** Remove a single tile from a railroad station.
+ * This allows for custom-built station with holes and weird layouts
+ * @param x,y tile coordinates to remove
+ * @param p1 unused
+ * @param p2 unused
+ */
+int32 CmdRemoveFromRailroadStation(int x, int y, uint32 flags, uint32 p1, uint32 p2)
+{
+	TileIndex tile = TileVirtXY(x, y);
+	Station *st;
+
+	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
+
+	// make sure the specified tile belongs to the current player, and that it is a railroad station.
+	if (!IsTileType(tile, MP_STATION) || _m[tile].m5 >= 8 || !_patches.nonuniform_stations) return CMD_ERROR;
+	st = GetStation(_m[tile].m2);
+	if (_current_player != OWNER_WATER && (!CheckOwnership(st->owner) || !EnsureNoVehicle(tile))) return CMD_ERROR;
+
+	// if we reached here, it means we can actually delete it. do that.
+	if (flags & DC_EXEC) {
+		if (HASBIT(_m[tile].m3, 4)) {
+			/* This is a custom station tile. We should check if its segment
+			 * is still valid */
+			byte segment_id = _m[tile].m4;
+			DoClearSquare(tile);
+			if (!StationSegmentInUse(st, segment_id)) {
+				StationSegmentDelete(st, segment_id);
+				st->topleft = StationGetTopLeft(st);
+				st->bottomright = StationGetBottomRight(st);
+				MarkWholeStationDirty(st);
+			}
+		} else {
+			DoClearSquare(tile);
+		}
+		// now we need to make the "spanned" area of the railway station smaller if we deleted something at the edges.
+		// we also need to adjust train_tile.
+		MakeRailwayStationAreaSmaller(st);
+
+		// if we deleted the whole station, delete the train facility.
+		if (st->train_tile == 0) {
+			st->facilities &= ~FACIL_TRAIN;
+			UpdateStationVirtCoordDirty(st);
+			DeleteStationIfEmpty(st);
+		}
+	}
+	return _price.remove_rail_station;
+}
+
+// determine the number of platforms for the station
+uint GetStationPlatforms(Station *st, TileIndex tile)
+{
+	uint t;
+	int dir,delta;
+	int len;
+	assert(TileBelongsToRailStation(st, tile));
+
+	len = 0;
+	dir = _m[tile].m5&1;
+	delta = dir ? TileDiffXY(0, 1) : TileDiffXY(1, 0);
+
+	// find starting tile..
+	t = tile;
+	do { t -= delta; len++; } while (TileBelongsToRailStation(st, t) && (_m[t].m5&1) == dir);
+
+	// find ending tile
+	t = tile;
+	do { t += delta; len++; }while (TileBelongsToRailStation(st, t) && (_m[t].m5&1) == dir);
+
+	return len - 1;
+}
+
+
+/* TODO: Custom classes! */
+/* Indexed by class, just STAT_CLASS_DFLT and STAT_CLASS_WAYP supported. */
+static int _statspec_highest_id[STAT_CLASS_MAX] = {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
+static StationSpec *_station_spec[STAT_CLASS_MAX][256];
+static uint32 _station_class[STAT_CLASS_MAX] = {'DFLT', 'WAYP', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // Station Class IDs
+const char *_station_class_names[STAT_CLASS_MAX] = {"Default", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""}; // Station Class Names
+
+int AllocateCustomStationClass(uint32 classid)
+{
+	int id;
+	for (id = 0; id < STAT_CLASS_MAX; id++) {
+		if (_station_class[id] == classid) {
+			// classid exists, use it.
+			return id;
+		} else if (_station_class[id] == 0) {
+			// Allocate this id.
+			_station_class[id] = classid;
+			return id;
+		}
+	}
+
+	printf("SHOULDN'T BE HERE\n");
+	return 0;
+}
+
+void SetCustomStationClassName(int classid, const char *name)
+{
+	assert(classid < STAT_CLASS_MAX);
+	_station_class_names[classid] = strdup(name);
+}
+
+StringID GetCustomStationClassName(int classid)
+{
+	assert(classid < STAT_CLASS_MAX);
+	if (!_station_class_names[classid])
+		return 0;
+	ttd_strlcpy(_userstring, _station_class_names[classid], lengthof(_userstring));
+	return STR_SPEC_USERSTRING;
+}
+
+StringID CustomStationGetStationName(StationSpec *spec)
+{
+	if (spec == NULL || spec->name == NULL)
+		return STR_01A9_NONE;
+	ttd_strlcpy(_userstring, spec->name, lengthof(_userstring));
+	return STR_SPEC_USERSTRING;
+}
+
+int GetNumCustomStationClasses(void)
+{
+	int i, j = 0;
+
+	for (i = 0; i < STAT_CLASS_MAX; i++, j++) {
+		if (_station_class[i] == 0)
+			return j;
+		if (_station_class[i] == 'WAYP')
+			j--;
+	}
+
+	return j;
+}
+
+StringID *BuildCustomStationClassDropdown(void)
+{
+	int i;
+	static StringID buf[STAT_CLASS_MAX + 1];
+	StringID *p = buf;
+	for (i = 0; i < STAT_CLASS_MAX; i++) {
+		if (_station_class[i] == 0)
+			break;
+		//if (_station_class[i] == 'WAYP')
+		//	continue;
+
+		// THIS IS TOTALLY WRONG
+		if (_station_class_names[i])
+			*p++ = SPECSTR_STATIONCLASS_START + i;
+			//*p++ = AllocateName(_station_class_names[i], 0);
+	}
+	*p = INVALID_STRING_ID;
+	return buf;
+}
+
+void SetCustomStation(byte local_stid, StationSpec *spec)
+{
+	StationClass sclass;
+	int stid = -1;
+
+	assert(spec->sclass < STAT_CLASS_MAX);
+	sclass = spec->sclass;
+
+	if (spec->localidx != 0) {
+		/* Already allocated, try to resolve to global stid */
+		int i = 0;
+
+		if (spec->sclass == STAT_CLASS_DFLT) i++;
+
+		for (; i <= _statspec_highest_id[sclass]; i++) {
+			if (_station_spec[sclass][i]->grfid == spec->grfid &&
+					_station_spec[sclass][i]->localidx == local_stid + 1) {
+				stid = i;
+				/* FIXME: Release original SpriteGroup to
+				 * prevent leaks. But first we need to
+				 * refcount the SpriteGroup. --pasky */
+				break;
+			}
+		}
+	}
+
+	if (stid == -1) {
+		/* Allocate new one. */
+		if (_statspec_highest_id[sclass] >= 255) {
+			error("Too many custom stations allocated.");
+			return;
+		}
+		stid = ++_statspec_highest_id[sclass];
+		spec->localidx = local_stid + 1;
+	}
+
+	//debug("Registering station #%d of class %d", stid, sclass);
+	_station_spec[sclass][stid] = spec;
+}
+
+StationSpec *GetCustomStation(StationClass sclass, byte stid)
+{
+	assert(sclass < STAT_CLASS_MAX);
+	//debug("Asking for station #%d of class %d", stid, sclass);
+	if (stid > _statspec_highest_id[sclass])
+		return NULL;
+	return _station_spec[sclass][stid];
+}
+
+/* from waypoint.c */
+extern Station *ComposeWaypointStation(TileIndex tile);
+
+static byte eval_cargo_type;
+
+uint16 EvalRealStation(RealSpriteGroup *rsg, int object)
+{
+	int cargo = 0;
+	int cargo_threshold = 0;
+
+	if (object != -1) {
+		TileIndex tile = object;
+
+		if (IsTileType(tile, MP_RAILWAY)) {
+			/* Waypoint */
+			cargo = 0;
+			cargo_threshold = 0;
+		} else {
+			/* Station */
+			Station *st = GetStation(_m[tile].m2);
+			StationSegment *segment = &st->segments[_m[tile].m4];
+			StationSpec *spec = GetCustomStation(segment->sclass, segment->cstation);
+			byte cargo_type = _local_cargo_id_ctype[eval_cargo_type];
+			if (cargo_type != CT_INVALID) {
+				cargo = st->goods[cargo_type].waiting_acceptance & 0xfff;
+			} else {
+				for (cargo_type = 0; cargo_type < NUM_CARGO; cargo_type++) {
+					cargo += st->goods[cargo_type].waiting_acceptance & 0xfff;
+				}
+			}
+			cargo_threshold = spec->cargo_threshold;
+
+			if (HASBIT(spec->flags, 1)) {
+				cargo /= (st->trainst_w + st->trainst_h);
+			}
+
+			cargo = min(cargo, 0xfff);
+		}
+	}
+
+	if (cargo >= cargo_threshold) {
+		if (rsg->loading_count > 0)
+			return rsg->loading[((cargo - cargo_threshold) * rsg->loading_count) / (4095 - cargo_threshold)];
+		DEBUG(grf, 1)("Cargo above threshold but no sprites associated?");
+	} else {
+		if (rsg->loaded_count > 0)
+			return rsg->loaded[(cargo * rsg->loaded_count) / cargo_threshold];
+		DEBUG(grf, 1)("Cargo below threshold but no sprites associated.");
+	}
+
+	//debug("cargo %d, threshold %d, loading_count %d, loaded_count %d", cargo, cargo_threshold, rsg->loading_count, rsg->loaded_count);
+	//debug("%x, %x", rsg->loading[0], rsg->loaded[0]);
+
+	//error("No sprites associated");
+	return rsg->loading[0];
+	//return 0x42d;
+}
+
+int EvalDeterministicStation(int variable, byte parameter, int object)
+{
+	TileIndex tile;
+	Station *st;
+	StationSegment *segment;
+	byte tiletype; /* Used by varaction 40/41/46/47 */
+
+	if (object == -1) {
+		/* Handle unbuilt objects */
+		switch (variable) {
+			case 0x10: return 0x2110000; /* Platforms, tracks & position */
+			case 0x42: return 0;         /* Track type */
+			case 0xFA: return _date;     /* Build date */
+			default: return -1;
+		}
+	}
+
+	tile = object;
+	if (IsTileType(tile, MP_RAILWAY)) {
+		/* OpenTTD handles waypoints differently to TTDPatch. Here we create a fake station for them. */
+		st = ComposeWaypointStation(tile);
+		segment = &st->segments[0];
+		tiletype = GB(_m[tile].m5, 0, 1);
+	} else {
+		st = GetStation(_m[tile].m2);
+		segment = &st->segments[_m[tile].m4];
+		tiletype = GB(_m[tile].m5, 0, 3);
+	}
+
+	switch (variable) {
+		case 0x10:
+		case 0x40:
+		case 0x41:
+		case 0x46:
+		case 0x47:
+			/* FIXME: This is ad hoc only
+			 * for waypoints. */
+			if (segment->sclass == STAT_CLASS_WAYP) {
+				return 0x2110000;
+			} else {
+				/* xTNLcCpP */
+				byte platform, position, platforms, length;
+				TileIndex starttile;
+				if (variable == 0x40 || variable == 0x46) {
+					/* Value based on whole station */
+					starttile = st->topleft;
+					if (segment->direction) {
+						platforms = TileX(st->bottomright) - TileX(st->topleft) + 1;
+						length = TileY(st->bottomright) - TileY(st->topleft) + 1;
+					} else {
+						platforms = TileY(st->bottomright) - TileY(st->topleft) + 1;
+						length = TileX(st->bottomright) - TileX(st->topleft) + 1;
+					}
+				} else {
+					/* Value based on this segment */
+					starttile = segment->tile;
+					platforms = segment->platforms;
+					length = segment->length;
+				}
+
+				if (segment->direction) {
+					platform = TileX(tile) - TileX(starttile);
+					position = TileY(tile) - TileY(starttile);
+				} else {
+					platform = TileY(tile) - TileY(starttile);
+					position = TileX(tile) - TileX(starttile);
+				}
+
+				if (variable == 0x46 || variable == 0x47) {
+					// XXX Make relative
+					platform -= platforms / 2;
+					position -= length / 2;
+				}
+
+				return
+					tiletype << 24 |
+					platforms << 20 |
+					length << 16 |
+					platform << 8 |
+					(platforms - platform - 1) << 12 |
+					position << 0 |
+					(length - position - 1) << 4;
+			}
+
+		case 0x42: {
+			/* Terrain and track type */
+			int value = 0;
+			switch(_m[tile].m3 & 0xF) {
+				case 0: value |= 0 << 8; break; // Railroad
+				case 1: value |= 2 << 8; break; // Monorail
+				case 2: value |= 3 << 8; break; // Maglev
+			}
+			return value;
+		}
+
+		case 0x43:
+			/* Player info 00ttmmnn */
+			return st->owner;
+
+		case 0x44:
+			/* PBS information */
+			if (PBSTileReserved(tile)) {
+				return 7;
+			} else {
+				return 4;
+			}
+
+		case 0x48: {
+			/* Accepted cargo types */
+			byte cargo_type;
+			int value = 0;
+			for (cargo_type = 0; cargo_type < NUM_CARGO; cargo_type++)
+				if (HASBIT(st->goods[cargo_type].waiting_acceptance, 15))
+					SETBIT(value, cargo_type);
+			return value;
+		}
+
+		/* Variables 0x60 to 0x7F require parameter */
+		case 0x60:
+			/* Amount of cargo waiting */
+			return st->goods[parameter].waiting_acceptance & 0xfff;
+
+		case 0x61:
+			/* Time since pickup. Unit should be 185 ticks, approx 2.5 days (?) */
+			return st->goods[parameter].days_since_pickup;
+
+		case 0x62:
+			/* Rating */
+			return st->goods[parameter].rating;
+
+		case 0x63:
+			return st->goods[parameter].enroute_time;
+
+		case 0x64:
+			return st->goods[parameter].last_speed | (st->goods[parameter].last_age << 8);
+	}
+
+	switch (variable - 0x70) {
+		case 0x12: return 50; ///< Why is newstations wanting this?
+		case 0x14: return st->string_id;
+		case 0x16: return 0;
+		case 0x1A: return st->had_vehicle_of_type;
+		case 0x80: return st->facilities;
+		case 0x81: return st->airport_type;
+		case 0x82: return st->truck_stops->status;
+		case 0x83: return st->bus_stops->status;
+		case 0x86: return st->airport_flags & 0xFFFF;
+		case 0x87: return st->airport_flags & 0xFF;
+		case 0x8A: return st->build_date;
+	}
+
+	if (variable >= 0x8C && variable <= 0xEC) {
+		GoodsEntry *g = &st->goods[(variable - 0x8C) >> 3];
+		switch ((variable - 0x8C) % 8) {
+			case 0: return g->waiting_acceptance;
+			case 1: return g->waiting_acceptance & 0xFF;
+			case 2: return g->days_since_pickup;
+			case 3: return g->rating;
+			case 4: return g->enroute_from;
+			case 5: return g->enroute_time;
+			case 6: return g->last_speed;
+			case 7: return g->last_age;
+		}
+	}
+
+	DEBUG(grf, 1)("EvalDeterministicStation: Unhandled variable `0x%x' in spritegroup", variable);
+	return -1;
+}
+
+uint32 EvalRandomBitsStation(int object)
+{
+	if (object == -1) {
+		return 0;
+	} else {
+		TileIndex tile = object;
+		Station *st = GetStation(_m[tile].m2);
+		StationSegment *segment = &st->segments[_m[tile].m4];
+		return st->random_bits | (StationSegmentRandomBitsGet(segment, tile) << 16);
+	}
+}
+
+uint16 GetStationCallBackResult(uint16 callback_info, StationSpec *spec, Station *stat, TileIndex tile)
+{
+	byte cargo = GC_DEFAULT;
+	uint16 result;
+
+	eval_cargo_type = cargo;
+	result = ResolveSpriteGroup(&spec->spritegroup[cargo], tile, callback_info, 4, (resolve_callback) ResolveSpriteGroup);
+
+	if (result == 0 && cargo != GC_DEFAULT) {
+		result = ResolveSpriteGroup(&spec->spritegroup[GC_DEFAULT], tile, callback_info, 4, (resolve_callback) ResolveSpriteGroup);
+	}
+
+	if (!HASBIT(result, 15))
+		return CALLBACK_FAILED;
+
+	if ((result & 0xff00) == 0xff00)
+		return result & 0xff;
+
+	return result & 0x7fff;
+}
+/*
+static uint16 TriggerStationSpriteGroup(const SpriteGroup *spritegroup,
+	int object, uint16 callback_info, byte feature, resolve_callback resolve_func)
+{
+	if (object != -1) {
+		if (spritegroup->type == SGT_RANDOMIZED) {
+			_vsg_bits_to_reseed |= RandomizedSpriteGroupTriggeredBits(
+				&spritegroup->g.random,
+				_vsg_random_triggers,
+				&GetStation(_m[object].m2)->waiting_triggers
+			);
+		}
+	}
+
+	return ResolveSpriteGroup(spritegroup, object, callback_info, feature, resolve_func);
+}
+
+static void DoTriggerStation(TileIndex tile, StationTrigger trigger, byte base_random_bits, byte cargo_type)
+{
+	byte new_random_bits;
+	uint16 result;
+	Station *st;
+	StationSpec *spec;
+
+	// Check this is a custom station segment.
+	if (!HASBIT(_m[tile].m3, 4))
+		return;
+
+	st = GetStation(_m[tile].m2);
+	spec = &st->segments[_m[tile].m4];
+
+	// Check property 0x12, cargo types for random triggers
+	if (!HASBIT(spec->cargotriggers, cargo_type))
+		return;
+
+	_vsg_random_triggers = trigger;
+	_vsg_bits_to_reseed = 0;
+	result = TriggerStationSpriteGroup(tile, 0, 0, (resolve_callback) TriggerStationSpriteGroup);
+	if (result == 0xffff && cargo_type != GC_DEFAULT) {
+		result = TriggerStationSpriteGroup(tile, 0, 0, (resolve_callback) TriggerStationSpriteGroup);
+	}
+
+	new_random_bits = Random();
+	st->random_bits &= ~(_vsg_bits_to_reseed & 0xffff);
+	st->random_bits |= new_random_bits & (_vsg_bits_to_reseed & 0xffff);
+
+	//switch (trigger)
+}*/
+
+uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte cargo_type, TileIndex tile)
+{
+	uint16 result;
+	//debug("Starting relocation for %x", tile);
+	eval_cargo_type = cargo_type;
+	result = ResolveSpriteGroup(&spec->spritegroup[cargo_type], tile, 0, 4, (resolve_callback) ResolveSpriteGroup);
+	//debug("Relocation for %x = %x", tile, result);
+	if (result == 0)
+		return 0x42D;
+	return result;
+}
+
+int GetCustomStationsCount(StationClass sclass)
+{
+	assert(sclass < STAT_CLASS_MAX);
+	return _statspec_highest_id[sclass] + 1;
+}
+
+/** Build railroad station
+ * @param x,y starting position of station dragging/placement
+ * @param p1 various bitstuffed elements
+ * - p1 = (bit  0)    - orientation (p1 & 1)
+ * - p1 = (bit  8-15) - number of tracks
+ * - p1 = (bit 16-23) - platform length
+ * @param p2 various bitstuffed elements
+ * - p2 = (bit  0- 3) - railtype (p2 & 0xF)
+ * - p2 = (bit  4)    - set for custom station (p2 & 0x10)
+ * - p2 = (bit  8-15) - custom station id (p2 >> 8)
+ * - p2 = (bit 16-19) - custom station class (p2 >> 16)
+ */
+int32 CmdBuildRailroadStation(int x, int y, uint32 flags, uint32 p1, uint32 p2)
+{
+	Station *st;
+	TileIndex tile_org;
+	int w_org, h_org;
+	int32 cost, ret;
+	int est;
+	int plat_len, numtracks;
+	int direction;
+	uint finalvalues[3];
+
+	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
+
+	tile_org = TileVirtXY(x, y);
+
+	/* Does the authority allow this? */
+	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile_org)) return CMD_ERROR;
+	if (!ValParamRailtype(p2 & 0xF)) return CMD_ERROR;
+
+	/* unpack parameters */
+	direction = p1 & 1;
+	numtracks = GB(p1,  8, 8);
+	plat_len  = GB(p1, 16, 8);
+	/* w = length, h = num_tracks */
+	if (direction) {
+		h_org = plat_len;
+		w_org = numtracks;
+	} else {
+		w_org = plat_len;
+		h_org = numtracks;
+	}
+
+	if (h_org > _patches.station_spread || w_org > _patches.station_spread) return CMD_ERROR;
+
+	// these values are those that will be stored in train_tile and station_platforms
+	finalvalues[0] = tile_org;
+	finalvalues[1] = w_org;
+	finalvalues[2] = h_org;
+
+	// Make sure the area below consists of clear tiles. (OR tiles belonging to a certain rail station)
+	est = -1;
+	// If DC_EXEC is in flag, do not want to pass it to CheckFlatLandBelow, because of a nice bug
+	//  for detail info, see: https://sourceforge.net/tracker/index.php?func=detail&aid=1029064&group_id=103924&atid=636365
+	if (CmdFailed(ret = CheckFlatLandBelow(tile_org, w_org, h_org, flags&~DC_EXEC, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
+	cost = ret + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len;
 
-/** Remove a single tile from a railroad station.
- * This allows for custom-built station with holes and weird layouts
- * @param x,y tile coordinates to remove
- * @param p1 unused
- * @param p2 unused
- */
-int32 CmdRemoveFromRailroadStation(int x, int y, uint32 flags, uint32 p1, uint32 p2)
-{
-	TileIndex tile = TileVirtXY(x, y);
-	Station *st;
+	// Make sure there are no similar stations around us.
+	st = GetStationAround(tile_org, w_org, h_org, est);
+	if (st == CHECK_STATIONS_ERR) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
+	if (HASBIT(p2, 4)) {
+		// This is a custom station segment
+		StationSpec *statspec = GetCustomStation((p2 >> 16) & 0xF, (p2 >> 8) & 0xFF);
+
+		// If the spec doesn't exist then probably server/client stations are
+		// not the same
+		if (!statspec)
+			return CMD_ERROR;
 
-	// make sure the specified tile belongs to the current player, and that it is a railroad station.
-	if (!IsTileType(tile, MP_STATION) || _m[tile].m5 >= 8 || !_patches.nonuniform_stations) return CMD_ERROR;
-	st = GetStation(_m[tile].m2);
-	if (_current_player != OWNER_WATER && (!CheckOwnership(st->owner) || !EnsureNoVehicle(tile))) return CMD_ERROR;
+		// Check the size is permissible
+		if (HASBIT(statspec->disallowed_platforms, numtracks - 1) ||
+			HASBIT(statspec->disallowed_lengths, plat_len - 1))
+			return CMD_ERROR;
 
-	// if we reached here, it means we can actually delete it. do that.
-	if (flags & DC_EXEC) {
-		DoClearSquare(tile);
-		// now we need to make the "spanned" area of the railway station smaller if we deleted something at the edges.
-		// we also need to adjust train_tile.
-		MakeRailwayStationAreaSmaller(st);
+		// Check the station is available
+		if (HASBIT(statspec->callbackmask, CBM_AVAILABILITY) &&
+			GetStationCallBackResult(CBID_STATION_AVAILABILITY, statspec, NULL, INVALID_TILE) == 0)
+			return CMD_ERROR;
+	}
 
-		// if we deleted the whole station, delete the train facility.
-		if (st->train_tile == 0) {
-			st->facilities &= ~FACIL_TRAIN;
-			UpdateStationVirtCoordDirty(st);
-			DeleteStationIfEmpty(st);
-		}
+	// See if there is a deleted station close to us.
+	if (st == NULL) {
+		st = GetClosestStationFromTile(tile_org, 8, _current_player);
+		if (st != NULL && st->facilities) st = NULL;
 	}
-	return _price.remove_rail_station;
-}
 
-// determine the number of platforms for the station
-uint GetStationPlatforms(Station *st, TileIndex tile)
-{
-	uint t;
-	int dir,delta;
-	int len;
-	assert(TileBelongsToRailStation(st, tile));
+	if (st != NULL) {
+		// Reuse an existing station.
+		if (st->owner != OWNER_NONE && st->owner != _current_player)
+			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
 
-	len = 0;
-	dir = _m[tile].m5&1;
-	delta = dir ? TileDiffXY(0, 1) : TileDiffXY(1, 0);
+		if (st->train_tile != 0) {
+			// check if we want to expanding an already existing station?
+			if (_is_old_ai_player || !_patches.join_stations)
+				return_cmd_error(STR_3005_TOO_CLOSE_TO_ANOTHER_RAILROAD);
+			if (!CanExpandRailroadStation(st, finalvalues, direction))
+				return CMD_ERROR;
+		}
 
-	// find starting tile..
-	t = tile;
-	do { t -= delta; len++; } while (TileBelongsToRailStation(st, t) && (_m[t].m5&1) == dir);
+		//XXX can't we pack this in the "else" part of the if above?
+		if (!CheckStationSpreadOut(st, tile_org, w_org, h_org))
+			return CMD_ERROR;
 
-	// find ending tile
-	t = tile;
-	do { t += delta; len++; }while (TileBelongsToRailStation(st, t) && (_m[t].m5&1) == dir);
+	}	else {
+		// Create a new station
+		st = AllocateStation();
+		if (st == NULL)
+			return CMD_ERROR;
 
-	return len - 1;
-}
+		st->town = ClosestTownFromTile(tile_org, (uint)-1);
+		if (_current_player < MAX_PLAYERS && flags&DC_EXEC)
+			SETBIT(st->town->have_ratings, _current_player);
 
+		if (!GenerateStationName(st, tile_org, 0))
+			return CMD_ERROR;
 
-/* TODO: Custom classes! */
-/* Indexed by class, just STAT_CLASS_DFLT and STAT_CLASS_WAYP supported. */
-static int _statspec_highest_id[2] = {-1, -1};
-static StationSpec _station_spec[2][256];
+		if (flags & DC_EXEC)
+			StationInitialize(st, tile_org);
+	}
 
-void SetCustomStation(byte local_stid, StationSpec *spec)
-{
-	StationClass sclass;
-	int stid = -1;
+	if (flags & DC_EXEC) {
+		TileIndexDiff tile_delta;
+		byte *layout_ptr;
+		StationID station_index = st->index;
+		StationSpec *statspec;
+		byte segid = 0;
 
-	assert(spec->sclass == STAT_CLASS_DFLT || spec->sclass == STAT_CLASS_WAYP);
-	sclass = spec->sclass - 1;
+		// Now really clear the land below the station
+		// It should never return CMD_ERROR.. but you never know ;)
+		//  (a bit strange function name for it, but it really does clear the land, when DC_EXEC is in flags)
+		if (CmdFailed(CheckFlatLandBelow(tile_org, w_org, h_org, flags, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
 
-	if (spec->localidx != 0) {
-		/* Already allocated, try to resolve to global stid */
-		int i;
+		st->train_tile = finalvalues[0];
+		if (!st->facilities) st->xy = finalvalues[0];
+		st->facilities |= FACIL_TRAIN;
+		st->owner = _current_player;
 
-		for (i = 0; i <= _statspec_highest_id[sclass]; i++) {
-			if (_station_spec[sclass][i].grfid == spec->grfid &&
-					_station_spec[sclass][i].localidx == local_stid + 1) {
-				stid = i;
-				/* FIXME: Release original SpriteGroup to
-				 * prevent leaks. But first we need to
-				 * refcount the SpriteGroup. --pasky */
-				break;
-			}
-		}
-	}
+		st->trainst_w = finalvalues[1];
+		st->trainst_h = finalvalues[2];
 
-	if (stid == -1) {
-		/* Allocate new one. */
-		if (_statspec_highest_id[sclass] >= 255) {
-			error("Too many custom stations allocated.");
-			return;
-		}
-		stid = ++_statspec_highest_id[sclass];
-		spec->localidx = local_stid + 1;
-	}
+		st->build_date = _date;
 
-	//debug("Registering station #%d of class %d", stid, sclass);
-	memcpy(&_station_spec[sclass][stid], spec, sizeof(*spec));
-}
+		tile_delta = direction ? TileDiffXY(0, 1) : TileDiffXY(1, 0);
 
-StationSpec *GetCustomStation(StationClass sclass, byte stid)
-{
-	assert(sclass == STAT_CLASS_DFLT || sclass == STAT_CLASS_WAYP);
-	sclass--;
-	//debug("Asking for station #%d of class %d", stid, sclass);
-	if (stid > _statspec_highest_id[sclass])
-		return NULL;
-	return &_station_spec[sclass][stid];
-}
+		statspec = HASBIT(p2, 4) != 0 ? GetCustomStation((p2 >> 16) & 0xF, (p2 >> 8) & 0xFF) : NULL;
+		if (statspec) {
+			/* Custom Station */
+			StationSegment *segment;
+			segid = StationSegmentAllocate(st, numtracks, plat_len);
+			segment = &st->segments[segid];
+
+			segment->tile      = tile_org;
+			segment->direction = direction;
+			segment->length    = plat_len;
+			segment->platforms = numtracks;
+			segment->sclass    = (p2 >> 16) &  0xF;
+			segment->cstation  = (p2 >>  8) & 0xFF;
 
-static RealSpriteGroup *ResolveStationSpriteGroup(SpriteGroup *spritegroup, Station *stat)
-{
-	switch (spritegroup->type) {
-		case SGT_REAL:
-			return &spritegroup->g.real;
+			segment->grfid     = statspec->grfid;
+			segment->gstation  = statspec->localidx;
+		}
+		layout_ptr = alloca(numtracks * plat_len);
+		GetStationLayout(layout_ptr, numtracks, plat_len, statspec);
 
-		case SGT_DETERMINISTIC: {
-			DeterministicSpriteGroup *dsg = &spritegroup->g.determ;
-			SpriteGroup *target;
-			int value = -1;
+		st->topleft = StationGetTopLeft(st);
+		st->bottomright = StationGetBottomRight(st);
 
-			if ((dsg->variable >> 6) == 0) {
-				/* General property */
-				value = GetDeterministicSpriteValue(dsg->variable);
+		do {
+			TileIndex tile = tile_org;
+			int w = plat_len;
+			do {
+				ModifyTile(tile,
+					MP_SETTYPE(MP_STATION) | MP_MAPOWNER_CURRENT |
+					MP_MAP2 | MP_MAP5 | MP_MAP3LO | MP_MAP3HI,
+					station_index, /* map2 parameter */
+					p2 & 0xFF,     /* map3lo parameter */
+					segid,         /* map3hi parameter */
+					(*layout_ptr++) + direction   /* map5 parameter */
+				);
 
-			} else {
-				if (stat == NULL) {
-					/* We are in a build dialog of something,
-					 * and we are checking for something undefined.
-					 * That means we should get the first target
-					 * (NOT the default one). */
-					if (dsg->num_ranges > 0) {
-						target = &dsg->ranges[0].group;
-					} else {
-						target = dsg->default_group;
+				if (statspec && HASBIT(p2, 4)) { // Custom station
+					uint16 callback;
+					// Set random bits for this tile
+					StationSegmentRandomBitsSet(&st->segments[segid], tile, Random() & 0xF);
+
+					callback = GetStationCallBackResult(CBID_STATION_TILE_LAYOUT, statspec, st, tile);
+					if (callback != CALLBACK_FAILED) {
+						assert(callback < 8);
+						ModifyTile(tile,
+							MP_MAP5,
+							callback + direction   /* map5 parameter */
+						);
 					}
-					return ResolveStationSpriteGroup(target, NULL);
-				}
 
-				/* Station-specific property. */
-				if (dsg->var_scope == VSG_SCOPE_PARENT) {
-					/* TODO: Town structure. */
-
-				} else /* VSG_SELF */ {
-					if (dsg->variable == 0x40 || dsg->variable == 0x41) {
-						/* FIXME: This is ad hoc only
-						 * for waypoints. */
-						value = 0x01010000;
-					} else {
-						/* TODO: Only small fraction done. */
-						// TTDPatch runs on little-endian arch;
-						// Variable is 0x70 + offset in the TTD's station structure
-						switch (dsg->variable - 0x70) {
-							case 0x80:
-								value = stat->facilities;
-								break;
-							case 0x81:
-								value = stat->airport_type;
-								break;
-							case 0x82:
-								value = stat->truck_stops->status;
-								break;
-							case 0x83:
-								value = stat->bus_stops->status;
-								break;
-							case 0x86:
-								value = stat->airport_flags & 0xFFFF;
-								break;
-							case 0x87:
-								value = stat->airport_flags & 0xFF;
-								break;
-							case 0x8A:
-								value = stat->build_date;
-								break;
-						}
-					}
+					if (statspec->blocked & (1 << _m[tile].m5))
+						_m[tile].m3 |= 0x80;
 				}
-			}
-
-			target = value != -1 ? EvalDeterministicSpriteGroup(dsg, value) : dsg->default_group;
-			return ResolveStationSpriteGroup(target, stat);
-		}
-
-		default:
-		case SGT_RANDOMIZED:
-			error("I don't know how to handle random spritegroups yet!");
-			return NULL;
-	}
-}
-
-uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte ctype)
-{
-	RealSpriteGroup *rsg;
 
-	rsg = ResolveStationSpriteGroup(&spec->spritegroup[ctype], stat);
+				tile += tile_delta;
+			} while (--w);
+			tile_org += tile_delta ^ TileDiffXY(1, 1); // perpendicular to tile_delta
+		} while (--numtracks);
 
-	if (rsg->sprites_per_set != 0) {
-		if (rsg->loading_count != 0) {
-			return rsg->loading[0];
-		} else if (rsg->loaded_count != 0) {
-			return rsg->loaded[0];
-		}
+		MarkWholeStationDirty(st);
+		UpdateStationVirtCoordDirty(st);
+		UpdateStationAcceptance(st, false);
+		InvalidateWindow(WC_STATION_LIST, st->owner);
 	}
 
-	error("Custom station 0x%08x::0x%02x has no sprites associated.",
-		spec->grfid, spec->localidx);
-	/* This is what gets subscribed of dtss->image in newgrf.c,
-	 * so it's probably kinda "default offset". Try to use it as
-	 * emergency measure. */
-	return 0x42D;
-}
-
-int GetCustomStationsCount(StationClass sclass)
-{
-	assert(sclass == STAT_CLASS_DFLT || sclass == STAT_CLASS_WAYP);
-	sclass--;
-	return _statspec_highest_id[sclass] + 1;
+	return cost;
 }
 
-
 static int32 RemoveRailroadStation(Station *st, TileIndex tile, uint32 flags)
 {
 	int w,h;
@@ -1415,9 +1979,15 @@
 	} while (--h);
 
 	if (flags & DC_EXEC) {
+		int i;
+
 		st->train_tile = 0;
 		st->facilities &= ~FACIL_TRAIN;
 
+		if (st->num_segments > 0)
+			for (i = 0; i < st->num_segments; i++)
+				StationSegmentDelete(st, i);
+
 		UpdateStationVirtCoordDirty(st);
 		DeleteStationIfEmpty(st);
 	}
@@ -2139,7 +2709,7 @@
 	byte railtype = _m[ti->tile].m3 & 0xF;
 	const RailtypeInfo *rti = GetRailTypeInfo(railtype);
 	SpriteID offset;
-	uint32 relocation = 0;
+	uint32 relocation = 0, ground_relocation = 0;
 
 	{
 		uint owner = GetTileOwner(ti->tile);
@@ -2152,24 +2722,43 @@
 	if (ti->tileh != 0 && (ti->map5 < 0x4C || ti->map5 > 0x51))
 		DrawFoundation(ti, ti->tileh);
 
-	if (_m[ti->tile].m3 & 0x10) {
+	if (HASBIT(_m[ti->tile].m3, 4)) {
 		// look for customization
-		StationSpec *statspec = GetCustomStation(STAT_CLASS_DFLT, _m[ti->tile].m4);
-
-		//debug("Cust-o-mized %p", statspec);
-
-		if (statspec != NULL) {
-			Station *st = GetStation(_m[ti->tile].m2);
+		Station *st = GetStation(_m[ti->tile].m2);
+		if (st->num_segments > 0) {
+			StationSegment *segment = &st->segments[_m[ti->tile].m4];
+			StationSpec *statspec = GetCustomStation(segment->sclass, segment->cstation);
+
+			//debug("Cust-o-mized %p", statspec);
+
+			if (statspec != NULL) {
+				relocation = GetCustomStationRelocation(statspec, st, GC_DEFAULT, ti->tile);
+				t = &statspec->renderdata[ti->map5];
+
+				if (HASBIT(statspec->callbackmask, CBM_SPRITE_LAYOUT)) {
+					uint16 callback;
+					DEBUG(grf, 2)("Executing callback for %x", ti->tile);
+					callback = GetStationCallBackResult(CBID_STATION_SPRITE_LAYOUT, statspec, st, ti->tile);
+					if (callback != CALLBACK_FAILED)
+						t = &statspec->renderdata[callback+segment->direction];
+					DEBUG(grf, 2)("Done callback for %x", ti->tile);
+				}
 
-			relocation = GetCustomStationRelocation(statspec, st, 0);
-			//debug("Relocation %d", relocation);
-			t = &statspec->renderdata[ti->map5];
+				ground_relocation = statspec->ground_relocation;
+			}
 		}
 	}
 
 	if (t == NULL) t = &_station_display_datas[ti->map5];
 
 	image = t->ground_sprite;
+	if (HASBIT(image, 31)) {
+		/* Bit 31 indicates we should use the sprite from the grf file
+		 * instead of TTD's */
+		image &= 0xFFFF;
+		image += ground_relocation;
+	}
+
 	if (image & PALETTE_MODIFIER_COLOR)
 		image |= image_or_modificator;
 
@@ -2177,6 +2766,8 @@
 	offset = (image & SPRITE_MASK) < _custom_sprites_base ? rti->total_offset : railtype;
 	image += offset;
 
+	//printf("3:groundsprite = 0x%x\n", image);
+
 	// station_land array has been increased from 82 elements to 114
 	// but this is something else. If AI builds station with 114 it looks all weird
 	DrawGroundSprite(image);
@@ -2193,7 +2784,9 @@
 
 	foreach_draw_tile_seq(dtss, t->seq) {
 		image = dtss->image + relocation;
-		image += offset;
+		//printf("image: 0x%x\n", image);
+		if (relocation == 0)
+			image += offset;
 		if (_display_opt & DO_TRANS_BUILDINGS) {
 			MAKE_TRANSPARENT(image);
 		} else {
@@ -2203,6 +2796,7 @@
 		if ((byte)dtss->delta_z != 0x80) {
 			AddSortableSpriteToDraw(image, ti->x + dtss->delta_x, ti->y + dtss->delta_y, dtss->width, dtss->height, dtss->unk, ti->z + dtss->delta_z);
 		} else {
+			MAKE_TRANSPARENT(image);
 			AddChildSpriteScreen(image, dtss->delta_x, dtss->delta_y);
 		}
 	}
@@ -2230,6 +2824,60 @@
 	}
 }
 
+void DrawStationSprite(int x, int y, StationClass sclass, byte stat_id, uint railtype, byte direction)
+{
+	StationSpec *spec;
+	uint32 relocation;
+	DrawTileSprites *cust;
+	DrawTileSeqStruct const *seq;
+	const RailtypeInfo *rti = GetRailTypeInfo(railtype);
+	uint32 ormod, img;
+
+	ormod = PLAYER_SPRITE_COLOR(_local_player);
+
+	x += 33;
+	y += 17;
+
+	/* draw default station graphics of ID 0 */
+	if (stat_id == 0 && sclass == STAT_CLASS_DFLT) {
+		StationPickerDrawSprite(x, y, railtype, direction + 2);
+		return;
+	}
+
+	spec = GetCustomStation(sclass, stat_id);
+	assert(spec);
+	relocation = GetCustomStationRelocation(spec, NULL, GC_PURCHASE, INVALID_TILE);
+	if (relocation == 0x42D)
+		relocation = GetCustomStationRelocation(spec, NULL, GC_DEFAULT, INVALID_TILE);
+
+	// emulate station tile - open with building
+	// add 1 to get the other direction
+	if (spec->tiles >= 3) {
+		cust = &spec->renderdata[2 + direction];
+	} else {
+		// Not all station layouts have a building
+		cust = &spec->renderdata[0 + direction];
+	}
+
+	img = cust->ground_sprite;
+	if (HASBIT(img, 31)) {
+		img &= 0xFFFF;
+		img += spec->ground_relocation;
+	}
+
+	img += (img < _custom_sprites_base) ? rti->total_offset : railtype;
+	
+	if (img & PALETTE_MODIFIER_COLOR) img = (img & SPRITE_MASK);
+	DrawSprite(img | ormod, x, y);
+
+	foreach_draw_tile_seq(seq, cust->seq) {
+		Point pt = RemapCoords(seq->delta_x, seq->delta_y, seq->delta_z);
+		uint32 image = seq->image + relocation;
+		if((byte)seq->delta_z != 0x80)
+			DrawSprite((image & SPRITE_MASK) | ormod, x + pt.x, y + pt.y);
+	}
+}
+
 static uint GetSlopeZ_Station(TileInfo *ti)
 {
 	uint z = ti->z;
@@ -2278,6 +2926,9 @@
 		case TRANSPORT_RAIL:
 			if (i < 8) {
 				const byte tile_track_status_rail[8] = { 1, 2, 1, 2, 1, 2, 1, 2 };
+				/* m3 bit 7 indicates that tile is not passable */
+				if (HASBIT(_m[tile].m3, 7))
+					return 0;
 				j = tile_track_status_rail[i];
 			}
 			j += (j << 8);
@@ -2713,6 +3364,7 @@
 	st->goods[type].enroute_time = 0;
 	st->goods[type].enroute_from = st->index;
 	InvalidateWindow(WC_STATION_VIEW, st->index);
+	MarkWholeStationDirty(st);
 }
 
 /** Rename a station
@@ -3055,6 +3707,25 @@
 	SLE_END()
 };
 
+static uint16 SSRBLen(void *object)
+{
+	StationSegment *segment = object;
+	return segment->platforms * segment->length;
+}
+
+static const SaveLoad _station_segment_desc[] = {
+	SLE_VAR(StationSegment, tile,      SLE_UINT32),
+	SLE_VAR(StationSegment, direction, SLE_UINT8),
+	SLE_VAR(StationSegment, length,    SLE_UINT8),
+	SLE_VAR(StationSegment, platforms, SLE_UINT8),
+	//SLE_VAR(StationSegment, sclass,    SLE_UINT8),
+	//SLE_VAR(StationSegment, cstation,  SLE_UINT8),
+	SLE_CONDVARR(StationSegment, random_bits, SLE_UINT8, SSRBLen, 17, 255),
+	SLE_VAR(StationSegment, grfid,     SLE_UINT32), ///< GRF file the station is from.
+	SLE_VAR(StationSegment, gstation,  SLE_UINT8),  ///< id within GRF file.
+	SLE_END()
+};
+
 static const SaveLoad _station_desc[] = {
 	SLE_CONDVAR(Station, xy,           SLE_FILE_U16 | SLE_VAR_U32, 0, 5),
 	SLE_CONDVAR(Station, xy,           SLE_UINT32, 6, 255),
@@ -3095,13 +3766,17 @@
 
 	SLE_VAR(Station,last_vehicle,				SLE_UINT16),
 
-	SLE_CONDVAR(Station,class_id,				SLE_UINT8, 3, 255),
-	SLE_CONDVAR(Station,stat_id,				SLE_UINT8, 3, 255),
+	SLE_CONDVAR(NullStruct,null,				SLE_FILE_U8 | SLE_VAR_NULL, 3, 255),
+	SLE_CONDVAR(NullStruct,null,				SLE_FILE_U8 | SLE_VAR_NULL, 3, 255),
 	SLE_CONDVAR(Station,build_date,			SLE_UINT16, 3, 255),
 
 	SLE_CONDREF(Station,bus_stops,					REF_ROADSTOPS, 6, 255),
 	SLE_CONDREF(Station,truck_stops,				REF_ROADSTOPS, 6, 255),
 
+	SLE_CONDVAR(Station,random_bits,            SLE_UINT32, 17, 255),
+	SLE_CONDVAR(Station,waiting_triggers,       SLE_UINT8, 17, 255),
+	SLE_CONDVAR(Station,num_segments,           SLE_UINT8, 17, 255),
+
 	// reserve extra space in savegame here. (currently 28 bytes)
 	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 32, 2, 255),
 
@@ -3221,8 +3896,89 @@
 	}
 }
 
+static void Save_STATION_SEGMENT( void )
+{
+	Station *st;
+	uint index = 0;
+
+	FOR_ALL_STATIONS(st) {
+		byte i;
+		if (st->xy == 0)
+			continue;
+		if (st->num_segments == 0)
+			continue;
+
+		for (i = 0; i < st->num_segments; i++) {
+			SlSetArrayIndex(index++);
+			SlObject(&st->segments[i], _station_segment_desc);
+			//SlSetArrayIndex(index++);
+			//SlArray(st->segments[i].random_bits, st->segments[i].platforms * st->segments[i].length, SLE_UINT8);
+		}
+	}
+}
+
+static void Load_STATION_SEGMENT( void )
+{
+	Station *st = GetStation(0);
+	byte i = 0;
+
+	while (SlIterateArray() != -1) {
+		if (i == st->num_segments) {
+			while (st->index + 1 < GetStationPoolSize() && st != NULL) {
+				st = GetStation(st->index + 1);
+				if (st->num_segments > 0)
+					break;
+			}
+			if (st == NULL)
+				break;
+			i = 0;
+		}
+		if (st->segments == NULL) {
+			st->segments = malloc(st->num_segments * sizeof(StationSegment));
+		}
+		SlObject(&st->segments[i], _station_segment_desc);
+		//st->segments[i].random_bits = malloc(st->segments[i].platforms * st->segments[i].length);
+		//SlIterateArray();
+		//SlArray(st->segments[i].random_bits, SlGetFieldLength(), SLE_UINT8);
+
+		{
+			/* Set up the segment's sclass and cstation parameters from the
+			 * currently loaded GRF list. */
+			StationClass class;
+			int id;
+			StationSegment *segment = &st->segments[i];
+
+			/* Default to normal station */
+			segment->sclass = 0;
+			segment->cstation = 0;
+
+			/* Loop through all available classes and IDs to find a match. */
+			for (class = 0; class < STAT_CLASS_MAX; class++) {
+				for (id = 0; id <= _statspec_highest_id[class]; id++) {
+					if (_station_spec[class][id] && _station_spec[class][id]->grfid == segment->grfid && _station_spec[class][id]->localidx == segment->gstation) {
+						segment->sclass = class;
+						segment->cstation = id;
+						break;
+					}
+				}
+			}
+		}
+		i++;
+	}
+
+	// These variables are not saved and depend on station segments to be
+	// loaded.
+	FOR_ALL_STATIONS(st) {
+		if (st->xy != 0) {
+			st->topleft = StationGetTopLeft(st);
+			st->bottomright = StationGetBottomRight(st);
+		}
+	}
+}
+
 const ChunkHandler _station_chunk_handlers[] = {
 	{ 'STNS', Save_STNS,      Load_STNS,      CH_ARRAY },
-	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY | CH_LAST},
+	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY },
+	{ 'STSG', Save_STATION_SEGMENT, Load_STATION_SEGMENT, CH_ARRAY | CH_LAST },
 };
 
Index: engine.c
===================================================================
--- engine.c	(revision 2949)
+++ engine.c	(working copy)
@@ -17,6 +17,7 @@
 #include "saveload.h"
 #include "sprite.h"
 #include "variables.h"
+#include "newgrf_callbacks.h"
 
 enum {
 	ENGINE_AVAILABLE = 1,
@@ -308,190 +309,214 @@
 	_engine_custom_sprites[engine][cargo] = *group;
 }
 
-typedef SpriteGroup *(*resolve_callback)(const SpriteGroup *spritegroup,
-	const Vehicle *veh, uint16 callback_info, void *resolve_func); /* XXX data pointer used as function pointer */
+/* Hack to allow specifying a direction other than the vehicle's actual direction.
+ * Used for depot/vehicle windows, etc */
+static byte eval_vehicle_direction;
+
+uint16 EvalRealVehicle(RealSpriteGroup *rsg, int object)
+{
+	int cargo;
+	bool is_moving;
+	byte totalsets;
+	int spriteset;
 
-static const SpriteGroup* ResolveVehicleSpriteGroup(const SpriteGroup *spritegroup,
-	const Vehicle *veh, uint16 callback_info, resolve_callback resolve_func)
-{
-	//debug("spgt %d", spritegroup->type);
-	switch (spritegroup->type) {
-		case SGT_REAL:
-		case SGT_CALLBACK:
-			return spritegroup;
-
-		case SGT_DETERMINISTIC: {
-			const DeterministicSpriteGroup *dsg = &spritegroup->g.determ;
-			const SpriteGroup *target;
-			int value = -1;
-
-			//debug("[%p] Having fun resolving variable %x", veh, dsg->variable);
-			if (dsg->variable == 0x0C) {
-				/* Callback ID */
-				value = callback_info & 0xFF;
-			} else if ((dsg->variable >> 6) == 0) {
-				/* General property */
-				value = GetDeterministicSpriteValue(dsg->variable);
-			} else {
-				/* Vehicle-specific property. */
-
-				if (veh == NULL) {
-					/* We are in a purchase list of something,
-					 * and we are checking for something undefined.
-					 * That means we should get the first target
-					 * (NOT the default one). */
-					if (dsg->num_ranges > 0) {
-						target = &dsg->ranges[0].group;
-					} else {
-						target = dsg->default_group;
-					}
-					return resolve_func(target, NULL, callback_info, resolve_func);
-				}
-
-				if (dsg->var_scope == VSG_SCOPE_PARENT) {
-					/* First engine in the vehicle chain */
-					if (veh->type == VEH_Train)
-						veh = GetFirstVehicleInChain(veh);
-				}
+	if (!rsg->sprites_per_set)
+		return 0;
 
-				if (dsg->variable == 0x40 || dsg->variable == 0x41) {
-					if (veh->type == VEH_Train) {
-						const Vehicle *u = GetFirstVehicleInChain(veh);
-						byte chain_before = 0, chain_after = 0;
-
-						while (u != veh) {
-							chain_before++;
-							if (dsg->variable == 0x41 && u->engine_type != veh->engine_type)
-								chain_before = 0;
-							u = u->next;
-						}
-						while (u->next != NULL && (dsg->variable == 0x40 || u->next->engine_type == veh->engine_type)) {
-							chain_after++;
-							u = u->next;
-						};
-
-						value = chain_before | chain_after << 8
-						        | (chain_before + chain_after) << 16;
-					} else {
-						value = 1; /* 1 vehicle in the chain */
-					}
+	if (object == -1) {
+		/* Purchase window */
+		cargo = 0;
+		is_moving = false;
+	} else {
+		Vehicle *v = GetVehicle(object);
+		if (v->cargo_cap > 0) {
+			cargo = (v->cargo_count * 100) / v->cargo_cap;
+		} else {
+			cargo = 0;
+		}
+		is_moving = (v->cur_speed != 0);
+	}
 
-				} else {
-					// TTDPatch runs on little-endian arch;
-					// Variable is 0x80 + offset in TTD's vehicle structure
-					switch (dsg->variable - 0x80) {
-#define veh_prop(id_, value_) case (id_): value = (value_); break
-						veh_prop(0x00, veh->type);
-						veh_prop(0x01, veh->subtype);
-						veh_prop(0x04, veh->index);
-						veh_prop(0x05, veh->index & 0xFF);
-						/* XXX? Is THIS right? */
-						veh_prop(0x0A, PackOrder(&veh->current_order));
-						veh_prop(0x0B, PackOrder(&veh->current_order) & 0xff);
-						veh_prop(0x0C, veh->num_orders);
-						veh_prop(0x0D, veh->cur_order_index);
-						veh_prop(0x10, veh->load_unload_time_rem);
-						veh_prop(0x11, veh->load_unload_time_rem & 0xFF);
-						veh_prop(0x12, veh->date_of_last_service);
-						veh_prop(0x13, veh->date_of_last_service & 0xFF);
-						veh_prop(0x14, veh->service_interval);
-						veh_prop(0x15, veh->service_interval & 0xFF);
-						veh_prop(0x16, veh->last_station_visited);
-						veh_prop(0x17, veh->tick_counter);
-						veh_prop(0x18, veh->max_speed);
-						veh_prop(0x19, veh->max_speed & 0xFF);
-						veh_prop(0x1F, veh->direction);
-						veh_prop(0x28, veh->cur_image);
-						veh_prop(0x29, veh->cur_image & 0xFF);
-						veh_prop(0x32, veh->vehstatus);
-						veh_prop(0x33, veh->vehstatus);
-						veh_prop(0x34, veh->cur_speed);
-						veh_prop(0x35, veh->cur_speed & 0xFF);
-						veh_prop(0x36, veh->subspeed);
-						veh_prop(0x37, veh->acceleration);
-						veh_prop(0x39, veh->cargo_type);
-						veh_prop(0x3A, veh->cargo_cap);
-						veh_prop(0x3B, veh->cargo_cap & 0xFF);
-						veh_prop(0x3C, veh->cargo_count);
-						veh_prop(0x3D, veh->cargo_count & 0xFF);
-						veh_prop(0x3E, veh->cargo_source); // Probably useless; so what
-						veh_prop(0x3F, veh->cargo_days);
-						veh_prop(0x40, veh->age);
-						veh_prop(0x41, veh->age & 0xFF);
-						veh_prop(0x42, veh->max_age);
-						veh_prop(0x43, veh->max_age & 0xFF);
-						veh_prop(0x44, veh->build_year);
-						veh_prop(0x45, veh->unitnumber);
-						veh_prop(0x46, veh->engine_type);
-						veh_prop(0x47, veh->engine_type & 0xFF);
-						veh_prop(0x48, veh->spritenum);
-						veh_prop(0x49, veh->day_counter);
-						veh_prop(0x4A, veh->breakdowns_since_last_service);
-						veh_prop(0x4B, veh->breakdown_ctr);
-						veh_prop(0x4C, veh->breakdown_delay);
-						veh_prop(0x4D, veh->breakdown_chance);
-						veh_prop(0x4E, veh->reliability);
-						veh_prop(0x4F, veh->reliability & 0xFF);
-						veh_prop(0x50, veh->reliability_spd_dec);
-						veh_prop(0x51, veh->reliability_spd_dec & 0xFF);
-						veh_prop(0x52, veh->profit_this_year);
-						veh_prop(0x53, veh->profit_this_year & 0xFFFFFF);
-						veh_prop(0x54, veh->profit_this_year & 0xFFFF);
-						veh_prop(0x55, veh->profit_this_year & 0xFF);
-						veh_prop(0x56, veh->profit_last_year);
-						veh_prop(0x57, veh->profit_last_year & 0xFF);
-						veh_prop(0x58, veh->profit_last_year);
-						veh_prop(0x59, veh->profit_last_year & 0xFF);
-						veh_prop(0x5A, veh->next == NULL ? INVALID_VEHICLE : veh->next->index);
-						veh_prop(0x5C, veh->value);
-						veh_prop(0x5D, veh->value & 0xFFFFFF);
-						veh_prop(0x5E, veh->value & 0xFFFF);
-						veh_prop(0x5F, veh->value & 0xFF);
-						veh_prop(0x60, veh->string_id);
-						veh_prop(0x61, veh->string_id & 0xFF);
-						/* 00h..07h=sub image? 40h=in tunnel; actually some kind of status
-						 * aircraft: >=13h when in flight
-						 * train, ship: 80h=in depot
-						 * rv: 0feh=in depot */
-						/* TODO veh_prop(0x62, veh->???); */
-
-						/* TODO: The rest is per-vehicle, I hope no GRF file looks so far.
-						 * But they won't let us have an easy ride so surely *some* GRF
-						 * file does. So someone needs to do this too. --pasky */
+	totalsets = is_moving ? rsg->loaded_count : rsg->loading_count;
+	if (cargo == 100 || totalsets == 1) {
+		spriteset = totalsets - 1;
+	} else if (cargo == 0 || totalsets == 2) {
+		spriteset = 0;
+	} else {
+		spriteset = cargo * (totalsets - 2) / 100 + 1;
+		if (spriteset == 0) {
+			spriteset = 1;
+		} else if (spriteset == totalsets - 1) {
+			spriteset--;
+		}
+	}
 
-#undef veh_prop
-					}
-				}
-			}
+	return (is_moving ? rsg->loaded[spriteset] : rsg->loading[spriteset]) + (eval_vehicle_direction % rsg->sprites_per_set);
+}
 
-			target = value != -1 ? EvalDeterministicSpriteGroup(dsg, value) : dsg->default_group;
-			//debug("Resolved variable %x: %d, %p", dsg->variable, value, callback);
-			return resolve_func(target, veh, callback_info, resolve_func);
+int EvalDeterministicVehicle(int variable, byte parameter, int object)
+{
+	Vehicle *v;
+	if (object == -1) {
+		/* Build list */
+		switch (variable) {
+			case 0xC4: return _cur_year;       /* Build year */
+			case 0xDA: return INVALID_VEHICLE; /* Next vehicle */
+			default: return -1;
 		}
+	}
+	v = GetVehicle(object);
 
-		case SGT_RANDOMIZED: {
-			const RandomizedSpriteGroup *rsg = &spritegroup->g.random;
-
-			if (veh == NULL) {
-				/* Purchase list of something. Show the first one. */
-				assert(rsg->num_groups > 0);
-				//debug("going for %p: %d", rsg->groups[0], rsg->groups[0].type);
-				return resolve_func(&rsg->groups[0], NULL, callback_info, resolve_func);
+	switch (variable) {
+		case 0x40:
+		case 0x41:
+		/* Get length of vehicle consist */
+		if (v->type == VEH_Train) {
+			Vehicle *u = GetFirstVehicleInChain(v);
+			byte chain_before = 0, chain_after = 0;
+
+			while (u != v) {
+				chain_before++;
+				if (variable == 0x41 && u->engine_type != v->engine_type)
+					chain_before = 0;
+				u = u->next;
 			}
 
-			if (rsg->var_scope == VSG_SCOPE_PARENT) {
-				/* First engine in the vehicle chain */
-				if (veh->type == VEH_Train)
-					veh = GetFirstVehicleInChain(veh);
+			while (u->next != NULL && (variable == 0x40 || u->next->engine_type == v->engine_type)) {
+				chain_after++;
+				u = u->next;
 			}
 
-			return resolve_func(EvalRandomizedSpriteGroup(rsg, veh->random_bits), veh, callback_info, resolve_func);
+			return chain_before | chain_after << 8 | (chain_before + chain_after) << 16;
+		} else {
+			/* Road vehicles, aeroplanes and ships */
+			return 1;
 		}
+		case 0x42: /* Consist's cargo */
+			return -1;
+		case 0x43: /* Player information */
+			return v->owner;
+		case 0x44: /* Aircraft information */
+			if (v->type == VEH_Aircraft)
+				/* Should also return airport type */
+				return (v->z_pos - TileHeight(v->tile)) << 16;
+			else
+				return -1;
+		case 0x45: /* Curve information, for e.g. tilting trains */
+			if (v->type == VEH_Train) {
+				return -1;
+			} else {
+				return -1;
+			}
+		case 0x60: /* Count vehicle (engine) ID occurance */
+			if (v->type == VEH_Train) {
+				byte count = 0;
+				while (v) {
+					if (v->engine_type == parameter)
+						count++;
+					v = v->next;
+				}
+				return count;
+			} else {
+				return (v->engine_type == parameter) ? 1 : 0;
+			}
+		case 0xF2: /* Refit cycle */
+			return v->refit_cycle;
+	}
 
-		default:
-			error("I don't know how to handle such a spritegroup %d!", spritegroup->type);
-			return NULL;
+	/* Determine value from vehicle struct */
+	switch (variable - 0x80) {
+		case 0x00: return v->type;
+		case 0x01: return v->subtype;
+		case 0x04: return v->index;
+		case 0x05: return v->index & 0xFF; /* XXX: Is THIS right? */
+		case 0x0A: return PackOrder(&v->current_order);
+		case 0x0B: return PackOrder(&v->current_order) & 0xFF;
+		case 0x0C: return v->num_orders;
+		case 0x0D: return v->cur_order_index;
+		case 0x10: return v->load_unload_time_rem;
+		case 0x11: return v->load_unload_time_rem & 0xFF;
+		case 0x12: return v->date_of_last_service;
+		case 0x13: return v->date_of_last_service & 0xFF;
+		case 0x14: return v->service_interval;
+		case 0x15: return v->service_interval & 0xFF;
+		case 0x16: return v->last_station_visited;
+		case 0x17: return v->tick_counter;
+		case 0x18: return v->max_speed;
+		case 0x19: return v->max_speed & 0xFF;
+		case 0x1F: return v->direction;
+		case 0x28: return v->cur_image;
+		case 0x29: return v->cur_image & 0xFF;
+		case 0x32: return v->vehstatus;
+		case 0x33: return v->vehstatus;
+		case 0x34: return v->cur_speed;
+		case 0x35: return v->cur_speed & 0xFF;
+		case 0x36: return v->subspeed;
+		case 0x37: return v->acceleration;
+		case 0x39: return v->cargo_type;
+		case 0x3A: return v->cargo_cap;
+		case 0x3B: return v->cargo_cap & 0xFF;
+		case 0x3C: return v->cargo_count;
+		case 0x3D: return v->cargo_count & 0xFF;
+		case 0x3E: return v->cargo_source; // Probably useless; so what
+		case 0x3F: return v->cargo_days;
+		case 0x40: return v->age;
+		case 0x41: return v->age & 0xFF;
+		case 0x42: return v->max_age;
+		case 0x43: return v->max_age & 0xFF;
+		case 0x44: return v->build_year;
+		case 0x45: return v->unitnumber;
+		case 0x46: return v->engine_type;
+		case 0x47: return v->engine_type & 0xFF;
+		case 0x48: return v->spritenum;
+		case 0x49: return v->day_counter;
+		case 0x4A: return v->breakdowns_since_last_service;
+		case 0x4B: return v->breakdown_ctr;
+		case 0x4C: return v->breakdown_delay;
+		case 0x4D: return v->breakdown_chance;
+		case 0x4E: return v->reliability;
+		case 0x4F: return v->reliability & 0xFF;
+		case 0x50: return v->reliability_spd_dec;
+		case 0x51: return v->reliability_spd_dec & 0xFF;
+		case 0x52: return v->profit_this_year;
+		case 0x53: return v->profit_this_year & 0xFFFFFF;
+		case 0x54: return v->profit_this_year & 0xFFFF;
+		case 0x55: return v->profit_this_year & 0xFF;
+		case 0x56: return v->profit_last_year;
+		case 0x57: return v->profit_last_year & 0xFF;
+		case 0x58: return v->profit_last_year;
+		case 0x59: return v->profit_last_year & 0xFF;
+		case 0x5A: return v->next == NULL ? INVALID_VEHICLE : v->next->index;
+		case 0x5C: return v->value;
+		case 0x5D: return v->value & 0xFFFFFF;
+		case 0x5E: return v->value & 0xFFFF;
+		case 0x5F: return v->value & 0xFF;
+		case 0x60: return v->string_id;
+		case 0x61: return v->string_id & 0xFF;
 	}
+
+	DEBUG(grf, 1)("EvalDeterministicVehicle: Unhandled variable `0x%x' in spritegroup", variable);
+	return -1;
+}
+
+uint32 EvalRandomBitsVehicle(int object)
+{
+	if (object == -1)
+		return 0;
+	return GetVehicle(object)->random_bits;
+}
+
+ParentObject EvalGetParentObjectVehicle(int object)
+{
+	ParentObject parent;
+
+	parent.feature = 0;
+	if (object == -1)
+		parent.object = -1;
+	else
+		parent.object = GetFirstVehicleInChain(GetVehicle(object))->index;
+
+	return parent;
 }
 
 static const SpriteGroup *GetVehicleSpriteGroup(byte engine, const Vehicle *v)
@@ -518,64 +543,29 @@
 int GetCustomEngineSprite(byte engine, const Vehicle *v, byte direction)
 {
 	const SpriteGroup *group;
-	const RealSpriteGroup *rsg;
 	byte cargo = GC_PURCHASE;
-	byte loaded = 0;
-	bool in_motion = 0;
-	int totalsets, spriteset;
-	int r;
+	int object;
+	uint16 result;
 
 	if (v != NULL) {
-		int capacity = v->cargo_cap;
-
 		cargo = _global_cargo_id[_opt.landscape][v->cargo_type];
 		assert(cargo != GC_INVALID);
-
-		if (capacity == 0) capacity = 1;
-		loaded = (v->cargo_count * 100) / capacity;
-		in_motion = (v->cur_speed != 0);
+		object = v->index;
+	} else {
+		object = -1;
 	}
 
-	group = GetVehicleSpriteGroup(engine, v);
-	group = ResolveVehicleSpriteGroup(group, v, 0, (resolve_callback) ResolveVehicleSpriteGroup);
+	eval_vehicle_direction = direction;
 
-	if (group->type == SGT_REAL && group->g.real.sprites_per_set == 0 && cargo != GC_DEFAULT) {
+	group = GetVehicleSpriteGroup(engine, v);
+	result = ResolveSpriteGroup(group, object, 0, 0, (resolve_callback) ResolveSpriteGroup);
+	if (result == 0 && cargo != GC_DEFAULT) {
 		// This group is empty but perhaps there'll be a default one.
-		group = ResolveVehicleSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], v, 0,
-		                                (resolve_callback) ResolveVehicleSpriteGroup);
-	}
-
-	assert(group->type == SGT_REAL);
-	rsg = &group->g.real;
-
-	if (!rsg->sprites_per_set) {
-		// This group is empty. This function users should therefore
-		// look up the sprite number in _engine_original_sprites.
-		return 0;
+		result = ResolveSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], object, 0, 0,
+		                                (resolve_callback) ResolveSpriteGroup);
 	}
 
-	assert(rsg->sprites_per_set <= 8);
-	direction %= rsg->sprites_per_set;
-
-	totalsets = in_motion ? rsg->loaded_count : rsg->loading_count;
-
-	// My aim here is to make it possible to visually determine absolutely
-	// empty and totally full vehicles. --pasky
-	if (loaded == 100 || totalsets == 1) { // full
-		spriteset = totalsets - 1;
-	} else if (loaded == 0 || totalsets == 2) { // empty
-		spriteset = 0;
-	} else { // something inbetween
-		spriteset = loaded * (totalsets - 2) / 100 + 1;
-		// correct possible rounding errors
-		if (!spriteset)
-			spriteset = 1;
-		else if (spriteset == totalsets - 1)
-			spriteset--;
-	}
-
-	r = (in_motion ? rsg->loaded[spriteset] : rsg->loading[spriteset]) + direction;
-	return r;
+	return result;
 }
 
 /**
@@ -601,9 +591,21 @@
 {
 	const SpriteGroup *group;
 	byte cargo = GC_DEFAULT;
+	uint16 result;
 
-	if (v != NULL)
+	if (v != NULL) {
 		cargo = _global_cargo_id[_opt.landscape][v->cargo_type];
+		eval_vehicle_direction = v->direction;
+	} else {
+		switch(GetEngine(engine)->type) {
+			case VEH_Train: cargo = RailVehInfo(engine)->cargo_type; break;
+			case VEH_Road: cargo = RoadVehInfo(engine)->cargo_type; break;
+			case VEH_Ship: cargo = ShipVehInfo(engine)->cargo_type; break;
+			case VEH_Aircraft: cargo = GC_PASSENGERS; break;
+			default: cargo = GC_DEFAULT;
+		}
+		eval_vehicle_direction = 2;
+	}
 
 	group = &_engine_custom_sprites[engine][cargo];
 
@@ -613,18 +615,21 @@
 		if (overset != NULL) group = overset;
 	}
 
-	group = ResolveVehicleSpriteGroup(group, v, callback_info, (resolve_callback) ResolveVehicleSpriteGroup);
+	result = ResolveSpriteGroup(group, v->index, callback_info, 0, (resolve_callback) ResolveSpriteGroup);
 
-	if (group->type == SGT_REAL && group->g.real.sprites_per_set == 0 && cargo != GC_DEFAULT) {
+	if (result == 0 && cargo != GC_DEFAULT) {
 		// This group is empty but perhaps there'll be a default one.
-		group = ResolveVehicleSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], v, callback_info,
-		                                (resolve_callback) ResolveVehicleSpriteGroup);
+		result = ResolveSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], v->index, callback_info, 0,
+		                                (resolve_callback) ResolveSpriteGroup);
 	}
 
-	if (group->type != SGT_CALLBACK)
+	if (!HASBIT(result, 15))
 		return CALLBACK_FAILED;
 
-	return group->g.callback.result;
+	if ((result & 0xff00) == 0xff00)
+		return result & 0xff;
+
+	return result & 0x7fff;
 }
 
 
@@ -634,39 +639,38 @@
 static byte _vsg_random_triggers;
 static byte _vsg_bits_to_reseed;
 
-static const SpriteGroup *TriggerVehicleSpriteGroup(const SpriteGroup *spritegroup,
-	Vehicle *veh, uint16 callback_info, resolve_callback resolve_func)
+static uint16 TriggerVehicleSpriteGroup(const SpriteGroup *spritegroup,
+	int object, uint16 callback_info, byte feature, resolve_callback resolve_func)
 {
 	if (spritegroup->type == SGT_RANDOMIZED) {
 		_vsg_bits_to_reseed |= RandomizedSpriteGroupTriggeredBits(
 			&spritegroup->g.random,
 			_vsg_random_triggers,
-			&veh->waiting_triggers
+			&GetVehicle(object)->waiting_triggers
 		);
 	}
 
-	return ResolveVehicleSpriteGroup(spritegroup, veh, callback_info, resolve_func);
+	return ResolveSpriteGroup(spritegroup, object, callback_info, feature, resolve_func);
 }
 
 static void DoTriggerVehicle(Vehicle *veh, VehicleTrigger trigger, byte base_random_bits, bool first)
 {
-	const SpriteGroup *group;
-	const RealSpriteGroup *rsg;
 	byte new_random_bits;
+	uint16 result;
 
 	_vsg_random_triggers = trigger;
 	_vsg_bits_to_reseed = 0;
-	group = TriggerVehicleSpriteGroup(GetVehicleSpriteGroup(veh->engine_type, veh), veh, 0,
+	result = TriggerVehicleSpriteGroup(GetVehicleSpriteGroup(veh->engine_type, veh), veh->index, 0, 0,
 	                                  (resolve_callback) TriggerVehicleSpriteGroup);
 
-	if (group->type == SGT_REAL && group->g.real.sprites_per_set == 0 && veh->cargo_type != GC_DEFAULT) {
+	if (result == 0 && veh->cargo_type != GC_DEFAULT) {
 		// This group turned out to be empty but perhaps there'll be a default one.
-		group = TriggerVehicleSpriteGroup(&_engine_custom_sprites[veh->engine_type][GC_DEFAULT], veh, 0,
+		result = TriggerVehicleSpriteGroup(&_engine_custom_sprites[veh->engine_type][GC_DEFAULT], veh->index, 0, 0,
 		                                  (resolve_callback) TriggerVehicleSpriteGroup);
 	}
 
-	assert(group->type == SGT_REAL);
-	rsg = &group->g.real;
+	//assert(group->type == SGT_REAL);
+	//rsg = &group->g.real;
 
 	new_random_bits = Random();
 	veh->random_bits &= ~_vsg_bits_to_reseed;
Index: sprite.c
===================================================================
--- sprite.c	(revision 2949)
+++ sprite.c	(working copy)
@@ -5,6 +5,9 @@
 #include "sprite.h"
 #include "variables.h"
 
+#include "debug.h"
+#include "newgrf.h"
+#include "functions.h"
 
 SpriteGroup *EvalDeterministicSpriteGroup(const DeterministicSpriteGroup *dsg, int value)
 {
@@ -29,7 +32,6 @@
 
 	for (i = 0; i < dsg->num_ranges; i++) {
 		DeterministicSpriteGroupRange *range = &dsg->ranges[i];
-
 		if (range->low <= value && value <= range->high)
 			return &range->group;
 	}
@@ -61,9 +63,9 @@
 	}
 }
 
-SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, byte random_bits)
+SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, uint32 random_bits)
 {
-	byte mask;
+	uint32 mask;
 	byte index;
 
 	/* Noone likes mangling with bits, but you don't get around it here.
@@ -96,3 +98,159 @@
 
 	return (rsg->num_groups - 1) << rsg->lowest_randbit;
 }
+
+/*
+ * NewGRF sprite resolver
+ */
+extern EvalRealProc
+	EvalRealVehicle,
+	EvalRealStation;
+
+extern EvalDeterministicProc
+	EvalDeterministicVehicle,
+	EvalDeterministicStation;
+
+extern EvalRandomBitsProc
+	EvalRandomBitsVehicle,
+	EvalRandomBitsStation;
+
+extern EvalGetParentObjectProc
+	EvalGetParentObjectVehicle;
+
+typedef struct {
+	EvalRealProc* real;
+	EvalDeterministicProc* deterministic;
+	EvalRandomBitsProc* randombits;
+	EvalGetParentObjectProc* getparentobject;
+} EvalFeatureProcs;
+
+const EvalFeatureProcs evalfeature_procs[] = {
+	{ &EvalRealVehicle, &EvalDeterministicVehicle, &EvalRandomBitsVehicle, &EvalGetParentObjectVehicle }, ///< Trains
+	{ &EvalRealVehicle, &EvalDeterministicVehicle, &EvalRandomBitsVehicle, NULL }, ///< Road vehicles
+	{ &EvalRealVehicle, &EvalDeterministicVehicle, &EvalRandomBitsVehicle, NULL }, ///< Ships
+	{ &EvalRealVehicle, &EvalDeterministicVehicle, &EvalRandomBitsVehicle, NULL }, ///< Aircraft
+	{ &EvalRealStation, &EvalDeterministicStation, &EvalRandomBitsStation, NULL }, ///< Stations
+	{ NULL, NULL, NULL, NULL, }, ///< Canals
+	{ NULL, NULL, NULL, NULL, }, ///< Bridges
+	{ NULL, NULL, NULL, NULL, }, ///< Town buildings
+};
+
+uint16 ResolveSpriteGroup(const SpriteGroup *spritegroup, int object, uint16 callback_info, byte feature, resolve_callback resolve_func)
+{
+	switch (spritegroup->type) {
+		case SGT_REAL: {
+			const RealSpriteGroup *rsg = &spritegroup->g.real;
+			if (rsg->sprites_per_set > 0) {
+				if (evalfeature_procs[feature].real != NULL) {
+					return evalfeature_procs[feature].real(&spritegroup->g.real, object);
+				} else {
+					DEBUG(grf, 1)("ResolveSpriteGroup: need real handler for feature `%x'.", feature);
+				}
+			}
+			return 0;
+		}
+
+		case SGT_CALLBACK:
+			return spritegroup->g.callback.result;
+
+		case SGT_DETERMINISTIC: {
+			const DeterministicSpriteGroup *dsg = &spritegroup->g.determ;
+			const SpriteGroup *target;
+			int value = -1;
+			
+			if (dsg->variable == 0x0C) {
+				value = callback_info & 0xFF;
+			} else if (dsg->variable < 0x10) {
+				/* General property */
+				value = GetDeterministicSpriteValue(dsg->variable);
+				DEBUG(grf, 2)("ResolveSpriteGroup: Generic deterministic: var 0x%x, result 0x%x.", dsg->variable, value);
+			} else {
+				/* Object specific property */
+
+#if 0
+				if (object == -1) {
+					/* Purchase list */
+					if (dsg->num_ranges > 0) {
+						target = &dsg->ranges[0].group;
+					} else {
+						target = dsg->default_group;
+					}
+					return resolve_func(target, object, callback_info, feature, resolve_func);
+				}
+#endif
+
+				if (dsg->var_scope == VSG_SCOPE_PARENT) {
+					/* Get parent object */
+					if (evalfeature_procs[feature].getparentobject != NULL) {
+						ParentObject parent = evalfeature_procs[feature].getparentobject(object);
+						if (evalfeature_procs[parent.feature].deterministic != NULL) {
+							value = evalfeature_procs[parent.feature].deterministic(dsg->variable, dsg->parameter, parent.object);
+							DEBUG(grf, 2)("ResolveSpriteGroup: Deterministic feature `%x': var 0x%x, object 0x%x, result 0x%x.", parent.feature, dsg->variable, parent.object, value);
+						} else {
+							DEBUG(grf, 1)("ResolveSpriteGroup: need determinstic handler for feature `%x'.", parent.feature);
+						}
+					} else {
+						DEBUG(grf, 1)("ResolveSpriteGroup: need parent handler for feature `%x'.", feature);
+					}
+				} else {
+					if (evalfeature_procs[feature].deterministic != NULL) {
+						value = evalfeature_procs[feature].deterministic(dsg->variable, dsg->parameter, object);
+						DEBUG(grf, 2)("ResolveSpriteGroup: Deterministic feature `%x': var 0x%x, object 0x%x, result 0x%x.", feature, dsg->variable, object, value);
+					} else {
+						DEBUG(grf, 1)("ResolveSpriteGroup: need determinstic handler for feature `%x'.", feature);
+					}
+				}
+			}
+
+			if (value == -1) {
+				if (dsg->num_ranges > 0) {
+					target = &dsg->ranges[0].group;
+				} else {
+					target = dsg->default_group;
+				}
+			} else {
+				target = EvalDeterministicSpriteGroup(dsg, value);
+			}
+
+			return resolve_func(target, object, callback_info, feature, resolve_func);
+		}
+
+		case SGT_RANDOMIZED: {
+			const RandomizedSpriteGroup *rsg = &spritegroup->g.random;
+			uint32 random_bits = 0;
+
+			//if (object == -1) {
+				/* Purchase list */
+			//	assert(rsg->num_groups > 0);
+
+			//	return resolve_func(&rsg->groups[0], object, callback_info, feature, resolve_func);
+			//}
+
+			if (rsg->var_scope == VSG_SCOPE_PARENT) {
+				/* Get parent object */
+				if (evalfeature_procs[feature].getparentobject != NULL) {
+					ParentObject parent = evalfeature_procs[feature].getparentobject(object);
+					if (evalfeature_procs[parent.feature].randombits != NULL) {
+						random_bits = evalfeature_procs[parent.feature].randombits(parent.object);
+					} else {
+						DEBUG(grf, 1)("ResolveSpriteGroup: need randombits handler for feature `%x'.", parent.feature);
+					}
+				} else {
+					DEBUG(grf, 1)("ResolveSpriteGroup: need parent handler for feature `%x'.", feature);
+				}
+			} else {
+				if (evalfeature_procs[feature].randombits != NULL) {
+					random_bits = evalfeature_procs[feature].randombits(object);
+				} else {
+					DEBUG(grf, 1)("ResolveSpriteGroup: need randombits handler for feature `%x'.", feature);
+				}
+			}
+
+			return resolve_func(EvalRandomizedSpriteGroup(rsg, random_bits), object, callback_info, feature, resolve_func);
+		}
+
+		default:
+			error("Unknown sprite group type `0x%x'.", spritegroup->type);
+			return 0;
+	}
+}
Index: engine.h
===================================================================
--- engine.h	(revision 2949)
+++ engine.h	(working copy)
@@ -138,34 +138,6 @@
 	NUM_GLOBAL_CID  =  31
 };
 
-// This enum lists the implemented callbacks
-// Use as argument for the GetCallBackResult function (see comments there)
-enum CallbackID {
-	// Powered wagons, if the result is lower as 0x40 then the wagon is powered
-	// TODO: interpret the rest of the result, aka "visual effects"
-	CBID_WAGON_POWER = 0x10,
-
-	// Vehicle length, returns the amount of 1/8's the vehicle is shorter
-	// only for train vehicles
-	CBID_VEH_LENGTH = 0x11,
-
-	// Refit capacity, the passed vehicle needs to have its ->cargo_type set to
-	// the cargo we are refitting to, returns the new cargo capacity
-	CBID_REFIT_CAP = 0x15,
-};
-
-// bit positions for rvi->callbackmask, indicates which callbacks are used by an engine
-// (some callbacks are always used, and dont appear here)
-enum CallbackMask {
-	CBM_WAGON_POWER = 0,
-	CBM_VEH_LENGTH = 1,
-	CBM_REFIT_CAP = 3,
-};
-
-enum {
-	CALLBACK_FAILED = 0xFFFF
-};
-
 VARDEF const uint32 _default_refitmasks[NUM_VEHICLE_TYPES];
 VARDEF const CargoID _global_cargo_id[NUM_LANDSCAPE][NUM_CARGO];
 VARDEF const uint32 _landscape_global_cargo_mask[NUM_LANDSCAPE];
Index: sprite.h
===================================================================
--- sprite.h	(revision 2949)
+++ sprite.h	(working copy)
@@ -70,6 +70,7 @@
 	// Take this variable:
 	VarSpriteGroupScope var_scope;
 	byte variable;
+	byte parameter; ///< Used for variables between 0x60 and 0x7F inclusive.
 
 	// Do this with it:
 	byte shift_num;
@@ -147,10 +148,25 @@
 /* This takes randomized bitmask (probably associated with
  * vehicle/station/whatever) and chooses corresponding SpriteGroup
  * accordingly to the given RandomizedSpriteGroup. */
-SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, byte random_bits);
+SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, uint32 random_bits);
 /* Triggers given RandomizedSpriteGroup with given bitmask and returns and-mask
  * of random bits to be reseeded, or zero if there were no triggers matched
  * (then they are |ed to @waiting_triggers instead). */
 byte RandomizedSpriteGroupTriggeredBits(const RandomizedSpriteGroup *rsg, byte triggers, byte *waiting_triggers);
 
+typedef struct ParentObject {
+	byte feature;
+	int object;
+} ParentObject;
+
+typedef uint16 EvalRealProc(const RealSpriteGroup *rsg, int object);
+typedef int EvalDeterministicProc(int variable, byte parameter, int object);
+typedef uint32 EvalRandomBitsProc(int object);
+typedef ParentObject EvalGetParentObjectProc(int object);
+
+typedef uint16 (*resolve_callback)(const SpriteGroup *spritegroup,
+	int object, uint16 callback_info, byte feature, void *resolve_func); /* XXX data pointer used as function pointer */
+
+uint16 ResolveSpriteGroup(const SpriteGroup *spritegroup, int object, uint16 callback_info, byte feature, resolve_callback resolve_func);
+
 #endif
Index: openttd.h
===================================================================
--- openttd.h	(revision 2949)
+++ openttd.h	(working copy)
@@ -515,6 +515,10 @@
 	SPECSTR_SCREENSHOT_START = 0x7140,
 	SPECSTR_SCREENSHOT_END = 0x715F,
 
+	// reserve 32 strings for custom station classes
+	SPECSTR_STATIONCLASS_START = 0x7160,
+	SPECSTR_STATIONCLASS_END = 0x717F,
+
 	// Used to implement SetDParamStr
 	STR_SPEC_DYNSTRING = 0xF800,
 	STR_SPEC_USERSTRING = 0xF808,
Index: strings.c
===================================================================
--- strings.c	(revision 2949)
+++ strings.c	(working copy)
@@ -26,6 +26,7 @@
 static char *FormatString(char *buff, const char *str, const int32 *argv, uint casei);
 
 extern const char _openttd_revision[];
+extern char *_station_class_names[];
 
 typedef struct LanguagePack {
 	uint32 ident;
@@ -959,6 +960,12 @@
 		return strecpy(buff, GetScreenshotFormatDesc(i), NULL);
 	}
 
+	// custom station class name?
+	if (IS_INT_INSIDE(ind, (SPECSTR_STATIONCLASS_START - 0x70E4), (SPECSTR_STATIONCLASS_END - 0x70E4) + 1)) {
+		int i = ind - (SPECSTR_STATIONCLASS_START - 0x70E4);
+		return strecpy(buff, _station_class_names[i], NULL);
+	}
+
 	assert(0);
 	return NULL;
 }
Index: saveload.c
===================================================================
--- saveload.c	(revision 2949)
+++ saveload.c	(working copy)
@@ -29,7 +29,7 @@
 #include <setjmp.h>
 
 enum {
-	SAVEGAME_MAJOR_VERSION = 16,
+	SAVEGAME_MAJOR_VERSION = 17,
 	SAVEGAME_MINOR_VERSION = 0,
 
 	SAVEGAME_LOADABLE_VERSION = (SAVEGAME_MAJOR_VERSION << 8) + SAVEGAME_MINOR_VERSION
@@ -534,6 +534,9 @@
 				length += SlCalcRefLen(); break;
 			case SL_ARR: case SL_CONDARR: /* Array */
 				length += SlCalcArrayLen(NULL, sld->length, sld->type); break;
+			case SL_CONDVARR: /* Variable length array */
+				assert(sld->length_handler != NULL);
+				length += sld->length_handler(object) * SlCalcConvLen(NULL, sld->type); break;
 			default: NOT_REACHED();
 			}
 		} else if (sld->cmd == SL_WRITEBYTE) {
@@ -583,6 +586,18 @@
 				break;
 			case SL_ARR: case SL_CONDARR: /* Array */
 				SlArray(ptr, sld->length, sld->type); break;
+			case SL_CONDVARR: /* Variable length array */
+				{
+					uint16 len = sld->length_handler(object);
+					void *array;
+					if (_sl.save) {
+						array = *(void**)ptr;
+					} else {
+						array = malloc(len * SlCalcConvLen(NULL, sld->type));
+						*(void**)ptr = array;
+					}
+					SlArray(array, len, sld->type);
+				} break;
 			default: NOT_REACHED();
 			}
 
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 2949)
+++ train_cmd.c	(working copy)
@@ -21,6 +21,7 @@
 #include "debug.h"
 #include "waypoint.h"
 #include "vehicle_gui.h"
+#include "newgrf_callbacks.h"
 
 #define IS_FIRSTHEAD_SPRITE(spritenum) \
 	(is_custom_sprite(spritenum) ? IS_CUSTOM_FIRSTHEAD_SPRITE(spritenum) : _engine_sprite_add[spritenum] == 0)
@@ -100,7 +101,7 @@
 			uint16 callback = CALLBACK_FAILED;
 
 			if (HASBIT(rvi_u->callbackmask, CBM_WAGON_POWER))
-				callback = GetCallBackResult(CBID_WAGON_POWER,  u->engine_type, u);
+				callback = GetCallBackResult(CBID_TRAIN_WAGON_POWER,  u->engine_type, u);
 
 			if (callback == CALLBACK_FAILED)
 				callback = rvi_u->visual_effect;
@@ -113,13 +114,13 @@
 		}
 
 		// max speed is the minimum of the speed limits of all vehicles in the consist
-		if (rvi_u->max_speed != 0)
+		if (rvi_u->max_speed != 0 && !UsesWagonOverride(u))
 			max_speed = min(rvi_u->max_speed, max_speed);
 
 		// check the vehicle length (callback)
 		veh_len = CALLBACK_FAILED;
 		if (HASBIT(rvi_u->callbackmask, CBM_VEH_LENGTH))
-			veh_len = GetCallBackResult(CBID_VEH_LENGTH,  u->engine_type, u);
+			veh_len = GetCallBackResult(CBID_TRAIN_WAGON_LENGTH,  u->engine_type, u);
 		if (veh_len == CALLBACK_FAILED)
 			veh_len = rvi_u->shorten_factor;
 		veh_len = clamp(veh_len, 0, u->next == NULL ? 7 : 5); // the clamp on vehicles not the last in chain is stricter, as too short wagons can break the 'follow next vehicle' code
@@ -1522,7 +1523,7 @@
 				/* Check the 'refit capacity' callback */
 				CargoID temp_cid = v->cargo_type;
 				v->cargo_type = new_cid;
-				amount = GetCallBackResult(CBID_REFIT_CAP, v->engine_type, v);
+				amount = GetCallBackResult(CBID_VEHICLE_REFIT_CAPACITY, v->engine_type, v);
 				v->cargo_type = temp_cid;
 			}
 
@@ -1545,9 +1546,14 @@
 					cost += (_price.build_railvehicle >> 8);
 				num += amount;
 				if (flags & DC_EXEC) {
-					v->cargo_count = 0;
-					v->cargo_type = new_cid;
-					v->cargo_cap = amount;
+					if (new_cid == v->cargo_type) {
+						v->refit_cycle++;
+					} else {
+						v->refit_cycle = 0;
+						v->cargo_count = 0;
+						v->cargo_type = new_cid;
+						v->cargo_cap = amount;
+					}
 					InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 					InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
 				}
Index: saveload.h
===================================================================
--- saveload.h	(revision 2949)
+++ saveload.h	(working copy)
@@ -121,12 +121,15 @@
 	SL_CONDVAR   = 0 | (1 << 2), // 4
 	SL_CONDREF   = 1 | (1 << 2), // 5
 	SL_CONDARR   = 2 | (1 << 2), // 6
+	SL_CONDVARR  = 7, ///< (Conditional) Variable length array
 	// non-normal save-load types
 	SL_WRITEBYTE = 8,
 	SL_INCLUDE   = 9,
 	SL_END       = 15
 };
 
+typedef uint16 SaveLoadVARRProc(void *object);
+
 /** SaveLoad type struct. Do NOT use this directly but use the SLE_ macros defined just below! */
 typedef struct SaveLoad {
 	byte cmd;             /// the action to take with the saved/loaded type, All types need different action
@@ -135,31 +138,33 @@
 	uint16 length;        /// (conditional) length of the variable (eg. arrays) (max array size is 65536 elements)
 	uint16 version_from;  /// save/load the variable starting from this savegame version
 	uint16 version_to;    /// save/load the variable until this savegame version
+	SaveLoadVARRProc *length_handler; ///< Procedure to calculate the length
 } SaveLoad;
 
 /* Simple variables, references (pointers) and arrays */
-#define SLE_VAR(base, variable, type) {SL_VAR, type, offsetof(base, variable), 0, 0, 0}
-#define SLE_REF(base, variable, type) {SL_REF, type, offsetof(base, variable), 0, 0, 0}
-#define SLE_ARR(base, variable, type, length) {SL_ARR, type, offsetof(base, variable), length, 0, 0}
+#define SLE_VAR(base, variable, type) {SL_VAR, type, offsetof(base, variable), 0, 0, 0, NULL}
+#define SLE_REF(base, variable, type) {SL_REF, type, offsetof(base, variable), 0, 0, 0, NULL}
+#define SLE_ARR(base, variable, type, length) {SL_ARR, type, offsetof(base, variable), length, 0, 0, NULL}
 /* Conditional variables, references (pointers) and arrays that are only valid for certain savegame versions */
-#define SLE_CONDVAR(base, variable, type, from, to) {SL_CONDVAR, type, offsetof(base, variable), 0, from, to}
-#define SLE_CONDREF(base, variable, type, from, to) {SL_CONDREF, type, offsetof(base, variable), 0, from, to}
-#define SLE_CONDARR(base, variable, type, length, from, to) {SL_CONDARR, type, offsetof(base, variable), length, from, to}
+#define SLE_CONDVAR(base, variable, type, from, to) {SL_CONDVAR, type, offsetof(base, variable), 0, from, to, NULL}
+#define SLE_CONDREF(base, variable, type, from, to) {SL_CONDREF, type, offsetof(base, variable), 0, from, to, NULL}
+#define SLE_CONDARR(base, variable, type, length, from, to) {SL_CONDARR, type, offsetof(base, variable), length, from, to, NULL}
+#define SLE_CONDVARR(base, variable, type, length_handler, from, to) {SL_CONDVARR, type, offsetof(base, variable), 0, from, to, length_handler}
 /* Translate values ingame to different values in the savegame and vv */
-#define SLE_WRITEBYTE(base, variable, game_value, file_value) {SL_WRITEBYTE, 0, offsetof(base, variable), 0, game_value, file_value}
+#define SLE_WRITEBYTE(base, variable, game_value, file_value) {SL_WRITEBYTE, 0, offsetof(base, variable), 0, game_value, file_value, NULL}
 /* Load common code and put it into each struct (currently only for vehicles */
-#define SLE_INCLUDE(base, variable, include_index) {SL_INCLUDE, 0, offsetof(base, variable), 0, include_index, 0}
+#define SLE_INCLUDE(base, variable, include_index) {SL_INCLUDE, 0, offsetof(base, variable), 0, include_index, 0, NULL}
 
 /* The same as the ones at the top, only the offset is given directly; used for unions */
-#define SLE_VARX(offset, type) {SL_VAR, type, offset, 0, 0, 0}
-#define SLE_REFX(offset, type) {SL_REF, type, offset, 0, 0, 0}
-#define SLE_CONDVARX(offset, type, from, to) {SL_CONDVAR, type, offset, 0, from, to}
-#define SLE_CONDREFX(offset, type, from, to) {SL_CONDREF, type, offset, 0, from, to}
-#define SLE_WRITEBYTEX(offset, something) {SL_WRITEBYTE, 0, offset, 0, something, 0}
-#define SLE_INCLUDEX(offset, type) {SL_INCLUDE, type, offset, 0, 0, 0}
+#define SLE_VARX(offset, type) {SL_VAR, type, offset, 0, 0, 0, NULL}
+#define SLE_REFX(offset, type) {SL_REF, type, offset, 0, 0, 0, NULL}
+#define SLE_CONDVARX(offset, type, from, to) {SL_CONDVAR, type, offset, 0, from, to, NULL}
+#define SLE_CONDREFX(offset, type, from, to) {SL_CONDREF, type, offset, 0, from, to, NULL}
+#define SLE_WRITEBYTEX(offset, something) {SL_WRITEBYTE, 0, offset, 0, something, 0, NULL}
+#define SLE_INCLUDEX(offset, type) {SL_INCLUDE, type, offset, 0, 0, 0, NULL}
 
 /* End marker */
-#define SLE_END() {SL_END, 0, 0, 0, 0, 0}
+#define SLE_END() {SL_END, 0, 0, 0, 0, 0, NULL}
 
 void SlSetArrayIndex(uint index);
 int SlIterateArray(void);
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 2949)
+++ rail_cmd.c	(working copy)
@@ -23,6 +23,7 @@
 #include "npf.h"
 #include "rail.h"
 #include "railtypes.h" // include table for railtypes
+#include "newgrf_callbacks.h"
 
 extern uint16 _custom_sprites_base;
 
@@ -1502,7 +1503,14 @@
 				DrawTileSeqStruct const *seq;
 				// emulate station tile - open with building
 				DrawTileSprites *cust = &stat->renderdata[2 + (m5 & 0x1)];
-				uint32 relocation = GetCustomStationRelocation(stat, ComposeWaypointStation(ti->tile), 0);
+				//GRFFile *file;
+				uint32 relocation = GetCustomStationRelocation(stat, ComposeWaypointStation(ti->tile), GC_DEFAULT, ti->tile);
+
+				if (HASBIT(stat->callbackmask, CBM_SPRITE_LAYOUT)) {
+					uint32 callback = GetStationCallBackResult(CBID_STATION_SPRITE_LAYOUT, stat, NULL, ti->tile);
+					if (callback != CALLBACK_FAILED)
+						cust = &stat->renderdata[callback + (m5 & 0x1)];
+				}
 
 				/* We don't touch the 0x8000 bit. In all this
 				 * waypoint code, it is used to indicate that
@@ -1514,6 +1522,10 @@
 				 * up to the GRF file to decide that. */
 
 				image = cust->ground_sprite;
+				if (HASBIT(image, 31)) {
+					image &= 0xFFFF;
+					image += stat->ground_relocation;
+				}
 				image += (image < _custom_sprites_base) ? rti->total_offset : GetRailType(ti->tile);
 
 				DrawGroundSprite(image);
Index: vehicle.h
===================================================================
--- vehicle.h	(revision 2949)
+++ vehicle.h	(working copy)
@@ -239,6 +239,7 @@
 	int32 profit_this_year;
 	int32 profit_last_year;
 	uint32 value;
+	byte refit_cycle;
 
 	union {
 		VehicleRail rail;
Index: economy.c
===================================================================
--- economy.c	(revision 2949)
+++ economy.c	(working copy)
@@ -1464,6 +1464,7 @@
 
 	if (result != 0) {
 		InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
+		MarkWholeStationDirty(st);
 
 		if (result & 2)
 			InvalidateWindow(WC_STATION_VIEW, last_visited);
Index: widget.c
===================================================================
--- widget.c	(revision 2949)
+++ widget.c	(working copy)
@@ -459,7 +459,7 @@
 
 static int GetDropdownItem(Window *w)
 {
-	uint item;
+	uint item, counter;
 	int y;
 
 	if (GetWidgetFromPos(w, _cursor.pos.x - w->left, _cursor.pos.y - w->top) < 0)
@@ -474,6 +474,12 @@
 	if (item >= _dropdown_item_count || (HASBIT(_dropdown_disabled,item) && !_dropdown_disabled_items) || _dropdown_items[item] == 0)
 		return - 1;
 
+	// make sure that item match the index of the string, that was clicked
+	// basically we just add one for each hidden item before the clicked one
+	for (counter = 0 ; item >= counter; ++counter) {
+		if (HASBIT(_dropdown_disabled_items, counter)) item++;
+	}
+
 	return item;
 }
 
@@ -520,12 +526,6 @@
 		case WE_CLICK: {
 			item = GetDropdownItem(w);
 			if (item >= 0) {
-				// make sure that item match the index of the string, that was clicked
-				// basically we just add one for each hidden item before the clicked one
-				byte counter;
-				for (counter = 0 ; item >= counter; ++counter) {
-					if (HASBIT(_dropdown_disabled_items, counter)) item++;
-				}
 				_dropdown_var1 = 4;
 				_dropdown_selindex = item;
 				SetWindowDirty(w);
Index: waypoint.c
===================================================================
--- waypoint.c	(revision 2949)
+++ waypoint.c	(working copy)
@@ -16,6 +16,7 @@
 #include "variables.h"
 #include "table/sprites.h"
 #include "table/strings.h"
+#include "engine.h" // Global Cargo IDs?
 
 enum {
 	/* Max waypoints: 64000 (8 * 8000) */
@@ -345,13 +346,23 @@
 {
 	Waypoint *wp = GetWaypointByTile(tile);
 	static Station stat;
+	static byte random_bits = 0;
 
 	stat.train_tile = stat.xy = wp->xy;
 	stat.town = GetTown(wp->town_index);
 	stat.string_id = wp->string == STR_NULL ? /* FIXME? */ 0 : wp->string;
 	stat.build_date = wp->build_date;
-	stat.class_id = 6;
-	stat.stat_id = wp->stat_id;
+	//stat.class_id = 6;
+	//stat.stat_id = wp->stat_id;
+	stat.num_segments = 1;
+	stat.segments = realloc(stat.segments, sizeof(StationSegment));
+	stat.segments[0].sclass = STAT_CLASS_WAYP;
+	stat.segments[0].cstation = wp->stat_id;
+	stat.segments[0].tile = tile;
+	stat.segments[0].platforms = 1;
+	stat.segments[0].length = 1;
+	stat.segments[0].direction = _m[tile].m5 & 1;
+	stat.segments[0].random_bits = &random_bits;
 
 	return &stat;
 }
@@ -382,12 +393,19 @@
 
 	stat = GetCustomStation(STAT_CLASS_WAYP, stat_id - 1);
 	assert(stat);
-	relocation = GetCustomStationRelocation(stat, NULL, 1);
+	relocation = GetCustomStationRelocation(stat, NULL, GC_PURCHASE, INVALID_TILE);
+	if (relocation == 0x42D)
+		relocation = GetCustomStationRelocation(stat, NULL, GC_DEFAULT, INVALID_TILE);
+
 	// emulate station tile - open with building
 	// add 1 to get the other direction
 	cust = &stat->renderdata[2];
 
 	img = cust->ground_sprite;
+	if (HASBIT(img, 31)) {
+		img &= 0xfff;
+		img += stat->ground_relocation;
+	}
 	img += (img < _custom_sprites_base) ? rti->total_offset : railtype;
 
 	if (img & PALETTE_MODIFIER_COLOR) img = (img & SPRITE_MASK);
Index: station.h
===================================================================
--- station.h	(revision 2949)
+++ station.h	(working copy)
@@ -46,6 +46,24 @@
 	struct RoadStop *prev;
 } RoadStop;
 
+/**
+ * Describes an individually built block of a custom station.
+ */
+typedef struct StationSegment {
+	TileIndex tile;     ///< Top-left tile of the segment.
+	bool direction;     ///< Direction of the tracks. 0 = x, 1 = y
+	byte length;        ///< Length of the platforms.
+	byte platforms;     ///< Number of platforms.
+
+	byte sclass;        ///< Custom station class.
+	byte cstation;      ///< Custom station number.
+	byte *random_bits;  ///< pointer to array of 4 random bits for *each tile*.
+
+	/* These are used to tie the station to the grf file */
+	uint32 grfid;       ///< GRF ID
+	uint8 gstation;     ///< station number
+} StationSegment;
+
 struct Station {
 	TileIndex xy;
 	RoadStop *bus_stops;
@@ -70,8 +88,8 @@
 	// trainstation width/height
 	byte trainst_w, trainst_h;
 
-	byte class_id; // custom graphics station class
-	byte stat_id; // custom graphics station id in the @class_id class
+	//byte class_id; // custom graphics station class
+	//byte stat_id; // custom graphics station id in the @class_id class
 	uint16 build_date;
 
 	//uint16 airport_flags;
@@ -88,6 +106,23 @@
 	byte truck_stop_status_obsolete;
 	byte bus_stop_status_obsolete;
 	byte blocked_months_obsolete;
+
+	/**
+	 * Random data for NewGRF
+	 */
+	uint16 random_bits;
+	byte waiting_triggers;
+	/**
+	 * Number of custom station segments to this station.
+	 */
+	byte num_segments;
+	/**
+	 * Array of custom station segments.
+	 * Dynamically allocated.
+	 */
+	StationSegment *segments;
+	TileIndex topleft;     ///< Top left coordinate of station. Not saved.
+	TileIndex bottomright; ///< Bottom right coordinate of station. Not saved.
 };
 
 enum {
@@ -198,9 +233,9 @@
 typedef byte *StationLayout;
 
 typedef enum StationClass {
-	STAT_CLASS_NONE, // unused station slot or so
-	STAT_CLASS_DFLT, // default station class
-	STAT_CLASS_WAYP, // waypoints
+	//STAT_CLASS_NONE, // unused station slot or so
+	STAT_CLASS_DFLT = 0, // default station class
+	STAT_CLASS_WAYP = 1, // waypoints
 
 	/* TODO: When we actually support custom classes, they are
 	 * going to be allocated dynamically (with some classid->sclass
@@ -219,11 +254,11 @@
 	/* Bitmask of platform numbers/lengths available for the station.  Bits
 	 * 0..6 correspond to 1..7, while bit 7 corresponds to >7 platforms or
 	 * lenght. */
-	byte allowed_platforms;
-	byte allowed_lengths;
+	byte disallowed_platforms;
+	byte disallowed_lengths;
 
 	/* Custom sprites */
-	byte tiles;
+	uint16 tiles;
 	/* 00 = plain platform
 	 * 02 = platform with building
 	 * 04 = platform with roof, left side
@@ -231,7 +266,8 @@
 	 *
 	 * These numbers are used for stations in NE-SW direction, or these
 	 * numbers plus one for stations in the NW-SE direction.  */
-	DrawTileSprites renderdata[8];
+	uint16 ground_relocation;
+	DrawTileSprites *renderdata;
 
 	/* Custom layouts */
 	/* The layout array is organized like [lenghts][platforms], both being
@@ -250,12 +286,41 @@
 	 * default OTTD station layout should be used for stations of these
 	 * dimensions. */
 	StationLayout **layouts;
+	/* @name
+	 * Name for the station */
+	char *name;
+	/* @cargotriggers  Cargo types for random triggers (12)
+	 * This sets which cargo types should trigger re-randomizing. The cargo
+	 * types are given as a bitmask of the bits from column 3 (type B) in
+	 * CargoTypes. If nothing is set (the default), the no random triggers
+	 * will happen, to conserve CPU time. */
+	uint32 cargotriggers;
+	/* @flags General Flags (13)
+	 * bit 0 - use different sprite set for ground sprites (var. 10 is 1
+	 *         for ground sprites, 0 otherwise)
+	 * bit 1 - when calculating the cargo amount to display, divide the
+	 *         amount by the station size (to simulate cargo distributed
+	 *         over the area of the station) */
+	byte flags;
+	byte callbackmask;
+	/* Bit mask of tile types that cannot pass traffic */
+	byte blocked;
+	/* @cargo_threshold
+	 * Threshold of little/lots of cargo */
+	uint16 cargo_threshold;
 
 	/* Sprite offsets for renderdata->seq->image. spritegroup[0] is default
 	 * whilst spritegroup[1] is "GC_PURCHASE". */
-	SpriteGroup spritegroup[2];
+	SpriteGroup spritegroup[31]; /* NUM_GLOBAL_CID */
 } StationSpec;
 
+int AllocateCustomStationClass(uint32 classid);
+void SetCustomStationClassName(int classid, const char *name);
+StringID GetCustomStationClassName(int classid);
+StringID CustomStationGetStationName(StationSpec *spec);
+int GetNumCustomStationClasses(void);
+StringID *BuildCustomStationClassDropdown(void);
+
 /* Here, @stid is local per-GRFFile station index. If spec->localidx is not yet
  * set, it gets new dynamically allocated global index and spec->localidx is
  * set to @stid, otherwise we take it as that we are replacing it and try to
@@ -267,8 +332,9 @@
 /* Get sprite offset for a given custom station and station structure (may be
  * NULL if ctype is set - that means we are in a build dialog). The station
  * structure is used for variational sprite groups. */
-uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte ctype);
+uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte ctype, TileIndex tile);
 int GetCustomStationsCount(StationClass sclass);
+void DrawStationSprite(int x, int y, StationClass sclass, byte image, uint railtype, byte direction);
 
 RoadStop * GetRoadStopByTile(TileIndex tile, RoadStopType type);
 static inline int GetRoadStopType(TileIndex tile)
@@ -283,7 +349,7 @@
 
 static inline bool IsTrainStationTile(TileIndex tile)
 {
-	return IsTileType(tile, MP_STATION) && IS_BYTE_INSIDE(_m[tile].m5, 0, 8);
+	return IsTileType(tile, MP_STATION) && IS_BYTE_INSIDE(_m[tile].m5, 0, 8) && !HASBIT(_m[tile].m3, 7);
 }
 
 static inline bool IsCompatibleTrainStationTile(TileIndex tile, TileIndex ref)
@@ -324,4 +390,19 @@
 	return (_m[tile].m5 - 0x43) & 3;
 }
 
+typedef enum StationTrigger {
+	STATION_TRIGGER_NEW_CARGO     = 1 << 0,
+	STATION_TRIGGER_NO_CARGO      = 1 << 1,
+	STATION_TRIGGER_TRAIN_ARRIVES = 1 << 2,
+	STATION_TRIGGER_TRAIN_LEAVES  = 1 << 3,
+	STATION_TRIGGER_TRAIN_CARGO   = 1 << 4,
+	STATION_TRIGGER_TRAIN_RESERVE = 1 << 5,
+} StationTrigger;
+void TriggerStation(TileIndex tile, StationTrigger trigger);
+
+/** Tell the graphics system to redraw the station.
+ * @param st The station to redraw
+ */
+void MarkWholeStationDirty(Station *st);
+
 #endif /* STATION_H */
Index: rail_gui.c
===================================================================
--- rail_gui.c	(revision 2949)
+++ rail_gui.c	(working copy)
@@ -20,12 +20,16 @@
 #include "waypoint.h"
 #include "debug.h"
 #include "variables.h"
+#include "newgrf_callbacks.h"
 
 static uint _cur_railtype;
 static bool _remove_button_clicked;
 static byte _build_depot_direction;
 static byte _waypoint_count=1;
 static byte _cur_waypoint_type;
+static byte _station_count=0;
+static byte _cur_station_type;
+static byte _cur_station_class = 0;
 
 struct {
 	byte orientation;
@@ -137,7 +141,8 @@
 {
 	if (success) {
 		SndPlayTileFx(SND_20_SPLAT_2, tile);
-		ResetObjectToPlace();
+		if (_cur_station_type == 0 && _cur_station_class == 0)
+			ResetObjectToPlace();
 	}
 }
 
@@ -151,7 +156,7 @@
 	} else {
 		// TODO: Custom station selector GUI. Now we just try using first custom station
 		// (and fall back to normal stations if it isn't available).
-		DoCommandP(tile, _railstation.orientation | (_railstation.numtracks<<8) | (_railstation.platlength<<16),_cur_railtype|1<<4, CcStation,
+		DoCommandP(tile, _railstation.orientation | (_railstation.numtracks<<8) | (_railstation.platlength<<16),_cur_railtype | (_cur_station_class != 0 || _cur_station_type != 0) << 4 | _cur_station_type << 8 | _cur_station_class << 16, CcStation,
 				CMD_BUILD_RAILROAD_STATION | CMD_NO_WATER | CMD_AUTO | CMD_MSG(STR_100F_CAN_T_BUILD_RAILROAD_STATION));
 	}
 }
@@ -269,6 +274,7 @@
 
 static void BuildRailClick_Station(Window *w)
 {
+	_station_count = GetCustomStationsCount(_cur_station_class);
 	if (HandlePlacePushButton(w, 12, SPR_CURSOR_RAIL_STATION, 1, PlaceRail_Station)) ShowStationBuilder();
 }
 
@@ -596,7 +602,7 @@
 
 	// TODO: Custom station selector GUI. Now we just try using first custom station
 	// (and fall back to normal stations if it isn't available).
-	DoCommandP(TileXY(sx, sy), _railstation.orientation | (w << 8) | (h << 16), _cur_railtype | 1 << 4, CcStation,
+	DoCommandP(TileXY(sx, sy), _railstation.orientation | (w << 8) | (h << 16), _cur_railtype | (_cur_station_class != 0 || _cur_station_type != 0) << 4 | _cur_station_type << 8 | _cur_station_class << 16, CcStation,
 		CMD_BUILD_RAILROAD_STATION | CMD_NO_WATER | CMD_AUTO | CMD_MSG(STR_100F_CAN_T_BUILD_RAILROAD_STATION));
 }
 
@@ -606,6 +612,8 @@
 	case WE_PAINT: {
 		int rad;
 		uint bits;
+		byte i;
+		StationSpec *stat = GetCustomStation(_cur_station_class, _cur_station_type);
 
 		if (WP(w,def_d).close) return;
 
@@ -617,6 +625,8 @@
 			bits |= (1<<(12-1)) << (_railstation.platlength);
 		}
 		bits |= (1<<20) << (_station_show_coverage);
+		//if (IS_BYTE_INSIDE(_cur_station_type - w->vscroll.pos, 0, 5))
+		//	bits |= (1<<22) << (_cur_station_type - w->vscroll.pos);
 		w->click_state = bits;
 
 		if (_railstation.dragdrop) {
@@ -640,18 +650,83 @@
 			SETBIT(w->disabled_state, bits + 5);
 			SETBIT(w->disabled_state, bits + 12);
 		}
+		/* Update buttons for allowed platforms/lengths */
+		if (stat != NULL) {
+			for (bits = 0; bits < 7; bits++) {
+				if (HASBIT(stat->disallowed_platforms, bits)) SETBIT(w->disabled_state, bits + 5);
+				if (HASBIT(stat->disallowed_lengths,   bits)) SETBIT(w->disabled_state, bits + 12);
+			}
+		}
+		/*for (i = 0; i < 5; i++) {
+			stat = GetCustomStation(_cur_station_class, i + w->vscroll.pos);
+			if (stat == NULL) {
+				// Stations that don't exist
+				if (_cur_station_class == 0 && i + w->vscroll.pos == 0) {
+					CLRBIT(w->disabled_state, i + 22);
+				} else {
+					SETBIT(w->disabled_state, i + 22);
+				}
+			} else {
+				// Callback 0x13
+				uint16 callback = 1;
+				if (HASBIT(stat->callbackmask, CBM_AVAILABILITY)) {
+					callback = GetStationCallBackResult(CBID_STATION_AVAILABILITY, stat, NULL, INVALID_TILE);
+				}
+				if (callback == 0) {
+					SETBIT(w->disabled_state, i + 22);
+				} else {
+					CLRBIT(w->disabled_state, i + 22);
+				}
+			}
+		}*/
+
+		// Somehow this works. How?
+		SetDParam(1, GetCustomStationClassName(_cur_station_class));
 
 		DrawWindowWidgets(w);
 
-		StationPickerDrawSprite(39, 42, _cur_railtype, 2);
-		StationPickerDrawSprite(107, 42, _cur_railtype, 3);
+		//StationPickerDrawSprite(39, 132, _cur_railtype, 2);
+		//StationPickerDrawSprite(107, 132, _cur_railtype, 3);
 
-		DrawStringCentered(74, 15, STR_3002_ORIENTATION, 0);
-		DrawStringCentered(74, 76, STR_3003_NUMBER_OF_TRACKS, 0);
-		DrawStringCentered(74, 101, STR_3004_PLATFORM_LENGTH, 0);
-		DrawStringCentered(74, 141, STR_3066_COVERAGE_AREA_HIGHLIGHT, 0);
+		DrawStringCentered(74, 105, STR_3002_ORIENTATION, 0);
+		DrawStringCentered(74, 166, STR_3003_NUMBER_OF_TRACKS, 0);
+		DrawStringCentered(74, 191, STR_3004_PLATFORM_LENGTH, 0);
+		DrawStringCentered(74, 231, STR_3066_COVERAGE_AREA_HIGHLIGHT, 0);
+
+		DrawStationCoverageAreaText(2, 256, (uint)-1, rad);
+
+		/* Custom Station GUI */
+		for (i = 0; i < 5; i++) {
+			StationSpec *spec;
+			char *default_name = "Default";
+			char *name = default_name;
+			bool selected = (_cur_station_type == w->vscroll.pos + i);
+
+			if (w->vscroll.pos + i >= _station_count) {
+				GfxFillRect(8, 33 + i * 14, 127, 44 + i * 14, PALETTE_MODIFIER_GREYOUT);
+				continue;
+			}
+			//DrawString(10 + offset, 34 + offset + i * 14, CustomStationGetStationName(GetCustomStation(_cur_station_class, i + w->vscroll.pos)), 0x10);
+			spec = GetCustomStation(_cur_station_class, i + w->vscroll.pos);
+			if (spec) {
+				if (HASBIT(spec->callbackmask, CBM_AVAILABILITY) && (GetStationCallBackResult(CBID_STATION_AVAILABILITY, spec, NULL, INVALID_TILE) == 0)) {
+					GfxFillRect(8, 33 + i * 14, 127, 44 + i * 14, PALETTE_MODIFIER_GREYOUT);
+					selected = false;
+				}
+				if (spec->name) {
+					name = spec->name;
+				}
+			//} else {
+			//	name = "Default";
+			}
+			if (selected) {
+				GfxFillRect(8, 33 + i * 14, 127, 44 + i * 14, 156);
+			}
+			DoDrawString(name, 10, 34 + i * 14, selected ? 0xC : 0x10);
+		}
 
-		DrawStationCoverageAreaText(2, 166, (uint)-1, rad);
+		DrawStationSprite( 6, 115, _cur_station_class, _cur_station_type, _cur_railtype, 0);
+		DrawStationSprite(74, 115, _cur_station_class, _cur_station_type, _cur_railtype, 1);
 	} break;
 
 	case WE_CLICK: {
@@ -701,9 +776,55 @@
 			SndPlayFx(SND_15_BEEP);
 			SetWindowDirty(w);
 			break;
+
+		case 22:
+		/*case 23:
+		case 24:
+		case 25:
+		case 26:
+			if ((e->click.widget - 22 + w->vscroll.pos) < _station_count)
+				_cur_station_type = e->click.widget - 22 + w->vscroll.pos;
+			SndPlayFx(SND_15_BEEP);
+			SetWindowDirty(w);
+			break; */
+			{
+				int y = (e->click.pt.y - 32) / 14;
+				StationSpec *spec;
+
+				if (y >= w->vscroll.cap) return;
+				y += w->vscroll.pos;
+				if (y >= _station_count) return;
+				// Check callback 13
+				spec = GetCustomStation(_cur_station_class, y);
+				if (spec && HASBIT(spec->callbackmask, CBM_AVAILABILITY) && (GetStationCallBackResult(CBID_STATION_AVAILABILITY, spec, NULL, INVALID_TILE) == 0))
+					return;
+
+				_cur_station_type = y;
+				SndPlayFx(SND_15_BEEP);
+				SetWindowDirty(w);
+			} break;
+		case 24:
+		case 25:
+			ShowDropDownMenu(w, BuildCustomStationClassDropdown(), _cur_station_class, 25, 2, true);
+			break;
 		}
 	} break;
 
+	case WE_DROPDOWN_SELECT:
+		switch (e->dropdown.button) {
+			case 25: /* CustomStationClassDropDown */
+				if (_cur_station_class != e->dropdown.index) {
+					_cur_station_class = e->dropdown.index;
+					_cur_station_type = 0;
+					_station_count = GetCustomStationsCount(_cur_station_class);
+					w->vscroll.count = _station_count;
+					w->vscroll.pos = _cur_station_type;
+				}
+				SndPlayFx(SND_15_BEEP);
+				SetWindowDirty(w);
+				break;
+		} break;
+
 	case WE_MOUSELOOP: {
 		if (WP(w,def_d).close) {
 			DeleteWindow(w);
@@ -722,36 +843,45 @@
 static const Widget _station_builder_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,     7,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,     7,    11,   147,     0,    13, STR_3000_RAIL_STATION_SELECTION, STR_018C_WINDOW_TITLE_DRAG_THIS},
-{      WWT_PANEL,   RESIZE_NONE,     7,     0,   147,    14,   199, 0x0,					STR_NULL},
-{      WWT_PANEL,   RESIZE_NONE,    14,     7,    72,    26,    73, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
-{      WWT_PANEL,   RESIZE_NONE,    14,    75,   140,    26,    73, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
-
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,    87,    98, STR_00CB_1,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,    87,    98, STR_00CC_2,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,    87,    98, STR_00CD_3,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,    87,    98, STR_00CE_4,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,    87,    98, STR_00CF_5,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,    87,    98, STR_0335_6,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,    87,    98, STR_0336_7,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,   112,   123, STR_00CB_1,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,   112,   123, STR_00CC_2,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,   112,   123, STR_00CD_3,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,   112,   123, STR_00CE_4,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,   112,   123, STR_00CF_5,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,   112,   123, STR_0335_6,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,   112,   123, STR_0336_7,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{      WWT_PANEL,   RESIZE_NONE,     7,     0,   147,    14,   289, 0x0,					STR_NULL},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,    72,   116,   163, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
+{      WWT_PANEL,   RESIZE_NONE,    14,    75,   140,   116,   163, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
+
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,   177,   188, STR_00CB_1,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,   177,   188, STR_00CC_2,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,   177,   188, STR_00CD_3,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,   177,   188, STR_00CE_4,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,   177,   188, STR_00CF_5,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,   177,   188, STR_0335_6,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,   177,   188, STR_0336_7,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,   202,   213, STR_00CB_1,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,   202,   213, STR_00CC_2,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,   202,   213, STR_00CD_3,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,   202,   213, STR_00CE_4,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,   202,   213, STR_00CF_5,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,   202,   213, STR_0335_6,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,   202,   213, STR_0336_7,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
 
 //{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    14,    73,   137,   148, STR_02DB_OFF, STR_3065_DON_T_HIGHLIGHT_COVERAGE},
 //{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    74,   133,   137,   148, STR_02DA_ON, STR_3064_HIGHLIGHT_COVERAGE_AREA},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,   111,   126,   137, STR_DRAG_DROP, STR_STATION_DRAG_DROP},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    14,    73,   152,   163, STR_02DB_OFF, STR_3065_DON_T_HIGHLIGHT_COVERAGE},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    74,   133,   152,   163, STR_02DA_ON, STR_3064_HIGHLIGHT_COVERAGE_AREA},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,   111,   216,   227, STR_DRAG_DROP, STR_STATION_DRAG_DROP},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    14,    73,   242,   253, STR_02DB_OFF, STR_3065_DON_T_HIGHLIGHT_COVERAGE},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    74,   133,   242,   253, STR_02DA_ON, STR_3064_HIGHLIGHT_COVERAGE_AREA},
+{     WWT_MATRIX,   RESIZE_NONE,    14,     7,   128,    32,   101, 0x501, STR_WAYPOINT_GRAPHICS_TIP},
+/*{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    32,    45, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    46,    59, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    60,    73, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    74,    87, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    88,   101, 0x0, STR_WAYPOINT_GRAPHICS_TIP},*/
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   129,   140,    32,   101, 0x0, STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{          WWT_6,   RESIZE_NONE,    14,     7,   140,    17,    28, STR_02E1, STR_NULL},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   129,   139,    18,    27, STR_0225, STR_WAYPOINT_GRAPHICS_TIP},
 {   WIDGETS_END},
 };
 
 static const WindowDesc _station_builder_desc = {
-	-1, -1, 148, 200,
+	-1, -1, 148, 290,
 	WC_BUILD_STATION,WC_BUILD_TOOLBAR,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET,
 	_station_builder_widgets,
@@ -760,7 +890,9 @@
 
 static void ShowStationBuilder(void)
 {
-	AllocateWindowDesc(&_station_builder_desc);
+	Window *w = AllocateWindowDesc(&_station_builder_desc);
+	w->vscroll.cap = 5;
+	w->vscroll.count = _station_count;
 }
 
 static void BuildTrainDepotWndProc(Window *w, WindowEvent *e)
Index: newgrf_callbacks.h
===================================================================
--- newgrf_callbacks.h	(revision 0)
+++ newgrf_callbacks.h	(revision 0)
@@ -0,0 +1,135 @@
+/* $id$ */
+
+#ifndef NEWGRF_CALLBACKS_H
+#define NEWGRF_CALLBACKS_H
+
+/**
+ * @file newgrf_callbacks.h
+ * Provides Callback IDs and masks.
+ */
+
+/**
+ * List of callbacks.
+ * The names are formatted as CBID_<CLASS>_<CALLBACK>
+ */
+enum CallbackID {
+	/**
+	 * Powered wagons, if the result is lower as 0x40 then the wagon is powered.
+	 */
+	CBID_TRAIN_WAGON_POWER          = 0x10,
+
+	/**
+	 * Wagon length.
+	 * @return The amount of "1/8s" the vehicle is shorter by.
+	 */
+	CBID_TRAIN_WAGON_LENGTH         = 0x11,
+
+	/**
+	 * Load amount.
+	 * Used instead of property 0x07 when the consist is changed.
+	 */
+	CBID_VEHICLE_LOAD_AMOUNT        = 0x12,
+
+	/**
+	 * Station availability.
+	 * Controls whether the station should be available in the construction
+	 * window.
+	 */
+	CBID_STATION_AVAILABILITY       = 0x13,
+	/**
+	 * Station sprite layout.
+	 * Selects an entry from the sprite layout of a station.
+	 */
+	CBID_STATION_SPRITE_LAYOUT      = 0x14,
+
+	/**
+	 * Refit capacity. The passed vehicle needs to have its ->cargo_type set to
+	 * the cargo we are refitting to.
+	 * @return The new cargo capacity.
+	 */
+	CBID_VEHICLE_REFIT_CAPACITY     = 0x15,
+
+	CBID_TRAIN_ARTICULATED          = 0x16,
+
+	CBID_HOUSE_CONSTRUCTION         = 0x17,
+
+	CBID_GENERIC_AI_CONSTRUCTION    = 0x18,
+
+	CBID_VEHICLE_CARGO_DISPLAY      = 0x19,
+
+	CBID_HOUSE_NEXT_ANIM_FRAME      = 0x1A,
+	CBID_HOUSE_ANIM_CONTROL         = 0x1B,
+	CBID_HOUSE_STATE_CHANGE         = 0x1C,
+
+	CBID_TRAIN_WAGON_ATTACH         = 0x1D,
+
+	CBID_HOUSE_COLOUR_REMAP         = 0x1E,
+	CBID_HOUSE_CARGO_ACCEPTANCE     = 0x1F,
+	CBID_HOUSE_ANIM_FRAME_LEN       = 0x20,
+	CBID_HOUSE_TRIGGER_DESTRUCTION  = 0x21,
+
+	CBID_INDUSTRY_AVAILABILITY      = 0x22,
+
+	CBID_TRAIN_ADDITIONAL_TEXT      = 0x23,
+
+	/**
+	 * Custom station layout.
+	 * Called once for each tile of a station being built. This callback is
+	 * always used.
+	 * @return New tile type to build. Returned values are 00, 02, 04 or 06.
+	 */
+	CBID_STATION_TILE_LAYOUT        = 0x24,
+
+	CBID_INDUSTRY_ANIM_CONTROL      = 0x25,
+	CBID_INDUSTRY_NEXT_ANIM_FRAME   = 0x26,
+	CBID_INDUSTRY_ANIM_FRAME_LEN    = 0x27,
+	CBID_INDUSTRY_LOCATION_PERM     = 0x28,
+	CBID_INDUSTRY_PROD_CHANGE       = 0x29,
+
+	CBID_HOUSE_CARGO_TYPES          = 0x2A,
+
+	CBID_INDUSTRY_CARRGO_ACCEPTANCE = 0x2B,
+	CBID_INDUSTRY_CARGO_TYPES       = 0x2C,
+
+	CBID_VEHICLE_COLOUR_REMAP       = 0x2D,
+
+	CBID_HOUSE_CARGO_GENERATION     = 0x2E,
+
+	CBID_INDUSTRY_SLOPE_CHECK       = 0x2F,
+	CBID_INDUSTRY_FOUNDATIONS       = 0x30,
+
+	CBID_VEHICLE_START_STOP_CHECK   = 0x31,
+	CBID_VEHICLE_EVENT_32DAYS       = 0x32,
+};
+
+/**
+ * Callback masks related to vehicles.
+ * Value is the bit position.
+ */
+enum VehicleCallbackMask {
+	CBM_WAGON_POWER  = 0, ///< Powered wagons (trains only)
+	CBM_VEH_LENGTH   = 1, ///< Wagon length (trains only)
+	CBM_LOAD_AMOUNT  = 2, ///< Load amount
+	CBM_REFIT_CAP    = 3, ///< Refitted capacity
+	CBM_ARTICULATED  = 4, ///< Build articulated engines (trains only)
+	CBM_CARGO_SUFFIX = 5, ///< Show suffix after cargo name
+	CBM_COLOUR_REMAP = 6, ///< Colour mapping for vehicle
+};
+
+/**
+ * Callback masks related to stations.
+ * Value is the bit position.
+ */
+enum StationCallbackMask {
+	CBM_AVAILABILITY  = 0, ///< Whether to make station available.
+	CBM_SPRITE_LAYOUT = 1, ///< Use callback to select sprite layout.
+};
+
+/**
+ * Result of a failed callback.
+ */
+enum {
+	CALLBACK_FAILED = 0xFFFF
+};
+
+#endif /* NEWGRF_CALLBACKS_H */
Index: newgrf.c
===================================================================
--- newgrf.c	(revision 2949)
+++ newgrf.c	(working copy)
@@ -747,9 +747,6 @@
 	int i;
 	int ret = 0;
 
-	/* This is one single huge TODO. It doesn't handle anything more than
-	 * just waypoints for now. */
-
 	//printf("sci %d %d [0x%02x]\n", stid, numinfo, prop);
 	switch (prop) {
 		case 0x08:
@@ -764,22 +761,7 @@
 				classid |= *(buf++) << 8;
 				classid |= *(buf++);
 
-				switch (classid) {
-					case 'DFLT':
-						stat->sclass = STAT_CLASS_DFLT;
-						break;
-					case 'WAYP':
-						stat->sclass = STAT_CLASS_WAYP;
-						break;
-					default:
-						/* TODO: No support for custom
-						 * classes for now, so stuff
-						 * everything to the single
-						 * default one. --pasky */
-						stat->sclass = STAT_CLASS_DFLT;
-						//stat->sclass = STAT_CLASS_CUSTOM;
-						break;
-				}
+				stat->sclass = AllocateCustomStationClass(classid);
 			}
 			break;
 		}
@@ -789,17 +771,12 @@
 				StationSpec *stat = &_cur_grffile->stations[stid + i];
 				int t;
 
-				stat->tiles = grf_load_byte(&buf);
+				stat->tiles = grf_load_extended(&buf);
+				stat->renderdata = realloc(stat->renderdata, stat->tiles * sizeof(DrawTileSprites));
 				for (t = 0; t < stat->tiles; t++) {
 					DrawTileSprites *dts = &stat->renderdata[t];
 					int seq_count = 0;
 
-					if (t >= 8) {
-						grfmsg(GMS_WARN, "StationChangeInfo: Sprite %d>=8, skipping.", t);
-						grf_load_dword(&buf); // at least something
-						continue;
-					}
-
 					dts->ground_sprite = grf_load_dword(&buf);
 					if (!dts->ground_sprite) {
 						static const DrawTileSeqStruct empty = {0x80, 0, 0, 0, 0, 0, 0};
@@ -807,6 +784,13 @@
 						continue;
 					}
 
+					/*if (HASBIT(dts->ground_sprite, 31)) {
+						// Bit 31 indicates a custom ground sprite
+						assert(_cur_grffile->spritegroups);
+						dts->ground_sprite &= 0xffff;
+						dts->ground_sprite += ResolveSpriteGroup(&_cur_grffile->spritegroups[0], -1, 0, 4, (resolve_callback) ResolveSpriteGroup) - 0x42D;
+					}*/
+
 					dts->seq = NULL;
 					while (buf < *bufp + len) {
 						DrawTileSeqStruct *dtss;
@@ -837,6 +821,7 @@
 				int t;
 
 				stat->tiles = srcstat->tiles;
+				stat->renderdata = realloc(stat->renderdata, stat->tiles * sizeof(DrawTileSprites));
 				for (t = 0; t < stat->tiles; t++) {
 					DrawTileSprites *dts = &stat->renderdata[t];
 					DrawTileSprites *sdts = &srcstat->renderdata[t];
@@ -867,11 +852,11 @@
 		}
 		case 0x0b:
 		{	/* Callback */
-			/* TODO */
 			FOR_EACH_OBJECT {
-				grf_load_byte(&buf);
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+				
+				stat->callbackmask = grf_load_byte(&buf);
 			}
-			ret = 1;
 			break;
 		}
 		case 0x0C:
@@ -879,7 +864,7 @@
 			FOR_EACH_OBJECT {
 				StationSpec *stat = &_cur_grffile->stations[stid + i];
 
-				stat->allowed_platforms = ~grf_load_byte(&buf);
+				stat->disallowed_platforms = grf_load_byte(&buf);
 			}
 			break;
 		}
@@ -888,7 +873,7 @@
 			FOR_EACH_OBJECT {
 				StationSpec *stat = &_cur_grffile->stations[stid + i];
 
-				stat->allowed_lengths = ~grf_load_byte(&buf);
+				stat->disallowed_lengths = grf_load_byte(&buf);
 			}
 			break;
 		}
@@ -957,16 +942,17 @@
 		{	/* Little/lots cargo threshold */
 			/* TODO */
 			FOR_EACH_OBJECT {
-				grf_load_word(&buf);
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+
+				stat->cargo_threshold = grf_load_word(&buf);
 			}
-			ret = 1;
 			break;
 		}
 		case 0x11:
 		{	/* Pylon placement */
 			/* TODO; makes sense only for electrified tracks */
 			FOR_EACH_OBJECT {
-				grf_load_word(&buf);
+				grf_load_byte(&buf);
 			}
 			ret = 1;
 			break;
@@ -975,11 +961,40 @@
 		{	/* Cargo types for random triggers */
 			/* TODO */
 			FOR_EACH_OBJECT {
-				grf_load_dword(&buf);
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+
+				stat->cargotriggers = grf_load_dword(&buf);
+			}
+			break;
+		}
+		case 0x13:
+		{	/* General Flags (13) */
+			FOR_EACH_OBJECT {
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+
+				byte flags = grf_load_byte(&buf);
+				if ((flags & 3) != flags)
+					grfmsg(GMS_WARN, "StationChangeInfo: Unsupported flags %x, ignoring.", flags & ~3);
+				stat->flags = flags & 3;
+			}
+			break;
+		}
+		case 0x14:
+		{	/* Catenary placement */
+			FOR_EACH_OBJECT {
+				grf_load_byte(&buf);
 			}
 			ret = 1;
 			break;
 		}
+		case 0x15:
+		{	/* Blocked tile */
+			FOR_EACH_OBJECT {
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+				stat->blocked = grf_load_byte(&buf);
+			}
+			break;
+		}
 		default:
 			ret = 1;
 			break;
@@ -1146,10 +1161,10 @@
 
 	// Old style callback results have the highest byte 0xFF so signify it is a callback result
 	// New style ones only have the highest bit set (allows 15-bit results, instead of just 8)
-	if ((value >> 8) == 0xFF)
-		value &= 0xFF;
-	else
-		value &= ~0x8000;
+	//if ((value >> 8) == 0xFF)
+	//	value &= 0xFF;
+	//else
+	//	value &= ~0x8000;
 
 	group.g.callback.result = value;
 
@@ -1195,7 +1210,7 @@
 	);
 
 	for (i = 0; i < num_sets * num_ents; i++) {
-		LoadNextSprite(_cur_spriteid++, _file_index);
+		LoadNextSprite(_cur_spriteid + i, _file_index);
 	}
 }
 
@@ -1230,6 +1245,10 @@
 	int i;
 
 	check_length(len, 5, "NewSpriteGroup");
+
+	// Sprite IDs should increment only on an action 0x02
+	_cur_spriteid = _cur_grffile->spriteset_start + (_cur_grffile->spriteset_numsets * _cur_grffile->spriteset_numents);
+
 	feature = buf[1];
 	setid = buf[2];
 	numloaded = buf[3];
@@ -1264,11 +1283,14 @@
 
 		dg->var_scope = numloaded == 0x82 ? VSG_SCOPE_PARENT : VSG_SCOPE_SELF;
 		dg->variable = grf_load_byte(&buf);
+		/* Variables 0x60 - 0x7F include an extra parameter */
+		if (IS_BYTE_INSIDE(dg->variable, 0x60, 0x80))
+			dg->parameter = grf_load_byte(&buf);
 
 		dg->shift_num = grf_load_byte(&buf);
 		dg->and_mask = grf_load_byte(&buf);
 		dg->operation = dg->shift_num >> 6; /* w00t */
-		dg->shift_num &= 0x3F;
+		dg->shift_num &= 0x1F;
 		if (dg->operation != DSG_OP_NONE) {
 			dg->add_val = grf_load_byte(&buf);
 			dg->divmod_val = grf_load_byte(&buf);
@@ -1286,6 +1308,7 @@
 				/* This doesn't exist for us. */
 				grf_load_word(&buf); // skip range
 				i--; dg->num_ranges--;
+				printf("This doesn't exist for us.\n");
 				continue;
 			} else {
 			/* XXX: If multiple surreal sets attach a surreal
@@ -1303,6 +1326,7 @@
 			*dg->default_group = NewCallBackResult(groupid);
 		} else if (groupid >= _cur_grffile->spritegroups_count) {
 			/* This spritegroup stinks. */
+			printf("This spritegroup stinks.\n");
 			free(dg->ranges), dg->ranges = NULL;
 			grfmsg(GMS_WARN, "NewSpriteGroup(%02x:0x%x): Default groupid %04x is cargo callback or unknown, ignoring spritegroup.", setid, numloaded, groupid);
 			return;
@@ -1351,15 +1375,19 @@
 		for (i = 0; i < rg->num_groups; i++) {
 			uint16 groupid = grf_load_word(&buf);
 
-			if (groupid & 0x8000 || groupid >= _cur_grffile->spritegroups_count) {
+			if (groupid & 0x8000) {
+				rg->groups[i] = NewCallBackResult(groupid);
+			} else if (groupid >= _cur_grffile->spritegroups_count) {
+				printf("Not here? groupid = %x, _cur_grffile->spritegroups_count = %x\n", groupid, _cur_grffile->spritegroups_count);
 				/* This doesn't exist for us. */
 				i--;
 				rg->num_groups--;
 				continue;
-			}
+			} else {
 			/* XXX: If multiple surreal sets attach a surreal
 			 * set this way, we are in trouble. */
-			rg->groups[i] = _cur_grffile->spritegroups[groupid];
+				rg->groups[i] = _cur_grffile->spritegroups[groupid];
+			}
 		}
 
 		return;
@@ -1410,13 +1438,19 @@
 
 	for (i = 0; i < numloaded; i++) {
 		uint16 spriteset_id = grf_load_word(&loaded_ptr);
-		rg->loaded[i] = _cur_grffile->spriteset_start + spriteset_id * _cur_grffile->spriteset_numents;
+		if (spriteset_id & 0x8000)
+			rg->loaded[i] = spriteset_id;
+		else
+			rg->loaded[i] = _cur_grffile->spriteset_start + spriteset_id * _cur_grffile->spriteset_numents;
 		DEBUG(grf, 8) ("NewSpriteGroup: + rg->loaded[%i]  = %u (subset %u)", i, rg->loaded[i], spriteset_id);
 	}
 
 	for (i = 0; i < numloading; i++) {
 		uint16 spriteset_id = grf_load_word(&loading_ptr);
-		rg->loading[i] = _cur_grffile->spriteset_start + spriteset_id * _cur_grffile->spriteset_numents;
+		if (spriteset_id & 0x8000)
+			rg->loading[i] = spriteset_id;
+		else
+			rg->loading[i] = _cur_grffile->spriteset_start + spriteset_id * _cur_grffile->spriteset_numents;
 		DEBUG(grf, 8) ("NewSpriteGroup: + rg->loading[%i] = %u (subset %u)", i, rg->loading[i], spriteset_id);
 	}
 }
@@ -1449,7 +1483,7 @@
 	uint8 cidcount;
 	int c, i;
 
-	check_length(len, 7, "VehicleMapSpriteGroup");
+	check_length(len, 6, "VehicleMapSpriteGroup");
 	feature = buf[1];
 	idcount = buf[2] & 0x7F;
 	wagover = (buf[2] & 0x80) == 0x80;
@@ -1484,12 +1518,9 @@
 					return;
 				}
 
-				if (ctype != 0xFF) {
-					/* TODO: No support for any other cargo. */
-					continue;
-				}
+				if (ctype == GC_INVALID) ctype = GC_PURCHASE;
 
-				stat->spritegroup[1] = _cur_grffile->spritegroups[groupid];
+				stat->spritegroup[ctype] = _cur_grffile->spritegroups[groupid];
 			}
 		}
 
@@ -1507,10 +1538,12 @@
 				uint8 stid = buf[3 + i];
 				StationSpec *stat = &_cur_grffile->stations[stid];
 
-				stat->spritegroup[0] = _cur_grffile->spritegroups[groupid];
+				stat->spritegroup[GC_DEFAULT] = _cur_grffile->spritegroups[groupid];
 				stat->grfid = _cur_grffile->grfid;
+				// Save the sprite set start for custom ground sprites.
+				// This is rarely used, except by newstats...
+				stat->ground_relocation = _cur_grffile->sprite_offset - 0x42D;
 				SetCustomStation(stid, stat);
-				stat->sclass = STAT_CLASS_NONE;
 			}
 		}
 		return;
@@ -1611,6 +1644,19 @@
 	}
 }
 
+static inline void SetCustomStationName(byte stid, const char *name)
+{
+	if (strlen(name) == 0)
+		return;
+
+	if (_cur_grffile->stations[stid].name != NULL) {
+		/* Name already exists, let's replace it. */
+		free(_cur_grffile->stations[stid].name);
+	}
+
+	_cur_grffile->stations[stid].name = strdup(name);
+}
+
 /* Action 0x04 */
 static void VehicleNewName(byte *buf, int len)
 {
@@ -1642,24 +1688,17 @@
 	lang     = grf_load_byte(&buf);
 	num      = grf_load_byte(&buf);
 	id       = (lang & 0x80) ? grf_load_word(&buf) : grf_load_byte(&buf);
-
-	if (feature > 3) {
-		DEBUG(grf, 7) ("VehicleNewName: Unsupported feature %d, skipping", feature);
-		return;
-	}
-
-	id      += _vehshifts[feature];
 	endid    = id + num;
 
-	DEBUG(grf, 6) ("VehicleNewName: About to rename engines %d..%d (feature %d) in language 0x%x.",
-	               id, endid, feature, lang);
+	DEBUG(grf, 6) ("VehicleNewName: About to rename engines %x..%x (feature %x) in language 0x%x.",
+	               id, endid - 1, feature, lang);
 
-	if (lang & 0x80) {
+	if ((lang & 0x80) && (id < 0xC400)) {
 		grfmsg(GMS_WARN, "VehicleNewName: No support for changing in-game texts. Skipping.");
 		return;
 	}
 
-	if (!(lang & 3)) {
+	if (!(lang & 3 || lang == 0x48)) {
 		/* XXX: If non-English name, silently skip it. */
 		DEBUG(grf, 7) ("VehicleNewName: Skipping non-English name.");
 		return;
@@ -1671,8 +1710,33 @@
 		int ofs = strlen(name) + 1;
 
 		if (ofs < 128) {
-			DEBUG(grf, 8) ("VehicleNewName: %d <- %s", id, name);
-			SetCustomEngineName(id, name);
+			DEBUG(grf, 8) ("VehicleNewName: %x <- %s", id, name);
+			switch (id & 0xFF00) {
+				case 0x0000:
+					if (!(lang & 0x80)) {
+						/* New vehicle name (uses a byte value, so top bit is zero) */
+						if (feature > 3) {
+							DEBUG(grf, 7) ("VehicleNewName: Unsupported feature %d, skipping", feature);
+							return;
+						}
+						SetCustomEngineName(id + _vehshifts[feature], name);
+						break;
+					}
+					DEBUG(grf, 7) ("VehicleNewName: Unsupported ID (%x)", id);
+					break;
+				case 0xC400: /* Station Class */
+					SetCustomStationClassName(_cur_grffile->stations[id & 0xFF].sclass, name);
+					break;
+				case 0xC500: /* Station Name */
+					SetCustomStationName(id & 0xFF, name);
+					break;
+				case 0xC900: /* House name */
+				case 0xD000: /* Miscellaneous text */
+				case 0xDC00: /* Miscellaneous persistent text (should be saved) */
+				default:
+					DEBUG(grf, 7) ("VehicleNewName: Unsupported ID (%x)", id);
+					break;
+			}
 		} else {
 			DEBUG(grf, 7) ("VehicleNewName: Too long a name (%d)", ofs);
 		}
@@ -2065,6 +2129,14 @@
 				res = (int32)src1 << src2;
 			break;
 
+		case 0x07:
+			res = src1 & src2;
+			break;
+
+		case 0x08:
+			res = src1 | src2;
+			break;
+
 		default:
 			grfmsg(GMS_ERROR, "ParamSet: Unknown operation %d, skipping.", oper);
 			return;
@@ -2138,14 +2210,15 @@
 	                   | (1 << 0x18)  /* newrvs */
 	                   | (1 << 0x19)  /* newships */
 	                   | (1 << 0x1A)  /* newplanes */
-			               | (1 << 0x1B); /* signalsontrafficside */
+			               | (1 << 0x1B) /* signalsontrafficside */
 	                   /* Uncomment following if you want to fool the GRF file.
 	                    * Some GRF files will refuse to load without this
 	                    * but you can still squeeze something from them even
 	                    * without the support - i.e. USSet. --pasky */
-			               //| (1 << 0x1C); /* electrifiedrailway */
+			               | (1 << 0x1C); /* electrifiedrailway */
 
 	_ttdpatch_flags[2] = (1 << 0x0D)  /* buildonslopes */
+	                   | (1 << 0x12)  /* newstations */
 	                   | (1 << 0x16)  /* canals */
 	                   | (1 << 0x17); /* newstartyear */
 }
@@ -2197,7 +2270,7 @@
 	 * in an earlier stage than associating, so...  We just process actions
 	 * 1 and 2 in stage 1 now, let's hope that won't get us into problems.
 	 * --pasky */
-	uint32 action_mask = (stage == 0) ? 0x0001FF40 : 0x0001FFBF;
+	uint32 action_mask = (stage == 0) ? 0x0001FF46 : 0x0001FFBF;
 	static const SpecialSpriteHandler handlers[] = {
 		/* 0x00 */ VehicleChangeInfo,
 		/* 0x01 */ NewSpriteSet,
