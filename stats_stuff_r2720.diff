Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 2720)
+++ station_cmd.c	(working copy)
@@ -23,6 +23,7 @@
 #include "sprite.h"
 #include "depot.h"
 #include "pbs.h"
+#include "network.h"
 
 enum {
 	/* Max stations: 64000 (64 * 1000) */
@@ -448,8 +449,8 @@
 	st->airport_tile = st->dock_tile = st->train_tile = 0;
 	st->bus_stops = st->truck_stops = NULL;
 	st->had_vehicle_of_type = 0;
-	st->time_since_load = 255;
-	st->time_since_unload = 255;
+	st->time_since_load = INVALID_TIME;
+	st->time_since_unload = INVALID_TIME;
 	st->delete_ctr = 0;
 	st->facilities = 0;
 
@@ -459,11 +460,14 @@
 		ge->waiting_acceptance = 0;
 		ge->days_since_pickup = 0;
 		ge->enroute_from = INVALID_STATION;
-		ge->rating = 175;
+		ge->rating = RATING_START_VALUE;
 		ge->last_speed = 0;
-		ge->last_age = 0xFF;
+		ge->last_age = INVALID_AGE;
 		ge->feeder_profit = 0;
+		ge->last_vehicle_speed = 0;
+		ge->last_vehicle_type = INVALID_VEHICLE;
 	}
+	InitializeStationStats(st);
 
 	_global_station_sort_dirty = true; // build a new station
 }
@@ -2520,46 +2524,166 @@
 static void UpdateStationRating(Station *st)
 {
 	GoodsEntry *ge;
-	int rating;
+	RatingStats *rs;
 	StationID index;
-	int waiting;
+	int rating, waiting, lv_type, speed, old_rating, points, point_clamp;
 	bool waiting_changed = false;
+	byte age, days;
 
 	byte_inc_sat(&st->time_since_load);
 	byte_inc_sat(&st->time_since_unload);
 
 	ge = st->goods;
+	rs = st->rating_stats;
+
 	do {
 		if (ge->enroute_from != INVALID_STATION) {
-			byte_inc_sat(&ge->enroute_time);
-			byte_inc_sat(&ge->days_since_pickup);
-
 			rating = 0;
+			old_rating = 0;
+			points = 0;
+			lv_type = ge->last_vehicle_type;
+			if (lv_type == INVALID_VEHICLE && st->last_vehicle != INVALID_VEHICLE)
+				lv_type = GetVehicle(st->last_vehicle)->type;
 
+			speed = ge->last_speed;
+			if (_patches.nsr_speed)
 			{
-				int b = ge->last_speed;
-				if ((b-=85) >= 0)
-					rating += b >> 2;
+				points = ge->last_vehicle_speed;
+				if (points == 0)
+					points = speed;
+				rs->last_speed = points;
+				switch (lv_type)
+				{
+					case VEH_Train:
+						if (points <= RP_T_SPEED_CAP) // "normal" trains
+							points += (ge == &st->goods[CT_PASSENGERS]) ? RP_T_SPEED_PASS_BONUS : RP_T_SPEED_CARGO_BONUS;
+						else // monorail + maglev, currently too few trains to be worth more distinction
+							points /= RP_SPEED_MULT;
+						break;
+					case VEH_Road:
+						points *= 3 / 2;
+						points += (ge == &st->goods[CT_PASSENGERS]) ? RP_R_SPEED_PASS_BONUS : RP_R_SPEED_CARGO_BONUS;
+						break;
+					case VEH_Ship:
+						rs->last_speed = points / 2;
+						if (ge != &st->goods[CT_PASSENGERS])
+							points *= RP_SPEED_MULT;
+						break;
+					case VEH_Aircraft:
+						rs->last_speed = (points * 64) / 5; // * 8 * 16 / 10
+						if (ge != &st->goods[CT_PASSENGERS])
+							points *= RP_SPEED_MULT;
+						break;
+					default:	
+						points = 0;
+				}
+				// max 170 >> 2 = 42 points for speedrating
+				rating += clamp(points, 0, RP_MAX_SPEED_POINTS) >> 2;
 			}
+			else
+			{
+				if ((speed -= 85) >= 0)
+					rating += speed >> 2;
+				rs->last_speed = ge->last_speed;
+			}
+			rs->ratings[RATING_SPEED] = rating - old_rating;
+			old_rating = rating;
 
+			age = ge->last_age;
+			if (_patches.nsr_age)
 			{
-				byte age = ge->last_age;
+				if (ge == &st->goods[CT_PASSENGERS]) {
+					switch (lv_type)	// scale age to RP_MAX_AGE years
+					{
+						case VEH_Train:		point_clamp = RP_AGE_T_CLAMP;	break;
+						case VEH_Road:			point_clamp = RP_AGE_R_CLAMP;	break;
+						case VEH_Ship:			point_clamp = RP_AGE_S_CLAMP;	break;
+						case VEH_Aircraft:	point_clamp = RP_AGE_A_CLAMP;	break;
+						default:					point_clamp = RP_MAX_AGE;
+					}
+					points = clamp(points, 0, point_clamp) * RP_MAX_AGE / point_clamp;
+					switch (age) // give bonus to rating for low age
+					{ // uses real age, not scaled age
+						case 0:	rating += RP_AGE_BONUS_0;	break;
+						case 1:	rating += RP_AGE_BONUS_1;	break;
+						case 2:	rating += RP_AGE_BONUS_2;	break;
+						case 3:	rating += RP_AGE_BONUS_3;	break;
+						case 4:	rating += RP_AGE_BONUS_4;	break;
+						case 5:	rating += RP_AGE_BONUS_5;	break;
+					}
+				} else { // non passengers dont care for vehicle-age
+					rating += RP_AGE_BONUS_0;
+					points = 0;
+				}
+				rating += (RP_MAX_AGE_POINTS - points);
+			}
+			else
+			{
 				(age >= 3) ||
 				(rating += 10, age >= 2) ||
 				(rating += 10, age >= 1) ||
 				(rating += 13, true);
 			}
+			rs->last_age = age;
+			rs->ratings[RATING_AGE] = rating - old_rating;
+			old_rating = rating;
 
 			{
 				if (st->owner != OWNER_NONE && !IS_HUMAN_PLAYER(st->owner))
 							rating += _rating_boost[_opt.diff.competitor_intelligence];
 			}
 
-			if (st->owner < MAX_PLAYERS && HASBIT(st->town->statues, st->owner))
-				rating += 26;
+			if (_patches.nsr_town_rating)
+			{
+				if (st->owner < MAX_PLAYERS)
+				{
+					if (HASBIT(st->town->statues, st->owner))	rating += RP_OTHER_STATUE;
+					// if townratings are not changed this will be within -20..+20
+					rating += (st->town->ratings[st->owner] / RP_OTHER_LA_MULT);
+				} else {
+					if (st->owner == OWNER_NONE)
+						rating += 26; // oilrigs dont have owner... for now give maxpoints till i know what i want to do here ;)
+				}
+			}
+			else
+			{
+				if (st->owner < MAX_PLAYERS && HASBIT(st->town->statues, st->owner))
+					rating += 26;
+			}
+			rs->ratings[RATING_OTHER] = rating - old_rating;
+			old_rating = rating;
 
+			days = ge->days_since_pickup;
+			if (_patches.nsr_wait_days)
 			{
-				byte days = ge->days_since_pickup;
+				if (ge == &st->goods[CT_PASSENGERS])
+					points = days * 2; // double wait effect for Passengers
+				else
+					points = days;
+				switch (lv_type)	// scale waitdays to RP_MAX_DAYS days
+				{
+					case VEH_Train:		point_clamp = RP_DAYS_T_CLAMP;	break;
+					case VEH_Road:			point_clamp = RP_DAYS_R_CLAMP;	break;
+					case VEH_Ship:			point_clamp = RP_DAYS_S_CLAMP;	break;
+					case VEH_Aircraft:	point_clamp = RP_DAYS_A_CLAMP;	break;
+					default:					point_clamp = RP_MAX_DAYS;
+				}
+				points = clamp(points, 0, point_clamp) * RP_MAX_DAYS / point_clamp;
+				rating += (RP_MAX_DAYS_POINTS - points * RP_MAX_DAYS_POINTS / RP_MAX_DAYS);
+				switch (days) // give bonus for short wait-time
+				{ // uses real days, not scaled days
+					case 0:	rating += RP_DAYS_BONUS_0;	break;
+					case 1:	rating += RP_DAYS_BONUS_1;	break;
+					case 2:	rating += RP_DAYS_BONUS_2;	break;
+					case 3:	rating += RP_DAYS_BONUS_3;	break;
+					case 4:	rating += RP_DAYS_BONUS_4;	break;
+					case 5:	rating += RP_DAYS_BONUS_5;	break;
+					case 6:	rating += RP_DAYS_BONUS_6;	break;
+					case 7:	rating += RP_DAYS_BONUS_7;	break;
+				}
+			}
+			else
+			{
 				if (st->last_vehicle != INVALID_VEHICLE &&
 						GetVehicle(st->last_vehicle)->type == VEH_Ship)
 							days >>= 2;
@@ -2569,9 +2693,42 @@
 				(rating += 45, days > 3) ||
 				(rating += 35, true);
 			}
+			rs->days_since_pickup = ge->days_since_pickup;
+			rs->ratings[RATING_PICKUP] = rating - old_rating;
+			old_rating = rating;
 
+			byte_inc_sat(&ge->enroute_time);
+			byte_inc_sat(&ge->days_since_pickup);
+
+			waiting = ge->waiting_acceptance & MAX_CARGO_WAITING;
+			if (_patches.nsr_wait_cargo)
 			{
-				waiting = ge->waiting_acceptance & 0xFFF;
+				if (ge == &st->goods[CT_PASSENGERS])
+					points = waiting * 2;
+				else
+					points = waiting;
+				switch (lv_type) // scale points to RP_MAX_WAIT
+				{
+					case VEH_Train:		point_clamp = RP_WAIT_T_CLAMP;		break;
+					case VEH_Road:			point_clamp = RP_WAIT_R_CLAMP;		break;
+					case VEH_Ship:			point_clamp = RP_WAIT_S_CLAMP;		break;
+					case VEH_Aircraft:	point_clamp = RP_WAIT_A_CLAMP;		break;
+					default:					point_clamp = RP_MAX_WAIT;
+				}
+				points = clamp(points, 0, point_clamp) * RP_MAX_WAIT / point_clamp;
+				rating += RP_MAX_WAIT_POINTS - points;
+				switch (points) // give bonus for low waiting cargo
+				{ // uses scaled waiting
+					case 0: rating += RP_WAIT_BONUS_0;	break;
+					case 1: rating += RP_WAIT_BONUS_1;	break;
+					case 2: rating += RP_WAIT_BONUS_2;	break;
+					case 3: rating += RP_WAIT_BONUS_3;	break;
+					case 4: rating += RP_WAIT_BONUS_4;	break;
+					case 5: rating += RP_WAIT_BONUS_5;	break;
+				}
+			}
+			else
+			{
 				(rating -= 90, waiting > 1500) ||
 				(rating += 55, waiting > 1000) ||
 				(rating += 35, waiting > 600) ||
@@ -2579,9 +2736,13 @@
 				(rating += 20, waiting > 100) ||
 				(rating += 10, true);
 			}
+			rs->waiting = waiting;
+			rs->ratings[RATING_WAITING] = rating - old_rating;
+			old_rating = rating;
 
 			{
 				int or = ge->rating; // old rating
+				rs->ratings[RATING_TOTAL] = rating;
 
 				// only modify rating in steps of -2, -1, 0, 1 or 2
 				ge->rating = rating = or + clamp(clamp(rating, 0, 255) - or, -2, 2);
@@ -2604,9 +2765,10 @@
 				}
 
 				if (waiting_changed)
-					ge->waiting_acceptance = (ge->waiting_acceptance & ~0xFFF) + waiting;
+					ge->waiting_acceptance = (ge->waiting_acceptance & ~MAX_CARGO_WAITING) + waiting;
 			}
 		}
+		rs++;
 	} while (++ge != endof(st->goods));
 
 	index = st->index;
@@ -2615,6 +2777,8 @@
 		InvalidateWindow(WC_STATION_VIEW, index);
 	else
 		InvalidateWindowWidget(WC_STATION_VIEW, index, 5);
+
+	InvalidateWindow(WC_STATION_RATING_DETAIL, index);
 }
 
 /* called for every station each tick */
@@ -2656,11 +2820,54 @@
 
 }
 
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted)
+{
+	times_counted -= 1; // number of calculated averages till now is one less than actually counted times
+	if (times_counted == 0)
+		return lastamount;
+	average = (uint32)((uint64)(((uint64)average * (uint64)times_counted + (uint64)lastamount) / ((uint64)times_counted + 1)));
+	return average;
+}
+
 void StationMonthlyLoop(void)
 {
+	Station *st;
+	StationStats *sts;
+	GoodsEntry *ge;
+
+ 	FOR_ALL_STATIONS(st) {
+		if (st->months_counted != STS_NO_MONTHS_COUNTED)
+		{
+			for (ge = st->goods; ge != endof(st->goods); ge++) {
+				if (ge->months_counted != STS_NO_MONTHS_COUNTED) 
+				{
+					// set current months stats to 0 after storing value for last month
+					// do this for all stats (currently In/Out/Transfer)
+					// also determine new min/max-values
+					for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+						sts->month_min = min(sts->month_min, sts->this_month);
+						sts->month_max = max(sts->month_max, sts->this_month);
+						sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, ge->months_counted);
+						sts->last_month = sts->this_month;
+						sts->this_month = 0;
+					}
+					ge->months_counted++; // one more month counted
+				}
+			}
+			// update vehicle-counts and min/max
+			for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, st->months_counted);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			st->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, st->index);
+	}
 }
 
-
 void ModifyStationRatingAround(TileIndex tile, byte owner, int amount, uint radius)
 {
 	Station *st;
@@ -2689,6 +2896,7 @@
 	st->goods[type].enroute_time = 0;
 	st->goods[type].enroute_from = st->index;
 	InvalidateWindow(WC_STATION_VIEW, st->index);
+	InvalidateWindow(WC_STATION_STATS, st->index);
 }
 
 /** Rename a station
@@ -2867,7 +3075,7 @@
 	int j;
 
 	FOR_ALL_STATIONS(st) {
-		if (st->xy == 0) {
+		if (st->xy == INVALID_TILE) {
 			st->town = ClosestTownFromTile(tile, (uint)-1);
 			st->sign.width_1 = 0;
 			if (!GenerateStationName(st, tile, 2))
@@ -2881,7 +3089,7 @@
 			_m[tile].m2 = st->index;
 
 			st->owner = OWNER_NONE;
-      st->airport_flags = 0;
+			st->airport_flags = 0;
 			st->airport_type = AT_OILRIG;
 			st->xy = tile;
 			st->bus_stops = NULL;
@@ -2890,8 +3098,8 @@
 			st->dock_tile = tile;
 			st->train_tile = 0;
 			st->had_vehicle_of_type = 0;
-			st->time_since_load = 255;
-			st->time_since_unload = 255;
+			st->time_since_load = INVALID_TIME;
+			st->time_since_unload = INVALID_TIME;
 			st->delete_ctr = 0;
 			st->last_vehicle = INVALID_VEHICLE;
 			st->facilities = FACIL_AIRPORT | FACIL_DOCK;
@@ -2900,9 +3108,9 @@
 				st->goods[j].waiting_acceptance = 0;
 				st->goods[j].days_since_pickup = 0;
 				st->goods[j].enroute_from = INVALID_STATION;
-				st->goods[j].rating = 175;
+				st->goods[j].rating = RATING_START_VALUE;
 				st->goods[j].last_speed = 0;
-				st->goods[j].last_age = 255;
+				st->goods[j].last_age = INVALID_AGE;
 			}
 
 			UpdateStationVirtCoordDirty(st);
@@ -3078,12 +3286,23 @@
 	SLE_CONDREF(Station,bus_stops,					REF_ROADSTOPS, 6, 255),
 	SLE_CONDREF(Station,truck_stops,				REF_ROADSTOPS, 6, 255),
 
+	// station stats data
+//	SLE_CONDVAR(Station,months_counted,	SLE_UINT16, xx, 255),
+
 	// reserve extra space in savegame here. (currently 28 bytes)
 	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 32, 2, 255),
 
 	SLE_END()
 };
 
+// station stats data
+//	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,average,	SLE_UINT32, xx, 255),
+//	SLE_END()
+//};
+
 static const SaveLoad _goods_desc[] = {
 	SLE_VAR(GoodsEntry,waiting_acceptance,SLE_UINT16),
 	SLE_VAR(GoodsEntry,days_since_pickup,	SLE_UINT8),
@@ -3095,22 +3314,33 @@
 	SLE_VAR(GoodsEntry,last_age,					SLE_UINT8),
 	SLE_CONDVAR(GoodsEntry,feeder_profit,			SLE_INT32, 14, 255),
 
+	// station stats data
+//	SLE_CONDVAR(GoodsEntry,months_counted,	SLE_UINT16, xx, 255),
+
 	SLE_END()
 };
 
 
 static void SaveLoad_STNS(Station *st)
 {
-	int i;
+	int i; //, j;
 
 	SlObject(st, _station_desc);
 	for (i = 0; i != NUM_CARGO; i++) {
 		SlObject(&st->goods[i], _goods_desc);
+//		for (j = 0; j < STS_AMNT_TYPES; j++)
+//			SlObject(&st->goods[i].cargo_amount[j], _stats_desc);
 
+		// initialize new station rating values
+		st->goods[i].last_vehicle_speed = st->goods[i].last_speed;
+		st->goods[i].last_vehicle_type = INVALID_VEHICLE;
+
 		/* In older versions, enroute_from had 0xFF as INVALID_STATION, is now 0xFFFF */
-		if (_sl.full_version < 0x700 && st->goods[i].enroute_from == 0xFF)
-			st->goods[i].enroute_from = 0xFFFF;
+		if (_sl.full_version < 0x700 && st->goods[i].enroute_from == INVALID_STATION_OLD)
+			st->goods[i].enroute_from = INVALID_STATION;
 	}
+//	for (i = 0; i < STS_VEH_TYPES; i++) 
+//		SlObject(&st->vehicles[i], _stats_desc);
 }
 
 static void Save_STNS(void)
@@ -3118,7 +3348,7 @@
 	Station *st;
 	// Write the stations
 	FOR_ALL_STATIONS(st) {
-		if (st->xy != 0) {
+		if (st->xy != INVALID_TILE) {
 			SlSetArrayIndex(st->index);
 			SlAutolength((AutolengthProc*)SaveLoad_STNS, st);
 		}
@@ -3136,6 +3366,7 @@
 
 		st = GetStation(index);
 		SaveLoad_STNS(st);
+		InitializeStationStats(st);
 
 		// this means it's an oldstyle savegame without support for nonuniform stations
 		if (st->train_tile && st->trainst_h == 0) {
@@ -3202,3 +3433,108 @@
 	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY | CH_LAST},
 };
 
+void SearchVehiclesForStation(Station *st)
+{
+	Vehicle *v;
+	int i;
+	Order* ord;
+	
+	ord = NULL;
+	if (st->xy == INVALID_TILE) return;
+	for(i = 0; i < STS_VEH_TYPES; i++) st->veh_scheduled[i] = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ||       //Trains (first engine, that contains the orders)
+			( (v->type == VEH_Road) && (v->subtype == SUBTYPE_NONE) ) ||       //Road vehicles (subtype should always be 0 anyway)
+			( (v->type == VEH_Ship) && (v->subtype == SUBTYPE_NONE) ) ||       //Ships, subtype should be 0 anyway)
+			( (v->type == VEH_Aircraft) && (
+				(v->subtype == SUBTYPE_NONE) ||                            //Choppers
+				(v->subtype == SUBTYPE_AIRCRAFT) ) ) ) &&                               //Fixed-wing stuff
+			( (v->owner == st->owner) || (v->owner == _local_player) ) )	// station owner or current player for oilrigs
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == st->index && ord->type == OT_GOTO_STATION) {
+					switch (v->type) {
+						case VEH_Train:
+							st->veh_scheduled[STS_VEH_TRAIN]++;
+							break;
+						case VEH_Road:
+							st->veh_scheduled[STS_VEH_ROAD]++;
+							if (v->cargo_type == CT_PASSENGERS)
+								st->veh_scheduled[STS_VEH_BUS]++;
+							else
+								st->veh_scheduled[STS_VEH_TRUCK]++;
+							break;
+						case VEH_Ship:
+							st->veh_scheduled[STS_VEH_SHIP]++;
+							break;
+						case VEH_Aircraft:
+							st->veh_scheduled[STS_VEH_AIRCRAFT]++;
+							break;
+						default:
+							NOT_REACHED();
+					}
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	}
+}
+
+int32 CmdResetStationCheat(int NOT_USED_x, int NOT_USED_y, uint32 NOT_USED_flags, uint32 station, uint32 NOT_USED_p2)
+{
+	Station *st = GetStation(station);
+	GoodsEntry *ge;
+#ifndef _DEBUG
+	if (_networking) return CMD_ERROR;
+#endif
+
+	// Reset all goods at station
+	for(ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->last_speed = 0;
+		ge->waiting_acceptance = 0;
+		ge->days_since_pickup = 0;
+		ge->enroute_from = INVALID_STATION;
+		ge->enroute_time = 0;
+		ge->rating = RATING_START_VALUE;
+		ge->last_age = INVALID_AGE;
+		ge->feeder_profit = 0;
+	}
+	st->had_vehicle_of_type = 0;
+	st->time_since_load = INVALID_TIME;
+	st->time_since_unload = INVALID_TIME;
+	st->last_vehicle = INVALID_VEHICLE;
+
+	UpdateStationAcceptance(st, false);
+	return 0;
+}
+
+void InitializeStationStats(Station *st)
+{
+	StationStats *sts;
+	GoodsEntry *ge;
+
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->months_counted = STS_NO_MONTHS_COUNTED;
+		for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+			sts->average = 0;
+			sts->last_month = 0;
+			sts->month_max = 0;
+			sts->month_min = STS_INIT_MINIMUM;
+			sts->this_month = 0;
+		}
+	}
+	st->months_counted = STS_NO_MONTHS_COUNTED;
+	for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = STS_INIT_MINIMUM;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForStation(st);
+}
Index: engine.c
===================================================================
--- engine.c	(revision 2720)
+++ engine.c	(working copy)
@@ -339,9 +339,13 @@
 			int value = -1;
 
 			//debug("[%p] Having fun resolving variable %x", veh, dsg->variable);
+
 			if (dsg->variable == 0x0C) {
 				/* Callback ID */
 				value = callback_info & 0xFF;
+			} else if (dsg->variable == 0x10) {
+				/* Articulated engine Callback stage */
+				value = (callback_info >> 8) & 0xFF;
 			} else if ((dsg->variable >> 6) == 0) {
 				/* General property */
 				value = GetDeterministicSpriteValue(dsg->variable);
@@ -1049,3 +1053,21 @@
 
 	return true;
 }
+
+/**
+ * Calculates the maximum speed of a train vehicle.
+ * @param veh The vehicle to calculate the max speed of
+ * @return The maximum speed of the vehicle, or 0xFFFF if it has no max speed
+ */
+uint16 TrainVehSpeed(const Vehicle *veh)
+{
+	const RailVehicleInfo *rvi = RailVehInfo(veh->engine_type);
+
+	if (rvi->max_speed == 0)
+		return 0xFFFF;
+
+	if ((rvi->flags & RVI_WAGON) && (!_patches.wagon_speed_limits || GetWagonOverrideSpriteSet(veh->engine_type, veh->u.rail.first_engine) != NULL))
+		return 0xFFFF;
+
+	return rvi->max_speed;
+}
Index: engine.h
===================================================================
--- engine.h	(revision 2720)
+++ engine.h	(working copy)
@@ -14,12 +14,13 @@
 	byte base_cost;
 	uint16 max_speed;
 	uint16 power;
+	byte TE_coeff;
 	byte weight;
 	byte running_cost_base;
 	byte engclass; // 0: steam, 1: diesel, 2: electric
 	byte capacity;
 	byte cargo_type;
-	byte callbackmask; // see CallbackMask enum
+	byte callbackmask;
 	uint16 pow_wag_power;
 	byte pow_wag_weight;
 	byte visual_effect; // NOTE: this is not 100% implemented yet, at the moment it is only used as a 'fallback' value
@@ -152,6 +153,11 @@
 	// Refit capacity, the passed vehicle needs to have its ->cargo_type set to
 	// the cargo we are refitting to, returns the new cargo capacity
 	CBID_REFIT_CAP = 0x15,
+
+	// Articulated engine, pass NULL as vehicle, use `build stage` as bits 8-15
+	// of callback_info, returns the engine-id of the next vehicle part to
+	// add, or 0xFF if no more parts need to be added
+	CBID_ARTIC_ENGINE = 0x16,
 };
 
 // bit positions for rvi->callbackmask, indicates which callbacks are used by an engine
@@ -160,6 +166,7 @@
 	CBM_WAGON_POWER = 0,
 	CBM_VEH_LENGTH = 1,
 	CBM_REFIT_CAP = 3,
+	CBM_ARTIC_ENGINE = 4,
 };
 
 enum {
@@ -182,6 +189,8 @@
 #define GetCustomVehicleSprite(v, direction) GetCustomEngineSprite(v->engine_type, v, direction)
 #define GetCustomVehicleIcon(et, direction) GetCustomEngineSprite(et, NULL, direction)
 
+uint16 TrainVehSpeed(const Vehicle *veh);
+
 typedef enum VehicleTrigger {
 	VEHICLE_TRIGGER_NEW_CARGO = 1,
 	// Externally triggered only for the first vehicle in chain
Index: aircraft_cmd.c
===================================================================
--- aircraft_cmd.c	(revision 2720)
+++ aircraft_cmd.c	(working copy)
@@ -332,7 +332,7 @@
 				(_m[tile].m5 == 32 || _m[tile].m5 == 65 || _m[tile].m5 == 86);
 }
 
-static bool CheckStoppedInHangar(Vehicle *v)
+bool CheckStoppedInHangar(Vehicle *v)
 {
 	if (!(v->vehstatus & VS_STOPPED) || !IsAircraftHangarTile(v->tile)) {
 		_error_message = STR_A01B_AIRCRAFT_MUST_BE_STOPPED;
@@ -1266,6 +1266,13 @@
 		return;
 
 	st = GetStation(v->u.air.targetairport);
+	if ((v->subtype == SUBTYPE_NONE) || (v->subtype == SUBTYPE_AIRCRAFT))
+	{
+		st->vehicles[STS_VEH_AIRCRAFT].this_month++;
+		if (st->months_counted == STS_NO_MONTHS_COUNTED) st->months_counted = 1;
+	}
+	InvalidateWindow(WC_STATION_STATS, st->index);
+	
 	v->last_station_visited = v->u.air.targetairport;
 
 	/* Check if station was ever visited before */
Index: vehicle_gui.c
===================================================================
--- vehicle_gui.c	(revision 2720)
+++ vehicle_gui.c	(working copy)
@@ -16,6 +16,9 @@
 #include "gfx.h"
 #include "variables.h"
 #include "vehicle_gui.h"
+#include "station.h"
+#include "waypoint.h"
+#include "depot.h"
 
 Sorting _sorting;
 
@@ -63,6 +66,7 @@
 		switch (w->window_class) {
 		case WC_TRAINS_LIST: case WC_ROADVEH_LIST:
 		case WC_SHIPS_LIST:  case WC_AIRCRAFT_LIST:
+		case WC_VEHICLES_LIST:
 			WP(w, vehiclelist_d).flags |= VL_REBUILD;
 			SetWindowDirty(w);
 			break;
@@ -78,6 +82,7 @@
 		switch (w->window_class) {
 		case WC_TRAINS_LIST: case WC_ROADVEH_LIST:
 		case WC_SHIPS_LIST:  case WC_AIRCRAFT_LIST:
+		case WC_VEHICLES_LIST:
 			WP(w, vehiclelist_d).flags |= VL_RESORT;
 			SetWindowDirty(w);
 			break;
@@ -85,61 +90,6 @@
 		}
 }
 
-void BuildVehicleList(vehiclelist_d *vl, int type, int owner, int station)
-{
-	int subtype = (type != VEH_Aircraft) ? TS_Front_Engine : 2;
-	int n = 0;
-	int i;
-
-	if (!(vl->flags & VL_REBUILD)) return;
-
-	/* Create array for sorting */
-	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
-	if (_vehicle_sort == NULL)
-		error("Could not allocate memory for the vehicle-sorting-list");
-
-	DEBUG(misc, 1) ("Building vehicle list for player %d station %d...",
-		owner, station);
-
-	if (station != -1) {
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == type && v->subtype <= subtype) {
-				const Order *order;
-
-				FOR_VEHICLE_ORDERS(v, order) {
-					if (order->type == OT_GOTO_STATION && order->station == station) {
-						_vehicle_sort[n].index = v->index;
-						_vehicle_sort[n].owner = v->owner;
-						++n;
-						break;
-					}
-				}
-			}
-		}
-	} else {
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == type && v->subtype <= subtype && v->owner == owner) {
-				_vehicle_sort[n].index = v->index;
-				_vehicle_sort[n].owner = v->owner;
-				++n;
-			}
-		}
-	}
-
-	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
-	if (n!=0 && vl->sort_list == NULL)
-		error("Could not allocate memory for the vehicle-sorting-list");
-	vl->list_length = n;
-
-	for (i = 0; i < n; ++i)
-		vl->sort_list[i] = _vehicle_sort[i];
-
-	vl->flags &= ~VL_REBUILD;
-	vl->flags |= VL_RESORT;
-}
-
 void SortVehicleList(vehiclelist_d *vl)
 {
 	if (!(vl->flags & VL_RESORT)) return;
@@ -608,7 +558,7 @@
 	switch (WP(w,replaceveh_d).vehicletype) {
 		case VEH_Train: {
 			byte railtype = _railtype_selected_in_replace_gui;
-			DrawString(157, 99 + (14 * w->vscroll.cap), _rail_types_list[railtype], 0x10);
+			DrawString(157, 109 + (14 * w->vscroll.cap), _rail_types_list[railtype], 0x10);
 			/* draw sorting criteria string */
 
 			/* Ensure that custom engines which substituted wagons
@@ -836,7 +786,7 @@
 				}
 
 
-				DrawString(145, (w->resize.step_height == 24 ? 77 : 87 ) + ( w->resize.step_height * w->vscroll.cap), STR_02BD, 0x10);
+				DrawString(145, (w->resize.step_height == 24 ? 87 : 97 ) + ( w->resize.step_height * w->vscroll.cap), STR_02BD, 0x10);
 
 
 				/*	now we draw the two arrays according to what we just counted */
@@ -960,24 +910,24 @@
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,       STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   443,     0,    13, STR_REPLACE_VEHICLES_WHITE, STR_018C_WINDOW_TITLE_DRAG_THIS},
 {  WWT_STICKYBOX,   RESIZE_NONE,    14,   444,   455,     0,    13, 0x0,            STR_STICKY_BUTTON},
-{      WWT_PANEL,     RESIZE_TB,    14,     0,   227,   126,   197, 0x0,            STR_NULL},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   138,   210,   221, STR_REPLACE_VEHICLES_START, STR_REPLACE_HELP_START_BUTTON},
-{      WWT_PANEL,     RESIZE_TB,    14,   139,   316,   198,   209, 0x0,            STR_REPLACE_HELP_REPLACE_INFO_TAB},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   306,   443,   210,   221, STR_REPLACE_VEHICLES_STOP,  STR_REPLACE_HELP_STOP_BUTTON},
+{      WWT_PANEL,     RESIZE_TB,    14,     0,   227,   126,   207, 0x0,            STR_NULL},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   138,   220,   231, STR_REPLACE_VEHICLES_START, STR_REPLACE_HELP_START_BUTTON},
+{      WWT_PANEL,     RESIZE_TB,    14,   139,   316,   208,   219, 0x0,            STR_REPLACE_HELP_REPLACE_INFO_TAB},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   306,   443,   220,   231, STR_REPLACE_VEHICLES_STOP,  STR_REPLACE_HELP_STOP_BUTTON},
 {     WWT_MATRIX, RESIZE_BOTTOM,    14,     0,   215,    14,   125, 0x801,          STR_REPLACE_HELP_LEFT_ARRAY},
 {  WWT_SCROLLBAR, RESIZE_BOTTOM,    14,   216,   227,    14,   125, 0x0,            STR_0190_SCROLL_BAR_SCROLLS_LIST},
 {     WWT_MATRIX, RESIZE_BOTTOM,    14,   228,   443,    14,   125, 0x801,          STR_REPLACE_HELP_RIGHT_ARRAY},
 { WWT_SCROLL2BAR, RESIZE_BOTTOM,    14,   444,   455,    14,   125, 0x0,            STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{      WWT_PANEL,     RESIZE_TB,    14,   228,   455,   126,   197, 0x0,            STR_NULL},
+{      WWT_PANEL,     RESIZE_TB,    14,   228,   455,   126,   207, 0x0,            STR_NULL},
 // train specific stuff
-{      WWT_PANEL,     RESIZE_TB,    14,     0,   138,   198,   209, 0x0,            STR_NULL},
-{      WWT_PANEL,     RESIZE_TB,    14,   139,   153,   210,   221, 0x0,            STR_NULL},
-{      WWT_PANEL,     RESIZE_TB,    14,   154,   277,   210,   221, 0x0,            STR_REPLACE_HELP_RAILTYPE},
-{   WWT_CLOSEBOX,     RESIZE_TB,    14,   278,   289,   210,   221, STR_0225,       STR_REPLACE_HELP_RAILTYPE},
-{      WWT_PANEL,     RESIZE_TB,    14,   290,   305,   210,   221, 0x0,            STR_NULL},
-{      WWT_PANEL,     RESIZE_TB,    14,   317,   455,   198,   209, 0x0,            STR_NULL},
+{      WWT_PANEL,     RESIZE_TB,    14,     0,   138,   208,   219, 0x0,            STR_NULL},
+{      WWT_PANEL,     RESIZE_TB,    14,   139,   153,   220,   231, 0x0,            STR_NULL},
+{      WWT_PANEL,     RESIZE_TB,    14,   154,   277,   220,   231, 0x0,            STR_REPLACE_HELP_RAILTYPE},
+{   WWT_CLOSEBOX,     RESIZE_TB,    14,   278,   289,   220,   231, STR_0225,       STR_REPLACE_HELP_RAILTYPE},
+{      WWT_PANEL,     RESIZE_TB,    14,   290,   305,   220,   231, 0x0,            STR_NULL},
+{      WWT_PANEL,     RESIZE_TB,    14,   317,   455,   208,   219, 0x0,            STR_NULL},
 // end of train specific stuff
-{  WWT_RESIZEBOX,     RESIZE_TB,    14,   444,   455,   210,   221, 0x0,            STR_RESIZE_BUTTON},
+{  WWT_RESIZEBOX,     RESIZE_TB,    14,   444,   455,   220,   231, 0x0,            STR_RESIZE_BUTTON},
 {   WIDGETS_END},
 };
 
@@ -1016,7 +966,7 @@
 };
 
 static const WindowDesc _replace_rail_vehicle_desc = {
-	-1, -1, 456, 222,
+	-1, -1, 456, 232,
 	WC_REPLACE_VEHICLE,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE,
 	_replace_rail_vehicle_widgets,
@@ -1073,3 +1023,104 @@
 {
 	memset(&_sorting, 0, sizeof(_sorting));
 }
+
+void BuildVehicleListMasked(vehiclelist_d *vl, DisplayListOption *listopt, int owner)
+{
+	const byte landscape = _opt.landscape;
+	int i, n = 0;
+	uint64 cmask;
+
+	if (!(vl->flags & VL_REBUILD)) return;
+
+	/* Create array for sorting */
+	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
+	if (_vehicle_sort == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+
+	DEBUG(misc, 1) ("Building vehicle list for player %d station at %d...",
+		owner, listopt->xy);
+	
+	if (listopt->xy != INVALID_TILE) {  // Build List for a station/waypoint/depot (other?)
+		const Vehicle *v;
+
+		assert(listopt->xy < MapSize()); // not really needed, you will get an empty list when xy is outside the mapbounds
+
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->type_mask, v->type)
+				&& ((v->subtype == TS_Front_Engine)
+					|| (v->type == VEH_Aircraft && v->subtype == SUBTYPE_AIRCRAFT))) {
+				if (listopt->cargo_mask == CARGO_MASK_ALL) {
+					cmask = CARGO_MASK_ALL;
+				} else {
+					const Vehicle *u = v;
+					cmask = 0;
+					for (u = v; u != NULL; u = u->next) { // check cargotypes of all vehicles of the consist (trains/aircraft)
+					// vehicles that cant carry any cargo may have cargotype 0 == CT_PASSENGERS,
+					// so we have to make sure we only get those that could really carry cargo
+					// think we should make them have INVALID_CARGO cargotype instead... (Asterix)
+						if (u->cargo_cap != 0)
+							cmask |= HASBIT(_landscape_global_cargo_mask[landscape], u->cargo_type);
+					}
+				}
+				if (listopt->cargo_mask & cmask) {
+					const Order *order;
+
+					FOR_VEHICLE_ORDERS(v, order) { // check if consist is scheduled for this map-position
+						if (order->type == OT_GOTO_STATION && GetStation(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						} else if (order->type == OT_GOTO_WAYPOINT && GetWaypoint(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						} else if (order->type == OT_GOTO_DEPOT && GetDepot(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						}
+					} // Vehicle Orders
+				}
+			}
+		} // All Vehicles
+	} else {
+		Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->type_mask, v->type) && (v->owner == owner)
+				&& ((v->subtype == TS_Front_Engine)
+					|| (v->type == VEH_Aircraft && v->subtype == SUBTYPE_AIRCRAFT))) {
+				if (listopt->cargo_mask == CARGO_MASK_ALL) {
+					_vehicle_sort[n].index = v->index;
+					_vehicle_sort[n].owner = v->owner;
+					++n;
+				} else {
+					Vehicle *u = v;
+					cmask = 0;
+					for (u = v; u != NULL; u = u->next) { // check cargotypes of all vehicles of the consist (trains/aircraft)
+						if (u->cargo_cap != 0)
+							cmask |= HASBIT(_landscape_global_cargo_mask[landscape], u->cargo_type);
+					}
+					if (listopt->cargo_mask & cmask) {
+						_vehicle_sort[n].index = v->index;
+						_vehicle_sort[n].owner = v->owner;
+						++n;
+					}
+				}
+			}
+		} // All Vehicles
+	}
+
+	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
+	if (n != 0 && vl->sort_list == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+	vl->list_length = n;
+
+	for (i = 0; i < n; ++i)
+		vl->sort_list[i] = _vehicle_sort[i];
+
+	vl->flags &= ~VL_REBUILD;
+	vl->flags |= VL_RESORT;
+}
Index: vehicle_gui.h
===================================================================
--- vehicle_gui.h	(revision 2720)
+++ vehicle_gui.h	(working copy)
@@ -4,6 +4,7 @@
 #define VEHICLE_GUI_H
 
 #include "vehicle.h"
+#include "window.h"
 
 struct vehiclelist_d;
 
@@ -15,7 +16,15 @@
 void RebuildVehicleLists(void);
 void ResortVehicleLists(void);
 
-void BuildVehicleList(struct vehiclelist_d *vl, int type, int owner, int station);
+/** builds a list of all vehicles that comply with the criteria given
+  *
+  * @param vl: the list to be build/rebuild
+  * @param listopt: struct with the listoptions
+  * @param owner: the owner of the vehicles that are added to the list
+  *
+  * @see DisplayListOption
+  */
+void BuildVehicleListMasked(struct vehiclelist_d *vl, DisplayListOption *listopt, int owner);
 void SortVehicleList(struct vehiclelist_d *vl);
 
 int CDECL GeneralOwnerSorter(const void *a, const void *b);
@@ -57,6 +66,7 @@
 	Listing roadveh;
 	Listing ship;
 	Listing train;
+	Listing masked;
 } Sorting;
 
 extern Sorting _sorting;
@@ -75,5 +85,9 @@
 void DrawAircraftPurchaseInfo(int x, int y, EngineID engine_number);
 void DrawShipPurchaseInfo(int x, int y, EngineID engine_number);
 
+void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection);
+void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection);
+void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection);
+void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection);
 
 #endif /* VEHICLE_GUI_H */
Index: misc_gui.c
===================================================================
--- misc_gui.c	(revision 2720)
+++ misc_gui.c	(working copy)
@@ -1706,14 +1706,15 @@
 	{CE_BOOL, 0, STR_CHEAT_SETUP_PROD,			&_cheats.setup_prod.value,			&_cheats.setup_prod.been_used,			NULL,											0, 0, 0},
 	{CE_UINT8, 0, STR_CHEAT_SWITCH_CLIMATE, &_opt.landscape, 								&_cheats.switch_climate.been_used,	&ClickChangeClimateCheat,-1, 4, 1},
 	{CE_UINT8, 0, STR_CHEAT_CHANGE_DATE,		&_cur_year,											&_cheats.change_date.been_used,			&ClickChangeDateCheat,	 -1, 1, 1},
+	{CE_BOOL, 0, STR_CHEAT_RESET_STATION,			&_cheats.reset_station.value,			&_cheats.reset_station.been_used,			&ClickResetStationCheat,											0, 0, 0},
 };
 
 
 static const Widget _cheat_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   399,     0,    13, STR_CHEATS,	STR_018C_WINDOW_TITLE_DRAG_THIS},
-{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_NULL},
-{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_CHEATS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_CHEATS_TIP},
 {   WIDGETS_END},
 };
 
@@ -1848,7 +1849,7 @@
 	}
 }
 static const WindowDesc _cheats_desc = {
-	240, 22, 400, 160,
+	240, 22, 400, 174,
 	WC_CHEATS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
 	_cheat_widgets,
Index: lang/english.txt
===================================================================
--- lang/english.txt	(revision 2720)
+++ lang/english.txt	(working copy)
@@ -1029,6 +1029,7 @@
 STR_CONFIG_PATCHES_SERVINT_SHIPS                                :{LTBLUE}Default service interval for ships: {ORANGE}{STRING1} days/%
 STR_CONFIG_PATCHES_SERVINT_SHIPS_DISABLED                       :{LTBLUE}Default service interval for ships: {ORANGE}disabled
 STR_CONFIG_PATCHES_NOSERVICE                                    :{LTBLUE}Disable servicing when breakdowns set to none: {ORANGE}{STRING1}
+STR_CONFIG_PATCHES_WAGONSPEEDLIMITS                             :{LTBLUE}Enable wagon speed limits: {ORANGE}{STRING1}
 
 STR_CONFIG_PATCHES_COLORED_NEWS_DATE                            :{LTBLUE}Coloured news appears in: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_STARTING_DATE                                :{LTBLUE}Starting date: {ORANGE}{STRING1}
@@ -1058,6 +1059,12 @@
 STR_CONFIG_PATCHES_QUERY_CAPT                                   :{WHITE}Change setting value
 STR_CONFIG_PATCHES_SERVICE_INTERVAL_INCOMPATIBLE                :{WHITE}Some or all of the default service interval(s) below are incompatible with the chosen setting! 5-90% and 30-800 days are valid
 
+STR_CONFIG_PATCHES_NSR_SPEED                                    :{LTBLUE}Enable new rating for Vehicle-Speed: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_AGE                                      :{LTBLUE}Enable new rating for Vehicle-Age: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_WAIT_DAYS                                :{LTBLUE}Enable new rating for days since last pickup: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_WAIT_CARGO                               :{LTBLUE}Enable new rating for Cargo/Passengers waiting: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_TOWN_RATING                              :{LTBLUE}Enable new rating for Local Authority Acceptance: {ORANGE}{STRING}
+
 STR_TEMPERATE_LANDSCAPE                                         :Temperate landscape
 STR_SUB_ARCTIC_LANDSCAPE                                        :Sub-arctic landscape
 STR_SUB_TROPICAL_LANDSCAPE                                      :Sub-tropical landscape
@@ -1075,6 +1082,7 @@
 STR_CHEAT_SWITCH_CLIMATE                                        :{LTBLUE}Switch climate: {ORANGE} {STRING}
 STR_CHEAT_CHANGE_DATE                                           :{LTBLUE}Change date: {ORANGE} {DATE_SHORT}
 STR_CHEAT_SETUP_PROD                                            :{LTBLUE}Enable modifying production values: {ORANGE}{STRING1}
+STR_CHEAT_RESET_STATION                                         :{LTBLUE}Enable Resetting of Stations: {ORANGE}{STRING}
 
 STR_HEADING_FOR_WAYPOINT                                        :{LTBLUE}Heading for {WAYPOINT}
 STR_HEADING_FOR_WAYPOINT_VEL                                    :{LTBLUE}Heading for {WAYPOINT}, {VELOCITY}
@@ -1089,6 +1097,26 @@
 STR_WAYPOINT                                                    :{WHITE}Waypoint
 STR_WAYPOINT_GRAPHICS_TIP                                       :{BLACK}Select waypoint type
 
+STR_SIGNAL_SELECTION                                            :{WHITE}Signal Type Selection
+STR_SIGNAL_PRESIG_COMBO                                         :{BLACK}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{STRING}
+STR_SIGNAL_NORMAL                                               :Normal Signals
+STR_SIGNAL_ENTRANCE                                             :Entrance Presignals
+STR_SIGNAL_COMBO                                                :Combo Presignals
+STR_SIGNAL_EXIT                                                 :Exit Presignals
+STR_SIGNAL_PBS                                                  :PBS Signals
+STR_SIGNAL_COMPLETION                                           :{BLACK}Auto Completion
+STR_SIGNAL_DENSITY_DESC                                         :{BLACK}Signal Density: 
+STR_SIGNAL_DENSITY_TILES                                        :{GOLD}{NUM} tile(s)
+############ Leave those lines in this order!!
+STR_SIGNAL_TYPE_STANDARD                                        :{GOLD}Light Signals
+STR_SIGNAL_TYPE_SEMAPHORES                                      :{GOLD}Semaphores
+############ End of leave-in-this-order
+
+STR_SIGNAL_TYPE_TIP                                             :{BLACK}Select signal type
+STR_SIGNAL_DENSITY_TIP                                          :{BLACK}Select signal density for dragging
+STR_SIGNAL_COMPLETION_TIP                                       :{BLACK}With autocompletion on, signals will be built in the direction you were dragging, following the track until a junction is encountered.
+STR_SIGNAL_PRESIG_TIP                                           :{BLACK}Select the type of presignal, if any
+
 STR_WAYPOINT_VIEWPORT                                           :{WHITE}{WAYPOINT}
 STR_WAYPOINT_VIEWPORT_TINY                                      :{TINYFONT}{WHITE}{WAYPOINT}
 STR_WAYPOINT_RAW                                                :{WAYPOINT}
@@ -2404,6 +2432,12 @@
 STR_881D_NEW_MONORAIL_VEHICLES                                  :{WHITE}New Monorail Vehicles
 STR_881E_NEW_MAGLEV_VEHICLES                                    :{WHITE}New Maglev Vehicles
 STR_881F_BUILD_VEHICLE                                          :{BLACK}Build Vehicle
+STR_CLONE_ROAD_VEHICLE                                          :{BLACK}Clone Vehicle
+STR_CLONE_ROAD_VEHICLE_INFO 	                                :{BLACK}This will build a copy of the road vehicle
+STR_CLONE_ROAD_VEHICLE_DEPOT_INFO	                        :{BLACK}This will build a copy of a road vehicle. Click this button and then on a road vehicle inside or outside the depot
+STR_CLONE_TRAIN                                     		:{BLACK}Clone Train
+STR_CLONE_TRAIN_INFO 	                  			:{BLACK}This will build a copy of the train including all cars
+STR_CLONE_TRAIN_DEPOT_INFO	                        	:{BLACK}This will build a copy of a train including all cars. Click this button and then on a train inside or outside the depot
 STR_8820_RENAME                                                 :{BLACK}Rename
 STR_8823_SKIP                                                   :{BLACK}Skip
 STR_8824_DELETE                                                 :{BLACK}Delete
@@ -2560,6 +2594,9 @@
 STR_9807_MUST_BUILD_SHIP_DEPOT_FIRST                            :{WHITE}Must build ship depot first
 STR_9808_NEW_SHIPS                                              :{WHITE}New Ships
 STR_9809_BUILD_SHIP                                             :{BLACK}Build Ship
+STR_CLONE_SHIP                                              	:{BLACK}Clone Ship
+STR_CLONE_SHIP_INFO 	                                        :{BLACK}This will build a copy of the ship
+STR_CLONE_SHIP_DEPOT_INFO	                          	:{BLACK}This will build a copy of a ship. Click this button and then on a ship inside or outside the depot
 STR_980B_SHIP_MUST_BE_STOPPED_IN                                :{WHITE}Ship must be stopped in depot
 STR_980C_CAN_T_SELL_SHIP                                        :{WHITE}Can't sell ship...
 STR_980D_CAN_T_BUILD_SHIP                                       :{WHITE}Can't build ship...
@@ -2624,6 +2661,9 @@
 STR_A001_CAN_T_BUILD_AIRPORT_HERE                               :{WHITE}Can't build airport here...
 STR_A002_AIRCRAFT_HANGAR                                        :{WHITE}{STATION} Aircraft Hangar
 STR_A003_NEW_AIRCRAFT                                           :{BLACK}New Aircraft
+STR_CLONE_AIRCRAFT                                           	:{BLACK}Clone Aircraft
+STR_CLONE_AIRCRAFT_INFO                                        	:{BLACK}This will build a copy of the aircraft
+STR_CLONE_AIRCRAFT_INFO_HANGAR_WINDOW                          	:{BLACK}This will build a copy of an aircraft. Click this button and then on an aircraft inside or outside the hangar
 STR_A004_INFORMATION                                            :{BLACK}Information
 STR_A005_NEW_AIRCRAFT                                           :{WHITE}New Aircraft
 STR_A006_BUILD_AIRCRAFT                                         :{BLACK}Build Aircraft
@@ -2706,6 +2746,51 @@
 STR_BUILD_DATE                                                  :{BLACK}Built: {LTBLUE}{DATE_LONG}
 STR_MULTIPLAYER_PAUSED                                          :{WHITE}Game is paused.{}Command cannot be executed
 
+STR_RESET_STATION                                               :{BLACK}* RESET *
+STR_RESET_STATION_TIP                                           :{BLACK}When pressing this button the Station is reset, as if it was newly built.
+STR_CAN_T_RESET_STATION                                         :{WHITE}Can't reset station...
+
+STR_STATION_STATS                                               :{BLACK}Statistics
+STR_STATION_GOODS_IN                                            :{BLACK}In
+STR_STATION_GOODS_OUT                                           :{BLACK}Out
+STR_STATION_GOODS_TRANSFER                                      :{BLACK}Transit
+STR_VEHICLES                                                    :{BLACK}Vehicles
+STR_SCHEDULED                                                   :{BLACK}Scheduled
+STR_VEHICLES_MONTH                                              :{BLACK}Last Month
+STR_VEHICLES_CURRENT                                            :{BLACK}Current Month
+STR_TRAINS                                                      :{BLACK}Trains
+STR_RVS                                                         :{BLACK}Road Vehicles
+STR_BUSSES                                                      :{BLACK}Buses
+STR_TRUCKS                                                      :{BLACK}Trucks
+STR_SHIPS                                                       :{BLACK}Ships
+STR_AIRCRAFT                                                    :{BLACK}Aircraft
+STR_NUMBER                                                      :{YELLOW}{COMMA}
+STR_STATION_MONTHS                                              :{BLACK}Cargo amount [This Month (Last Month) ]
+STR_CNUMBERS                                                    :{WHITE}{COMMA} {TINYFONT}{BLACK}({YELLOW}{COMMA}{BLACK})
+STR_VEHICLES_MONTHS_AVERAGE                                     :{BLACK}Average / Min / Max
+STR_MONTHS_COUNTED_NUM                                          :{BLACK}Months Counted: {GOLD}{COMMA}
+STR_MONTHS_TINY                                                 :{TINYFONT}{BLACK}Months
+STR_STATION_MONTHS_AVERAGE                                      :{BLACK}Cargo amount [Average (Min/Max) per Month]
+STR_TOGGLE_MINMAX                                               :{BLACK}Toggle  -This/Last Month-   or   -Average/Min/Max-   Stats
+STR_RESET_STATISTICS                                            :{BLACK}Reset Statistics
+STR_AVERAGENUMBERS                                              :{SILVER}{COMMA} {BLACK}{TINYFONT}({ORANGE}{COMMA}{BLACK}/{LTBLUE}{COMMA}{BLACK})
+STR_BLACK_SLASH                                                 :{BLACK}/
+STR_TINY_GOLD_NUMBER                                            :{TINYFONT}{GOLD}{COMMA}
+STR_SILVER_NUMBER                                               :{SILVER}{COMMA}
+STR_ORANGE_NUMBER                                               :{ORANGE}{COMMA}
+STR_LTBLUE_NUMBER                                               :{LTBLUE}{COMMA}
+STR_WHITE_NUMBER                                                :{WHITE}{COMMA}
+STR_STS_NOT_SCHEDULED                                           :{BLACK}Not Scheduled
+STR_AVERAGE                                                     :{BLACK}Average
+STR_MINIMUM                                                     :{BLACK}Minimum
+STR_MAXIMUM                                                     :{BLACK}Maximum
+STR_STS_VEHICLES_LAST_YEAR                                      :{BLACK}Last Year
+STR_STS_VEHICLES_THIS_YEAR                                      :{BLACK}This Year
+STR_STS_YEARS_COUNTED_NUM                                       :{BLACK}Years Counted: {GOLD}{COMMA}
+STR_STS_TOGGLE_MONTH_YEAR                                       :{BLACK}Toggle  -Monthly-   or   -Yearly-   Stats
+STR_STATION_COVERAGE                                            :{BLACK}Coverage
+STR_VEHICLE_CARGO_LIST                                          :{BLACK}Show List of Scheduled Vehicles for this Cargo-Type
+
 STR_PERFORMANCE_DETAIL                                          :{WHITE}Detailed performance rating
 STR_PERFORMANCE_DETAIL_KEY                                      :{BLACK}Detail
 STR_PERFORMANCE_DETAIL_AMOUNT_CURRENCY                          :{BLACK}({CURRCOMPACT}/{CURRCOMPACT})
@@ -2797,6 +2882,7 @@
 
 STR_PURCHASE_INFO_COST_WEIGHT                                   :{BLACK}Cost: {GOLD}{CURRENCY}{BLACK} Weight: {GOLD}{COMMA}t
 STR_PURCHASE_INFO_SPEED_POWER                                   :{BLACK}Speed: {GOLD}{VELOCITY}{BLACK}   Power: {GOLD}{COMMA}hp
+STR_PURCHASE_INFO_SPEED                                         :{BLACK}Speed: {GOLD}{VELOCITY}
 STR_PURCHASE_INFO_RUNNINGCOST                                   :{BLACK}Running Cost: {GOLD}{CURRENCY}/yr
 STR_PURCHASE_INFO_CAPACITY                                      :{BLACK}Capacity: {GOLD}{STRING1} {STRING}
 STR_PURCHASE_INFO_DESIGNED_LIFE                                 :{BLACK}Designed: {GOLD}{NUM}{BLACK} Life: {GOLD}{COMMA} years
@@ -2806,3 +2892,27 @@
 STR_PURCHASE_INFO_COST_SPEED                                    :{BLACK}Cost: {GOLD}{CURRENCY}{BLACK} Speed: {GOLD}{VELOCITY}
 STR_PURCHASE_INFO_AIRCRAFT_CAPACITY                             :{BLACK}Capacity: {GOLD}{COMMA} passengers, {COMMA} bags of mail
 STR_PURCHASE_INFO_PWAGPOWER_PWAGWEIGHT                          :{BLACK}Powered Wagons: {GOLD}+{COMMA}hp{BLACK} Weight: {GOLD}+{COMMA}t
+STR_PURCHASE_INFO_MAX_TE                                        :{BLACK}Max. Tractive Effort: {GOLD}{COMMA}kN
+
+STR_STATION_RATING_DETAIL                                          :{WHITE}Detailed service ratings - {1:STATIONFEATURES}
+STR_STATION_RATING_DETAIL_KEY                                      :{BLACK}Detail
+STR_STATION_RATING_DETAIL_SCORES                                   :{BLACK}({NUM}/{NUM})
+STR_STATION_RATING_DETAIL_PERCENT                                  :{WHITE}{NUM}%
+STR_STATION_RATING_DETAIL_INT                                      :{BLACK}{NUM}
+STR_STATION_RATING_DETAIL_WAITING                                  :{BLACK}Waiting cargo:
+STR_STATION_RATING_DETAIL_WAITING_EX                               :{BLACK}{STRING}
+STR_STATION_RATING_DETAIL_SPEED                                    :{BLACK}Last speed:
+STR_STATION_RATING_DETAIL_SPEED_EX                                 :{BLACK}{NUM}
+STR_STATION_RATING_DETAIL_AGE                                      :{BLACK}Last age:
+STR_STATION_RATING_DETAIL_AGE_EX                                   :{BLACK}{COMMA} year(s)
+STR_STATION_RATING_DETAIL_PICKUP                                   :{BLACK}Days since pickup:
+STR_STATION_RATING_DETAIL_PICKUP_EX                                :{BLACK}{COMMA} day(s)
+STR_STATION_RATING_DETAIL_OTHER                                    :{BLACK}Other ratings:
+STR_STATION_RATING_DETAIL_TOTAL                                    :{BLACK}Total rating:
+STR_STATION_RATING_DETAIL_SPEED_TIP                                :{BLACK}Maximum speed of the last vehicle entering the station (internal value, clipped at 255)
+STR_STATION_RATING_DETAIL_AGE_TIP                                  :{BLACK}Age of the last vehicle entering the station
+STR_STATION_RATING_DETAIL_PICKUP_TIP                               :{BLACK}Number of days since the last cargo pickup
+STR_STATION_RATING_DETAIL_WAITING_TIP                              :{BLACK}Cargo waiting at the station
+STR_STATION_RATING_DETAIL_OTHER_TIP                                :{BLACK}Other ratings are mainly if the town of the station has a statue of the company owner
+STR_STATION_RATING_DETAIL_TOTAL_TIP                                :{BLACK}Total rating - The station rating is updated according to this value in small increments
+STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP                         :{BLACK}Click here to toggle cargo type
Index: variables.h
===================================================================
--- variables.h	(revision 2720)
+++ variables.h	(working copy)
@@ -130,6 +130,7 @@
 	bool nonuniform_stations;// allow nonuniform train stations
 	bool always_small_airport; // always allow small airports
 	bool realistic_acceleration; // realistic acceleration for trains
+	bool wagon_speed_limits; // use wagon speed limits
 	bool forbid_90_deg; // forbid trains to make 90 deg turns
 	bool invisible_trees; // don't show trees when buildings are transparent
 	bool no_servicing_if_no_breakdowns; // dont send vehicles to depot when breakdowns are disabled
@@ -214,6 +215,12 @@
  	uint32 npf_crossing_penalty; /* The penalty for level crossings */
 
 	bool population_in_label; // Show the population of a town in his label?
+
+	bool nsr_speed;			// new station rating: vehicle speed
+	bool nsr_age;			// new station rating: vehicle age
+	bool nsr_wait_days;		// new station rating: days since last pickup
+	bool nsr_wait_cargo;	// new station rating: amount of cargo waiting
+	bool nsr_town_rating;	// new station rating: include local authority rating
 } Patches;
 
 VARDEF Patches _patches;
@@ -239,6 +246,7 @@
 	Cheat switch_climate;
 	Cheat change_date;				//changes date ingame
 	Cheat setup_prod;				//setup raw-material production in game
+	Cheat reset_station;		// allow resetting of Stations
 } Cheats;
 
 VARDEF Cheats _cheats;
@@ -333,6 +341,8 @@
 
 VARDEF char _ini_videodriver[16], _ini_musicdriver[16], _ini_sounddriver[16];
 
+VARDEF bool _show_average_stats; // show Average Stats for Station-Stats?
+
 // debug features
 VARDEF char _savedump_path[64];
 VARDEF uint _savedump_first, _savedump_freq, _savedump_last;
Index: roadveh_cmd.c
===================================================================
--- roadveh_cmd.c	(revision 2720)
+++ roadveh_cmd.c	(working copy)
@@ -796,6 +796,14 @@
 
 static void RoadVehArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_ROAD].this_month++;
+	if (st->months_counted == STS_NO_MONTHS_COUNTED) st->months_counted = 1;
+	if (v->cargo_type == CT_PASSENGERS)
+		st->vehicles[STS_VEH_BUS].this_month++;
+	else
+		st->vehicles[STS_VEH_TRUCK].this_month++;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	if (v->engine_type < 123) {
 		/* Check if station was ever visited before */
 		if (!(st->had_vehicle_of_type & HVOT_BUS)) {
Index: openttd.h
===================================================================
--- openttd.h	(revision 2720)
+++ openttd.h	(working copy)
@@ -270,7 +270,7 @@
 
 	NUM_CARGO = 12,
 
-	CT_INVALID = 0xFF
+	CT_INVALID = 0xFF,
 };
 
 typedef uint AcceptedCargo[NUM_CARGO];
@@ -446,6 +446,11 @@
 	WC_HIGHSCORE = 0x4D,
 	WC_ENDSCREEN = 0x4E,
 	WC_SIGN_LIST = 0x4F,
+	WC_STATION_STATS = 0x50,
+	WC_WAYPOINT_STATS = 0x51,
+	WC_STATION_RATING_DETAIL = 0x52,
+	WC_VEHICLES_LIST = 0x53,
+	WC_BUILD_SIGNALS = 0x54,
 };
 
 
Index: station_gui.c
===================================================================
--- station_gui.c	(revision 2720)
+++ station_gui.c	(working copy)
@@ -15,7 +15,11 @@
 #include "command.h"
 #include "variables.h"
 #include "vehicle_gui.h"
+#include "engine.h"
+#include "depot.h"
 
+extern int _traininfo_vehicle_pitch;
+
 static void StationsWndShowStationRating(int x, int y, int type, uint acceptance, int rating)
 {
 	static const byte _rating_colors[NUM_CARGO] = {152,32,15,174,208,194,191,55,184,10,191,48};
@@ -287,9 +291,35 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   210,   221, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   129,   192,   210,   221, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   210,   221, STR_STATION_COVERAGE,	STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_expanded_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,	STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,	STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,	STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,	STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,   197, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   198,   209, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   198,   209, STR_3033_ACCEPTS,	STR_3056_SHOW_LIST_OF_ACCEPTED_CARGO},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   198,   209, STR_0130_RENAME,	STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,   198,   209, STR_TRAIN,	STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY,	STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE,	STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP,	STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   210,   221, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   210,   221, STR_RESET_STATION,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   210,   221, STR_STATION_COVERAGE,	STR_NULL},
+{   WIDGETS_END},
+};
+
 static const Widget _station_view_widgets[] = {
 {    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -305,9 +335,35 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   110,   121, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   129,   192,   110,   121, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   110,   121, STR_STATION_COVERAGE,	STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,	STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,	STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,	STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,	STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,    97, 0x0,	STR_NULL},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,    98,   109, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,    98,   109, STR_3032_RATINGS,	STR_3054_SHOW_STATION_RATINGS},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,    98,   109, STR_0130_RENAME,	STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,    98,   109, STR_TRAIN,	STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY,	STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE,	STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP,	STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   110,   121, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   110,   121, STR_RESET_STATION,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   110,   121, STR_STATION_COVERAGE,	STR_NULL},
+{   WIDGETS_END},
+};
+
 static void DrawStationViewWindow(Window *w)
 {
 	Station *st;
@@ -324,7 +380,7 @@
 
 	num = 1;
 	for(i=0; i!=NUM_CARGO; i++) {
-		if ((st->goods[i].waiting_acceptance & 0xFFF) != 0) {
+		if ((st->goods[i].waiting_acceptance & MAX_CARGO_WAITING) != 0) {
 			num++;
 			if (st->goods[i].enroute_from != station_id)
 				num++;
@@ -332,7 +388,11 @@
 	}
 	SetVScrollCount(w, num);
 
-	w->disabled_state = st->owner == _local_player ? 0 : (1 << 9);
+	// 9 = Rename Station, 16 = Reset station
+	if (_cheats.reset_station.value)
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 16);
+	else
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9);
 
 	if (!(st->facilities & FACIL_TRAIN)) SETBIT(w->disabled_state,  10);
 	if (!(st->facilities & FACIL_TRUCK_STOP) &&
@@ -351,7 +411,7 @@
 	if (--pos < 0) {
 		str = STR_00D0_NOTHING;
 		for(i=0; i!=NUM_CARGO; i++)
-			if (st->goods[i].waiting_acceptance & 0xFFF)
+			if (st->goods[i].waiting_acceptance & MAX_CARGO_WAITING)
 				str = STR_EMPTY;
 		SetDParam(0, str);
 		DrawString(x, y, STR_0008_WAITING, 0);
@@ -360,7 +420,7 @@
 
 	i = 0;
 	do {
-		uint waiting = (st->goods[i].waiting_acceptance & 0xFFF);
+		uint waiting = (st->goods[i].waiting_acceptance & MAX_CARGO_WAITING);
 		if (waiting == 0)
 			continue;
 
@@ -398,7 +458,8 @@
 		}
 	} while (pos > -5 && ++i != 12);
 
-	if (IsWindowOfPrototype(w, _station_view_widgets)) {
+	if (IsWindowOfPrototype(w, _station_view_widgets) ||
+		IsWindowOfPrototype(w, _station_view_cheat_widgets) ) {
 		char *b = _userstring;
 
 		b = InlineString(b, STR_000C_ACCEPTS);
@@ -437,7 +498,36 @@
 	}
 }
 
+int32 ClickResetStationCheat(int32 cheat_activated, int32 NOT_USED)
+{ // switch all open station-view-windows to new widget-set when cheat toggled
+	Window *w;
 
+	for (w = _windows; w != _last_window; ++w) {
+		if (w->window_class == WC_STATION_VIEW) {
+			/* toggle height/widget set */
+			SetWindowDirty(w);
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (cheat_activated != 0) { // Reset button enabled?
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+				} else {
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+				}
+				w->height = ST_VIEW_EXP_HEIGHT;
+			} else {
+				if (cheat_activated != 0) { // Reset button enabled?
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+				} else {
+					AssignWidgetToWindow(w, _station_view_widgets);
+				}
+				w->height = ST_VIEW_HEIGHT;
+			}
+			SetWindowDirty(w);
+		}
+	}
+	return 0;
+}
+
 static void StationViewWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -447,42 +537,46 @@
 
 	case WE_CLICK:
 		switch(e->click.widget) {
-		case 7:
+		case 7: { // go to Location of station
 			ScrollMainWindowToTile(GetStation(w->window_number)->xy);
 			break;
-
-		case 8:
+		}
+		case 8: { // toggle rating/acceptance
 			SetWindowDirty(w);
 
 			/* toggle height/widget set */
-			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)) {
-				AssignWidgetToWindow(w, _station_view_widgets);
-				w->height = 110;
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_widgets);
+				w->height = ST_VIEW_HEIGHT;
 			} else {
-				AssignWidgetToWindow(w, _station_view_expanded_widgets);
-				w->height = 210;
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+				w->height = ST_VIEW_EXP_HEIGHT;
 			}
 
 			SetWindowDirty(w);
 			break;
-
-		case 9: {
+		}
+		case 9: { // Rename Station
 			SetDParam(0, w->window_number);
 			ShowQueryString(STR_STATION, STR_3030_RENAME_STATION_LOADING, 31, 180, w->window_class, w->window_number);
 		} break;
-
 		case 10: { /* Show a list of scheduled trains to this station */
 			const Station *st = GetStation(w->window_number);
 			ShowPlayerTrains(st->owner, w->window_number);
 			break;
 		}
-
 		case 11: { /* Show a list of scheduled road-vehicles to this station */
 			const Station *st = GetStation(w->window_number);
 			ShowPlayerRoadVehicles(st->owner, w->window_number);
 			break;
 		}
-
 		case 12: { /* Show a list of scheduled aircraft to this station */
 			const Station *st = GetStation(w->window_number);
 			/* Since oilrigs have no owners, show the scheduled aircraft of current player */
@@ -490,7 +584,6 @@
 			ShowPlayerAircraft(owner, w->window_number);
 			break;
 		}
-
 		case 13: { /* Show a list of scheduled ships to this station */
 			const Station *st = GetStation(w->window_number);
 			/* Since oilrigs/bouys have no owners, show the scheduled ships of current player */
@@ -498,9 +591,30 @@
 			ShowPlayerShips(owner, w->window_number);
 			break;
 		}
+		case 14: { // Show Statistics for Station
+			ShowStationStatsWindow(w->window_number);
+			break;
 		}
+		case 15: { // Show Details for Station Rating
+			const Station *st = GetStation(w->window_number);
+			ShowStationRatingDetail(st->index);
+			break;
+		}
+		case 16: { // Reset Station
+			Station *st = GetStation(w->window_number);
+			if (_cheats.reset_station.value) {
+				DoCommandP(st->xy, w->window_number, 0, NULL,
+					CMD_RESET_STATION_CHEAT | CMD_MSG(STR_CAN_T_RESET_STATION));
+				SetWindowDirty(w);
+			}
+			InitializeStationStats(st);
+			break;
+ 		}
+		case 17: { //ToDo: show station coverage
+			break;
+		}
+		} // end of switch(e->click.widget)
 		break;
-
 	case WE_ON_EDIT_TEXT: {
 		if (e->edittext.str[0] != '\0') {
 			Station* st = GetStation(w->window_number);
@@ -515,34 +629,784 @@
 		WindowNumber wno =
 			(w->window_number << 16) | GetStation(w->window_number)->owner;
 
+		// Destroy vehicle-windows related to this window, too
 		DeleteWindowById(WC_TRAINS_LIST, wno);
 		DeleteWindowById(WC_ROADVEH_LIST, wno);
 		DeleteWindowById(WC_SHIPS_LIST, wno);
 		DeleteWindowById(WC_AIRCRAFT_LIST, wno);
+		DeleteWindowById(WC_STATION_STATS, w->window_number);
 		break;
 	}
 	}
 }
 
-
 static const WindowDesc _station_view_desc = {
-	-1, -1, 249, 110,
+	-1, -1, 249, ST_VIEW_HEIGHT,
 	WC_STATION_VIEW,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
 	_station_view_widgets,
 	StationViewWndProc
 };
 
+// alternate widget-set if reset-station-cheat is enabled
+static const WindowDesc _station_view_cheat_desc = {
+	-1, -1, 249, ST_VIEW_HEIGHT,
+	WC_STATION_VIEW,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_view_cheat_widgets,
+	StationViewWndProc
+};
+
 void ShowStationViewWindow(int station)
 {
 	Window *w;
 	byte color;
 
-	w = AllocateWindowDescFront(&_station_view_desc, station);
+	if (_cheats.reset_station.value)
+		w = AllocateWindowDescFront(&_station_view_cheat_desc, station);
+	else
+		w = AllocateWindowDescFront(&_station_view_desc, station);
 	if (w) {
 		color = GetStation(w->window_number)->owner;
+		if (color != OWNER_NONE)
+			w->caption_color = color;
+		w->vscroll.cap = 5;
+	}
+}
+
+void StationStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _station_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   398,     0,    13, STR_300A_0, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   399,   410,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    91,   410,    14,    25, STR_TOGGLE_MINMAX, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,    26,    37, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    38,    49, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    50,    61, STR_RVS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    62,    73, STR_BUSSES, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    74,    85, STR_TRUCKS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    85,    97, STR_SHIPS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    98,   109, STR_AIRCRAFT, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    91,   410,    38,   109, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,   110,   135, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   398,   136,   191, 0x0,0x0},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   399,   410,   136,   191, 0x0, STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WIDGETS_END},
+};
+
+WindowDesc _station_view_stats = {
+	-1, -1, 411, 192,
+	WC_STATION_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_stats_widgets,
+	StationStatsWndProc
+};
+
+void DrawStationStatWindow(Window *w, Station *st)
+{
+	int i, y, numcargo = 0, pos;
+	GoodsEntry *ge;
+	
+	// count number of goods at station (months_counted will be 0 if good not delivered/picked up)
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		if (ge->months_counted != STS_NO_MONTHS_COUNTED) numcargo++;
+	}
+	SetVScrollCount(w, numcargo);
+		
+	//Get the Station name
+	SetDParam(0, st->index);
+	
+	//and the little carrier type images
+	SetDParam(1, st->facilities);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawStringCentered(45, 28, STR_VEHICLES, 0);
+
+	//Part 1:       Find the number of carriers on the station
+	y = 27;
+	if (_show_average_stats) {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(275, y, STR_VEHICLES_MONTHS_AVERAGE, 0);
+		SetDParam(0, max(st->months_counted - 1,0));
+		DrawStringRightAligned(405, y, STR_MONTHS_COUNTED_NUM, 0);
+	} else {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(295, y, STR_VEHICLES_MONTH, 0);
+		DrawStringRightAligned(395, y, STR_VEHICLES_CURRENT, 0);	
+	}
+
+	y = 38;
+	for (i = 0; i < STS_VEH_TYPES; i++) {
+		if (w->custom[i] != 0) {
+			SetDParam(0, w->custom[i]);
+			DrawStringRightAligned(150, y+i*12, STR_NUMBER, 0);
+			CLRBIT(w->disabled_state, i+7);
+		} else {
+			SETBIT(w->disabled_state, i+7);
+		}
+		if (_show_average_stats) {
+			if (st->vehicles[i].average != 0 || st->vehicles[i].month_max !=0) {
+				SetDParam(0, st->vehicles[i].average / AVERAGE_MULTIPLIER);
+				DrawStringRightAligned(235, y+i*12, STR_SILVER_NUMBER, 0);
+				DrawStringRightAligned(245, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_min);
+				DrawStringRightAligned(290, y+i*12, STR_ORANGE_NUMBER, 0);
+				DrawStringRightAligned(300, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_max);
+				DrawStringRightAligned(350, y+i*12, STR_LTBLUE_NUMBER, 0);
+			}
+		} else {
+			if (st->vehicles[i].last_month != 0) {
+				SetDParam(0, st->vehicles[i].last_month);
+				DrawStringRightAligned(295, y+i*12, STR_NUMBER, 0);
+			}
+			if (st->vehicles[i].this_month) {
+				SetDParam(0, st->vehicles[i].this_month);
+				DrawStringRightAligned(395, y+i*12, STR_WHITE_NUMBER, 0);
+			}
+		}
+	}
+	
+	y = 124;
+	if (_show_average_stats) {
+		DrawString(5, y-10, STR_STATION_MONTHS_AVERAGE, 0);
+		DrawStringRightAligned(100, y+2, STR_MONTHS_TINY, 0);
+	} else {
+		DrawString(5, y-10, STR_STATION_MONTHS, 0);
+	}
+	DrawStringRightAligned(200, y, STR_STATION_GOODS_IN, 0);
+	DrawStringRightAligned(305, y, STR_STATION_GOODS_OUT, 0);
+	DrawStringRightAligned(395, y, STR_STATION_GOODS_TRANSFER, 0);
+	
+	y += 5;
+	pos = w->vscroll.pos;
+	for (i = 0; i < NUM_CARGO; i++) {
+		ge = &st->goods[i];
+		if (ge->months_counted != 0 && ((--pos < 0) && (pos >= -4)) )
+		{
+			StationStats *sts = ge->cargo_amount;
+			//Print the cargo name
+			y += 12;
+			SetDParam(0, _cargoc.names_s[i]);
+			DrawString(3, y, STR_02BD, 0);
+			if (_show_average_stats) {
+				SetDParam(0, ge->months_counted - 1);
+				DrawStringRightAligned(100, y, STR_TINY_GOLD_NUMBER, 0);
+				if (sts[STS_AMOUNT_IN].average != 0 || sts[STS_AMOUNT_IN].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_IN].month_min);
+					SetDParam(2, sts[STS_AMOUNT_IN].month_max);
+					DrawStringRightAligned(200, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].average != 0 || sts[STS_AMOUNT_OUT].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_OUT].month_min);
+					SetDParam(2, sts[STS_AMOUNT_OUT].month_max);
+					DrawStringRightAligned(305, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].average != 0 || sts[STS_AMOUNT_TRANSFER].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].month_min);
+					SetDParam(2, sts[STS_AMOUNT_TRANSFER].month_max);
+					DrawStringRightAligned(395, y, STR_AVERAGENUMBERS, 0);
+				}
+			} else {
+				if (sts[STS_AMOUNT_IN].this_month != 0 || sts[STS_AMOUNT_IN].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].this_month);
+					SetDParam(1, sts[STS_AMOUNT_IN].last_month);
+					DrawStringRightAligned(200, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].this_month != 0 || sts[STS_AMOUNT_OUT].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].this_month);
+					SetDParam(1, sts[STS_AMOUNT_OUT].last_month);
+					DrawStringRightAligned(305, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].this_month != 0 || sts[STS_AMOUNT_TRANSFER].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].this_month);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].last_month);
+					DrawStringRightAligned(395, y, STR_CNUMBERS, 0);
+				}
+			}
+		}
+	}
+}
+
+void StationStatsWndProc(Window *w, WindowEvent *e)
+{
+	Station *st = GetStation(w->window_number);
+	switch(e->event)
+	{
+	case WE_TICK: {
+//		static int counter = 0;
+//		if (++counter % 40) return;
+		int i;
+		
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+		InvalidateWindow(WC_STATION_STATS, w->window_number);
+		break;
+	}
+	case WE_PAINT: {
+		DrawStationStatWindow(w, st);
+		break;
+		}
+	case WE_CLICK: {
+		switch (e->click.widget)
+		{
+			case 4:			// Reset Statistics
+				if (st->owner == _current_player) {
+					InitializeStationStats(st);
+					InvalidateWindow(WC_STATION_STATS, w->window_number);
+				}
+				break;
+			case 5:			// Toggle Average and This Month
+				_show_average_stats ^= 1;
+				InvalidateWindow(WC_STATION_STATS, w->window_number);
+				break;
+			case 7:			//Trains
+				ShowPlayerTrains(st->owner, st->index);
+				break;
+			case 8: 		//Road Vehicles
+				ShowPlayerRoadVehicles(st->owner, st->index);
+				break;
+			case 9:			// Buses
+				ShowPlayerVehicles(st->owner, st->index, 1 << VEH_Road, 1 << GC_PASSENGERS, st->xy);
+				break;
+			case 10:		// Trucks
+				ShowPlayerVehicles(st->owner, st->index, 1 << VEH_Road, CARGO_MASK_ALL &~(1 << GC_PASSENGERS), st->xy);
+				break;
+			case 11: 		//Ships
+				ShowPlayerShips(st->owner, st->index);
+				break;
+			case 12: 		//Aircraft
+				ShowPlayerAircraft(st->owner, st->index);
+				break;
+		}
+	} break;
+	case WE_DESTROY: {
+//		DeleteWindowById(WC_TRAINS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_ROADVEH_LIST, st->owner + ( (st->index + 1) << 8) + 64 + 128);
+//		DeleteWindowById(WC_SHIPS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_AIRCRAFT_LIST, st->owner + ( (st->index + 1) << 8));
+	} break;
+	}
+}
+
+void ShowStationStatsWindow(int station)
+{
+	Window *w;
+	byte color;
+
+	Station *st = GetStation(station);
+
+	w = AllocateWindowDescFront(&_station_view_stats, st->index);
+	if (w) {
+		int i;
+		color = st->owner;
 		if (color != 0x10)
 			w->caption_color = color;
+		w->vscroll.cap = 4;
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+	}
+}
+
+static void StationRatingDetailWndProc(Window *w, WindowEvent *e)
+{
+	// String IDs to display
+	static const uint16 rating_str[] = {
+		STR_STATION_RATING_DETAIL_WAITING,
+		STR_STATION_RATING_DETAIL_SPEED,
+		STR_STATION_RATING_DETAIL_AGE,
+		STR_STATION_RATING_DETAIL_PICKUP,
+		STR_STATION_RATING_DETAIL_OTHER,
+		STR_STATION_RATING_DETAIL_TOTAL
+	};
+	// More string IDs to display
+	static const uint16 rating_str_ex[] = {
+		STR_STATION_RATING_DETAIL_WAITING_EX,
+		STR_STATION_RATING_DETAIL_SPEED_EX,
+		STR_STATION_RATING_DETAIL_AGE_EX,
+		STR_STATION_RATING_DETAIL_PICKUP_EX,
+		STR_NULL,
+		STR_NULL
+	};
+	static const int rating_max_score[] = {40, 42, 33, 130, 26, 255};
+
+	switch(e->event) {
+	case WE_PAINT: {
+		int i, x, cur_x, val;
+		byte cargo;
+		uint16 y = 16;
+		int color_done, color_notdone;
+		int max_score;
+		Station *st = GetStation(w->window_number);
+		RatingStats *rs;
+
+		// Disable cargo types that don't have ratings and click first cargo
+		w->disabled_state = 0;
+		for (i=0; i!=NUM_CARGO; i++) {
+			if(st->goods[i].enroute_from == INVALID_STATION) {
+				SETBIT(w->disabled_state, i + 9);
+				CLRBIT(w->click_state, i + 9);
+			} else if(w->click_state == 0) {
+				SETBIT(w->click_state, i + 9);
+			}
+		}
+		if(w->click_state == 0)
+			SETBIT(w->disabled_state, 21);
+
+		// Draw standard stuff
+		SetDParam(0, st->index);
+		SetDParam(1, st->facilities);
+		DrawWindowWidgets(w);
+
+		// Paint the cargo icons
+		cur_x = 9;
+		for (i = 0; i != NUM_CARGO; i++) {
+			if(st->goods[i].enroute_from != INVALID_STATION)
+				DrawSprite(_cargoc.sprites[i], cur_x, y);
+			cur_x += 28;
+		}
+
+		// The colors used to show how the progress is going
+		color_done = _color_list[6].window_color_1b;
+		color_notdone = _color_list[4].window_color_1b;
+
+		// No cargo type selected
+		if(w->click_state == 0)
+			break;
+
+		// The type of cargo of which we check the detail service rating
+		cargo = FindFirstBit(w->click_state) - 9;
+		
+		if (cargo < NUM_CARGO) 
+			w->listopt.cargo_mask = 1 << GetGlobalCargoID(_opt_ptr->landscape, cargo);
+		else
+			w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = VEHICLE_TYPE_ALL;
+		w->listopt.xy = st->xy;
+
+		rs = &st->rating_stats[cargo];
+
+		y += 18;
+
+		for(i=0; i<NUM_RATINGS; i++) {
+			DrawString(7, y, rating_str[i], 0);
+
+			// Draw the raw values
+			switch(i) {
+				case RATING_WAITING:
+					SetDParam(1, rs->waiting);
+					SetDParam(0, _cargoc.names_long[cargo]);
+					break;
+				case RATING_SPEED:
+					SetDParam(0, rs->last_speed);
+					break;
+				case RATING_AGE:
+					SetDParam(0, rs->last_age);
+					break;
+				case RATING_PICKUP:
+					SetDParam(0, rs->days_since_pickup);
+					break;
+				default:
+					break;
+			}
+
+			if(rating_str_ex[i] != STR_NULL)
+				DrawStringRightAligned(205, y, rating_str_ex[i], 0);
+
+			// Calculate the %-bar
+			val = rs->ratings[i];
+
+			max_score = rating_max_score[i];
+			if (val > max_score) x = 50;
+			else if (val <= 0) x = 0;
+			else x = ((val * 50) / max_score);
+
+			// Draw the bar
+			if (x != 0)
+				GfxFillRect(210, y-2, x + 210, y+10, color_done);
+			if (x != 50)
+				GfxFillRect(x + 210, y-2, 50 + 210, y+10, color_notdone);
+
+			// Calculate the %
+			if (val > max_score) x = 100;
+			else x = ((val * 100) / max_score);
+
+			// Draw it
+			SetDParam(0, x);
+			DrawStringCentered(235, y, STR_STATION_RATING_DETAIL_PERCENT, 0);
+
+			// Draw the score and max_score
+			SetDParam(0, val);
+			SetDParam(1, max_score);
+			DrawString(265, y, STR_STATION_RATING_DETAIL_SCORES, 0);
+
+			y += 20;
+		}
+
+		break;
+	}
+
+	case WE_CLICK:
+		// Check which button is clicked
+		if (IS_INT_INSIDE(e->click.widget, 9, 21)) {
+			// Is it no on disable?
+			if ((w->disabled_state & (1 << e->click.widget)) == 0) {
+				Station *st = GetStation(w->window_number);
+				Window *w2 = FindWindowById(WC_VEHICLES_LIST, (st->index << 16) | st->owner);
+				vehiclelist_d *vl;
+				w->click_state = 1 << e->click.widget;
+				w->listopt.cargo_mask = 1 << GetGlobalCargoID(_opt_ptr->landscape, FindFirstBit(w->click_state) - 9);
+				SetWindowDirty(w);
+				if (w2) {
+					vl = &WP(w2, vehiclelist_d);
+					vl->flags |= VL_REBUILD;
+					w2->listopt.cargo_mask = w->listopt.cargo_mask;
+					SetWindowDirty(w2);
+				}
+			}
+		} else if (e->click.widget == 21) {
+			Station *st = GetStation(w->window_number);
+			ShowPlayerVehicles(st->owner, st->index, w->listopt.type_mask, w->listopt.cargo_mask, w->listopt.xy);
+			w->click_state = 1 << (GetLocalCargoID(FindFirstBit(w->listopt.cargo_mask)) + 9);
+			SetWindowDirty(w);
+		}
+		break;
+
+	case WE_CREATE:
+		{
+			w->hidden_state = 0;
+			w->disabled_state = 0;
+			w->click_state = 0;
+
+			SetWindowDirty(w);
+		}
+		break;
+	}
+}
+
+static const Widget _station_rating_detail_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   325,     0,    13, STR_STATION_RATING_DETAIL,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   326,   337,     0,    13, 0x0, STR_STICKY_BUTTON},
+
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    28,    47, 0x0,STR_STATION_RATING_DETAIL_WAITING_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    48,    67, 0x0,STR_STATION_RATING_DETAIL_SPEED_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    68,    87, 0x0,STR_STATION_RATING_DETAIL_AGE_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    88,   107, 0x0,STR_STATION_RATING_DETAIL_PICKUP_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,   108,   127, 0x0,STR_STATION_RATING_DETAIL_OTHER_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,   128,   147, 0x0,STR_STATION_RATING_DETAIL_TOTAL_TIP},
+
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     1,    28,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    29,    56,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    57,    84,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    85,   112,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   113,   140,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   141,   168,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   169,   196,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   197,   224,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   225,   252,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   253,   280,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   281,   308,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   309,   336,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   336,    148,   160, STR_VEHICLE_CARGO_LIST, 0x0},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _station_rating_detail_desc = {
+	-1, -1, 338, 161,
+	WC_STATION_RATING_DETAIL,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_rating_detail_widgets,
+	StationRatingDetailWndProc
+};
+
+void ShowStationRatingDetail(int station)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_station_rating_detail_desc, station);
+	if (w) {
+		color = GetStation(w->window_number)->owner;
+		if (color != 0x10)
+			w->caption_color = color;
 		w->vscroll.cap = 5;
 	}
 }
+
+static void PlayerVehiclesWndProc(Window *w, WindowEvent *e)
+{
+	int station = (int)w->window_number >> 16;
+	int owner = w->window_number & 0xff;
+	vehiclelist_d *vl = &WP(w, vehiclelist_d);
+
+	switch(e->event) {
+	case WE_PAINT: {
+		int x = 2;
+		int y = PLY_WND_PRC__OFFSET_TOP_WIDGET;
+		int max;
+		int i;
+
+		BuildVehicleListMasked(vl, &w->listopt, owner);
+		SortVehicleList(vl);
+
+		SetVScrollCount(w, vl->list_length);
+		// disable 'Sort By' tooltip on Unsorted sorting criteria
+		if (vl->sort_type == SORT_BY_UNSORTED)
+			w->disabled_state |= (1 << 3);
+
+		/* draw the widgets */
+		{
+			const Player *p = GetPlayer((owner != OWNER_NONE) ? owner : _current_player);
+			if (station == -1) {
+				/* Company Name -- (###) Trains */
+				SetDParam(0, p->name_1);
+				SetDParam(1, p->name_2);
+				SetDParam(2, w->vscroll.count);
+				w->widget[1].unkA = STR_VEHICLES;
+			} else {
+				/* Station Name -- (###) Trains */
+				SetDParam(0, station);
+				SetDParam(1, w->vscroll.count);
+				w->widget[1].unkA = STR_SCHEDULED;
+			}
+			DrawWindowWidgets(w);
+		}
+		/* draw sorting criteria string */
+		DrawString(85, 15, _vehicle_sort_listing[vl->sort_type], 0x10);
+		/* draw arrow pointing up/down for ascending/descending sorting */
+		DoDrawString(vl->flags & VL_DESC ? "\xAA" : "\xA0", 69, 15, 0x10);
+
+		max = min(w->vscroll.pos + w->vscroll.cap, vl->list_length);
+		for (i = w->vscroll.pos; i < max; ++i) {
+			Vehicle *v = GetVehicle(vl->sort_list[i].index);
+			StringID str;
+
+			assert(v->owner == owner || v->owner == _current_player);
+
+			switch (v->type) {
+				case VEH_Train:
+				{
+					DrawTrainImage(
+						v, x + 21, y + 6 + _traininfo_vehicle_pitch, w->hscroll.cap, 0, INVALID_VEHICLE);
+
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_RAIL) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_TRAIN_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 21, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Road:
+				{
+					DrawRoadVehImage(v, x + 22, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_ROAD) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_ROADVEH_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 24, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Aircraft:
+				{
+					DrawAircraftImage(v, x + 19, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsAircraftHangarTile(v->tile) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_AIRCRAFT_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 19, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Ship:
+				{
+					DrawShipImage(v, x + 19, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_WATER) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_SHIP_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 12, y, STR_01AB, 0);
+					}
+					break;
+				}
+				default:
+					continue;
+			}
+			DrawVehicleProfitButton(v, x, y + 13);
+			SetDParam(0, v->profit_this_year);
+			SetDParam(1, v->profit_last_year);
+			DrawString(x + 21, y + 18, STR_0198_PROFIT_THIS_YEAR_LAST_YEAR, 0);
+
+			y += PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		}
+		break;
+	}
+
+	case WE_CLICK: {
+		switch(e->click.widget) {
+		case 3: /* Flip sorting method ascending/descending */
+			vl->flags ^= VL_DESC;
+			vl->flags |= VL_RESORT;
+			_sorting.masked.order = !!(vl->flags & VL_DESC);
+			SetWindowDirty(w);
+			break;
+
+		case 4: case 5:/* Select sorting criteria dropdown menu */
+			ShowDropDownMenu(w, _vehicle_sort_listing, vl->sort_type, 5, 0, 0);
+			return;
+
+		case 7: { /* Matrix to show vehicles */
+			uint32 id_v = (e->click.pt.y - PLY_WND_PRC__OFFSET_TOP_WIDGET) / PLY_WND_PRC__SIZE_OF_ROW_BIG;
+
+			if (id_v >= w->vscroll.cap) { return;} // click out of bounds
+
+			id_v += w->vscroll.pos;
+			{
+				Vehicle *v;
+				if (id_v >= vl->list_length) return; // click out of list bound
+				v = GetVehicle(vl->sort_list[id_v].index);
+
+				assert(v->owner == owner);
+				
+				switch (v->type)
+				{
+				case VEH_Train:
+					ShowTrainViewWindow(v);
+					break;
+				case VEH_Ship:
+					ShowShipViewWindow(v);
+					break;
+				case VEH_Road:
+					ShowRoadVehViewWindow(v);
+					break;
+				case VEH_Aircraft:
+					ShowAircraftViewWindow(v);
+					break;
+				}
+			}
+		} break;
+		}
+	}	break;
+
+	case WE_DROPDOWN_SELECT: /* we have selected a dropdown item in the list */
+		if (vl->sort_type != e->dropdown.index) {
+			// value has changed -> resort
+			vl->flags |= VL_RESORT;
+			vl->sort_type = e->dropdown.index;
+			_sorting.masked.criteria = vl->sort_type;
+
+			// enable 'Sort By' if a sorter criteria is chosen
+			if (vl->sort_type != SORT_BY_UNSORTED)
+				CLRBIT(w->disabled_state, 3);
+		}
+		SetWindowDirty(w);
+		break;
+
+	case WE_CREATE: /* set up resort timer */
+		vl->sort_list = NULL;
+		vl->flags = VL_REBUILD | (_sorting.train.order << (VL_DESC - 1));
+		vl->sort_type = _sorting.masked.criteria;
+		vl->resort_timer = DAY_TICKS * PERIODIC_RESORT_DAYS;
+		break;
+
+	case WE_DESTROY:
+		free(vl->sort_list);
+		break;
+
+	case WE_TICK: /* resort the list every 20 seconds orso (10 days) */
+		if (--vl->resort_timer == 0) {
+			DEBUG(misc, 1) ("Periodic resort trains list player %d station %d",
+				owner, station);
+			vl->resort_timer = DAY_TICKS * PERIODIC_RESORT_DAYS;
+			vl->flags |= VL_RESORT;
+			SetWindowDirty(w);
+		}
+		break;
+
+	case WE_RESIZE:
+		/* Update the scroll + matrix */
+		w->hscroll.cap += e->sizing.diff.x / 29;
+		w->vscroll.cap += e->sizing.diff.y / PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		break;
+	}
+}
+
+static const Widget _player_vehicles_widgets[] = {
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,							STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,  RESIZE_RIGHT,    14,    11,   312,     0,    13, STR_VEHICLES,				STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,     RESIZE_LR,    14,   313,   324,     0,    13, 0x0,										STR_STICKY_BUTTON},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    80,    14,    25, SRT_SORT_BY,						STR_SORT_ORDER_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,    81,   232,    14,    25, 0x0,										STR_SORT_CRITERIA_TIP},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   233,   243,    14,    25, STR_0225,							STR_SORT_CRITERIA_TIP},
+{      WWT_PANEL,  RESIZE_RIGHT,    14,   244,   324,    14,    25, 0x0,										STR_NULL},
+{     WWT_MATRIX,     RESIZE_RB,    14,     0,   312,    26,   207, 0x701,									STR_883D_TRAINS_CLICK_ON_TRAIN_FOR},
+{  WWT_SCROLLBAR,    RESIZE_LRB,    14,   313,   324,    26,   207, 0x0,										STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_PANEL,    RESIZE_RTB,    14,     0,   312,   208,   219, 0x0,										STR_NULL},
+{  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   313,   324,   208,   219, 0x0,										STR_RESIZE_BUTTON},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _player_vehicles_desc = {
+	-1, -1, 325, 220,
+	WC_VEHICLES_LIST,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE,
+	_player_vehicles_widgets,
+	PlayerVehiclesWndProc
+};
+
+void ShowPlayerVehicles(int player, int station, uint32 type_mask, uint64 cargo_mask, TileIndex xy)
+{
+	Window *w;
+
+	w = AllocateWindowDescFront(&_player_vehicles_desc, (station << 16) | player);
+	if (w) {
+		w->listopt.cargo_mask = cargo_mask;
+		w->listopt.type_mask = type_mask;
+		w->listopt.xy = xy;
+
+		w->caption_color = (player != OWNER_NONE) ? player : _current_player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 5; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_BIG * 3); /* Minimum of 4 vehicles */
+	} else {
+		w = FindWindowById(WC_VEHICLES_LIST, (station << 16) | player);
+		if (w) {
+			vehiclelist_d *vl;
+			vl = &WP(w, vehiclelist_d);
+			vl->flags |= VL_REBUILD;
+			w->listopt.cargo_mask = cargo_mask;
+			w->listopt.type_mask = type_mask;
+			w->listopt.xy = xy;
+			SetWindowDirty(w);
+		}
+	}
+}
Index: aircraft_gui.c
===================================================================
--- aircraft_gui.c	(revision 2720)
+++ aircraft_gui.c	(working copy)
@@ -61,7 +61,7 @@
 	y += 10;
 }
 
-static void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetAircraftImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -89,7 +89,16 @@
 	}
 }
 
+void CcCloneAircraft(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
 
+	if (success) {
+		v = GetVehicle(_new_aircraft_id);
+		ShowAircraftViewWindow(v);
+	}
+}
+
 static void NewAircraftWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -496,11 +505,14 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  50,  67, 0x2B4,    STR_A03B_REFIT_AIRCRAFT_TO_CARRY },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B2,    STR_A028_SHOW_AIRCRAFT_S_ORDERS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B3,    STR_A02B_SHOW_AIRCRAFT_DETAILS },
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_CLONE_AIRCRAFT_INFO },
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 104, 103, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 104, 115, 0x0,      STR_NULL },
 { WIDGETS_END }
 };
 
+bool CheckStoppedInHangar(Vehicle *v);
+
 static void AircraftViewWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -587,6 +599,12 @@
 		case 10: /* show details */
 			ShowAircraftDetailsWindow(v);
 			break;
+		case 11: {
+			/* clone vehicle */
+			Vehicle *v;
+			v = GetVehicle(w->window_number);
+			DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, CcCloneAircraft, CMD_CLONE_VEHICLE | CMD_MSG(STR_A008_CAN_T_BUILD_AIRCRAFT));
+		} break;
 		}
 	} break;
 
@@ -602,6 +620,19 @@
 		DeleteWindowById(WC_VEHICLE_REFIT, w->window_number);
 		DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
 		break;
+		
+		       case WE_MOUSELOOP:
+               {
+                       Vehicle *v;
+                       uint32 h;
+                       v = GetVehicle(w->window_number);
+                       h = CheckStoppedInHangar(v) ? (1<< 7) : (1 << 11);
+                       if (h != w->hidden_state) {
+                               w->hidden_state = h;
+                               SetWindowDirty(w);
+                       }
+               } break;
+
 	}
 }
 
@@ -636,7 +667,7 @@
 
 	/* setup disabled buttons */
 	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7));
+		IsTileOwner(tile, _local_player) ? 0 : ((1<<4) | (1<<7) | (1<<8));
 
 	/* determine amount of items for scroller */
 	num = 0;
@@ -741,6 +772,42 @@
 	}
 }
 
+/**
+ * Clones an aircraft
+ * @param *v is the original vehicle to clone
+ * @param *w is the window of the hangar where the clone is build
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	if (v->type != VEH_Aircraft) {
+		// it's not an aircraft, do nothing
+		return false;
+	}
+
+
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneAircraft,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
+
 static void AircraftDepotWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -754,14 +821,48 @@
 			AircraftDepotClickAircraft(w, e->click.pt.x, e->click.pt.y);
 			break;
 		case 7: /* show build aircraft window */
+			ResetObjectToPlace();
 			ShowBuildAircraftWindow(w->window_number);
 			break;
-		case 8: /* scroll to tile */
+			
+				case 8: /* clone button */
+			InvalidateWidget(w, 8);
+				TOGGLEBIT(w->click_state, 8);
+				
+				if (HASBIT(w->click_state, 8)) {
+					_place_clicked_vehicle = NULL;
+					SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, VHM_RECT, w);
+				} else {
+					ResetObjectToPlace();
+				}
+					break;
+		case 9: /* scroll to tile */
+			ResetObjectToPlace();
 			ScrollMainWindowToTile(w->window_number);
 			break;
 		}
 		break;
 
+
+case WE_PLACE_OBJ: {
+		ClonePlaceObj(e->place.tile, w);
+	} break;
+
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 8);
+		InvalidateWidget(w, 8);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+		// since OTTD checks all open depot windows, we will make sure that it triggers the one with a clicked clone button
+		if (v != NULL && HASBIT(w->click_state, 8)) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick( v, w);
+		}
+	} break;
+	
 	case WE_DESTROY:
 		DeleteWindowById(WC_BUILD_VEHICLE, w->window_number);
 		break;
@@ -824,8 +925,9 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   295,    14,    61, 0x204,										STR_A021_AIRCRAFT_CLICK_ON_AIRCRAFT},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   319,   330,    14,    61, 0x0,											STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   159,    62,    73, STR_A003_NEW_AIRCRAFT,		STR_A022_BUILD_NEW_AIRCRAFT},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   160,   318,    62,    73, STR_00E4_LOCATION,				STR_A024_CENTER_MAIN_VIEW_ON_HANGAR},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   105,    62,    73, STR_A003_NEW_AIRCRAFT,		STR_A022_BUILD_NEW_AIRCRAFT},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,   106,   212,    62,    73, STR_CLONE_AIRCRAFT,		STR_CLONE_AIRCRAFT_INFO_HANGAR_WINDOW},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   213,   318,    62,    73, STR_00E4_LOCATION,				STR_A024_CENTER_MAIN_VIEW_ON_HANGAR},
 {      WWT_PANEL,    RESIZE_RTB,    14,   319,   318,    62,    73, 0x0,													STR_NULL},
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   319,   330,    62,    73, 0x0,											STR_RESIZE_BUTTON},
 {   WIDGETS_END},
@@ -927,7 +1029,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Aircraft, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1123,6 +1225,13 @@
 	}
 
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Aircraft;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = w->window_number;
 		w->vscroll.cap = 4;
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 2720)
+++ train_cmd.c	(working copy)
@@ -41,6 +41,7 @@
 void TrainCargoChanged(Vehicle *v) {
 	Vehicle *u;
 	uint16 weight = 0;
+	uint32 max_TE = 0;
 
 	for (u = v; u != NULL; u = u->next) {
 		const RailVehicleInfo *rvi = RailVehInfo(u->engine_type);
@@ -56,12 +57,16 @@
 		// consist weight is the sum of the weight of all vehicles in the consist
 		weight += vweight;
 
+		if (rvi->power != 0 || HASBIT(u->u.rail.flags, VRF_POWEREDWAGON))
+			max_TE += vweight * 10 * 1000 * rvi->TE_coeff / 256; // TE_max in [N]
+
 		// store vehicle weight in cache
 		u->u.rail.cached_veh_weight = vweight;
 	};
 
 	// store consist weight in cache
 	v->u.rail.cached_weight = weight;
+	v->u.rail.cached_max_TE = max_TE;
 }
 
 /**
@@ -114,7 +119,7 @@
 
 		// max speed is the minimum of the speed limits of all vehicles in the consist
 		if (rvi_u->max_speed != 0)
-			max_speed = min(rvi_u->max_speed, max_speed);
+			max_speed = min(TrainVehSpeed(u), max_speed);
 
 		// check the vehicle length (callback)
 		veh_len = CALLBACK_FAILED;
@@ -282,9 +287,9 @@
 			max_speed = min(61, max_speed);
 
 		if (HASBIT(u->u.rail.flags, VRF_GOINGUP)) {
-			incl += u->u.rail.cached_veh_weight * 60;		//3% slope, quite a bit actually
+			incl += u->u.rail.cached_veh_weight * 120;		//3% slope, quite a bit actually
 		} else if (HASBIT(u->u.rail.flags, VRF_GOINGDOWN)) {
-			incl -= u->u.rail.cached_veh_weight * 60;
+			incl -= u->u.rail.cached_veh_weight * 120;
 		}
 	}
 
@@ -320,12 +325,14 @@
 
 	if (force <= 0) force = 10000;
 
-	if (v->u.rail.railtype != 2) force = min(force, mass * 10 * 200);
+	if (v->u.rail.railtype != 2) force = min(force, v->u.rail.cached_max_TE);
 
+	v->cargo_cap = force / 1000;
+
 	if (mode == AM_ACCEL) {
 		return (force - resistance) / (mass * 4);
 	} else {
-		return min((-force - resistance) / (mass * 4), 10000 / (mass * 4));
+		return min(-force - resistance, -10000) / (mass * 4);
 	}
 }
 
@@ -568,7 +575,7 @@
 /** Build a railroad vehicle.
  * @param x,y tile coordinates (depot) where rail-vehicle is built
  * @param p1 engine type id
- * @param p2 unused
+ * @param p2 build only one engine, even if it is a dualheaded engine. It also prevents any free cars from being added to the train
  */
 int32 CmdBuildRailVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2)
 {
@@ -594,10 +601,19 @@
 	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 
 	rvi = RailVehInfo(p1);
+	e = GetEngine(p1);
 
+	/* Check if depot and new engine uses the same kind of tracks */
+	if (!IsCompatibleRail(e->railtype, GetRailType(tile))) return CMD_ERROR;
+
 	if (rvi->flags & RVI_WAGON) return CmdBuildRailWagon(p1, tile, flags);
 
 	value = EstimateTrainCost(rvi);
+		
+	//make sure we only pay for half a dualheaded engine if we only requested half of it
+	if (rvi->flags&RVI_MULTIHEAD && HASBIT(p2,0))
+		value /= 2;
+	
 
 	if (!(flags & DC_QUERY_COST)) {
 		v = AllocateVehicle();
@@ -633,7 +649,6 @@
 			v->dest_tile = 0;
 
 			v->engine_type = (byte)p1;
-			e = GetEngine(p1);
 
 			v->reliability = e->reliability;
 			v->reliability_spd_dec = e->reliability_spd_dec;
@@ -651,13 +666,60 @@
 
 			VehiclePositionChanged(v);
 
-			if (rvi->flags&RVI_MULTIHEAD && (u = AllocateVehicle()) != NULL)
-				AddRearEngineToMultiheadedTrain(v, u, true);
+			if (rvi->flags&RVI_MULTIHEAD && (u = AllocateVehicle()) != NULL && !HASBIT(p2,0)) {
+					AddRearEngineToMultiheadedTrain(v, u, true);
+			}
 
+			if (HASBIT(rvi->callbackmask, CBM_ARTIC_ENGINE)) {
+				Vehicle* w = v;
+				int i;
+				uint val = 0;
+				for(i = 1;val != 0xFF; i++) {
+					val = GetCallBackResult(CBID_ARTIC_ENGINE + (i << 8), v->engine_type, NULL) ;
+					if (val != 0xFF && (u = AllocateVehicle()) != NULL) {
+						RailVehicleInfo* rvi2;
+						if (val&0x80)
+							u->spritenum = 1;
+						else
+							u->spritenum = 0;
+						val &= ~0x80;
+						rvi2 = RailVehInfo(val);
+						u->direction = v->direction;
+						u->owner = v->owner;
+						u->tile = v->tile;
+						u->x_pos = v->x_pos;
+						u->y_pos = v->y_pos;
+						u->z_pos = v->z_pos;
+						u->z_height = 6;
+						u->u.rail.track = 0x80;
+						u->u.rail.first_engine = p1;
+						u->vehstatus = v->vehstatus & ~VS_STOPPED;
+						u->spritenum += rvi2->image_index;
+						u->cargo_type = rvi2->cargo_type;
+						u->cargo_cap = rvi2->capacity;
+						u->max_speed = rvi2->max_speed;
+						u->value = value;
+						u->u.rail.railtype = v->u.rail.railtype;
+						w->next = u;
+						u->engine_type = val;
+						u->build_year = v->build_year;
+						u->value = v->value;
+						u->type = VEH_Train;
+						u->subtype = TS_Artic_Part;
+						u->cur_image = 0xAC2;
+						VehiclePositionChanged(u);
+						w = u;
+					};
+				};
+			};
+
 			TrainConsistChanged(v);
 			UpdateTrainAcceleration(v);
-			NormalizeTrainVehInDepot(v);
 
+			if (!HASBIT(p2,0)) {	// do not move the cars if HASBIT(p2,0) is set
+				NormalizeTrainVehInDepot(v);
+			}
+
 			InvalidateWindow(WC_VEHICLE_DEPOT, tile);
 			RebuildVehicleLists();
 			InvalidateWindow(WC_COMPANY, v->owner);
@@ -703,11 +765,14 @@
 // returns the new value of first
 static Vehicle *UnlinkWagon(Vehicle *v, Vehicle *first)
 {
-	Vehicle *u;
+	Vehicle *u, *w;
 
 	// unlinking the first vehicle of the chain?
 	if (v == first) {
-		v = v->next;
+		for (u = v; u->next != NULL && u->next->subtype == TS_Artic_Part; u = u->next) {};
+
+		v = u->next;
+		u->next = NULL;
 		if (v == NULL) return NULL;
 
 		v->subtype = TS_Free_Car;
@@ -715,7 +780,13 @@
 	}
 
 	for (u = first; u->next != v; u = u->next) {}
-	u->next = v->next;
+
+	for (w = v; w->next != NULL && w->next->subtype == TS_Artic_Part; w = w->next) {};
+
+	u->next = w->next;
+	w->next = NULL;
+//	u->next = v->next;
+
 	return first;
 }
 
@@ -759,6 +830,10 @@
 
 	if (src->type != VEH_Train) return CMD_ERROR;
 
+	while (src->subtype == TS_Artic_Part) {
+		src = GetPrevVehicleInChain(src);
+	}
+
 	is_loco = !(RailVehInfo(src->engine_type)->flags & RVI_WAGON) && IS_FIRSTHEAD_SPRITE(src->spritenum);
 
 	// if nothing is selected as destination, try and find a matching vehicle to drag to.
@@ -769,9 +844,6 @@
 		dst = GetVehicle((int32)p1 >> 16);
 	}
 
-	// don't move the same vehicle..
-	if (src == dst) return 0;
-
 	/* the player must be the owner */
 	if (!CheckOwnership(src->owner) || (dst!=NULL && !CheckOwnership(dst->owner)))
 		return CMD_ERROR;
@@ -780,7 +852,21 @@
 	src_head = GetFirstVehicleInChain(src);
 	dst_head = NULL;
 	if (dst != NULL) dst_head = GetFirstVehicleInChain(dst);
+	if (dst != NULL) {
+		while (dst->next != NULL && dst->next->subtype == TS_Artic_Part)
+			dst = dst->next;
+//			return CMD_ERROR;
+	}
 
+	// don't move the same vehicle..
+	{
+		Vehicle *tmp = src;
+		while (tmp->next != NULL && tmp->next->subtype == TS_Artic_Part)
+			tmp = tmp ->next;
+		if (tmp == dst) return 0;
+	}
+
+
 	/* clear the ->first cache */
 	{
 		Vehicle *u;
@@ -802,7 +888,7 @@
 			return_cmd_error(STR_8819_TRAIN_TOO_LONG);
 
 		// if it's a multiheaded vehicle we're dragging to, drag to the vehicle before..
-		while (IS_CUSTOM_SECONDHEAD_SPRITE(dst->spritenum) || (
+		while ((RailVehInfo(dst->engine_type)->flags&RVI_MULTIHEAD && IS_CUSTOM_SECONDHEAD_SPRITE(dst->spritenum)) || (
 			!is_custom_sprite(dst->spritenum) && _engine_sprite_add[dst->spritenum] != 0)
 		) {
 			Vehicle *v = GetPrevVehicleInChain(dst);
@@ -844,7 +930,6 @@
 				dst_head = NULL;
 			// unlink single wagon from linked list
 			src_head = UnlinkWagon(src, src_head);
-			src->next = NULL;
 		}
 
 		if (dst == NULL) {
@@ -978,6 +1063,12 @@
 
 	if (v->type != VEH_Train || !CheckOwnership(v->owner)) return CMD_ERROR;
 
+	while (v->subtype == TS_Artic_Part) {
+		v = GetPrevVehicleInChain(v);
+	}
+//		return CMD_ERROR;
+
+
 	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 
 	first = GetFirstVehicleInChain(v);
@@ -1006,7 +1097,11 @@
 				cost -= v->value;
 				if (flags & DC_EXEC) {
 					v = UnlinkWagon(rear, v);
-					DeleteVehicle(rear);
+					while (rear != NULL) {
+						tmp = rear->next;
+						DeleteVehicle(rear);
+						rear = tmp;
+					}
 				}
 			}
 
@@ -1040,8 +1135,13 @@
 			cost -= v->value;
 			if (flags & DC_EXEC) {
 				first = UnlinkWagon(v, first);
-				DeleteVehicle(v);
 
+				while (v != NULL) {
+					tmp = v->next;
+					DeleteVehicle(v);
+					v = tmp;
+				}
+
 				/* 4 If the second wagon was an engine, update it to front_engine
 					* which UnlinkWagon() has changed to TS_Free_Car */
 				if (switch_engine) first->subtype = TS_Front_Engine;
@@ -1084,6 +1184,8 @@
 			* earlier in the chain (before deletion), leave it alone */
 			for (; v != NULL; v = tmp) {
 				tmp = v->next;
+				while (tmp != NULL && tmp->subtype == TS_Artic_Part)
+					tmp = tmp->next;
 
 				if (RailVehInfo(v->engine_type)->flags & RVI_MULTIHEAD) {
 					/* Always delete newly encountered front-engines */
@@ -1097,9 +1199,15 @@
 				}
 
 				cost -= v->value;
+
 				if (flags & DC_EXEC) {
 					first = UnlinkWagon(v, first);
-					DeleteVehicle(v);
+					while (v != NULL) {
+						Vehicle* tmp2 = v->next;
+						DeleteVehicle(v);
+						v = tmp2;
+					}
+
 				}
 			}
 
@@ -1472,10 +1580,7 @@
 /** Refits a train to the specified cargo type.
  * @param x,y unused
  * @param p1 vehicle ID of the train to refit
- * @param p2 various bitstuffed elements
- * - p2 = (bit 0-7) - the new cargo type to refit to (p2 & 0xFF)
- * - p2 = (bit 8)   - skip check for stopped in depot, used by autoreplace (p2 & 0x100)
- * @todo p2 bit8 check <b>NEEDS TO GO</b>
+ * @param p2 the new cargo type to refit to (p2 & 0xFF)
  */
 int32 CmdRefitRailVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2)
 {
@@ -1483,14 +1588,13 @@
 	int32 cost;
 	uint num;
 	CargoID new_cid = p2 & 0xFF; //gets the cargo number
-	bool SkipStoppedInDepotCheck = !!HASBIT(p2, 8); // XXX - needs to go, yes?
 
 	if (!IsVehicleIndex(p1)) return CMD_ERROR;
 
 	v = GetVehicle(p1);
 
 	if (v->type != VEH_Train || !CheckOwnership(v->owner)) return CMD_ERROR;
-	if (!SkipStoppedInDepotCheck && CheckTrainStoppedInDepot(v) < 0) return_cmd_error(STR_TRAIN_MUST_BE_STOPPED);
+	if (CheckTrainStoppedInDepot(v) < 0) return_cmd_error(STR_TRAIN_MUST_BE_STOPPED);
 
 	/* Check cargo */
 	if (new_cid > NUM_CARGO) return CMD_ERROR;
@@ -1537,10 +1641,7 @@
 					cost += (_price.build_railvehicle >> 8);
 				num += amount;
 				if (flags & DC_EXEC) {
-					//autorefitted train cars wants to keep the cargo
-					//it will be checked if the cargo is valid in CmdReplaceVehicle
-					if (!(SkipStoppedInDepotCheck))
-						v->cargo_count = 0;
+					v->cargo_count = 0;
 					v->cargo_type = new_cid;
 					v->cargo_cap = amount;
 					InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
@@ -1548,8 +1649,7 @@
 				}
 			}
 		}
-	// SkipStoppedInDepotCheck is called by CmdReplace and it should only apply to the single car it is called for
-	} while ( (v=v->next) != NULL || SkipStoppedInDepotCheck );
+	} while ( (v=v->next) != NULL );
 
 	_returned_refit_amount = num;
 
@@ -2333,6 +2433,9 @@
 			v->index,
 			0);
 	}
+	if (v->subtype == TS_Front_Engine) st->vehicles[STS_VEH_TRAIN].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
 
 	// Did we reach the final destination?
 	if (v->current_order.type == OT_GOTO_STATION &&
@@ -2821,8 +2924,20 @@
 					assert(v->u.rail.track);
 				}
 
-				if (v->subtype == TS_Front_Engine)
-				TrainMovedChangeSignals(gp.new_tile, enterdir);
+				if (v->subtype == TS_Front_Engine) {
+					TrainMovedChangeSignals(gp.new_tile, enterdir);
+					if (v->current_order.type == OT_GOTO_WAYPOINT && v->tile == v->dest_tile) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[WPS_ORDER_MONTH].this_month++;
+						wp->vehicles[WPS_ORDER_YEAR].this_month++;
+					} else if (IsRailWaypoint(_m[v->tile].m5)) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[WPS_PATHFIND_MONTH].this_month++;
+						wp->vehicles[WPS_PATHFIND_YEAR].this_month++;
+					}
+				}	
 
 				/* Signals can only change when the first
 				 * (above) or the last vehicle moves. */
Index: table/sprites.h
===================================================================
--- table/sprites.h	(revision 2720)
+++ table/sprites.h	(working copy)
@@ -66,6 +66,7 @@
 
 
 	/* Network GUI sprites */
+	SPR_SEMA = SPR_OPENTTD_BASE + 24,				// semaphore icon
 	SPR_SQUARE = SPR_OPENTTD_BASE + 23,     // colored square (used for newgrf compatibility)
 	SPR_LOCK = SPR_OPENTTD_BASE + 22,       // lock icon (for password protected servers)
 	SPR_FLAGS_BASE = SPR_OPENTTD_BASE + 90, // start of the flags block (in same order as enum NetworkLanguage)
Index: table/engines.h
===================================================================
--- table/engines.h	(revision 2720)
+++ table/engines.h	(working copy)
@@ -285,127 +285,127 @@
 };
 
 RailVehicleInfo _rail_vehicle_info[NUM_TRAIN_ENGINES] = {
-	// image_index  max_speed (kph)      running_cost_base                 callbackmask    shortened factor
-	// |  flags     |        power (hp)  |    running_cost_class           |   powered wagons power
-	// |  |    base_cost     |    weight      |    capacity                |   |   powered wagons weight
-	// |  |    |    |        |    |      |    |    |    cargo_type         |   |   |   visual effects
-	// |  |    |    |        |    |      |    |    |    |                  |   |   |   |   |
-	{  2, 0,   7,  64,     300,  47,    50,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   0 */
-	{ 19, 0,   8,  80,     600,  65,    65,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   1 */
-	{  2, 0,  10,  72,     400,  85,    90,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   2 */
-	{  0, 0,  15,  96,     900, 130,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   3 */
-	{  1, 0,  19, 112,    1000, 140,   145,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   4 */
-	{ 12, 0,  16, 120,    1400,  95,   125,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   5 */
-	{ 14, 0,  20, 152,    2000, 120,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   6 */
-	{  3, 0,  14,  88,    1100, 145,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   7 */
-	{  0, 0,  13, 112,    1000, 131,   120,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   8 */
-	{  1, 0,  19, 128,    1200, 162,   140,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   9 */
-	{  0, 0,  22, 144,    1600, 170,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*  10 */
-	{  8, 1,  11, 112,   600/2,32/2,  85/2,   1,  38,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  11 */
-	{ 10, 1,  14, 120,   700/2,38/2,  70/2,   1,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  12 */
-	{  4, 0,  15, 128,    1250,  72,    95,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  13 */
-	{  5, 0,  17, 144,    1750, 101,   120,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  14 */
-	{  4, 0,  18, 160,    2580, 112,   140,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  15 */
-	{ 14, 0,  23,  96,    4000, 150,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  16 */
-	{ 12, 0,  16, 112,    2400, 120,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  17 */
-	{ 13, 0,  30, 112,    6600, 207,   155,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  18 */
-	{ 15, 0,  18, 104,    1500, 110,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  19 */
-	{ 16, 1,  35, 160,  3500/2,95/2, 205/2,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  20 */
-	{ 18, 0,  21, 104,    2200, 120,   145,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  21 */
-	{  6, 1,  20, 200,  4500/2,70/2, 190/2,   1,   4,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  22 */
-	{ 20, 0,  26, 160,    3600,  84,   180,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  23 */
-	{ 20, 0,  30, 176,    5000,  82,   205,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  24 */
-	{ 21, 1,  40, 240,  7000/2,90/2, 240/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  25 */
-	{ 23, 1,  43, 264,  8000/2,95/2, 250/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  26 */
-	{ 33, 2, 247,   0,       0,  25,     0,   0,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  27 */
-	{ 35, 2, 228,   0,       0,  21,     0,   0,  30,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  28 */
-	{ 34, 2, 176,   0,       0,  18,     0,   0,  30,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  29 */
-	{ 36, 2, 200,   0,       0,  24,     0,   0,  30,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  30 */
-	{ 37, 2, 192,   0,       0,  20,     0,   0,  25,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  31 */
-	{ 38, 2, 190,   0,       0,  21,     0,   0,  25,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  32 */
-	{ 39, 2, 182,   0,       0,  19,     0,   0,  30,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  33 */
-	{ 40, 2, 181,   0,       0,  16,     0,   0,  30,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  34 */
-	{ 41, 2, 179,   0,       0,  19,     0,   0,  30,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  35 */
-	{ 42, 2, 196,   0,       0,  18,     0,   0,  20,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  36 */
-	{ 43, 2, 255,   0,       0,  30,     0,   0,  20,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  37 */
-	{ 44, 2, 191,   0,       0,  22,     0,   0,  25,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  38 */
-	{ 45, 2, 196,   0,       0,  18,     0,   0,  20,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  39 */
-	{ 46, 2, 179,   0,       0,  19,     0,   0,  30,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  40 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  25,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  41 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  25,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  42 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  21,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  43 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  30,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  44 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  30,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  45 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  30,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  46 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  20,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  47 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  25,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  48 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  25,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  49 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  20,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  50 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  22,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  51 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  25,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  52 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  30,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  53 */
-	{ 25, 0,  52, 304,    9000,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  54 */
-	{ 26, 1,  60, 336, 10000/2,85/2, 240/2,   2,  25,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  55 */
-	{ 26, 0,  53, 320,    5000,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  56 */
-	{ 60, 2, 247,   0,       0,  25,     0,   0,  45,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  57 */
-	{ 62, 2, 228,   0,       0,  21,     0,   0,  35,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  58 */
-	{ 61, 2, 176,   0,       0,  18,     0,   0,  35,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  59 */
-	{ 63, 2, 200,   0,       0,  24,     0,   0,  35,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  60 */
-	{ 64, 2, 192,   0,       0,  20,     0,   0,  30,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  61 */
-	{ 65, 2, 190,   0,       0,  21,     0,   0,  30,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  62 */
-	{ 66, 2, 182,   0,       0,  19,     0,   0,  35,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  63 */
-	{ 67, 2, 181,   0,       0,  16,     0,   0,  35,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  64 */
-	{ 68, 2, 179,   0,       0,  19,     0,   0,  35,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  65 */
-	{ 69, 2, 196,   0,       0,  18,     0,   0,  25,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  66 */
-	{ 70, 2, 255,   0,       0,  30,     0,   0,  25,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  67 */
-	{ 71, 2, 191,   0,       0,  22,     0,   0,  30,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  68 */
-	{ 72, 2, 196,   0,       0,  18,     0,   0,  25,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  69 */
-	{ 73, 2, 179,   0,       0,  19,     0,   0,  35,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  70 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  30,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  71 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  30,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  72 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  26,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  73 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  35,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  74 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  35,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  75 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  35,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  76 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  25,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  77 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  30,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  78 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  30,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  79 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  25,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  80 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  27,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  81 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  30,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  82 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  35,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  83 */
-	{ 28, 0,  70, 400,   10000, 105,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  84 */
-	{ 29, 0,  74, 448,   12000, 120,   253,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  85 */
-	{ 30, 0,  82, 480,   15000, 130,   254,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  86 */
-	{ 31, 1,  95, 640, 20000/2,150/2,255/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  87 */
-	{ 28, 0,  70, 480,   10000, 120,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  88 */
-	{ 60, 2, 247,   0,       0,  25,     0,   0,  47,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  89 */
-	{ 62, 2, 228,   0,       0,  21,     0,   0,  37,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  90 */
-	{ 61, 2, 176,   0,       0,  18,     0,   0,  37,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  91 */
-	{ 63, 2, 200,   0,       0,  24,     0,   0,  37,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  92 */
-	{ 64, 2, 192,   0,       0,  20,     0,   0,  32,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  93 */
-	{ 65, 2, 190,   0,       0,  21,     0,   0,  32,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  94 */
-	{ 66, 2, 182,   0,       0,  19,     0,   0,  37,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  95 */
-	{ 67, 2, 181,   0,       0,  16,     0,   0,  37,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  96 */
-	{ 68, 2, 179,   0,       0,  19,     0,   0,  37,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  97 */
-	{ 69, 2, 196,   0,       0,  18,     0,   0,  27,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  98 */
-	{ 70, 2, 255,   0,       0,  30,     0,   0,  27,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  99 */
-	{ 71, 2, 191,   0,       0,  22,     0,   0,  32,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /* 100 */
-	{ 72, 2, 196,   0,       0,  18,     0,   0,  27,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /* 101 */
-	{ 73, 2, 179,   0,       0,  19,     0,   0,  37,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /* 102 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  32,   CT_WATER        ,  0,  0,  0,  0,  0 }, /* 103 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  32,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /* 104 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  28,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /* 105 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  37,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /* 106 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  37,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /* 107 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  37,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /* 108 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  27,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /* 109 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  32,   CT_COLA         ,  0,  0,  0,  0,  0 }, /* 110 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  32,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /* 111 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  27,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /* 112 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  29,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /* 113 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  32,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /* 114 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  37,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /* 115 */
+	// image_index  max_speed (kph)           running_cost_base                 callbackmask    shortened factor
+	// |  flags     |        power (hp)       |    running_cost_class           |   powered wagons power
+	// |  |    base_cost     |    max-TE-coeff|    |    capacity                |   |   powered wagons weight
+	// |  |    |    |        |    |    weight |    |    |    cargo_type         |   |   |   visual effects
+	// |  |    |    |        |    |    |      |    |    |    |                  |   |   |   |   |
+	{  2, 0,   7,  64,     300,  76,  47,    50,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   0 */
+	{ 19, 0,   8,  80,     600,  76,  65,    65,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   1 */
+	{  2, 0,  10,  72,     400,  76,  85,    90,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   2 */
+	{  0, 0,  15,  96,     900,  76, 130,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   3 */
+	{  1, 0,  19, 112,    1000,  76, 140,   145,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   4 */
+	{ 12, 0,  16, 120,    1400,  76,  95,   125,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   5 */
+	{ 14, 0,  20, 152,    2000,  76, 120,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   6 */
+	{  3, 0,  14,  88,    1100,  76, 145,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   7 */
+	{  0, 0,  13, 112,    1000,  76, 131,   120,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   8 */
+	{  1, 0,  19, 128,    1200,  76, 162,   140,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   9 */
+	{  0, 0,  22, 144,    1600,  76, 170,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*  10 */
+	{  8, 1,  11, 112,   600/2,  76,32/2,  85/2,   1,  38,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  11 */
+	{ 10, 1,  14, 120,   700/2,  76,38/2,  70/2,   1,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  12 */
+	{  4, 0,  15, 128,    1250,  76,  72,    95,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  13 */
+	{  5, 0,  17, 144,    1750,  76, 101,   120,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  14 */
+	{  4, 0,  18, 160,    2580,  76, 112,   140,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  15 */
+	{ 14, 0,  23,  96,    4000,  76, 150,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  16 */
+	{ 12, 0,  16, 112,    2400,  76, 120,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  17 */
+	{ 13, 0,  30, 112,    6600,  76, 207,   155,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  18 */
+	{ 15, 0,  18, 104,    1500,  76, 110,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  19 */
+	{ 16, 1,  35, 160,  3500/2,  76,95/2, 205/2,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  20 */
+	{ 18, 0,  21, 104,    2200,  76, 120,   145,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  21 */
+	{  6, 1,  20, 200,  4500/2,  76,70/2, 190/2,   1,   4,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  22 */
+	{ 20, 0,  26, 160,    3600,  76,  84,   180,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  23 */
+	{ 20, 0,  30, 176,    5000,  76,  82,   205,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  24 */
+	{ 21, 1,  40, 240,  7000/2,  76,90/2, 240/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  25 */
+	{ 23, 1,  43, 264,  8000/2,  76,95/2, 250/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  26 */
+	{ 33, 2, 247,   0,       0,  76,  25,     0,   0,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  27 */
+	{ 35, 2, 228,   0,       0,  76,  21,     0,   0,  30,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  28 */
+	{ 34, 2, 176,   0,       0,  76,  18,     0,   0,  30,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  29 */
+	{ 36, 2, 200,   0,       0,  76,  24,     0,   0,  30,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  30 */
+	{ 37, 2, 192,   0,       0,  76,  20,     0,   0,  25,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  31 */
+	{ 38, 2, 190,   0,       0,  76,  21,     0,   0,  25,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  32 */
+	{ 39, 2, 182,   0,       0,  76,  19,     0,   0,  30,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  33 */
+	{ 40, 2, 181,   0,       0,  76,  16,     0,   0,  30,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  34 */
+	{ 41, 2, 179,   0,       0,  76,  19,     0,   0,  30,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  35 */
+	{ 42, 2, 196,   0,       0,  76,  18,     0,   0,  20,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  36 */
+	{ 43, 2, 255,   0,       0,  76,  30,     0,   0,  20,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  37 */
+	{ 44, 2, 191,   0,       0,  76,  22,     0,   0,  25,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  38 */
+	{ 45, 2, 196,   0,       0,  76,  18,     0,   0,  20,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  39 */
+	{ 46, 2, 179,   0,       0,  76,  19,     0,   0,  30,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  40 */
+	{ 47, 2, 199,   0,       0,  76,  25,     0,   0,  25,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  41 */
+	{ 48, 2, 182,   0,       0,  76,  18,     0,   0,  25,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  42 */
+	{ 49, 2, 185,   0,       0,  76,  19,     0,   0,  21,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  43 */
+	{ 50, 2, 176,   0,       0,  76,  19,     0,   0,  30,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  44 */
+	{ 51, 2, 178,   0,       0,  76,  20,     0,   0,  30,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  45 */
+	{ 52, 2, 192,   0,       0,  76,  20,     0,   0,  30,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  46 */
+	{ 53, 2, 190,   0,       0,  76,  21,     0,   0,  20,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  47 */
+	{ 54, 2, 182,   0,       0,  76,  24,     0,   0,  25,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  48 */
+	{ 55, 2, 181,   0,       0,  76,  21,     0,   0,  25,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  49 */
+	{ 56, 2, 183,   0,       0,  76,  21,     0,   0,  20,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  50 */
+	{ 57, 2, 196,   0,       0,  76,  18,     0,   0,  22,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  51 */
+	{ 58, 2, 193,   0,       0,  76,  18,     0,   0,  25,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  52 */
+	{ 59, 2, 191,   0,       0,  76,  18,     0,   0,  30,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  53 */
+	{ 25, 0,  52, 304,    9000,  76,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  54 */
+	{ 26, 1,  60, 336, 10000/2,  76,85/2, 240/2,   2,  25,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  55 */
+	{ 26, 0,  53, 320,    5000,  76,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  56 */
+	{ 60, 2, 247,   0,       0,  76,  25,     0,   0,  45,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  57 */
+	{ 62, 2, 228,   0,       0,  76,  21,     0,   0,  35,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  58 */
+	{ 61, 2, 176,   0,       0,  76,  18,     0,   0,  35,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  59 */
+	{ 63, 2, 200,   0,       0,  76,  24,     0,   0,  35,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  60 */
+	{ 64, 2, 192,   0,       0,  76,  20,     0,   0,  30,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  61 */
+	{ 65, 2, 190,   0,       0,  76,  21,     0,   0,  30,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  62 */
+	{ 66, 2, 182,   0,       0,  76,  19,     0,   0,  35,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  63 */
+	{ 67, 2, 181,   0,       0,  76,  16,     0,   0,  35,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  64 */
+	{ 68, 2, 179,   0,       0,  76,  19,     0,   0,  35,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  65 */
+	{ 69, 2, 196,   0,       0,  76,  18,     0,   0,  25,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  66 */
+	{ 70, 2, 255,   0,       0,  76,  30,     0,   0,  25,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  67 */
+	{ 71, 2, 191,   0,       0,  76,  22,     0,   0,  30,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  68 */
+	{ 72, 2, 196,   0,       0,  76,  18,     0,   0,  25,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  69 */
+	{ 73, 2, 179,   0,       0,  76,  19,     0,   0,  35,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  70 */
+	{ 47, 2, 199,   0,       0,  76,  25,     0,   0,  30,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  71 */
+	{ 48, 2, 182,   0,       0,  76,  18,     0,   0,  30,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  72 */
+	{ 49, 2, 185,   0,       0,  76,  19,     0,   0,  26,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  73 */
+	{ 50, 2, 176,   0,       0,  76,  19,     0,   0,  35,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  74 */
+	{ 51, 2, 178,   0,       0,  76,  20,     0,   0,  35,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  75 */
+	{ 52, 2, 192,   0,       0,  76,  20,     0,   0,  35,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  76 */
+	{ 53, 2, 190,   0,       0,  76,  21,     0,   0,  25,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  77 */
+	{ 54, 2, 182,   0,       0,  76,  24,     0,   0,  30,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  78 */
+	{ 55, 2, 181,   0,       0,  76,  21,     0,   0,  30,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  79 */
+	{ 56, 2, 183,   0,       0,  76,  21,     0,   0,  25,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  80 */
+	{ 57, 2, 196,   0,       0,  76,  18,     0,   0,  27,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  81 */
+	{ 58, 2, 193,   0,       0,  76,  18,     0,   0,  30,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  82 */
+	{ 59, 2, 191,   0,       0,  76,  18,     0,   0,  35,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  83 */
+	{ 28, 0,  70, 400,   10000,  76, 105,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  84 */
+	{ 29, 0,  74, 448,   12000,  76, 120,   253,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  85 */
+	{ 30, 0,  82, 480,   15000,  76, 130,   254,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  86 */
+	{ 31, 1,  95, 640, 20000/2,  76,150/2,255/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  87 */
+	{ 28, 0,  70, 480,   10000,  76, 120,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  88 */
+	{ 60, 2, 247,   0,       0,  76,  25,     0,   0,  47,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  89 */
+	{ 62, 2, 228,   0,       0,  76,  21,     0,   0,  37,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  90 */
+	{ 61, 2, 176,   0,       0,  76,  18,     0,   0,  37,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  91 */
+	{ 63, 2, 200,   0,       0,  76,  24,     0,   0,  37,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  92 */
+	{ 64, 2, 192,   0,       0,  76,  20,     0,   0,  32,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  93 */
+	{ 65, 2, 190,   0,       0,  76,  21,     0,   0,  32,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  94 */
+	{ 66, 2, 182,   0,       0,  76,  19,     0,   0,  37,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  95 */
+	{ 67, 2, 181,   0,       0,  76,  16,     0,   0,  37,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  96 */
+	{ 68, 2, 179,   0,       0,  76,  19,     0,   0,  37,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  97 */
+	{ 69, 2, 196,   0,       0,  76,  18,     0,   0,  27,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  98 */
+	{ 70, 2, 255,   0,       0,  76,  30,     0,   0,  27,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  99 */
+	{ 71, 2, 191,   0,       0,  76,  22,     0,   0,  32,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /* 100 */
+	{ 72, 2, 196,   0,       0,  76,  18,     0,   0,  27,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /* 101 */
+	{ 73, 2, 179,   0,       0,  76,  19,     0,   0,  37,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /* 102 */
+	{ 47, 2, 199,   0,       0,  76,  25,     0,   0,  32,   CT_WATER        ,  0,  0,  0,  0,  0 }, /* 103 */
+	{ 48, 2, 182,   0,       0,  76,  18,     0,   0,  32,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /* 104 */
+	{ 49, 2, 185,   0,       0,  76,  19,     0,   0,  28,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /* 105 */
+	{ 50, 2, 176,   0,       0,  76,  19,     0,   0,  37,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /* 106 */
+	{ 51, 2, 178,   0,       0,  76,  20,     0,   0,  37,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /* 107 */
+	{ 52, 2, 192,   0,       0,  76,  20,     0,   0,  37,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /* 108 */
+	{ 53, 2, 190,   0,       0,  76,  21,     0,   0,  27,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /* 109 */
+	{ 54, 2, 182,   0,       0,  76,  24,     0,   0,  32,   CT_COLA         ,  0,  0,  0,  0,  0 }, /* 110 */
+	{ 55, 2, 181,   0,       0,  76,  21,     0,   0,  32,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /* 111 */
+	{ 56, 2, 183,   0,       0,  76,  21,     0,   0,  27,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /* 112 */
+	{ 57, 2, 196,   0,       0,  76,  18,     0,   0,  29,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /* 113 */
+	{ 58, 2, 193,   0,       0,  76,  18,     0,   0,  32,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /* 114 */
+	{ 59, 2, 191,   0,       0,  76,  18,     0,   0,  37,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /* 115 */
 };
 
 ShipVehicleInfo _ship_vehicle_info[NUM_SHIP_ENGINES] = {
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 2720)
+++ rail_cmd.c	(working copy)
@@ -712,8 +712,10 @@
  * pre/exit/combo-signals, and what-else not
  * @param x,y coordinates where signals is being built
  * @param p1 various bitstuffed elements
- * - p1 = (bit 0-2) - track-orientation, valid values: 0-5 (Track enum)
- * - p1 = (bit 3)   - choose semaphores/signals or cycle normal/pre/exit/combo depending on context
+ * - p1 (bit 0-2) - track-orientation, valid values: 0-5 (Track enum)
+ * - p1 (bit 3)   - cycle normal/pre/exit/combo (only applies when signals already exist)
+ * - p1 (bit 4)   - choose semaphores/light signals (only applies when no signals already exist)
+ * - p1 (bit 5-7) - choose presignal type (only aplies when no signals already exist)
  * @param p2 used for CmdBuildManySignals() to copy direction of first signal
  * TODO: p2 should be replaced by two bits for "along" and "against" the track.
  */
@@ -721,14 +723,12 @@
 {
 	TileIndex tile = TileVirtXY(x, y);
 	bool semaphore;
-	bool pre_signal;
+	bool pre_signal_cycle;
+	byte pre_signal_type;
 	Track track = (Track)(p1 & 0x7);
 	byte m5;
 	int32 cost;
 
-	// Same bit, used in different contexts
-	semaphore = pre_signal = HASBIT(p1, 3);
-
 	if (!ValParamTrackOrientation(track) || !IsTileType(tile, MP_RAILWAY) || !EnsureNoVehicle(tile))
 		return CMD_ERROR;
 
@@ -756,6 +756,12 @@
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
+	// for when signals already exist
+	pre_signal_cycle = HASBIT(p1, 3);
+	// for placing new signals
+	semaphore = HASBIT(p1, 4);
+	pre_signal_type = (p1 >> 5) & 7;
+
 	if (!HasSignalOnTrack(tile, track)) {
 		// build new signals
 		cost = _price.build_signals;
@@ -775,7 +781,7 @@
 			_m[tile].m5 |= RAIL_TYPE_SIGNALS; // change into signals
 			_m[tile].m2 |= 0xF0;              // all signals are on
 			_m[tile].m3 &= ~0xF0;          // no signals built by default
-			_m[tile].m4 = semaphore ? 0x08 : 0;
+			_m[tile].m4 = (semaphore ? 0x08 : 0) + pre_signal_type;
 		}
 
 		if (p2 == 0) {
@@ -783,7 +789,7 @@
 				// build new signals
 				_m[tile].m3 |= SignalOnTrack(track);
 			} else {
-				if (pre_signal) {
+				if (pre_signal_cycle) {
 					// cycle between normal -> pre -> exit -> combo -> pbs ->...
 					byte type = ((GetSignalType(tile, track) + 1) % 5);
 					_m[tile].m4 &= ~0x07;
@@ -830,13 +836,231 @@
 	return cost;
 }
 
-/**	Build many signals by dragging; AutoSignals
+static const byte _dir_from_track[14] = {
+	0,1,0,1,2,1, 0,0,
+	2,3,3,2,3,0,
+};
+
+/**  Build many signals automagically,
+ * Copy a signal along the entire length of connected rail, stopping only when a junction is reached
+ * @param x,y tile to start from
+ * @param trackdir the trackdir (direction in which to start placing signals)
+ * @param signals type of signals to copy
+ * @param p2 various bitstuffed elements
+ * - p2 (bit 0)     - 1 = remove signals, 0 = build signals
+ * - p2 (bit 3)     - 0 = signals, 1 = semaphores
+ * - p2 (bit 24-31) - user defined signals_density
+ */
+int32 BuildAutoSignals(int x, int y, Trackdir trackdir, uint32 flags, uint32 p2, byte signals)
+{
+  byte signal_density = (p2 >> 24);
+	int16 signal_ctr = signal_density * 2;
+	byte signal_dir = 0;	// direction in which signals are placed 1=forward  2=backward  3=twoway
+	byte track_mode = 0;	// 128=bridge, 64=tunnel, 192=end of tunnel/bridge, 0=normal track
+	byte track_height = 0; // height of tunnel currently in
+	int32 retr, total_cost = 0;
+	TileIndex tile = TileVirtXY(x, y);
+	byte m5 = _m[tile].m5;
+	byte m3 = _m[tile].m3;
+	byte semaphores;
+	int mode = p2 & 0x1;
+	int lx, ly;
+	byte dir;
+
+
+	// remember start position and direction
+	int sx = x, sy = y;
+	Trackdir srb = trackdir;
+
+	// get first signal mode
+	if (signals & _signals_table[trackdir]) signal_dir |= 1;
+	if (signals & _signals_table_other[trackdir]) signal_dir |= 2;
+
+	if (signal_dir == 0)
+		return CMD_ERROR; // no signal on start tile to copy
+
+	semaphores = (HasSemaphores(tile, TrackdirToTrack(trackdir)) ? 16 : 0); // copy signal/semaphores style (independent of CTRL)
+
+	signals = 0;
+	lx = 0;
+	ly = 0;
+
+	for(;;) {
+		x += _railbit.xinc[trackdir];
+		y += _railbit.yinc[trackdir];
+
+		tile = TileVirtXY(x, y);
+
+		m5 = _m[tile].m5;
+
+		m3 = _m[tile].m3;
+
+		dir = _dir_from_track[trackdir];
+
+		if (track_mode & 128) { // currently on bridge
+			if (IsTileType(tile, MP_TUNNELBRIDGE) && ((m5 & 192) == 128))
+				// end of bridge
+				track_mode = 192;
+		} else if (track_mode & 64) { // currently in tunnel
+			if (IsTileType(tile, MP_TUNNELBRIDGE)
+			&& ((m5 & 0xF0) == 0)
+			&& ((m5 & 3) == (dir ^ 2))
+			&& (GetSlopeZ(x+8, y+8) == track_height))
+					// end of tunnel
+					track_mode = 192;
+		} else { // currently not on bridge/in tunnel
+			if (IsTileType(tile,MP_TUNNELBRIDGE)
+			&& (((m5 >> 1) & 3) == 0)
+			&& ((m5 & 192) == 128)
+			&& ((m5 & 1) == (dir & 1)) ) {
+				// start of bridge
+				track_mode = 128;
+			} else if (IsTileType(tile, MP_TUNNELBRIDGE)
+			&& ((m5 & 0xF0) == 0)
+			&& (((m5 >> 2) & 3) == 0) ) {
+				// start of tunnel
+				track_mode = 64;
+				track_height = GetSlopeZ(x+8, y+8);
+			};
+		};
+
+		/* for pieces that we cannot build signals on but are not an end of track or a junction, we continue counting. When a signal
+			 should be placed in one of these tiles, it is instead placed on the last possible place for signals, and the counting is
+			 reset from that place. If a signal already is there, one will be placed one the first possible tile encountered.
+		   last place where a signal could be placed is remembered by lx,ly
+			 if signal==0 a signal is already on lx,ly
+		*/
+		if ( (IsTileType(tile, MP_RAILWAY) && ((m5 & ~1) == RAIL_TYPE_WAYPOINT)	&& ((m5 & 1) == (dir & 1))) // check for waypoints
+			|| (IsTileType(tile, MP_STREET) && ((m5 >> 4) == 1)										&& (!(m5 & 8) != !(dir & 1))) // check for road crossings
+			|| (IsTileType(tile,MP_TUNNELBRIDGE) && ((m5 & 0xF8) == 0xE0)					&& ((m5 & 1) != (dir & 1))) // check overhanging bridges
+			|| (track_mode != 0) // are we on a bridge/in a tunnel
+		) {
+			if (track_mode == 192) track_mode = 0; // end of tunnel/bridge
+			signal_ctr -= 2; // these pieces are always diagonal, so count faster
+			if (signal_ctr <= 0) {
+				if (signals == 0) {
+					// signal will be placed on next available tile
+					signal_ctr = 1;
+				} else {
+					// signal will be placed on last possible tile, counting will reset from there
+					signal_ctr += signal_density * 2;
+					x = lx;
+					y = ly;
+					// Place Signal
+					retr = DoCommand(x, y, TrackdirToTrack(trackdir) | semaphores, signals, flags, (mode == 1) ? CMD_REMOVE_SIGNALS : CMD_BUILD_SIGNALS);
+					if (retr == CMD_ERROR) return CMD_ERROR;
+					total_cost += retr;
+					signals = 0;
+					track_mode = 0;
+				};
+			};
+			continue;
+		};
+
+		if (!IsTileType(tile, MP_RAILWAY))
+			return total_cost;  // no more track, we are finished
+
+		if ((m5 & RAIL_TYPE_SPECIAL) || !(m5 & 0x3F))
+			return total_cost;  // no more track, we are finished
+
+		// check for valid track combination, and calculate the trackdir
+		m5 &= 0x3F;
+		switch (trackdir) {
+			case 0: case 2: case 13: { // from SW
+				if (m5 == TRACK_BIT_DIAG1) { // SW to NE track
+					trackdir = 0;
+				} else if ((m5 & ~TRACK_BIT_UPPER) == TRACK_BIT_LOWER) { // SW to SE track
+					trackdir = 3;
+				} else if ((m5 & ~TRACK_BIT_RIGHT) == TRACK_BIT_LEFT) { // SW to NW track
+					trackdir = 12;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			case 8: case 4: case 11: { // from NE
+				if (m5 == TRACK_BIT_DIAG1) { // NE to SW track
+					trackdir = 8;
+				} else if ((m5 & ~TRACK_BIT_LOWER) == TRACK_BIT_UPPER) { // NE to NW track
+					trackdir = 10;
+				} else if ((m5 & ~TRACK_BIT_LEFT) == TRACK_BIT_RIGHT) { // NE to SE track
+					trackdir = 5;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			case 9: case 10: case 12: { // from SE
+				if (m5 == TRACK_BIT_DIAG2) { // SE to NW track
+					trackdir = 9;
+				} else if ((m5 & ~TRACK_BIT_UPPER) == TRACK_BIT_LOWER ) { // SE to SW track
+					trackdir = 11;
+				} else if ((m5 & ~TRACK_BIT_LEFT) == TRACK_BIT_RIGHT) { // SE to NE track
+					trackdir = 13;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			case 1: case 3: case 5: { // from NW
+				if (m5 == TRACK_BIT_DIAG2) { // NW to SE track
+					trackdir = 1;
+				} else if ((m5 & ~TRACK_BIT_LOWER) == TRACK_BIT_UPPER) { // NW to NE track
+					trackdir = 2;
+				} else if((m5 & ~TRACK_BIT_RIGHT) == TRACK_BIT_LEFT) { // NW to SW track
+					trackdir = 4;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			default:
+				assert(0);
+		}
+
+		// calculate signals to place
+		signals = 0;
+		if (signal_dir & 1) signals |= _signals_table[trackdir];
+		if (signal_dir & 2) signals |= _signals_table_other[trackdir];
+
+		if (x == sx && y == sy && trackdir == srb)
+			return total_cost; // back at the start, we are finished
+
+		// remember last place signals could be placed
+		lx = x;			ly = y;
+
+		m5 = _m[tile].m5;
+		if (mode)
+			// when removing signals, remove all signals we encounter
+			signal_ctr =( (((m5 & RAIL_TILE_TYPE_MASK) == RAIL_TYPE_SIGNALS)) && (m3 & _signals_table_both[trackdir]) ) ? 0 : 1;
+		else if (m5 & 0x3)
+			// count faster on diagonal tracks
+			signal_ctr -= 2;
+		else
+			signal_ctr -= 1;
+
+		if (signal_ctr <= 0) {
+			signal_ctr += signal_density * 2;
+			// Place Signal
+			retr = DoCommand(lx, ly, (trackdir & 7) | semaphores, signals , flags, (mode == 1) ? CMD_REMOVE_SIGNALS : CMD_BUILD_SIGNALS);
+			if (retr == CMD_ERROR) return CMD_ERROR;
+			total_cost += retr;
+			signals = 0;
+		};
+
+		// when removing signals, the last position is always handled
+		if (mode) signals = 0;
+
+	};
+
+
+};
+
+
+/** Build many signals by dragging; AutoSignals
  * @param x,y start tile of drag
  * @param p1  end tile of drag
  * @param p2 various bitstuffed elements
- * - p2 = (bit  0)    - 0 = build, 1 = remove signals
- * - p2 = (bit  3)    - 0 = signals, 1 = semaphores
- * - p2 = (bit  4- 6) - track-orientation, valid values: 0-5 (Track enum)
+ * - p2 = (bit 0)     - 0 = build, 1 = remove signals
+ * - p2 = (bit 1)     - 1 = autocompletion on, 0 = off
+ * - p2 = (bit 3)     - 0 = signals, 1 = semaphores
+ * - p2 = (bit 4- 6)  - track-orientation, valid values: 0-5 (Track enum)
  * - p2 = (bit 24-31) - user defined signals_density
  */
 static int32 CmdSignalTrackHelper(int x, int y, uint32 flags, uint32 p1, uint32 p2)
@@ -850,7 +1074,7 @@
 	int mode = p2 & 0x1;
 	Track track = GB(p2, 4, 3);
 	Trackdir trackdir = TrackToTrackdir(track);
-	byte semaphores = (HASBIT(p2, 3)) ? 8 : 0;
+	byte semaphores = (HASBIT(p2, 3)) ? 16 : 0;
 	byte signal_density = (p2 >> 24);
 
 	if (p1 > MapSize()) return CMD_ERROR;
@@ -879,7 +1103,7 @@
 		signals = _m[tile].m3 & SignalOnTrack(track);
 		if (signals == 0) signals = SignalOnTrack(track); /* Can this actually occur? */
 
-		semaphores = (HasSemaphores(tile, track) ? 8 : 0); // copy signal/semaphores style (independent of CTRL)
+		semaphores = (HasSemaphores(tile, track) ? 16 : 0); // copy signal/semaphores style (independent of CTRL)
 	} else // no signals exist, drag a two-way signal stretch
 		signals = SignalOnTrack(track);
 
@@ -904,6 +1128,15 @@
 			} else {
 				error = false;
 				total_cost += ret;
+
+				/* when autocompletion is on, use that to place the rest of the signals */
+				if HASBIT(p2, 1) {
+					ret = BuildAutoSignals(x, y, trackdir, flags, p2, signals);
+					if (ret == CMD_ERROR)
+						return CMD_ERROR;
+					total_cost += ret;
+					return total_cost;
+				}
 			}
 		}
 
@@ -913,7 +1146,7 @@
 		y += _railbit.yinc[trackdir];
 		signal_ctr++;
 
-		// toggle railbit for the non-diagonal tracks (|, -- tracks)
+		// toggle trackdir for the non-diagonal tracks (|, -- tracks)
 		if (!IsDiagonalTrackdir(trackdir)) trackdir ^= 1;
 	}
 
@@ -1854,12 +2087,6 @@
 	}
 }
 
-static const byte _dir_from_track[14] = {
-	0,1,0,1,2,1, 0,0,
-	2,3,3,2,3,0,
-};
-
-
 static void ChangeSignalStates(SetSignalsData *ssd)
 {
 	int i;
@@ -2165,8 +2392,7 @@
 	if (IsTileDepotType(tile, TRANSPORT_RAIL))
 		ShowTrainDepotWindow(tile);
 	else if (IsRailWaypoint(_m[tile].m5))
-		ShowRenameWaypointWindow(GetWaypointByTile(tile));
-
+		ShowWaypointStatsWindow(GetWaypointByTile(tile));
 }
 
 static void GetTileDesc_Track(TileIndex tile, TileDesc *td)
Index: vehicle.c
===================================================================
--- vehicle.c	(revision 2720)
+++ vehicle.c	(working copy)
@@ -18,9 +18,12 @@
 #include "engine.h"
 #include "sound.h"
 #include "debug.h"
+#include "gui.h"
+#include "npf.h"
 #include "vehicle_gui.h"
 #include "depot.h"
 #include "station.h"
+#include "gui.h"
 #include "rail.h"
 
 #define INVALID_COORD (-0x8000)
@@ -1669,6 +1672,123 @@
 	_current_player = OWNER_NONE;
 }
 
+int32 CmdCloneOrder(int x, int y, uint32 flags, uint32 veh1_veh2, uint32 mode);
+int32 CmdMoveRailVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+int32 CmdBuildRailVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+int32 CmdBuildRoadVeh(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+int32 CmdBuildShip(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+int32 CmdBuildAircraft(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+ 
+
+typedef int32 VehBuildProc(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+
+static VehBuildProc * const _veh_build_proc_table[] = {
+	CmdBuildRailVehicle,
+	CmdBuildRoadVeh,
+	CmdBuildShip,
+	CmdBuildAircraft,
+};
+
+static VehicleID * _new_vehicle_id_proc_table[] = {
+	&_new_train_id,
+	&_new_roadveh_id,
+	&_new_ship_id,
+	&_new_aircraft_id,	
+};
+
+/** Clone a vehicle. If it is a train, it will clone all the cars too
+ * @param x,y unused
+ * @param p1 the original vehicle's index
+ * @param p2 1 = shared orders, else copied orders
+ */
+int32 CmdCloneVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2)
+{
+	Vehicle *vfront, *v;
+	Vehicle *wfront, *w1, *w2;
+	int cost, total_cost;
+	VehBuildProc *proc;
+	VehicleID *new_id;
+	uint refit_command = 0;
+	byte needs_refitting = 255;
+
+	if (!IsVehicleIndex(p1))
+		return CMD_ERROR;
+	v = GetVehicle(p1);
+	wfront = v; 
+	w1 = v;
+	vfront = v;
+	
+	if (!CheckOwnership(v->owner))
+		return CMD_ERROR;
+	
+	if (v->type == VEH_Train && v->subtype != TS_Front_Engine) return CMD_ERROR;
+	
+	//no need to check if it is a depot since the build command do that
+	switch (v->type) {
+		case VEH_Train:		refit_command = CMD_REFIT_RAIL_VEHICLE; break;
+		case VEH_Road:		break;
+		case VEH_Ship:		refit_command = CMD_REFIT_SHIP; break;
+		case VEH_Aircraft:	refit_command = CMD_REFIT_AIRCRAFT; break;
+		default: return CMD_ERROR;
+	}
+
+	proc = _veh_build_proc_table[v->type - VEH_Train];
+	new_id = _new_vehicle_id_proc_table[v->type - VEH_Train];
+	total_cost = proc(x, y, flags, v->engine_type, 1);
+	if (total_cost == CMD_ERROR)
+		return CMD_ERROR;
+
+	if (flags & DC_EXEC) {
+		wfront = GetVehicle(*new_id);
+		w1 = wfront;
+		CmdCloneOrder(x, y, flags, (v->index << 16) | w1->index, p2 & 1 ? CO_SHARE : CO_COPY);
+		w1->cur_order_index = v->cur_order_index;
+		
+		if (wfront->cargo_type != v->cargo_type) {
+		//a refit is needed
+		needs_refitting = v->cargo_type;
+		}
+	}
+	if (v->type == VEH_Train) {
+		// now we handle the cars
+		v = v->next;
+		while (v != NULL) {
+			cost = proc(x, y, flags, v->engine_type, 1);
+			if (cost == CMD_ERROR)
+				return CMD_ERROR;
+			total_cost += cost;
+			
+			if (flags & DC_EXEC) {
+				// add this unit to the end of the train
+				w2 = GetVehicle(RailVehInfo(v->engine_type)->flags & RVI_WAGON ? _new_wagon_id : _new_train_id);
+				CmdMoveRailVehicle(x, y, flags, (w1->index << 16) | w2->index, 0);
+				w1 = w2;
+			}
+			v = v->next;
+		}
+
+		if (flags & DC_EXEC) {
+			_new_train_id = wfront->index;
+			v = vfront;
+			w1 = wfront;
+			while (w1 != NULL && v != NULL) {
+				w1->spritenum = v->spritenum; // makes sure that multiheaded engines are facing the correct way
+				if (w1->cargo_type != v->cargo_type)	// checks if a refit is needed
+					needs_refitting = v->cargo_type;
+				w1 = w1->next;
+				v = v->next;
+			}
+
+		}
+	}
+	if (flags && DC_EXEC && needs_refitting != 255 && v->type != VEH_Road) {	// right now we do not refit road vehicles
+		if (DoCommandByTile(wfront->tile, wfront->index, needs_refitting, 0, refit_command) != CMD_ERROR)
+			DoCommandByTile(wfront->tile, wfront->index, needs_refitting, DC_EXEC, refit_command);
+	}
+	return total_cost;
+}
+
+
 /** Give a custom name to your vehicle
  * @param x,y unused
  * @param p1 vehicle ID to name
Index: vehicle.h
===================================================================
--- vehicle.h	(revision 2720)
+++ vehicle.h	(working copy)
@@ -30,6 +30,7 @@
 // 1 and 3 do not appear to be used
 typedef enum TrainSubtypes {
 	TS_Front_Engine = 0, // Leading engine of a train
+	TS_Artic_Part = 1,
 	TS_Not_First = 2,    // Wagon or additional engine
 	TS_Free_Car = 4,     // First in a wagon chain (in depot)
 } TrainSubtype;
@@ -59,6 +60,7 @@
 	uint8 cached_veh_length;  // length of this vehicle in units of 1/8 of normal length, cached because this can be set by a callback
 	// cached values, recalculated when the cargo on a train changes (in addition to the conditions above)
 	uint16 cached_weight;     // total weight of the consist.
+	uint32 cached_max_TE;     // max tractive effort of the consist
 	uint16 cached_veh_weight; // weight of the vehicle.
 
 	// NOSAVE: for wagon override - id of the first engine in train
@@ -147,7 +149,7 @@
 
 struct Vehicle {
 	byte type;	// type, ie roadven,train,ship,aircraft,special
-	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)(Filled with values from EffectVehicles or TrainSubTypes)
+	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)
 
 	VehicleID index;	// NOSAVE: Index in vehicle array
 
Index: misc.c
===================================================================
--- misc.c	(revision 2720)
+++ misc.c	(working copy)
@@ -468,6 +468,7 @@
 void TownsMonthlyLoop(void);
 void IndustryMonthlyLoop(void);
 void StationMonthlyLoop(void);
+void WaypointMonthlyLoop(void);
 
 void PlayersYearlyLoop(void);
 void TrainsYearlyLoop(void);
@@ -550,6 +551,7 @@
 		TownsMonthlyLoop();
 		IndustryMonthlyLoop();
 		StationMonthlyLoop();
+		WaypointMonthlyLoop();
 #ifdef ENABLE_NETWORK
 		if (_network_server)
 			NetworkServerMonthlyLoop();
Index: economy.c
===================================================================
--- economy.c	(revision 2720)
+++ economy.c	(working copy)
@@ -1261,25 +1261,27 @@
 	return profit;
 }
 
-/*
- * Returns true if Vehicle v should wait loading because other vehicle is
- * already loading the same cargo type
+/* 
+ * Returns the amount of cargo is reserved for loading
+ * by other vehicles at the station
  * v = vehicle to load, u = GetFirstInChain(v)
  */
-static bool LoadWait(const Vehicle *v, const Vehicle *u) {
+static uint16 LoadWait(const Vehicle *v, const Vehicle *u) {
 	const Vehicle *w;
 	const Vehicle *x;
-	bool has_any_cargo = false;
 
-	if (!(u->current_order.flags & OF_FULL_LOAD)) return false;
+	uint16 cargo_reserved = 0;
+	
+	uint16 has_other_cargo = 0;
+	uint16 has_type = 0;
 
+	if (!(u->current_order.flags & OF_FULL_LOAD)) return 0;
+
 	for (w = u; w != NULL; w = w->next) {
-		if (w->cargo_count != 0) {
-			if (v->cargo_type == w->cargo_type &&
-					u->last_station_visited == w->cargo_source)
-				return false;
-			has_any_cargo = true;
-		}
+	  if (v->cargo_type == w->cargo_type) 
+			has_type += w->cargo_count;
+		else 
+			has_other_cargo += w->cargo_count;
 	}
 
 	FOR_ALL_VEHICLES(x) {
@@ -1287,31 +1289,29 @@
 				u->last_station_visited == x->last_station_visited && // at the same station
 				!(x->vehstatus & VS_STOPPED) && // not stopped
 				x->current_order.type == OT_LOADING && // loading
+				!(u->current_order.flags & OF_UNLOAD) && // not unloading
 				u != x) { // not itself
-			bool other_has_any_cargo = false;
-			bool has_space_for_same_type = false;
-			bool other_has_same_type = false;
+			uint16 other_has_other_cargo = 0;
+			uint16 other_has_space_for_same_type = 0;
+			uint16 other_has_same_type = 0;
 
 			for (w = x; w != NULL; w = w->next) {
-				if (w->cargo_count < w->cargo_cap && v->cargo_type == w->cargo_type)
-					has_space_for_same_type = true;
 
-				if (w->cargo_count != 0) {
-					if (v->cargo_type == w->cargo_type &&
-							u->last_station_visited == w->cargo_source)
-						other_has_same_type = true;
-					other_has_any_cargo = true;
-				}
+				if (v->cargo_type == w->cargo_type) {
+					other_has_space_for_same_type += w->cargo_cap - w->cargo_count;
+ 					other_has_same_type += w->cargo_count;
+				} else
+					other_has_other_cargo += w->cargo_count;
 			}
 
-			if (has_space_for_same_type) {
-				if (other_has_same_type) return true;
-				if (other_has_any_cargo && !has_any_cargo) return true;
+			if (other_has_space_for_same_type) {
+				if ((other_has_same_type > has_type) || (other_has_other_cargo > has_other_cargo))
+					cargo_reserved += other_has_space_for_same_type;
 			}
 		}
 	}
 
-	return false;
+	return cargo_reserved;
 }
 
 int LoadUnloadVehicle(Vehicle *v)
@@ -1353,6 +1353,9 @@
 				unloading_time += v->cargo_count; /* TTDBUG: bug in original TTD */
 				profit += DeliverGoods(v->cargo_count, v->cargo_type, v->cargo_source, last_visited, v->cargo_days);
 				result |= 1;
+				ge->cargo_amount[STS_AMOUNT_IN].this_month += v->cargo_count;
+				if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 				v->cargo_count = 0;
 			} else if (u->current_order.flags & ( OF_UNLOAD | OF_TRANSFER) ) {
 				/* unload goods and let it wait at the station */
@@ -1366,6 +1369,9 @@
 
 				v_profit_total += v_profit;
 
+				ge->cargo_amount[STS_AMOUNT_TRANSFER].this_month += v->cargo_count;
+				if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 
 				unloading_time += v->cargo_count;
 				if ((t=ge->waiting_acceptance & 0xFFF) == 0) {
@@ -1396,14 +1402,21 @@
 
 		/* update stats */
 		ge->days_since_pickup = 0;
+		ge->last_vehicle_type = u->type;
+
+		// TODO: use max-speed of whole consist for trains
 		t = u->max_speed;
 		if (u->type == VEH_Road) t >>=1;
 		if (u->type == VEH_Train) t = u->u.rail.cached_max_speed;
 
+		
+		ge->last_vehicle_speed = t;
 		// if last speed is 0, we treat that as if no vehicle has ever visited the station.
 		ge->last_speed = t < 255 ? t : 255;
+		// TODO: use age of oldest wagon of this type
 		ge->last_age = _cur_year - v->build_year;
 
+
 		// If there's goods waiting at the station, and the vehicle
 		//  has capacity for it, load it on the vehicle.
 		if ((count=ge->waiting_acceptance & 0xFFF) != 0 &&
@@ -1416,8 +1429,15 @@
 
 			/* Skip loading this vehicle if another train/vehicle is already handling
 			 * the same cargo type at this station */
-			if (_patches.improved_load && LoadWait(v,u)) continue;
+			if (_patches.improved_load) {
+				int loadmax = ge->waiting_acceptance - LoadWait(v,u);
 
+				if (loadmax <= 0)
+					continue;
+				cap = min(cap, loadmax);
+			}
+
+
 			/* TODO: Regarding this, when we do gradual loading, we
 			 * should first unload all vehicles and then start
 			 * loading them. Since this will cause
@@ -1434,6 +1454,11 @@
 			ge->waiting_acceptance -= cap;
 			v->profit_this_year -= feeder_profit_share;
 			ge->feeder_profit -= feeder_profit_share;
+
+			ge->cargo_amount[STS_AMOUNT_OUT].this_month += cap;
+			if (ge->months_counted == 0) ge->months_counted = 1;
+			InvalidateWindow(WC_STATION_STATS, st->index);
+
 			unloading_time += cap;
 			st->time_since_load = 0;
 
Index: ship_cmd.c
===================================================================
--- ship_cmd.c	(revision 2720)
+++ ship_cmd.c	(working copy)
@@ -446,6 +446,10 @@
 
 static void ShipArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_SHIP].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	/* Check if station was ever visited before */
 	if (!(st->had_vehicle_of_type & HVOT_SHIP)) {
 		uint32 flags;
Index: main_gui.c
===================================================================
--- main_gui.c	(revision 2720)
+++ main_gui.c	(working copy)
@@ -24,6 +24,7 @@
 #include "signs.h"
 #include "waypoint.h"
 #include "variables.h"
+#include "station.h"
 
 #include "network_data.h"
 #include "network_client.h"
@@ -308,22 +309,22 @@
 
 static void MenuClickShowTrains(int index)
 {
-	ShowPlayerTrains(index, -1);
+	ShowPlayerTrains(index, INVALID_STATION);
 }
 
 static void MenuClickShowRoad(int index)
 {
-	ShowPlayerRoadVehicles(index, -1);
+	ShowPlayerRoadVehicles(index, INVALID_STATION);
 }
 
 static void MenuClickShowShips(int index)
 {
-	ShowPlayerShips(index, -1);
+	ShowPlayerShips(index, INVALID_STATION);
 }
 
 static void MenuClickShowAir(int index)
 {
-	ShowPlayerAircraft(index, -1);
+	ShowPlayerAircraft(index, INVALID_STATION);
 }
 
 static void MenuClickBuildRail(int index)
@@ -1895,10 +1896,10 @@
 		case WKC_F10:ShowOperatingProfitGraph(); break;
 		case WKC_F11: ShowCompanyLeagueTable(); break;
 		case WKC_F12: ShowBuildIndustryWindow(); break;
-		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, -1); break;
-		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, -1); break;
-		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, -1); break;
-		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, -1); break;
+		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, INVALID_STATION); break;
 		case WKC_SHIFT | WKC_F5: ToolbarZoomInClick(w); break;
 		case WKC_SHIFT | WKC_F6: ToolbarZoomOutClick(w); break;
 		case WKC_SHIFT | WKC_F7: ShowBuildRailToolbar(_last_built_railtype,-1); break;
Index: roadveh_gui.c
===================================================================
--- roadveh_gui.c	(revision 2720)
+++ roadveh_gui.c	(working copy)
@@ -61,7 +61,7 @@
 	y += 10;
 }
 
-static void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetRoadVehImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -230,6 +230,16 @@
 	w->caption_color = v->owner;
 }
 
+void CcCloneRoadVeh(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
+
+	if (!success) return;
+
+	v = GetVehicle(_new_roadveh_id);
+	ShowRoadVehViewWindow(v);
+}
+
 static void RoadVehViewWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -308,6 +318,12 @@
 		case 10: /* show details */
 			ShowRoadVehDetailsWindow(v);
 			break;
+		case 11: {
+			/* clone vehicle */
+			Vehicle *v;
+			v = GetVehicle(w->window_number);
+			DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, CcCloneRoadVeh, CMD_CLONE_VEHICLE | CMD_MSG(STR_9009_CAN_T_BUILD_ROAD_VEHICLE));
+			} break;
 		}
 	} break;
 
@@ -322,6 +338,18 @@
 		DeleteWindowById(WC_VEHICLE_ORDERS, w->window_number);
 		DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
 		break;
+
+	case WE_MOUSELOOP:
+		{
+			Vehicle *v;
+			uint32 h;
+			v = GetVehicle(w->window_number);
+			h = IsTileDepotType(v->tile, TRANSPORT_ROAD) && (v->vehstatus&VS_STOPPED) ? (1<< 7) : (1 << 11);
+			if (h != w->hidden_state) {
+				w->hidden_state = h;
+				SetWindowDirty(w);
+			}
+		}
 	}
 }
 
@@ -337,6 +365,7 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  50,  67, 0x2CB,    STR_9020_FORCE_VEHICLE_TO_TURN_AROUND },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B2,    STR_901D_SHOW_VEHICLE_S_ORDERS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B3,    STR_9021_SHOW_ROAD_VEHICLE_DETAILS },
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_CLONE_ROAD_VEHICLE_INFO },
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 104, 103, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 104, 115, 0x0,      STR_NULL },
 { WIDGETS_END }
@@ -536,7 +565,7 @@
 
 	/* setup disabled buttons */
 	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7));
+		IsTileOwner(tile, _local_player) ? 0 : ((1<<4) | (1<<7) | (1<<8));
 
 	/* determine amount of items for scroller */
 	num = 0;
@@ -640,6 +669,41 @@
 	}
 }
 
+/**
+ * Clones a road vehicle
+ * @param *v is the original vehicle to clone
+ * @param *w is the window of the depot where the clone is build
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	if (v->type != VEH_Road) {
+		// it's not a road vehicle, do nothing
+		return false;
+	}
+
+
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneRoadVeh,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
 static void RoadDepotWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -654,12 +718,45 @@
 			break;
 
 		case 7:
+			ResetObjectToPlace();
 			ShowBuildRoadVehWindow(w->window_number);
 			break;
+			
+		case 8: /* clone button */
+			InvalidateWidget(w, 8);
+				TOGGLEBIT(w->click_state, 8);
+				
+				if (HASBIT(w->click_state, 8)) {
+					_place_clicked_vehicle = NULL;
+					SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, VHM_RECT, w);
+				} else {
+					ResetObjectToPlace();
+				}
+					break;
+				
+			case 9: /* scroll to tile */
+				ResetObjectToPlace();
+				ScrollMainWindowToTile(w->window_number);
+					break;
+		}
+	} break;
+	
+		case WE_PLACE_OBJ: {
+		ClonePlaceObj(e->place.tile, w);
+	} break;
 
-		case 8: /* scroll to tile */
-			ScrollMainWindowToTile(w->window_number);
-			break;
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 8);
+		InvalidateWidget(w, 8);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+	// since OTTD checks all open depot windows, we will make sure that it triggers the one with a clicked clone button
+		if (v != NULL && HASBIT(w->click_state, 8)) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick( v, w);
 		}
 	} break;
 
@@ -729,8 +826,9 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   279,    14,    55, 0x305,												STR_9022_VEHICLES_CLICK_ON_VEHICLE},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   303,   314,    14,    55, 0x0,													STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   150,    56,    67, STR_9004_NEW_VEHICLES,				STR_9023_BUILD_NEW_ROAD_VEHICLE},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   151,   302,    56,    67, STR_00E4_LOCATION,						STR_9025_CENTER_MAIN_VIEW_ON_ROAD},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   100,    56,    67, STR_9004_NEW_VEHICLES,				STR_9023_BUILD_NEW_ROAD_VEHICLE},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,   101,   200,    56,    67, STR_CLONE_ROAD_VEHICLE,		STR_CLONE_ROAD_VEHICLE_DEPOT_INFO},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   201,   302,    56,    67, STR_00E4_LOCATION,						STR_9025_CENTER_MAIN_VIEW_ON_ROAD},
 {      WWT_PANEL,    RESIZE_RTB,    14,   303,   302,    56,    67, 0x0,													STR_NULL},
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   303,   314,    56,    67, 0x0,													STR_RESIZE_BUTTON},
 {   WIDGETS_END},
@@ -806,7 +904,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Road, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -998,6 +1096,13 @@
 		w = AllocateWindowDescFront(&_other_player_roadveh_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Road;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = player;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: order_cmd.c
===================================================================
--- order_cmd.c	(revision 2720)
+++ order_cmd.c	(working copy)
@@ -351,6 +351,25 @@
 			/* Increase amount of orders */
 			u->num_orders++;
 
+			// count vehicles scheduled for station
+			if (new_order.type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(new_order.station)->veh_scheduled++;
+			} else {
+				Station *st = GetStation(new_order.station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]++;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]++;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]++;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]++;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]++;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]++;
+						break;
+				}
+			}
+
 			/* If the orderlist was empty, assign it */
 			if (u->orders == NULL) u->orders = v->orders;
 
@@ -432,12 +451,25 @@
 			GetVehicleOrder(v, sel_ord - 1)->next = order->next;
 		}
 
-		/* Give the item free */
-		order->type = OT_NOTHING;
-		order->next = NULL;
-
 		u = GetFirstVehicleFromSharedList(v);
 		while (u != NULL) {
+			if (order->type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(order->station)->veh_scheduled--;
+			} else {
+				Station *st = GetStation(order->station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]--;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]--;
+						break;
+				}
+			}
 			u->num_orders--;
 
 			if (sel_ord < u->cur_order_index)
@@ -462,6 +494,10 @@
 			u = u->next_shared;
 		}
 
+		/* Give the item free */
+		order->type = OT_NOTHING;
+		order->next = NULL;
+
 		RebuildVehicleLists();
 	}
 
@@ -1036,6 +1072,24 @@
 
 	order = NULL;
 	while (cur != NULL) {
+		// decrease vehicles scheduled for station
+		if (cur->type == OT_GOTO_WAYPOINT) {
+			GetWaypoint(cur->station)->veh_scheduled--;
+		} else {
+			Station *st = GetStation(cur->station);
+			switch (v->type)
+			{
+				case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+				case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+				case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+				case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+					if (v->cargo_type == CT_PASSENGERS)
+						st->veh_scheduled[STS_VEH_BUS]--;
+					else
+						st->veh_scheduled[STS_VEH_TRUCK]--;
+					break;
+			}
+		}
 		if (order != NULL) {
 			order->type = OT_NOTHING;
 			order->next = NULL;
Index: openttd.vcproj
===================================================================
--- openttd.vcproj	(revision 2720)
+++ openttd.vcproj	(working copy)
@@ -204,7 +204,7 @@
 			<File
 				RelativePath=".\music\dmusic.cpp">
 				<FileConfiguration
-					Name="Release|Win32">
+					Name="Debug|Win32">
 					<Tool
 						Name="VCCLCompilerTool"
 						UsePrecompiledHeader="0"
Index: settings.c
===================================================================
--- settings.c	(revision 2720)
+++ settings.c	(working copy)
@@ -859,6 +859,11 @@
 	{"full_load_any",				SDT_BOOL,		(void*)true,	&_patches.full_load_any,				NULL},
 	{"modified_catchment", 	SDT_BOOL,		(void*)true,	&_patches.modified_catchment,		NULL},
 
+	{"nsr_speed",	SDT_BOOL,	(void*)true,	&_patches.nsr_speed,	NULL},
+	{"nsr_age",	SDT_BOOL,	(void*)true,	&_patches.nsr_age,	NULL},
+	{"nsr_wait_days",	SDT_BOOL,	(void*)true,	&_patches.nsr_wait_days,	NULL},
+	{"nsr_wait_cargo",	SDT_BOOL,	(void*)true,	&_patches.nsr_wait_cargo,	NULL},
+	{"nsr_town_rating",	SDT_BOOL,	(void*)true,	&_patches.nsr_town_rating,	NULL},
 
 	{"inflation",						SDT_BOOL,		(void*)true,	&_patches.inflation,						NULL},
 	{"selectgoods",					SDT_BOOL,		(void*)true,	&_patches.selectgoods,					NULL},
@@ -881,6 +886,7 @@
 	{"nonuniform_stations",	SDT_BOOL,		(void*)true,	&_patches.nonuniform_stations,	NULL},
 	{"always_small_airport",SDT_BOOL,		(void*)false,	&_patches.always_small_airport,	NULL},
 	{"realistic_acceleration",SDT_BOOL, (void*)false,	&_patches.realistic_acceleration,	NULL},
+	{"wagon_speed_limits",	SDT_BOOL,		(void*)false,	&_patches.wagon_speed_limits,		NULL},
 	{"forbid_90_deg",				SDT_BOOL, 	(void*)false, &_patches.forbid_90_deg,					NULL},
 	{"improved_load",				SDT_BOOL,		(void*)false,	&_patches.improved_load,				NULL},
 
Index: callback_table.c
===================================================================
--- callback_table.c	(revision 2720)
+++ callback_table.c	(working copy)
@@ -10,6 +10,7 @@
 
 /* aircraft_gui.c */
 CommandCallback CcBuildAircraft;
+CommandCallback CcCloneAircraft;
 
 /* airport_gui.c */
 CommandCallback CcBuildAirport;
@@ -41,13 +42,16 @@
 
 /* roadveh_gui.c */
 CommandCallback CcBuildRoadVeh;
+CommandCallback CcCloneRoadVeh;
 
 /* ship_gui.c */
 CommandCallback CcBuildShip;
+CommandCallback CcCloneShip;
 
 /* train_gui.c */
 CommandCallback CcBuildWagon;
 CommandCallback CcBuildLoco;
+CommandCallback CcCloneTrain;
 
 CommandCallback *_callback_table[] = {
 	/* 0x00 */ NULL,
@@ -70,7 +74,11 @@
 	/* 0x11 */ CcPlaySound1D,
 	/* 0x12 */ CcPlaySound1E,
 	/* 0x13 */ CcStation,
-	/* 0x14 */ CcTerraform
+	/* 0x14 */ CcTerraform,
+	/* 0x15 */ CcCloneAircraft,
+	/* 0x16 */ CcCloneRoadVeh,
+	/* 0x17 */ CcCloneShip,
+	/* 0x18 */ CcCloneTrain,
 };
 
 const int _callback_table_count = lengthof(_callback_table);
Index: waypoint.c
===================================================================
--- waypoint.c	(revision 2720)
+++ waypoint.c	(working copy)
@@ -17,6 +17,7 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 #include "table/track_land.h"
+#include "gui.h"
 
 enum {
 	/* Max waypoints: 64000 (8 * 8000) */
@@ -46,7 +47,7 @@
 	Waypoint *wp;
 
 	FOR_ALL_WAYPOINTS(wp) {
-		if (wp->xy == 0) {
+		if (wp->xy == INVALID_TILE) {
 			uint index = wp->index;
 
 			memset(wp, 0, sizeof(Waypoint));
@@ -139,7 +140,7 @@
 	uint thres = 8, cur_dist;
 
 	FOR_ALL_WAYPOINTS(wp) {
-		if (wp->deleted && wp->xy) {
+		if (wp->deleted > 0 && wp->xy != INVALID_TILE) {
 			cur_dist = DistanceManhattan(tile, wp->xy);
 			if (cur_dist < thres) {
 				thres = cur_dist;
@@ -208,6 +209,7 @@
 		wp->deleted = 0;
 		wp->xy = tile;
 		wp->build_date = _date;
+		InitializeWaypointStats(wp);
 
 		if (wp->town_index == STR_NULL)
 			MakeDefaultWaypointName(wp);
@@ -224,7 +226,7 @@
 {
 	Order order;
 
-	wp->xy = 0;
+	wp->xy = INVALID_TILE;
 
 	order.type = OT_GOTO_WAYPOINT;
 	order.station = wp->index;
@@ -418,7 +420,7 @@
 
 	/* Convert the old 'town_or_string', to 'string' / 'town' / 'town_cn' */
 	FOR_ALL_WAYPOINTS(wp) {
-		if (wp->xy == 0)
+		if (wp->xy == INVALID_TILE)
 			continue;
 
 		wp->town_index = ClosestTownFromTile(wp->xy, (uint)-1)->index;
@@ -447,18 +449,36 @@
 	SLE_CONDVAR(Waypoint, build_date, SLE_UINT16, 3, 255),
 	SLE_CONDVAR(Waypoint, stat_id, SLE_UINT8, 3, 255),
 
+//	save waypoint stats... change xx to savegame-revision
+//	SLE_CONDVAR(Waypoint,months_counted,	SLE_UINT16, xx, 255),
+
 	SLE_END()
 };
 
+//	save waypoint stats... change xx to savegame-revision
+//static const SaveLoad _stats_desc[] = {
+//	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,average,	SLE_UINT32, xx, 255),
+//	SLE_END()
+//};
+
 static void Save_WAYP(void)
 {
 	Waypoint *wp;
+//	int i;
 
 	FOR_ALL_WAYPOINTS(wp) {
 		if (wp->xy != 0) {
 			SlSetArrayIndex(wp->index);
 			SlObject(wp, _waypoint_desc);
 		}
+// save waypoint stats
+//		for (i = 0; i < STS_VEH_TYPES; i++) 
+//			SlObject(&wp->vehicles[i], _stats_desc);
+
 	}
 }
 
@@ -474,9 +494,227 @@
 
 		wp = GetWaypoint(index);
 		SlObject(wp, _waypoint_desc);
+		InitializeWaypointStats(wp);
 	}
 }
 
 const ChunkHandler _waypoint_chunk_handlers[] = {
 	{ 'CHKP', Save_WAYP, Load_WAYP, CH_ARRAY | CH_LAST},
 };
+
+void WaypointMonthlyLoop(void)
+{
+	Waypoint *wp;
+	StationStats *sts;
+	int i;
+
+ 	FOR_ALL_WAYPOINTS(wp) {
+		if (wp->months_counted != STS_NO_MONTHS_COUNTED)
+		{
+			// update vehicle-counts and min/max
+			for (i = WPS_MONTHLY_STATS_START; i < WPS_MONTHLY_STATS_END; i++) {
+				sts = &wp->vehicles[i];
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, wp->months_counted);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			if (wp->months_counted == (wp->months_counted / 12) * 12)
+			{ // do this once a year to have yearly stats
+				for (i = WPS_YEARLY_STATS_START; i < WPS_YEARLY_STATS_END; i++) {
+					sts = &wp->vehicles[i];
+					sts->month_min = min(sts->month_min, sts->this_month);
+					sts->month_max = max(sts->month_max, sts->this_month);
+					sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, wp->months_counted / 12);
+					sts->last_month = sts->this_month;
+					sts->this_month = 0;
+				}
+			}
+			wp->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, wp->index);
+	}
+}
+
+void SearchVehiclesForWaypoint(Waypoint *wp)
+{
+	Vehicle *v;
+	Order* ord = NULL;
+
+	if (wp->xy == INVALID_TILE) return;
+	wp->veh_scheduled = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (v->owner == GetTileOwner(wp->xy)) &&
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ) //Trains (first engine, that contains the orders)
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == wp->index && ord->type == OT_GOTO_WAYPOINT) {
+					wp->veh_scheduled++;
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	} 
+}
+
+void InitializeWaypointStats(Waypoint *wp)
+{
+	StationStats *sts;
+
+	wp->months_counted = STS_NO_MONTHS_COUNTED;
+	for (sts = wp->vehicles; sts != endof(wp->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = STS_INIT_MINIMUM;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForWaypoint(wp);
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _waypoint_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   288,     0,    13, STR_WAYPOINT_VIEWPORT, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   289,   300,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   150,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   151,   300,    14,    25, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   300,    26,    37, STR_STS_TOGGLE_MONTH_YEAR, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   300,    38,   140, 0x0, 0x0},
+{      WIDGETS_END},
+};
+
+WindowDesc _waypoint_view_stats = {
+	-1, -1, 301, 141,
+	WC_WAYPOINT_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_waypoint_stats_widgets,
+	WaypointStatsWndProc
+};
+
+void DrawWaypointStatWindow(Window *w, Waypoint *wp)
+{
+	int i, j;
+	enum {
+		STAT_LINE_START = 40,
+		STAT_LINE_PREVIOUS = 60,
+		STAT_LINE_THIS = 72,
+		STAT_LINE_AVERAGE = 90,
+		STAT_LINE_MIN = 102,
+		STAT_LINE_MAX = 114,
+		STAT_LINE_COUNTED = 130,
+		STAT_COLUMN_TEXT = 10,
+		STAT_COLUMN_SCHEDULED = 170,
+		STAT_COLUMN_NOT_SCHEDULED = 290,
+		COL_DIF = STAT_COLUMN_NOT_SCHEDULED - STAT_COLUMN_SCHEDULED,
+	};
+
+	//Get the Station name
+	SetDParam(0, wp->index);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_START,	STR_SCHEDULED, 0);
+	if (w->listopt.type_mask == STS_SHOW_YEARLY_STATS) {
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_PREVIOUS,	STR_STS_VEHICLES_LAST_YEAR, 0);
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_THIS,	STR_STS_VEHICLES_THIS_YEAR, 0);
+		SetDParam(0, max((wp->months_counted - 1) / 12 ,0));
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_COUNTED,	STR_STS_YEARS_COUNTED_NUM, 0);
+	} else {
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_PREVIOUS,	STR_VEHICLES_MONTH, 0);
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_THIS,	STR_VEHICLES_CURRENT, 0);
+		SetDParam(0, max(wp->months_counted - 1,0));
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_COUNTED,	STR_MONTHS_COUNTED_NUM, 0);
+	}
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_AVERAGE,	STR_AVERAGE, 0);
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_MIN,	STR_MINIMUM, 0);
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_MAX,	STR_MAXIMUM, 0);
+
+	SetDParam(0, wp->veh_scheduled);
+	DrawStringRightAligned(STAT_COLUMN_SCHEDULED, STAT_LINE_START, STR_NUMBER, 0);
+	DrawStringRightAligned(STAT_COLUMN_NOT_SCHEDULED, STAT_LINE_START, STR_STS_NOT_SCHEDULED, 0);
+	if (wp->veh_scheduled != 0) {
+		CLRBIT(w->disabled_state, 5);
+	} else {
+		SETBIT(w->disabled_state, 5);
+	}
+
+	j = (w->listopt.type_mask == STS_SHOW_YEARLY_STATS) ? WPS_YEARLY_STATS_START : WPS_MONTHLY_STATS_START;
+	for (i = 0; i < WPS_STATS_TYPES / 2; i++)
+	{
+		SetDParam(0, wp->vehicles[i+j].last_month);
+		DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_PREVIOUS, STR_NUMBER, 0);
+		SetDParam(0, wp->vehicles[i+j].this_month);
+		DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_THIS, STR_WHITE_NUMBER, 0);
+
+		if (wp->months_counted > ((w->listopt.type_mask == STS_SHOW_YEARLY_STATS) ? 12 : 1)) {
+			SetDParam(0, wp->vehicles[i+j].average / AVERAGE_MULTIPLIER);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_AVERAGE, STR_SILVER_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_min);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_MIN, STR_ORANGE_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_max);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_MAX, STR_LTBLUE_NUMBER, 0);
+		}
+	}
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e)
+{
+	Waypoint *wp = GetWaypoint(w->window_number);
+	switch(e->event)
+	{
+		case WE_TICK: {
+			w->custom[0] = wp->veh_scheduled;
+			InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+			break;
+		}
+		case WE_PAINT: {
+			DrawWaypointStatWindow(w, wp);
+			break;
+			}
+		case WE_CLICK: {
+			switch (e->click.widget)
+			{
+			case 4:	// Reset Statistics
+				if (GetTileOwner(wp->xy) == _current_player) {
+					InitializeWaypointStats(wp);
+					InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+				}
+				break;
+			case 5:	// Show Trains
+				ShowWaypointTrains(GetTileOwner(wp->xy), wp->index);
+				break;
+			case 6:	// Toggle Monthly/Yearly Stats
+				if (w->listopt.type_mask == STS_SHOW_YEARLY_STATS)
+					w->listopt.type_mask = STS_SHOW_MONTHLY_STATS;
+				else
+					w->listopt.type_mask = STS_SHOW_YEARLY_STATS;
+				InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+				break;
+			}
+		} break;
+		case WE_DESTROY: {
+			DeleteWindowById(WC_TRAINS_LIST, GetTileOwner(wp->xy) + ( (wp->index + 1) << 8));
+		} break;
+	}
+}
+
+void ShowWaypointStatsWindow(Waypoint *wp)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_waypoint_view_stats, wp->index);
+	if (w) {
+		color = GetTileOwner(wp->xy);
+		w->listopt.type_mask = STS_SHOW_MONTHLY_STATS;
+		if (color != OWNER_NONE) w->caption_color = color;
+	}
+}
Index: waypoint.h
===================================================================
--- waypoint.h	(revision 2720)
+++ waypoint.h	(working copy)
@@ -4,7 +4,23 @@
 #define WAYPOINT_H
 
 #include "pool.h"
+#include "station.h"
 
+enum {
+	WPS_STATS_TYPES = 4,
+
+	WPS_MONTHLY_STATS_START = 0,
+	WPS_MONTHLY_STATS_END = 2,
+
+	WPS_YEARLY_STATS_START = 2,
+	WPS_YEARLY_STATS_END = 4,
+
+	WPS_ORDER_MONTH = 0, // reached WP by order
+	WPS_PATHFIND_MONTH = 1, // reached WP by normal pathfinding
+	WPS_ORDER_YEAR = 2, // yearly stats by order
+	WPS_PATHFIND_YEAR =3 , // yearly stats by pathfinding
+};
+
 struct Waypoint {
 	TileIndex xy;
 	uint16 index;
@@ -13,12 +29,20 @@
 	byte town_cn;          // The Nth waypoint for this town (consecutive number)
 	StringID string;       // If this is zero, town + town_cn is used for naming
 
+	StationStats vehicles[WPS_STATS_TYPES];
+	uint16 veh_scheduled;
+	uint16 months_counted;
+
 	ViewportSign sign;
 	uint16 build_date;
 	byte stat_id;
 	byte deleted;          // this is a delete counter. when it reaches 0, the waypoint struct is deleted.
 };
 
+void InitializeWaypointStats(Waypoint *wp);
+void ShowWaypointStatsWindow(Waypoint *wp);
+void ShowWaypointTrains(int player, int waypoint);
+
 enum {
 	RAIL_TYPE_WAYPOINT = 0xC4,
 	RAIL_WAYPOINT_TRACK_MASK = 1,
Index: train_gui.c
===================================================================
--- train_gui.c	(revision 2720)
+++ train_gui.c	(working copy)
@@ -18,6 +18,7 @@
 #include "engine.h"
 #include "vehicle_gui.h"
 #include "depot.h"
+#include "waypoint.h"
 
 int _traininfo_vehicle_pitch = 0;
 
@@ -46,6 +47,13 @@
 	DrawString(x,y, STR_PURCHASE_INFO_SPEED_POWER, 0);
 	y += 10;
 
+	/* Max Tractive Effort */
+	if (_patches.realistic_acceleration) {
+		SetDParam(0, rvi->weight * 10 * rvi->TE_coeff / 256); // TE_max in [kN])
+		DrawString(x,y, STR_PURCHASE_INFO_MAX_TE, 0);
+		y += 10;
+	};
+
 	/* Running cost */
 	SetDParam(0, (rvi->running_cost_base * _price.running_rail[rvi->engclass] >> 8) << multihead);
 	DrawString(x,y, STR_PURCHASE_INFO_RUNNINGCOST, 0);
@@ -80,6 +88,7 @@
 	SetDParam(0, e->reliability * 100 >> 16);
 	DrawString(x,y, STR_PURCHASE_INFO_RELIABILITY, 0);
 	y += 10;
+
 }
 
 /**
@@ -109,6 +118,13 @@
 	SetDParam(2, refittable ? STR_9842_REFITTABLE : STR_EMPTY);
 	DrawString(x, y, STR_PURCHASE_INFO_CAPACITY, 0);
 	y += 10;
+
+	/* Max speed */
+	if (rvi->max_speed != 0 && _patches.wagon_speed_limits) {
+		SetDParam(0, rvi->max_speed * 10 >> 4);
+		DrawString(x,y, STR_PURCHASE_INFO_SPEED, 0);
+		y += 10;
+	}
 }
 
 void CcBuildWagon(bool success, TileIndex tile, uint32 p1, uint32 p2)
@@ -154,6 +170,17 @@
 	ShowTrainViewWindow(v);
 }
 
+void CcCloneTrain(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
+
+	if (!success)
+		return;
+
+	v = GetVehicle(_new_train_id);
+	ShowTrainViewWindow(v);
+}
+
 static void engine_drawing_loop(int *x, int *y, int *pos, int *sel,
 	int *selected_id, byte railtype, byte show_max, bool is_engine)
 {
@@ -292,15 +319,15 @@
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   227,     0,    13, STR_JUST_STRING,					STR_018C_WINDOW_TITLE_DRAG_THIS},
 {     WWT_MATRIX, RESIZE_BOTTOM,    14,     0,   215,    14,   125, 0x801,										STR_8843_TRAIN_VEHICLE_SELECTION},
 {  WWT_SCROLLBAR, RESIZE_BOTTOM,    14,   216,   227,    14,   125, 0x0,											STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{      WWT_PANEL,     RESIZE_TB,    14,     0,   227,   126,   197, 0x0,											STR_NULL},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   107,   198,   209, STR_881F_BUILD_VEHICLE,		STR_8844_BUILD_THE_HIGHLIGHTED_TRAIN},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   108,   215,   198,   209, STR_8820_RENAME,					STR_8845_RENAME_TRAIN_VEHICLE_TYPE},
-{  WWT_RESIZEBOX,     RESIZE_TB,    14,   216,   227,   198,   209, 0x0,											STR_RESIZE_BUTTON},
+{      WWT_PANEL,     RESIZE_TB,    14,     0,   227,   126,   207, 0x0,											STR_NULL},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   107,   208,   219, STR_881F_BUILD_VEHICLE,		STR_8844_BUILD_THE_HIGHLIGHTED_TRAIN},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   108,   215,   208,   219, STR_8820_RENAME,					STR_8845_RENAME_TRAIN_VEHICLE_TYPE},
+{  WWT_RESIZEBOX,     RESIZE_TB,    14,   216,   227,   208,   219, 0x0,											STR_RESIZE_BUTTON},
 {   WIDGETS_END},
 };
 
 static const WindowDesc _new_rail_vehicle_desc = {
-	-1, -1, 228, 210,
+	-1, -1, 228, 220,
 	WC_BUILD_VEHICLE,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_RESIZABLE,
 	_new_rail_vehicle_widgets,
@@ -330,7 +357,7 @@
 	}
 }
 
-static void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection)
+void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection)
 {
 	int max_x = x + count * 29;
 
@@ -366,7 +393,7 @@
 
 	/* setup disabled buttons */
 	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 5) | (1 << 8));
+		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 5) | (1 << 8) | (1<<9));
 
 	/* determine amount of items for scroller */
 	num = 0;
@@ -580,6 +607,47 @@
 	}
 }
 
+/**
+ * Clones a train
+ * @param *v is the original vehicle to clone
+ * @param *w is the window of the depot where the clone is build
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	// for train vehicles: subtype 0 for locs and not zero for others
+	if (v->type == VEH_Train && v->subtype != 0) {
+		v = GetFirstVehicleInChain(v);
+		if (v->subtype != 0) // This happens when clicking on a train in depot with no loc attached
+			return false;
+	}else{
+		if (v->type != VEH_Train) {
+			// it's not a train, Do Nothing
+			return false;
+		}
+	}
+
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneTrain,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
 static void TrainDepotWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -590,17 +658,51 @@
 	case WE_CLICK: {
 		switch(e->click.widget) {
 		case 8:
+			ResetObjectToPlace();
 			ShowBuildTrainWindow(w->window_number);
 			break;
-		case 9:
+		case 10:
+			ResetObjectToPlace();
 			ScrollMainWindowToTile(w->window_number);
 			break;
 		case 6:
 			TrainDepotClickTrain(w, e->click.pt.x, e->click.pt.y);
 			break;
+		case 9: /* clone button */
+			InvalidateWidget(w, 9);
+			TOGGLEBIT(w->click_state, 9);
+
+			if (HASBIT(w->click_state, 9)) {
+				_place_clicked_vehicle = NULL;
+				SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, VHM_RECT, w);
+			} else {
+				ResetObjectToPlace();
+			}
+			break;
+
+ 		}
+ 	} break;
+ 
+	case WE_PLACE_OBJ: {
+		ClonePlaceObj(e->place.tile, w);
+	} break;
+
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 9);
+		InvalidateWidget(w, 9);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+	// since OTTD checks all open depot windows, we will make sure that it triggers the one with a clicked clone button
+		if (v != NULL && HASBIT(w->click_state, 9)) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick( v, w);
 		}
 	} break;
 
+
 	case WE_DESTROY:
 		DeleteWindowById(WC_BUILD_VEHICLE, w->window_number);
 		break;
@@ -680,10 +782,14 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   325,    14,    97, 0x601,									STR_883F_TRAINS_CLICK_ON_TRAIN_FOR},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   349,   360,    14,   109, 0x0,										STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   167,   110,   121, STR_8815_NEW_VEHICLES,	STR_8840_BUILD_NEW_TRAIN_VEHICLE},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   168,   348,   110,   121, STR_00E4_LOCATION,			STR_8842_CENTER_MAIN_VIEW_ON_TRAIN},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   116,   110,   121, STR_8815_NEW_VEHICLES,	STR_8840_BUILD_NEW_TRAIN_VEHICLE},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,   117,   232,   110,   121, STR_CLONE_TRAIN,		STR_CLONE_TRAIN_DEPOT_INFO},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   233,   348,   110,   121, STR_00E4_LOCATION,			STR_8842_CENTER_MAIN_VIEW_ON_TRAIN},
+
+
 { WWT_HSCROLLBAR,    RESIZE_RTB,    14,     0,   325,    98,   109, 0x0,										STR_HSCROLL_BAR_SCROLLS_LIST},
 {      WWT_PANEL,    RESIZE_RTB,    14,   349,   348,   110,   121, 0x0,										STR_NULL},
+
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   349,   360,   110,   121, 0x0,										STR_RESIZE_BUTTON},
 {   WIDGETS_END},
 };
@@ -803,6 +909,7 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B2,    STR_8847_SHOW_TRAIN_S_ORDERS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249, 104, 121, 0x2B3,    STR_884C_SHOW_TRAIN_DETAILS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B4,    STR_RAIL_REFIT_VEHICLE_TO_CARRY },
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_CLONE_TRAIN_INFO },
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 122, 121, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 122, 133, 0x0,      STR_NULL },
 { WIDGETS_END }
@@ -920,6 +1027,9 @@
 		case 12:
 			ShowRailVehicleRefitWindow(v);
 			break;
+		case 13:
+			DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, NULL, CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+			break;
 		}
 	} break;
 
@@ -942,7 +1052,7 @@
 
 		v = GetVehicle(w->window_number);
 		assert(v->type == VEH_Train);
-		h = CheckTrainStoppedInDepot(v) >= 0 ? (1 << 9) : (1 << 12);
+		h = CheckTrainStoppedInDepot(v) >= 0 ? (1 << 9)| (1 << 7) : (1 << 12) | (1 << 13);
 		if (h != w->hidden_state) {
 			w->hidden_state = h;
 			SetWindowDirty(w);
@@ -1287,7 +1397,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Train, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1483,6 +1593,13 @@
 		w = AllocateWindowDescFront(&_other_player_trains_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Train;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = player;
 		w->hscroll.cap = 10;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
@@ -1492,3 +1609,27 @@
 		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
 	}
 }
+
+void ShowWaypointTrains(int player, int waypoint)
+{
+	Window *w;
+
+	if (player == _local_player) {
+		w = AllocateWindowDescFront(&_player_trains_desc, (waypoint << 16) | player);
+	} else {
+		w = AllocateWindowDescFront(&_other_player_trains_desc, (waypoint << 16) | player);
+	}
+	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Train;
+		w->listopt.xy = GetWaypoint(waypoint)->xy;
+
+		w->caption_color = player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 7; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_SMALL;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
+	}
+}
Index: station.h
===================================================================
--- station.h	(revision 2720)
+++ station.h	(working copy)
@@ -8,7 +8,125 @@
 #include "sprite.h"
 #include "tile.h"
 #include "vehicle.h"
+#include "openttd.h"
+#include "engine.h"
 
+static inline CargoID GetGlobalCargoID(byte current_landscape, byte cargo_id)
+{
+	assert(current_landscape < NUM_LANDSCAPE && cargo_id < NUM_CARGO);
+	return _global_cargo_id[current_landscape][cargo_id];
+}
+
+static inline CargoID GetLocalCargoID(byte global_cargo_id)
+{
+	assert(global_cargo_id < NUM_GLOBAL_CID);
+	return _local_cargo_id_ctype[global_cargo_id];
+}
+
+enum {
+	RP_NUM_TYPES = 4,
+};
+
+enum {
+	RP_T_SPEED_CAP = 300,
+	RP_T_SPEED_PASS_BONUS = -85,
+	RP_T_SPEED_CARGO_BONUS = -60,
+	RP_SPEED_MULT = 2,
+	RP_R_SPEED_PASS_BONUS = -20,
+	RP_R_SPEED_CARGO_BONUS = 5,
+	RP_S_SPEED_MULT = 2,
+	RP_MAX_SPEED_POINTS = 170,
+
+	RP_AGE_BONUS_0 = 13,
+	RP_AGE_BONUS_1 = 9,
+	RP_AGE_BONUS_2 = 6,
+	RP_AGE_BONUS_3 = 4,
+	RP_AGE_BONUS_4 = 2,
+	RP_AGE_BONUS_5 = 1,
+	RP_AGE_T_CLAMP = 15,
+	RP_AGE_R_CLAMP = 8,
+	RP_AGE_S_CLAMP = 20,
+	RP_AGE_A_CLAMP = 12,
+	RP_MAX_AGE = 20,
+	RP_MAX_AGE_POINTS = 20,
+
+	RP_OTHER_STATUE = 6,
+	RP_OTHER_LA_MULT = 50,
+
+	RP_DAYS_T_CLAMP = 28,
+	RP_DAYS_R_CLAMP = 56,
+	RP_DAYS_S_CLAMP = 112,
+	RP_DAYS_A_CLAMP = 14,
+	RP_MAX_DAYS = 28,
+	RP_DAYS_BONUS_0 = 18,
+	RP_DAYS_BONUS_1 = 17,
+	RP_DAYS_BONUS_2 = 16,
+	RP_DAYS_BONUS_3 = 10,
+	RP_DAYS_BONUS_4 = 9,
+	RP_DAYS_BONUS_5 = 8,
+	RP_DAYS_BONUS_6 = 2,
+	RP_DAYS_BONUS_7 = 1,
+	RP_MAX_DAYS_POINTS = 112,
+
+	RP_WAIT_T_CLAMP = 1800,
+	RP_WAIT_R_CLAMP = 900,
+	RP_WAIT_S_CLAMP = 1500,
+	RP_WAIT_A_CLAMP = 1200,
+	RP_MAX_WAIT = 120,
+	RP_MAX_WAIT_POINTS = 30,
+	RP_WAIT_BONUS_0 = 10,
+	RP_WAIT_BONUS_1 = 7,
+	RP_WAIT_BONUS_2 = 5,
+	RP_WAIT_BONUS_3 = 3,
+	RP_WAIT_BONUS_4 = 2,
+	RP_WAIT_BONUS_5 = 1,
+
+	MAX_CARGO_WAITING = 0xFFF,
+};
+
+enum {
+	STS_NO_MONTHS_COUNTED = 0,
+	STS_AMOUNT_IN = 0,
+	STS_AMOUNT_OUT = 1,
+	STS_AMOUNT_TRANSFER = 2,
+	STS_VEH_TRAIN = 0,
+	STS_VEH_ROAD = 1,
+	STS_VEH_BUS = 2,
+	STS_VEH_TRUCK = 3,
+	STS_VEH_SHIP = 4,
+	STS_VEH_AIRCRAFT = 5,
+	STS_VEH_TYPES = 6,
+	STS_AMNT_TYPES = 3,
+	AVERAGE_MULTIPLIER = 10000, // controls how much digits behind comma are stored for average
+	STS_SHOW_MONTHLY_STATS = 0,
+	STS_SHOW_YEARLY_STATS = 1,
+	STS_SHOW_AVERAGE_STATS = 1,
+	STS_INIT_MINIMUM = 0xFFFF,
+};
+
+enum {
+	ST_VIEW_HEIGHT         = 122,
+	ST_VIEW_EXP_HEIGHT     = 222,
+};
+
+enum {
+	RATING_WAITING = 0,
+	RATING_SPEED = 1,
+	RATING_AGE = 2,
+	RATING_PICKUP = 3,
+	RATING_OTHER = 4,
+	RATING_TOTAL = 5,
+	NUM_RATINGS = 6,
+};
+
+typedef struct StationStats {
+	uint16 this_month;
+	uint16 last_month;
+	uint16 month_min;
+	uint16 month_max;
+	uint32 average;
+} StationStats;
+
 typedef struct GoodsEntry {
 	uint16 waiting_acceptance;
 	byte days_since_pickup;
@@ -17,7 +135,12 @@
 	byte enroute_time;
 	byte last_speed;
 	byte last_age;
+
+	StationStats cargo_amount[STS_AMNT_TYPES];
+	uint16 months_counted;
 	int32 feeder_profit;
+	int last_vehicle_type;
+	uint16 last_vehicle_speed;
 } GoodsEntry;
 
 typedef enum RoadStopType {
@@ -26,10 +149,14 @@
 } RoadStopType;
 
 enum {
-	INVALID_STATION = 0xFFFF,
-	INVALID_SLOT = 0xFFFF,
-	NUM_SLOTS = 2,
-	ROAD_STOP_LIMIT = 8,
+	INVALID_STATION     = 0xFFFF,
+	INVALID_STATION_OLD = 0xFF,
+	INVALID_SLOT        = 0xFFFF,
+	INVALID_AGE         = 0xFF,
+	INVALID_TIME        = 0xFF,
+	NUM_SLOTS           = 2,
+	ROAD_STOP_LIMIT     = 8,
+	RATING_START_VALUE  = 175,
 };
 
 typedef uint16 StationID;
@@ -46,6 +173,14 @@
 	struct RoadStop *prev;
 } RoadStop;
 
+typedef struct RatingStats {
+	uint16 last_speed;
+	byte last_age;
+	byte days_since_pickup;
+	uint16 waiting;
+	int16 ratings[NUM_RATINGS];
+} RatingStats;
+
 struct Station {
 	TileIndex xy;
 	RoadStop *bus_stops;
@@ -80,7 +215,12 @@
 
 	VehicleID last_vehicle;
 	GoodsEntry goods[NUM_CARGO];
+	RatingStats rating_stats[NUM_CARGO];
 
+	StationStats vehicles[STS_VEH_TYPES];
+	uint16 veh_scheduled[STS_VEH_TYPES];
+	uint16 months_counted;
+
 	/* Stuff that is no longer used, but needed for conversion */
 	TileIndex bus_tile_obsolete;
 	TileIndex lorry_tile_obsolete;
@@ -125,9 +265,16 @@
 
 void ModifyStationRatingAround(TileIndex tile, byte owner, int amount, uint radius);
 
+void SearchVehiclesForStation(Station *st);
+void ShowStationStatsWindow(int station);
+void InitializeStationStats(Station *st);
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted);
+void ShowPlayerVehicles(int player, int station, uint32 type_mask, uint64 cargo_mask, TileIndex xy);
+
 TileIndex GetStationTileForVehicle(const Vehicle *v, const Station *st);
 
 void ShowStationViewWindow(int station);
+void ShowStationRatingDetail(int station);
 void UpdateAllStationVirtCoord(void);
 
 VARDEF SortStruct *_station_sort;
@@ -324,4 +471,6 @@
 	return (_m[tile].m5 - 0x43) & 3;
 }
 
+int32 ClickResetStationCheat(int32 cheat_activated, int32 NOT_USED);
+
 #endif /* STATION_H */
Index: rail_gui.c
===================================================================
--- rail_gui.c	(revision 2720)
+++ rail_gui.c	(working copy)
@@ -24,7 +24,19 @@
 static byte _build_depot_direction;
 static byte _waypoint_count=1;
 static byte _cur_waypoint_type;
+static byte _cur_signal_type;
+static byte _cur_presig_type;
+static bool _cur_autosig_compl;
 
+static const StringID _presig_types_dropdown[] = {
+	STR_SIGNAL_NORMAL,
+	STR_SIGNAL_ENTRANCE,
+	STR_SIGNAL_EXIT,
+	STR_SIGNAL_COMBO,
+	STR_SIGNAL_PBS,
+	INVALID_STRING_ID
+};
+
 struct {
 	byte orientation;
 	byte numtracks;
@@ -37,6 +49,7 @@
 static void ShowBuildTrainDepotPicker(void);
 static void ShowBuildWaypointPicker(void);
 static void ShowStationBuilder(void);
+static void ShowSignalBuilder(void);
 
 typedef void OnButtonClick(Window *w);
 
@@ -172,8 +185,10 @@
 	if (trackstat != 0) {	while (!(trackstat & 1)) { i++; trackstat >>= 1; }}
 
 	if (!_remove_button_clicked) {
-		DoCommandP(tile, i + (_ctrl_pressed ? 8 : 0), 0, CcPlaySound1E,
-			CMD_BUILD_SIGNALS | CMD_AUTO | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE));
+		DoCommandP(tile, i + (_ctrl_pressed ? 8 : 0) +
+		                 (!HASBIT(_cur_signal_type, 0) != !_ctrl_pressed ? 16 : 0) +
+		                 (_cur_presig_type << 5) ,
+		                 0, CcPlaySound1E, CMD_BUILD_SIGNALS | CMD_AUTO | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE));
 	} else {
 		DoCommandP(tile, i, 0, CcPlaySound1E,
 			CMD_REMOVE_SIGNALS | CMD_AUTO | CMD_MSG(STR_1013_CAN_T_REMOVE_SIGNALS_FROM));
@@ -254,7 +269,8 @@
 
 static void BuildRailClick_Depot(Window *w)
 {
-	if (HandlePlacePushButton(w, 10, _depot_cursors[_cur_railtype], 1, PlaceRail_Depot)) ShowBuildTrainDepotPicker();
+	if (HandlePlacePushButton(w, 10, _depot_cursors[_cur_railtype], 1, PlaceRail_Depot))
+		ShowBuildTrainDepotPicker();
 }
 
 static void BuildRailClick_Waypoint(Window *w)
@@ -272,7 +288,8 @@
 
 static void BuildRailClick_AutoSignals(Window *w)
 {
-	HandlePlacePushButton(w, 13, ANIMCURSOR_BUILDSIGNALS, VHM_RECT, PlaceRail_AutoSignals);
+	if (HandlePlacePushButton(w, 13, ANIMCURSOR_BUILDSIGNALS, VHM_RECT, PlaceRail_AutoSignals))
+		ShowSignalBuilder();
 }
 
 static void BuildRailClick_Bridge(Window *w)
@@ -351,10 +368,11 @@
 	// _patches.drag_signals_density is given as a parameter such that each user in a network
 	// game can specify his/her own signal density
 	DoCommandP(TileVirtXY(thd->selstart.x, thd->selstart.y), TileVirtXY(thd->selend.x, thd->selend.y),
-	(_ctrl_pressed ? 1 << 3 : 0) | (trackstat << 4) | (_patches.drag_signals_density << 24),
-	CcPlaySound1E,
-	(_remove_button_clicked ?	CMD_REMOVE_SIGNAL_TRACK | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1013_CAN_T_REMOVE_SIGNALS_FROM) :
-	                          CMD_BUILD_SIGNAL_TRACK  | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE) ) );
+		(!HASBIT(_cur_signal_type, 0) != !_ctrl_pressed ? 1 << 3 : 0) | (trackstat << 4) |
+		(_patches.drag_signals_density << 24) | (_cur_autosig_compl ? 2 : 0),
+		CcPlaySound1E,
+		(_remove_button_clicked ?	CMD_REMOVE_SIGNAL_TRACK | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1013_CAN_T_REMOVE_SIGNALS_FROM) :
+		                          CMD_BUILD_SIGNAL_TRACK  | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE) ) );
 }
 
 static OnButtonClick * const _build_railroad_button_proc[] = {
@@ -474,6 +492,9 @@
 		if (w != NULL) WP(w,def_d).close=true;
 		w = FindWindowById(WC_BUILD_DEPOT, 0);
 		if (w != NULL) WP(w,def_d).close=true;
+		w = FindWindowById(WC_BUILD_SIGNALS, 0);
+		if (w != NULL) WP(w,def_d).close=true;
+
 		break;
 
 	case WE_PLACE_PRESIZE: {
@@ -938,10 +959,123 @@
 }
 
 
+static void BuildSignalWndProc(Window *w, WindowEvent *e)
+{
+	switch(e->event) {
+	case WE_PAINT: {
+		/* XXX TODO: dont always hide the buttons when more than 2 signal types are available */
+		w->hidden_state = (1 << 3) | (1 << 6);
+
+		/* XXX TODO: take into account the scroll position for setting the click state */
+		w->click_state = ((1 << 4) << _cur_signal_type) | (_cur_autosig_compl ? 1 << 9 : 0);
+
+		SetDParam(10, _presig_types_dropdown[_cur_presig_type]);
+		DrawWindowWidgets(w);
+
+		// Draw the string for current signal type
+		DrawStringCentered(69, 49, STR_SIGNAL_TYPE_STANDARD + _cur_signal_type, 0);
+
+		// Draw the strings for drag density
+		DrawStringCentered(69, 60, STR_SIGNAL_DENSITY_DESC, 0);
+		SetDParam(0, _patches.drag_signals_density);
+		DrawString( 50, 71, STR_SIGNAL_DENSITY_TILES , 0);
+
+		// Draw the '<' and '>' characters for the decrease/increase buttons
+		DrawStringCentered(30, 72, STR_6819, 0);
+		DrawStringCentered(40, 72, STR_681A, 0);
+
+		break;
+		}
+	case WE_CLICK: {
+		switch(e->click.widget) {
+			case 3: case 6: // scroll signal types
+				/* XXX TODO: implement scrolling */
+				break;
+			case 4: case 5: // select signal type
+				/* XXX TODO: take into account the scroll position for changing selected type */
+				_cur_signal_type = e->click.widget - 4;
+				SndPlayFx(SND_15_BEEP);
+				SetWindowDirty(w);
+				break;
+			case 7: // decrease drag density
+				if (_patches.drag_signals_density > 1) {
+					_patches.drag_signals_density--;
+					SndPlayFx(SND_15_BEEP);
+					SetWindowDirty(w);
+				};
+				break;
+			case 8: // increase drag density
+				if (_patches.drag_signals_density < 20) {
+					_patches.drag_signals_density++;
+					SndPlayFx(SND_15_BEEP);
+					SetWindowDirty(w);
+				};
+				break;
+			case 9: // autosignal mode toggle button
+				_cur_autosig_compl ^= 1;
+				SndPlayFx(SND_15_BEEP);
+				SetWindowDirty(w);
+				break;
+			case 10: case 11: // presignal-type dropdown list
+				ShowDropDownMenu(w, _presig_types_dropdown, _cur_presig_type, 11, 0, 0);
+				break;
+		}
+		break;
+	case WE_DROPDOWN_SELECT: // change presignal type
+		_cur_presig_type = e->dropdown.index;
+		SetWindowDirty(w);
+		break;
+	}
+
+	case WE_MOUSELOOP:
+		if (WP(w,def_d).close)
+			DeleteWindow(w);
+		return;
+
+	case WE_DESTROY:
+		if (!WP(w,def_d).close)
+			ResetObjectToPlace();
+		break;
+	}
+}
+
+static const Widget _build_signal_widgets[] = {
+{   WWT_CLOSEBOX, RESIZE_NONE,    7,    0,   10,    0,   13, STR_00C5                 , STR_018B_CLOSE_WINDOW},
+{   WWT_CAPTION,  RESIZE_NONE,    7,   11,  139,    0,   13, STR_SIGNAL_SELECTION     , STR_018C_WINDOW_TITLE_DRAG_THIS},
+{   WWT_PANEL,    RESIZE_NONE,    7,    0,  139,   14,  114, 0x0                      , STR_NULL},
+{   WWT_PANEL,    RESIZE_NONE,    7,   22,   30,   29,   39, SPR_ARROW_LEFT           , STR_SIGNAL_TYPE_TIP},
+{   WWT_PANEL,    RESIZE_NONE,    7,   43,   64,   24,   45, 0x50B                    , STR_SIGNAL_TYPE_TIP},
+{   WWT_PANEL,    RESIZE_NONE,    7,   75,   96,   24,   45, SPR_SEMA                 , STR_SIGNAL_TYPE_TIP},
+{   WWT_PANEL,    RESIZE_NONE,    7,  109,  117,   29,   39, SPR_ARROW_RIGHT          , STR_SIGNAL_TYPE_TIP},
+{   WWT_IMGBTN,   RESIZE_NONE,    3,   25,   34,   72,   80, 0x0                      , STR_SIGNAL_DENSITY_TIP},
+{   WWT_IMGBTN,   RESIZE_NONE,    3,   35,   44,   72,   80, 0x0                      , STR_SIGNAL_DENSITY_TIP},
+{   WWT_TEXTBTN,  RESIZE_NONE,    7,   20,  119,   84,   95, STR_SIGNAL_COMPLETION    , STR_SIGNAL_COMPLETION_TIP},
+{   WWT_6,        RESIZE_NONE,    7,   10,  129,   99,  110, STR_SIGNAL_PRESIG_COMBO  , STR_SIGNAL_PRESIG_TIP},
+{   WWT_CLOSEBOX, RESIZE_NONE,    7,  118,  128,  100,  109, STR_0225                 , STR_SIGNAL_PRESIG_TIP},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _build_signal_desc = {
+	-1,-1, 140, 115,
+	WC_BUILD_SIGNALS,WC_BUILD_TOOLBAR,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET,
+	_build_signal_widgets,
+	BuildSignalWndProc
+};
+
+static void ShowSignalBuilder(void)
+{
+	_cur_presig_type = 0;
+	AllocateWindowDesc(&_build_signal_desc);
+}
+
 void InitializeRailGui(void)
 {
 	_build_depot_direction = 3;
 	_railstation.numtracks = 1;
 	_railstation.platlength = 1;
 	_railstation.dragdrop = true;
+	_cur_signal_type = 0;
+	_cur_presig_type = 0;
+	_cur_autosig_compl = false;
 }
Index: settings_gui.c
===================================================================
--- settings_gui.c	(revision 2720)
+++ settings_gui.c	(working copy)
@@ -705,6 +705,7 @@
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_AIRCRAFT, "servint_aircraft", &_patches.servint_aircraft, 5,800,  5, &InValidateDetailsWindow},
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_SHIPS,		"servint_ships",    &_patches.servint_ships,		5,800,  5, &InValidateDetailsWindow},
 	{PE_BOOL,   0,         STR_CONFIG_PATCHES_NOSERVICE,        "no_servicing_if_no_breakdowns", &_patches.no_servicing_if_no_breakdowns, 0, 0, 0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_WAGONSPEEDLIMITS,	"wagon_speed_limits", &_patches.wagon_speed_limits,		0,  0,  0, NULL},
 };
 
 static const PatchEntry _patches_stations[] = {
@@ -718,6 +719,12 @@
 	{PE_BOOL,		0, STR_CONFIG_PATCHES_SERVICEATHELIPAD, "service_at_helipad", &_patches.serviceathelipad,					0,  0,  0, NULL},
 	{PE_BOOL, 0, STR_CONFIG_PATCHES_CATCHMENT, "modified_catchment", &_patches.modified_catchment, 0, 0, 0, NULL},
 
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_SPEED, "nsr_speed", &_patches.nsr_speed,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_AGE, "nsr_age", &_patches.nsr_age,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_TOWN_RATING, "nsr_town_rating", &_patches.nsr_town_rating,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_WAIT_DAYS, "nsr_wait_days", &_patches.nsr_wait_days,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_WAIT_CARGO, "nsr_wait_cargo", &_patches.nsr_wait_cargo,					0,  0,  0, NULL},
+
 };
 
 static const PatchEntry _patches_economy[] = {
@@ -1126,7 +1133,7 @@
 {   WWT_CLOSEBOX,   RESIZE_NONE,    10,     0,    10,     0,    13, STR_00C5,												STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    10,    11,   369,     0,    13, STR_CONFIG_PATCHES_CAPTION,			STR_018C_WINDOW_TITLE_DRAG_THIS},
 {      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    14,    41, 0x0,															STR_NULL},
-{      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    42,   320, 0x0,															STR_NULL},
+{      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    42,   340, 0x0,															STR_NULL},
 
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    10,    96,    16,    27, STR_CONFIG_PATCHES_GUI,					STR_NULL},
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    97,   183,    16,    27, STR_CONFIG_PATCHES_CONSTRUCTION,	STR_NULL},
@@ -1138,7 +1145,7 @@
 };
 
 static const WindowDesc _patches_selection_desc = {
-	WDP_CENTER, WDP_CENTER, 370, 321,
+	WDP_CENTER, WDP_CENTER, 370, 341,
 	WC_GAME_OPTIONS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET,
 	_patches_selection_widgets,
Index: ship_gui.c
===================================================================
--- ship_gui.c	(revision 2720)
+++ ship_gui.c	(working copy)
@@ -62,7 +62,7 @@
 	y += 10;
 }
 
-static void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetShipImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -320,6 +320,15 @@
 	ShowShipViewWindow(v);
 }
 
+void CcCloneShip(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
+	if (!success) return;
+
+	v = GetVehicle(_new_ship_id);
+	ShowShipViewWindow(v);
+}
+
 static void NewShipWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -465,60 +474,60 @@
 
 static void ShipViewWndProc(Window *w, WindowEvent *e) {
 	switch(e->event) {
-	case WE_PAINT: {
-		Vehicle *v = GetVehicle(w->window_number);
-		uint32 disabled = 1<<8;
-		StringID str;
+		case WE_PAINT: {
+			Vehicle *v = GetVehicle(w->window_number);
+			uint32 disabled = 1<<8;
+			StringID str;
 
-		// Possible to refit?
-		if (ShipVehInfo(v->engine_type)->refittable &&
+			// Possible to refit?
+			if (ShipVehInfo(v->engine_type)->refittable &&
 				v->vehstatus&VS_STOPPED &&
 				v->u.ship.state == 0x80 &&
 				IsTileDepotType(v->tile, TRANSPORT_WATER))
-			disabled = 0;
+				disabled = 0;
 
-		if (v->owner != _local_player)
-			disabled |= 1<<8 | 1<<7;
-		w->disabled_state = disabled;
+			if (v->owner != _local_player)
+				disabled |= 1<<8 | 1<<7;
+			w->disabled_state = disabled;
 
-		/* draw widgets & caption */
-		SetDParam(0, v->string_id);
-		SetDParam(1, v->unitnumber);
-		DrawWindowWidgets(w);
+			/* draw widgets & caption */
+			SetDParam(0, v->string_id);
+			SetDParam(1, v->unitnumber);
+			DrawWindowWidgets(w);
 
-		if (v->breakdown_ctr == 1) {
-			str = STR_885C_BROKEN_DOWN;
-		} else if (v->vehstatus & VS_STOPPED) {
-			str = STR_8861_STOPPED;
-		} else {
-			switch (v->current_order.type) {
-			case OT_GOTO_STATION: {
-				SetDParam(0, v->current_order.station);
-				SetDParam(1, v->cur_speed * 10 >> 5);
-				str = STR_HEADING_FOR_STATION + _patches.vehicle_speed;
-			} break;
+			if (v->breakdown_ctr == 1) {
+				str = STR_885C_BROKEN_DOWN;
+			} else if (v->vehstatus & VS_STOPPED) {
+				str = STR_8861_STOPPED;
+			} else {
+				switch (v->current_order.type) {
+					case OT_GOTO_STATION: {
+						SetDParam(0, v->current_order.station);
+						SetDParam(1, v->cur_speed * 10 >> 5);
+						str = STR_HEADING_FOR_STATION + _patches.vehicle_speed;
+					} break;
 
-			case OT_GOTO_DEPOT: {
-				Depot *depot = GetDepot(v->current_order.station);
-				SetDParam(0, depot->town_index);
-				SetDParam(1, v->cur_speed * 10 >> 5);
-				str = STR_HEADING_FOR_SHIP_DEPOT + _patches.vehicle_speed;
-			} break;
+					case OT_GOTO_DEPOT: {
+						Depot *depot = GetDepot(v->current_order.station);
+						SetDParam(0, depot->town_index);
+						SetDParam(1, v->cur_speed * 10 >> 5);
+						str = STR_HEADING_FOR_SHIP_DEPOT + _patches.vehicle_speed;
+					} break;
 
-			case OT_LOADING:
-			case OT_LEAVESTATION:
-				str = STR_882F_LOADING_UNLOADING;
-				break;
-
-			default:
-				if (v->num_orders == 0) {
-					str = STR_NO_ORDERS + _patches.vehicle_speed;
-					SetDParam(0, v->cur_speed * 10 >> 5);
-				} else
-					str = STR_EMPTY;
-				break;
+					case OT_LOADING:
+					case OT_LEAVESTATION:
+						str = STR_882F_LOADING_UNLOADING;
+						break;
+						
+					default:
+						if (v->num_orders == 0) {
+							str = STR_NO_ORDERS + _patches.vehicle_speed;
+							SetDParam(0, v->cur_speed * 10 >> 5);
+						} else
+							str = STR_EMPTY;
+						break;
+				}
 			}
-		}
 
 		/* draw the flag plus orders */
 		DrawSprite(v->vehstatus & VS_STOPPED ? 0xC12 : 0xC13, 2, w->widget[5].top + 1);
@@ -526,43 +535,61 @@
 		DrawWindowViewport(w);
 	} break;
 
-	case WE_CLICK: {
-		Vehicle *v = GetVehicle(w->window_number);
+		case WE_CLICK: {
+			Vehicle *v = GetVehicle(w->window_number);
 
-		switch(e->click.widget) {
-		case 5: /* start stop */
-			DoCommandP(v->tile, v->index, 0, NULL, CMD_START_STOP_SHIP | CMD_MSG(STR_9818_CAN_T_STOP_START_SHIP));
+			switch(e->click.widget) {
+				case 5: /* start stop */
+					DoCommandP(v->tile, v->index, 0, NULL, CMD_START_STOP_SHIP | CMD_MSG(STR_9818_CAN_T_STOP_START_SHIP));
+					break;
+				case 6: /* center main view */
+					ScrollMainWindowTo(v->x_pos, v->y_pos);
+					break;
+				case 7: /* goto hangar */
+					DoCommandP(v->tile, v->index, 0, NULL, CMD_SEND_SHIP_TO_DEPOT | CMD_MSG(STR_9819_CAN_T_SEND_SHIP_TO_DEPOT));
+					break;
+				case 8: /* refit */
+					ShowShipRefitWindow(v);
+					break;
+				case 9: /* show orders */
+					ShowOrdersWindow(v);
+					break;
+				case 10: /* show details */
+					ShowShipDetailsWindow(v);
+					break;
+				case 11: {
+					/* clone vehicle */
+					Vehicle *v;
+					v = GetVehicle(w->window_number);
+					DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, CcCloneShip, CMD_CLONE_VEHICLE | CMD_MSG(STR_980D_CAN_T_BUILD_SHIP));
+				} break;
+			}
+		} break;
+
+		case WE_RESIZE:
+			w->viewport->width  += e->sizing.diff.x;
+			w->viewport->height += e->sizing.diff.y;
+			w->viewport->virtual_width  += e->sizing.diff.x;
+			w->viewport->virtual_height += e->sizing.diff.y;
 			break;
-		case 6: /* center main view */
-			ScrollMainWindowTo(v->x_pos, v->y_pos);
+
+		case WE_DESTROY:
+			DeleteWindowById(WC_VEHICLE_ORDERS, w->window_number);
+			DeleteWindowById(WC_VEHICLE_REFIT, w->window_number);
+			DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
 			break;
-		case 7: /* goto hangar */
-			DoCommandP(v->tile, v->index, 0, NULL, CMD_SEND_SHIP_TO_DEPOT | CMD_MSG(STR_9819_CAN_T_SEND_SHIP_TO_DEPOT));
-			break;
-		case 8: /* refit */
-			ShowShipRefitWindow(v);
-			break;
-		case 9: /* show orders */
-			ShowOrdersWindow(v);
-			break;
-		case 10: /* show details */
-			ShowShipDetailsWindow(v);
-			break;
+
+		case WE_MOUSELOOP:
+		{
+			Vehicle *v;
+			uint32 h;
+			v = GetVehicle(w->window_number);
+			h = IsTileDepotType(v->tile, TRANSPORT_WATER) && v->vehstatus & VS_HIDDEN ? (1<< 7) : (1 << 11);
+			if (h != w->hidden_state) {
+				w->hidden_state = h;
+				SetWindowDirty(w);
+			}
 		}
-	} break;
-
-	case WE_RESIZE:
-		w->viewport->width  += e->sizing.diff.x;
-		w->viewport->height += e->sizing.diff.y;
-		w->viewport->virtual_width  += e->sizing.diff.x;
-		w->viewport->virtual_height += e->sizing.diff.y;
-		break;
-
-	case WE_DESTROY:
-		DeleteWindowById(WC_VEHICLE_ORDERS, w->window_number);
-		DeleteWindowById(WC_VEHICLE_REFIT, w->window_number);
-		DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
-		break;
 	}
 }
 
@@ -578,6 +605,7 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  50,  67, 0x2B4,    STR_983A_REFIT_CARGO_SHIP_TO_CARRY},
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B2,    STR_9828_SHOW_SHIP_S_ORDERS},
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B3,    STR_982B_SHOW_SHIP_DETAILS},
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_CLONE_SHIP_INFO},
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 104, 103, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 104, 115, 0x0,      STR_NULL },
 { WIDGETS_END }
@@ -720,6 +748,41 @@
 	}
 }
 
+/**
+ * Clones a ship
+ * @param *v is the original vehicle to clone
+ * @param *w is the window of the depot where the clone is build
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	if (v->type != VEH_Ship) {
+		// it's not a ship, do nothing
+		return false;
+	}
+
+
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneShip,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
 static void ShipDepotWndProc(Window *w, WindowEvent *e) {
 	switch(e->event) {
 	case WE_PAINT:
@@ -733,15 +796,50 @@
 			break;
 
 		case 7:
+			ResetObjectToPlace();
 			ShowBuildShipWindow(w->window_number);
 			break;
+			
+			case 8: /* clone button */
+			InvalidateWidget(w, 8);
+				TOGGLEBIT(w->click_state, 8);
+				
+				if (HASBIT(w->click_state, 8)) {
+					_place_clicked_vehicle = NULL;
+					SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, VHM_RECT, w);
+				} else {
+					ResetObjectToPlace();
+				}
+					break;
 
-		case 8: /* scroll to tile */
+		case 9: /* scroll to tile */
+			ResetObjectToPlace();
 			ScrollMainWindowToTile(w->window_number);
 			break;
 		}
 		break;
+		
+	case WE_PLACE_OBJ: {
+		//ClonePlaceObj(e->place.tile, w);
+		ClonePlaceObj(w->window_number, w);
+	} break;
 
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 8);
+		InvalidateWidget(w, 8);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+
+	// since OTTD checks all open depot windows, we will make sure that it triggers the one with a clicked clone button
+		if (v != NULL && HASBIT(w->click_state, 8)) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick(v, w);
+		}
+	} break;
+
 	case WE_DESTROY:
 		DeleteWindowById(WC_BUILD_VEHICLE, w->window_number);
 		break;
@@ -804,8 +902,9 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   269,    14,    61, 0x203,									STR_981F_SHIPS_CLICK_ON_SHIP_FOR},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   293,   304,    14,    61, 0x0,										STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   146,    62,    73, STR_9804_NEW_SHIPS,			STR_9820_BUILD_NEW_SHIP},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   147,   292,    62,    73, STR_00E4_LOCATION,			STR_9822_CENTER_MAIN_VIEW_ON_SHIP},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,    96,    62,    73, STR_9804_NEW_SHIPS,			STR_9820_BUILD_NEW_SHIP},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,    97,   194,    62,    73, STR_CLONE_SHIP,		STR_CLONE_SHIP_DEPOT_INFO},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   195,   292,    62,    73, STR_00E4_LOCATION,			STR_9822_CENTER_MAIN_VIEW_ON_SHIP},
 {      WWT_PANEL,    RESIZE_RTB,    14,   293,   292,    62,    73, 0x0,													STR_NULL},
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   293,   304,    62,    73, 0x0,										STR_RESIZE_BUTTON},
 {   WIDGETS_END},
@@ -909,7 +1008,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Ship, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1104,6 +1203,13 @@
 		w = AllocateWindowDescFront(&_other_player_ships_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Ship;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = w->window_number;
 		w->vscroll.cap = 4;
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: window.h
===================================================================
--- window.h	(revision 2720)
+++ window.h	(working copy)
@@ -37,6 +37,40 @@
    That was all.. good luck, and enjoy :) -- TrueLight */
 
 enum {
+	SUBTYPE_AIRCRAFT = 2,
+	SUBTYPE_NONE     = 0,
+	CARGO_MASK_ALL   = 0xFFFFFFFFFFFFFFFFll,
+	VEHICLE_TYPE_ALL = 0xF0000,
+};
+
+/** Options for building vehicle-lists
+  * stored in the window-struct and used in BuildVehicleList()
+  * 
+  * xy:         xy-value of the station/waypoint/depot the vehicle should be scheduled for
+  *             use INVALID_STATION if you dont want vehicles scheduled for a specific destination
+  * cargo_mask: 64-bit mask using global cargo ids
+  *             determines which vehicles should be selected by cargo-type
+  *             use CARGO_MASK_ALL if you dont want to distinguish by cargo-type
+  * type_mask:  32-bit mask that controls varios parts of the list
+  *             currently implemented:
+  *             Vehicle type: uses bits 16 to 19 (VEH_Train = 16, VEH_Aircraft = 19)
+  *                           to determine which vehicletypes should be selected
+  *                           use VEHICLE_TYPE_ALL if you dont want to distinguish by vehicletype
+  *             also used for statistics-windows to store whether to show monthly, yearly or average statistics
+  *
+  *             planned:
+  *             vehicle-age: select only yehicles older/newer/at given age
+  *             more specific vehicle type: e.g. select a specific Train-Engine to be shown only
+  *             flags: should age be same/higher/lower as given value?
+  *                    include or exclude given vehicle?
+  */
+typedef struct DisplayListOptions {
+	TileIndex xy;
+	uint64 cargo_mask;
+	uint32 type_mask;
+} DisplayListOption;
+
+enum {
 	RESIZE_NONE   = 0,
 
 	RESIZE_LEFT   = 1,
@@ -307,6 +341,8 @@
 
 	Message message;
 	byte custom[WINDOW_CUSTOM_SIZE];
+	
+	DisplayListOption listopt; // Options for displaying vehicle-lists
 };
 
 typedef struct {
Index: command.c
===================================================================
--- command.c	(revision 2720)
+++ command.c	(working copy)
@@ -159,6 +159,10 @@
 
 DEF_COMMAND(CmdReplaceVehicle);
 
+DEF_COMMAND(CmdCloneVehicle);
+
+DEF_COMMAND(CmdResetStationCheat);
+
 /* The master command table */
 static const Command _command_proc_table[] = {
 	{CmdBuildRailroadTrack,                  0}, /*   0 */
@@ -300,6 +304,9 @@
 	{CmdGiveMoney,                           0}, /* 113 */
 	{CmdChangePatchSetting,         CMD_SERVER}, /* 114 */
 	{CmdReplaceVehicle,                      0}, /* 115 */
+	{CmdCloneVehicle,                        0}, /* 116 */
+
+	{CmdResetStationCheat,                   0}, /* 117 */
 };
 
 /* This function range-checks a cmd, and checks if the cmd is not NULL */
@@ -444,7 +451,12 @@
 	// road fragments still stay there and the town won't let you
 	// disconnect the road system), but the exec will succeed and this
 	// fact will trigger an assertion failure. --pasky
+	// CMD_BUILD_SIGNAL_TRACK: With autosignal completion, it could happen
+	// 2 parts of a tile with 2 signals both get changed to semaphores (or back)
+	// cause the semaphore/normal status is stored per-tile, the real run will
+	// only charge you once for changing, but the test run will charge you twice
 	notest =
+		(cmd & 0xFF) == CMD_BUILD_SIGNAL_TRACK ||
 		(cmd & 0xFF) == CMD_CLEAR_AREA ||
 		(cmd & 0xFF) == CMD_CONVERT_RAIL ||
 		(cmd & 0xFF) == CMD_LEVEL_LAND ||
Index: command.h
===================================================================
--- command.h	(revision 2720)
+++ command.h	(working copy)
@@ -136,6 +136,10 @@
 	CMD_CHANGE_PATCH_SETTING = 114,
 
 	CMD_REPLACE_VEHICLE = 115,
+
+	CMD_CLONE_VEHICLE = 116,
+
+	CMD_RESET_STATION_CHEAT = 117,
 };
 
 enum {
Index: newgrf.c
===================================================================
--- newgrf.c	(revision 2720)
+++ newgrf.c	(working copy)
@@ -220,8 +220,10 @@
 			FOR_EACH_OBJECT {
 				uint16 speed = grf_load_word(&buf);
 
+				// we store 'no speed limit' as a speed of 0
+				if (speed == 0xFFFF) speed = 0;
+
 				rvi[i].max_speed = speed;
-				dewagonize(speed, engine + i);
 			}
 		} break;
 		case 0x0B: { /* Power */
@@ -360,6 +362,13 @@
 				rvi[i].callbackmask = callbacks;
 			}
 		} break;
+		case 0x1F: {	/* Tractive effort */
+			FOR_EACH_OBJECT {
+				int8 TE_coeff = grf_load_byte(&buf);
+
+				rvi[i].TE_coeff = TE_coeff;
+			}
+		}	break;
 		case 0x21: { /* Shorter vehicle */
 			FOR_EACH_OBJECT {
 				byte shorten_factor = grf_load_byte(&buf);
@@ -386,7 +395,6 @@
 		/* Fall-through for unimplemented one byte long properties. */
 		case 0x1A:	/* Sort order */
 		case 0x1C:	/* Refit cost */
-		case 0x1F:	/* Tractive effort */
 		case 0x20:	/* Air drag */
 		case 0x24:	/* High byte of vehicle weight */
 		case 0x25:	/* User-defined bit mask to set when checking veh. var. 42 */
@@ -2079,7 +2087,8 @@
 
 	_ttdpatch_flags[2] = (1 << 0x0D)  /* buildonslopes */
 	                   | (1 << 0x16)  /* canals */
-	                   | (1 << 0x17); /* newstartyear */
+	                   | (1 << 0x17)  /* newstartyear */
+	                   | (_patches.wagon_speed_limits ? (1 << 0x1D) : 0); /* wagonspeedlimits */
 }
 
 void InitNewGRFFile(const char *filename, int sprite_offset)
