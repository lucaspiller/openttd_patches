Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 2908)
+++ station_cmd.c	(working copy)
@@ -26,6 +26,10 @@
 #include "sprite.h"
 #include "depot.h"
 #include "pbs.h"
+#include "string.h"
+#include "strings.h"
+#include "newgrf_callbacks.h"
+#include "newgrf.h"
 
 enum {
 	/* Max stations: 64000 (64 * 1000) */
@@ -35,6 +39,9 @@
 	/* Max roadstops: 64000 (32 * 2000) */
 	ROADSTOP_POOL_BLOCK_SIZE_BITS = 5,       /* In bits, so (1 << 5) == 32 */
 	ROADSTOP_POOL_MAX_BLOCKS      = 2000,
+
+	/* Max station classes */
+	STAT_CLASS_MAX = 32,
 };
 
 /**
@@ -281,6 +288,187 @@
 	return NULL;
 }
 
+/**
+ * Marks a StationSegment as deleted.
+ * @param st Station.
+ * @param segid Segment index.
+ */
+static void StationSegmentDelete(Station *st, byte segid)
+{
+	int i = st->num_segments;
+	st->segments[segid].tile = INVALID_TILE;
+	free(st->segments[segid].random_bits);
+
+	while (i > 0 && st->segments[i-1].tile == INVALID_TILE) {
+		i--;
+	}
+
+	if (i == 0) {
+		// All segments are deleted so free the memory.
+		free(st->segments);
+		st->segments = NULL;
+		st->num_segments = 0;
+	} else if (i < st->num_segments) {
+		// Empty segments at end of list, free the unused memory.
+		st->segments = realloc(st->segments, i * sizeof(StationSegment));
+		st->num_segments = i;
+	}
+}
+
+/**
+ * Checks if a StationSegment is still valid by looping on all the tiles of
+ * the segment and checking that each tile is a station tile, in the correct
+ * station and with this segment index. If at least one does, then the segment
+ * is still in use.
+ * @param st Station.
+ * @param segid Segment index.
+ * @return True if the segment is in use.
+ */
+static bool StationSegmentInUse(Station *st, byte segid)
+{
+	StationSegment *segment = &st->segments[segid];
+	int h, w;
+
+	if (segment->direction) {
+		h = segment->length;
+		w = segment->platforms;
+	} else {
+		w = segment->length;
+		h = segment->platforms;
+	}
+
+	BEGIN_TILE_LOOP(t, w, h, segment->tile) {
+		if (IsTileType(t, MP_STATION) && _m[t].m2 == st->index && _m[t].m4 == segid)
+			return true;
+	} END_TILE_LOOP(t, w, h, segment->tile)
+
+	return false;
+}
+
+/**
+ * Returns an unused StationSegment.
+ * platforms and length are only used to calculate the size of the random bit array.
+ * @param st Station.
+ * @param platforms Number of platforms.
+ * @param length Length of platforms.
+ * @return Index of segment.
+ */
+static int StationSegmentAllocate(Station *st, byte platforms, byte length)
+{
+	int i;
+
+	for (i = 0; i < st->num_segments; i++) {
+		if (st->segments[i].tile == INVALID_TILE) {
+			/* Reuse existing deleted segment. */
+			st->segments[i].random_bits = malloc((platforms * length));
+			return i;
+		} else if (!StationSegmentInUse(st, i)) {
+			/* Segments can be overwritten but not deleted. Here we have found
+			 * such a segment, so reuse it. */
+			free(st->segments[i].random_bits);
+			st->segments[i].random_bits = malloc((platforms * length));
+			return i;
+		}
+	}
+
+	st->num_segments++;
+	st->segments = realloc(st->segments, st->num_segments * sizeof(StationSegment));
+	st->segments[i].random_bits = malloc((platforms * length));
+	return i;
+}
+
+static inline byte StationSegmentRandomBitsGet(StationSegment *segment, TileIndex tile)
+{
+	byte x = TileX(tile) - TileX(segment->tile);
+	byte y = TileY(tile) - TileY(segment->tile);
+	byte m = segment->direction ? segment->platforms : segment->length;
+	uint16 pos = x + y * m;
+
+	//return segment->random_bits[pos >> 1] & (0xF << (pos & 1));
+	return segment->random_bits[pos] & 0xF;
+}
+
+void StationSegmentRandomBitsSet(StationSegment *segment, TileIndex tile, byte bits)
+{
+	byte x = TileX(tile) - TileX(segment->tile);
+	byte y = TileY(tile) - TileY(segment->tile);
+	byte m = segment->direction ? segment->platforms : segment->length;
+	uint16 pos = x + y * m;
+
+	assert(bits < 16);
+	//segment->random_bits[pos >> 1] &= ~(0xF << (pos & 1)); // Clear the old bits
+	//segment->random_bits[pos >> 1] |= bits << (pos & 1);
+	segment->random_bits[pos] = bits;
+}
+
+/**
+ * Gets the top left tile of the station.
+ * @param st Station.
+ * @return TileIndex of top left tile.
+ */
+static TileIndex StationGetTopLeft(Station *st)
+{
+	int i;
+	uint minx = INVALID_TILE;
+	uint miny = INVALID_TILE;
+
+	if (st->num_segments == 0)
+		return st->xy;
+
+	for (i = 0; i < st->num_segments; i++) {
+		uint tilex, tiley;
+
+		if (st->segments[i].tile == INVALID_TILE)
+			continue;
+
+		tilex = TileX(st->segments[i].tile);
+		tiley = TileY(st->segments[i].tile);
+
+		if (tilex < minx) minx = tilex;
+		if (tiley < miny) miny = tiley;
+	}
+
+	return TileXY(minx, miny);
+}
+
+/**
+ * Gets the bottom right corner of the station.
+ * @param st Station.
+ * @return TileIndex of bottom right tile.
+ */
+static TileIndex StationGetBottomRight(Station *st)
+{
+	int i;
+	uint maxx = 0;
+	uint maxy = 0;
+
+	if (st->num_segments == 0)
+		return st->xy;
+
+	for (i = 0; i < st->num_segments; i++) {
+		uint tilex, tiley;
+		uint w, h;
+
+		if (st->segments[i].tile == INVALID_TILE)
+			continue;
+
+		tilex = TileX(st->segments[i].tile);
+		tiley = TileY(st->segments[i].tile);
+
+		if (st->segments[i].direction) {
+			h = st->segments[i].length;
+			w = st->segments[i].platforms;
+		} else {
+			w = st->segments[i].length;
+			h = st->segments[i].platforms;
+		}
+
+		if (tilex + w > maxx) maxx = tilex + w;
+		if (tiley + h > maxy) maxy = tiley + h;
+	}
+
+	return TileXY(maxx - 1, maxy - 1);
+}
 
 static int CountMapSquareAround(TileIndex tile, byte type, byte min, byte max)
 {
@@ -468,6 +656,10 @@
 		ge->feeder_profit = 0;
 	}
 
+	st->random_bits = Random();
+	st->num_segments = 0;
+	st->segments = NULL;
+
 	_global_station_sort_dirty = true; // build a new station
 }
 
@@ -935,161 +1127,6 @@
 	}
 }
 
-/** Build railroad station
- * @param x,y starting position of station dragging/placement
- * @param p1 various bitstuffed elements
- * - p1 = (bit  0)    - orientation (p1 & 1)
- * - p1 = (bit  8-15) - number of tracks
- * - p1 = (bit 16-23) - platform length
- * @param p2 various bitstuffed elements
- * - p2 = (bit  0- 3) - railtype (p2 & 0xF)
- * - p2 = (bit  4)    - set for custom station (p2 & 0x10)
- * - p2 = (bit  8-..) - custom station id (p2 >> 8)
- */
-int32 CmdBuildRailroadStation(int x, int y, uint32 flags, uint32 p1, uint32 p2)
-{
-	Station *st;
-	TileIndex tile_org;
-	int w_org, h_org;
-	int32 cost, ret;
-	int est;
-	int plat_len, numtracks;
-	int direction;
-	uint finalvalues[3];
-
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
-	tile_org = TileVirtXY(x, y);
-
-	/* Does the authority allow this? */
-	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile_org)) return CMD_ERROR;
-	if (!ValParamRailtype(p2 & 0xF)) return CMD_ERROR;
-
-	/* unpack parameters */
-	direction = p1 & 1;
-	numtracks = GB(p1,  8, 8);
-	plat_len  = GB(p1, 16, 8);
-	/* w = length, h = num_tracks */
-	if (direction) {
-		h_org = plat_len;
-		w_org = numtracks;
-	} else {
-		w_org = plat_len;
-		h_org = numtracks;
-	}
-
-	if (h_org > _patches.station_spread || w_org > _patches.station_spread) return CMD_ERROR;
-
-	// these values are those that will be stored in train_tile and station_platforms
-	finalvalues[0] = tile_org;
-	finalvalues[1] = w_org;
-	finalvalues[2] = h_org;
-
-	// Make sure the area below consists of clear tiles. (OR tiles belonging to a certain rail station)
-	est = -1;
-	// If DC_EXEC is in flag, do not want to pass it to CheckFlatLandBelow, because of a nice bug
-	//  for detail info, see: https://sourceforge.net/tracker/index.php?func=detail&aid=1029064&group_id=103924&atid=636365
-	if (CmdFailed(ret = CheckFlatLandBelow(tile_org, w_org, h_org, flags&~DC_EXEC, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
-	cost = ret + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len;
-
-	// Make sure there are no similar stations around us.
-	st = GetStationAround(tile_org, w_org, h_org, est);
-	if (st == CHECK_STATIONS_ERR) return CMD_ERROR;
-
-	// See if there is a deleted station close to us.
-	if (st == NULL) {
-		st = GetClosestStationFromTile(tile_org, 8, _current_player);
-		if (st != NULL && st->facilities) st = NULL;
-	}
-
-	if (st != NULL) {
-		// Reuse an existing station.
-		if (st->owner != OWNER_NONE && st->owner != _current_player)
-			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
-
-		if (st->train_tile != 0) {
-			// check if we want to expanding an already existing station?
-			if ((!_patches.ainew_active && _is_ai_player) || !_patches.join_stations)
-				return_cmd_error(STR_3005_TOO_CLOSE_TO_ANOTHER_RAILROAD);
-			if (!CanExpandRailroadStation(st, finalvalues, direction))
-				return CMD_ERROR;
-		}
-
-		//XXX can't we pack this in the "else" part of the if above?
-		if (!CheckStationSpreadOut(st, tile_org, w_org, h_org))
-			return CMD_ERROR;
-
-	}	else {
-		// Create a new station
-		st = AllocateStation();
-		if (st == NULL)
-			return CMD_ERROR;
-
-		st->town = ClosestTownFromTile(tile_org, (uint)-1);
-		if (_current_player < MAX_PLAYERS && flags&DC_EXEC)
-			SETBIT(st->town->have_ratings, _current_player);
-
-		if (!GenerateStationName(st, tile_org, 0))
-			return CMD_ERROR;
-
-		if (flags & DC_EXEC)
-			StationInitialize(st, tile_org);
-	}
-
-	if (flags & DC_EXEC) {
-		TileIndexDiff tile_delta;
-		byte *layout_ptr;
-		StationID station_index = st->index;
-		StationSpec *statspec;
-
-		// Now really clear the land below the station
-		// It should never return CMD_ERROR.. but you never know ;)
-		//  (a bit strange function name for it, but it really does clear the land, when DC_EXEC is in flags)
-		if (CmdFailed(CheckFlatLandBelow(tile_org, w_org, h_org, flags, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
-
-		st->train_tile = finalvalues[0];
-		if (!st->facilities) st->xy = finalvalues[0];
-		st->facilities |= FACIL_TRAIN;
-		st->owner = _current_player;
-
-		st->trainst_w = finalvalues[1];
-		st->trainst_h = finalvalues[2];
-
-		st->build_date = _date;
-
-		tile_delta = direction ? TileDiffXY(0, 1) : TileDiffXY(1, 0);
-
-		statspec = (p2 & 0x10) != 0 ? GetCustomStation(STAT_CLASS_DFLT, p2 >> 8) : NULL;
-		layout_ptr = alloca(numtracks * plat_len);
-		GetStationLayout(layout_ptr, numtracks, plat_len, statspec);
-
-		do {
-			TileIndex tile = tile_org;
-			int w = plat_len;
-			do {
-
-				ModifyTile(tile,
-					MP_SETTYPE(MP_STATION) | MP_MAPOWNER_CURRENT |
-					MP_MAP2 | MP_MAP5 | MP_MAP3LO | MP_MAP3HI,
-					station_index, /* map2 parameter */
-					p2 & 0xFF,     /* map3lo parameter */
-					p2 >> 8,       /* map3hi parameter */
-					(*layout_ptr++) + direction   /* map5 parameter */
-				);
-
-				tile += tile_delta;
-			} while (--w);
-			tile_org += tile_delta ^ TileDiffXY(1, 1); // perpendicular to tile_delta
-		} while (--numtracks);
-
-		UpdateStationVirtCoordDirty(st);
-		UpdateStationAcceptance(st, false);
-		InvalidateWindow(WC_STATION_LIST, st->owner);
-	}
-
-	return cost;
-}
-
 static bool TileBelongsToRailStation(Station *st, TileIndex tile)
 {
 	return IsTileType(tile, MP_STATION) && _m[tile].m2 == st->index && _m[tile].m5 < 8;
@@ -1172,7 +1209,17 @@
 
 	// if we reached here, it means we can actually delete it. do that.
 	if (flags & DC_EXEC) {
-		DoClearSquare(tile);
+		if (HASBIT(_m[tile].m3, 4)) {
+			/* This is a custom station tile. We should check if its segment
+			 * is still valid */
+			byte segment_id = _m[tile].m4;
+			DoClearSquare(tile);
+			if (!StationSegmentInUse(st, segment_id)) {
+				StationSegmentDelete(st, segment_id);
+			}
+		} else {
+			DoClearSquare(tile);
+		}
 		// now we need to make the "spanned" area of the railway station smaller if we deleted something at the edges.
 		// we also need to adjust train_tile.
 		MakeRailwayStationAreaSmaller(st);
@@ -1213,24 +1260,102 @@
 
 /* TODO: Custom classes! */
 /* Indexed by class, just STAT_CLASS_DFLT and STAT_CLASS_WAYP supported. */
-static int _statspec_highest_id[2] = {-1, -1};
-static StationSpec _station_spec[2][256];
+static int _statspec_highest_id[STAT_CLASS_MAX] = {0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
+static StationSpec *_station_spec[STAT_CLASS_MAX][256];
+static uint32 _station_class[STAT_CLASS_MAX] = {'DFLT', 'WAYP', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // Station Class IDs
+static const char *_station_class_names[STAT_CLASS_MAX] = {"Default", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""}; // Station Class Names
+
+int AllocateCustomStationClass(uint32 classid)
+{
+	int id;
+	for (id = 0; id < STAT_CLASS_MAX; id++) {
+		if (_station_class[id] == classid) {
+			// classid exists, use it.
+			return id;
+		} else if (_station_class[id] == 0) {
+			// Allocate this id.
+			_station_class[id] = classid;
+			return id;
+		}
+	}
+
+	printf("SHOULDN'T BE HERE\n");
+	return 0;
+}
+
+void SetCustomStationClassName(int classid, const char *name)
+{
+	assert(classid < STAT_CLASS_MAX);
+	_station_class_names[classid] = strdup(name);
+}
+
+StringID GetCustomStationClassName(int classid)
+{
+	assert(classid < STAT_CLASS_MAX);
+	if (!_station_class_names[classid])
+		return 0;
+	ttd_strlcpy(_userstring, _station_class_names[classid], lengthof(_userstring));
+	return STR_SPEC_USERSTRING;
+}
+
+StringID CustomStationGetStationName(StationSpec *spec)
+{
+	if (spec == NULL || spec->name == NULL)
+		return STR_01A9_NONE;
+	ttd_strlcpy(_userstring, spec->name, lengthof(_userstring));
+	return STR_SPEC_USERSTRING;
+}
+
+int GetNumCustomStationClasses(void)
+{
+	int i, j = 0;
+
+	for (i = 0; i < STAT_CLASS_MAX; i++, j++) {
+		if (_station_class[i] == 0)
+			return j;
+		if (_station_class[i] == 'WAYP')
+			j--;
+	}
+
+	return j;
+}
+
+StringID *BuildCustomStationClassDropdown(void)
+{
+	int i;
+	static StringID buf[STAT_CLASS_MAX + 1];
+	StringID *p = buf;
+	for (i = 0; i < STAT_CLASS_MAX; i++) {
+		if (_station_class[i] == 0)
+			break;
+		//if (_station_class[i] == 'WAYP')
+		//	continue;
+
+		// THIS IS TOTALLY WRONG
+		if (_station_class_names[i])
+			*p++ = AllocateName(_station_class_names[i], 0);
+	}
+	*p = INVALID_STRING_ID;
+	return buf;
+}
 
 void SetCustomStation(byte local_stid, StationSpec *spec)
 {
 	StationClass sclass;
 	int stid = -1;
 
-	assert(spec->sclass == STAT_CLASS_DFLT || spec->sclass == STAT_CLASS_WAYP);
-	sclass = spec->sclass - 1;
+	assert(spec->sclass < STAT_CLASS_MAX);
+	sclass = spec->sclass;
 
 	if (spec->localidx != 0) {
 		/* Already allocated, try to resolve to global stid */
-		int i;
+		int i = 0;
+
+		if (spec->sclass == STAT_CLASS_DFLT) i++;
 
-		for (i = 0; i <= _statspec_highest_id[sclass]; i++) {
-			if (_station_spec[sclass][i].grfid == spec->grfid &&
-					_station_spec[sclass][i].localidx == local_stid + 1) {
+		for (; i <= _statspec_highest_id[sclass]; i++) {
+			if (_station_spec[sclass][i]->grfid == spec->grfid &&
+					_station_spec[sclass][i]->localidx == local_stid + 1) {
 				stid = i;
 				/* FIXME: Release original SpriteGroup to
 				 * prevent leaks. But first we need to
@@ -1246,109 +1371,202 @@
 			error("Too many custom stations allocated.");
 			return;
 		}
-		stid = ++_statspec_highest_id[sclass];
-		spec->localidx = local_stid + 1;
+		stid = ++_statspec_highest_id[sclass];
+		spec->localidx = local_stid + 1;
+	}
+
+	//debug("Registering station #%d of class %d", stid, sclass);
+	_station_spec[sclass][stid] = spec;
+}
+
+StationSpec *GetCustomStation(StationClass sclass, byte stid)
+{
+	assert(sclass < STAT_CLASS_MAX);
+	//debug("Asking for station #%d of class %d", stid, sclass);
+	if (stid > _statspec_highest_id[sclass])
+		return NULL;
+	return _station_spec[sclass][stid];
+}
+
+/* from waypoint.c */
+extern Station *ComposeWaypointStation(TileIndex tile);
+
+int EvalDeterministicStation(int variable, byte parameter, int object)
+{
+	TileIndex tile;
+	Station *st;
+	StationSegment *segment;
+
+	if (object == -1) {
+		/* Handle unbuilt objects */
+		switch (variable) {
+			case 0x10: return 0x01010000; /* Platforms, tracks & position */
+			case 0x42: return 0;          /* Track type */
+			case 0xFA: return _date;      /* Build date */
+			default: return -1;
+		}
+	}
+
+	tile = object;
+	if (IsTileType(tile, MP_RAILWAY)) {
+		/* OpenTTD handles waypoints differently to TTDPatch. Here we create a fake station for them. */
+		st = ComposeWaypointStation(tile);
+		segment = &st->segments[0];
+	} else {
+		st = GetStation(_m[tile].m2);
+		segment = &st->segments[_m[tile].m4];
+	}
+
+	switch (variable) {
+		case 0x10:
+			return 0x01010000;
+		case 0x40:
+		case 0x41:
+		case 0x46:
+		case 0x47:
+			/* FIXME: This is ad hoc only
+			 * for waypoints. */
+			if (segment->sclass == 255) {
+				return 0x01010000;
+			} else {
+				/* xTNLcCpP */
+				byte platform, position, platforms, length;
+				TileIndex starttile;
+				if (variable == 0x40 || variable == 0x46) {
+					/* Value based on whole station */
+					starttile = st->topleft;
+					if (segment->direction) {
+						platforms = TileX(st->bottomright) - TileX(st->topleft) + 1;
+						length = TileY(st->bottomright) - TileY(st->topleft) + 1;
+					} else {
+						platforms = TileY(st->bottomright) - TileY(st->topleft) + 1;
+						length = TileX(st->bottomright) - TileX(st->topleft) + 1;
+					}
+				} else {
+					/* Value based on this segment */
+					starttile = segment->tile;
+					platforms = segment->platforms;
+					length = segment->length;
+				}
+
+				if (segment->direction) {
+					platform = TileX(tile) - TileX(starttile);
+					position = TileY(tile) - TileY(starttile);
+				} else {
+					platform = TileY(tile) - TileY(starttile);
+					position = TileX(tile) - TileX(starttile);
+				}
+
+				if (variable == 0x46 || variable == 0x47) {
+					// XXX Make relative
+					platform -= platforms / 2;
+					position -= length / 2;
+				}
+
+				return
+					platforms << 20 |
+					length << 16 |
+					platform << 8 |
+					(platforms - platform - 1) << 12 |
+					position << 0 |
+					(length - position - 1) << 4;
+			}
+
+		case 0x42: {
+			/* Terrain and track type */
+			int value = 0;
+			switch(_m[tile].m3 & 0xF) {
+				case 0: value |= 0 << 8; break; // Railroad
+				case 1: value |= 2 << 8; break; // Monorail
+				case 2: value |= 3 << 8; break; // Maglev
+			}
+			return value;
+		}
+
+		case 0x43:
+			/* Player info 00ttmmnn */
+			return st->owner;
+
+		case 0x44:
+			/* PBS information */
+			if (PBSTileReserved(tile)) {
+				return 7;
+			} else {
+				return 4;
+			}
+	}
+
+	switch (variable - 0x70) {
+		case 0x12: return 50; ///< Why is newstations wanting this?
+		case 0x14: return st->string_id;
+		case 0x16: return 0;
+		case 0x1A: return st->had_vehicle_of_type;
+		case 0x80: return st->facilities;
+		case 0x81: return st->airport_type;
+		case 0x82: return st->truck_stops->status;
+		case 0x83: return st->bus_stops->status;
+		case 0x86: return st->airport_flags & 0xFFFF;
+		case 0x87: return st->airport_flags & 0xFF;
+		case 0x8A: return st->build_date;
+	}
+
+	if (variable >= 0x8C && variable <= 0xEC) {
+		GoodsEntry *g = &st->goods[(variable - 0x8C) >> 3];
+		switch ((variable - 0x8C) % 8) {
+			case 0: return g->waiting_acceptance;
+			case 1: return g->waiting_acceptance & 0xFF;
+			case 2: return g->days_since_pickup;
+			case 3: return g->rating;
+			case 4: return g->enroute_from;
+			case 5: return g->enroute_time;
+			case 6: return g->last_speed;
+			case 7: return g->last_age;
+		}
 	}
 
-	//debug("Registering station #%d of class %d", stid, sclass);
-	memcpy(&_station_spec[sclass][stid], spec, sizeof(*spec));
+	DEBUG(grf, 1)("EvalDeterministicStation: Unhandled variable `0x%x' in spritegroup", variable);
+	
+	return -1;
 }
 
-StationSpec *GetCustomStation(StationClass sclass, byte stid)
+uint32 EvalRandomBitsStation(int object)
 {
-	assert(sclass == STAT_CLASS_DFLT || sclass == STAT_CLASS_WAYP);
-	sclass--;
-	//debug("Asking for station #%d of class %d", stid, sclass);
-	if (stid > _statspec_highest_id[sclass])
-		return NULL;
-	return &_station_spec[sclass][stid];
+	DEBUG(grf, 1)("EvalRandomBitsStation: handled for tile `0x%x'.", object);
+	if (object == -1) {
+		return 0;
+	} else {
+		TileIndex tile = object;
+		Station *st = GetStation(_m[tile].m2);
+		StationSegment *segment = &st->segments[_m[tile].m4];
+		return (st->random_bits & 0xFF) | (StationSegmentRandomBitsGet(segment, tile) << 16);
+	}
 }
 
-static RealSpriteGroup *ResolveStationSpriteGroup(SpriteGroup *spritegroup, Station *stat)
+uint16 GetStationCallBackResult(uint16 callback_info, StationSpec *spec, Station *stat, TileIndex tile)
 {
-	switch (spritegroup->type) {
-		case SGT_REAL:
-			return &spritegroup->g.real;
-
-		case SGT_DETERMINISTIC: {
-			DeterministicSpriteGroup *dsg = &spritegroup->g.determ;
-			SpriteGroup *target;
-			int value = -1;
-
-			if ((dsg->variable >> 6) == 0) {
-				/* General property */
-				value = GetDeterministicSpriteValue(dsg->variable);
-
-			} else {
-				if (stat == NULL) {
-					/* We are in a build dialog of something,
-					 * and we are checking for something undefined.
-					 * That means we should get the first target
-					 * (NOT the default one). */
-					if (dsg->num_ranges > 0) {
-						target = &dsg->ranges[0].group;
-					} else {
-						target = dsg->default_group;
-					}
-					return ResolveStationSpriteGroup(target, NULL);
-				}
+	const SpriteGroup *group;
 
-				/* Station-specific property. */
-				if (dsg->var_scope == VSG_SCOPE_PARENT) {
-					/* TODO: Town structure. */
-
-				} else /* VSG_SELF */ {
-					if (dsg->variable == 0x40 || dsg->variable == 0x41) {
-						/* FIXME: This is ad hoc only
-						 * for waypoints. */
-						value = 0x01010000;
-					} else {
-						/* TODO: Only small fraction done. */
-						// TTDPatch runs on little-endian arch;
-						// Variable is 0x70 + offset in the TTD's station structure
-						switch (dsg->variable - 0x70) {
-							case 0x80:
-								value = stat->facilities;
-								break;
-							case 0x81:
-								value = stat->airport_type;
-								break;
-							case 0x82:
-								value = stat->truck_stops->status;
-								break;
-							case 0x83:
-								value = stat->bus_stops->status;
-								break;
-							case 0x86:
-								value = stat->airport_flags & 0xFFFF;
-								break;
-							case 0x87:
-								value = stat->airport_flags & 0xFF;
-								break;
-							case 0x8A:
-								value = stat->build_date;
-								break;
-						}
-					}
-				}
-			}
+	group = &spec->spritegroup[0];
+	group = ResolveSpriteGroup(group, tile, callback_info, 4, (resolve_callback) ResolveSpriteGroup);
 
-			target = value != -1 ? EvalDeterministicSpriteGroup(dsg, value) : dsg->default_group;
-			return ResolveStationSpriteGroup(target, stat);
-		}
+	if (group->type == SGT_REAL && group->g.real.sprites_per_set == 0) {
+		group = ResolveSpriteGroup(group, tile, callback_info, 4, (resolve_callback) ResolveSpriteGroup);
+	}
 
-		default:
-		case SGT_RANDOMIZED:
-			error("I don't know how to handle random spritegroups yet!");
-			return NULL;
+	if (group->type != SGT_CALLBACK) {
+		DEBUG(grf, 1)("Callback 0x%x at 0x%x failed.", callback_info, tile);
+		return CALLBACK_FAILED;
 	}
+
+	DEBUG(grf, 1)("Callback 0x%x at 0x%x returned 0x%x.", callback_info, tile, group->g.callback.result);
+	return group->g.callback.result;
 }
 
-uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte ctype)
+uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte ctype, TileIndex tile)
 {
-	RealSpriteGroup *rsg;
+	const RealSpriteGroup *rsg;
 
-	rsg = ResolveStationSpriteGroup(&spec->spritegroup[ctype], stat);
+	rsg = &ResolveSpriteGroup(&spec->spritegroup[ctype], tile, 0, 4, (resolve_callback) ResolveSpriteGroup)->g.real;
 
 	if (rsg->sprites_per_set != 0) {
 		if (rsg->loading_count != 0) {
@@ -1358,6 +1576,9 @@
 		}
 	}
 
+	//if (ctype == 1)
+	//	return GetCustomStationRelocation(spec, stat, 0, tile);
+
 	error("Custom station 0x%08x::0x%02x has no sprites associated.",
 		spec->grfid, spec->localidx);
 	/* This is what gets subscribed of dtss->image in newgrf.c,
@@ -1368,11 +1589,209 @@
 
 int GetCustomStationsCount(StationClass sclass)
 {
-	assert(sclass == STAT_CLASS_DFLT || sclass == STAT_CLASS_WAYP);
-	sclass--;
+	assert(sclass < STAT_CLASS_MAX);
 	return _statspec_highest_id[sclass] + 1;
 }
 
+/** Build railroad station
+ * @param x,y starting position of station dragging/placement
+ * @param p1 various bitstuffed elements
+ * - p1 = (bit  0)    - orientation (p1 & 1)
+ * - p1 = (bit  8-15) - number of tracks
+ * - p1 = (bit 16-23) - platform length
+ * @param p2 various bitstuffed elements
+ * - p2 = (bit  0- 3) - railtype (p2 & 0xF)
+ * - p2 = (bit  4)    - set for custom station (p2 & 0x10)
+ * - p2 = (bit  8-15) - custom station id (p2 >> 8)
+ * - p2 = (bit 16-19) - custom station class (p2 >> 16)
+ */
+int32 CmdBuildRailroadStation(int x, int y, uint32 flags, uint32 p1, uint32 p2)
+{
+	Station *st;
+	TileIndex tile_org;
+	int w_org, h_org;
+	int32 cost, ret;
+	int est;
+	int plat_len, numtracks;
+	int direction;
+	uint finalvalues[3];
+
+	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
+
+	tile_org = TileVirtXY(x, y);
+
+	/* Does the authority allow this? */
+	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile_org)) return CMD_ERROR;
+	if (!ValParamRailtype(p2 & 0xF)) return CMD_ERROR;
+
+	/* unpack parameters */
+	direction = p1 & 1;
+	numtracks = GB(p1,  8, 8);
+	plat_len  = GB(p1, 16, 8);
+	/* w = length, h = num_tracks */
+	if (direction) {
+		h_org = plat_len;
+		w_org = numtracks;
+	} else {
+		w_org = plat_len;
+		h_org = numtracks;
+	}
+
+	if (h_org > _patches.station_spread || w_org > _patches.station_spread) return CMD_ERROR;
+
+	// these values are those that will be stored in train_tile and station_platforms
+	finalvalues[0] = tile_org;
+	finalvalues[1] = w_org;
+	finalvalues[2] = h_org;
+
+	// Make sure the area below consists of clear tiles. (OR tiles belonging to a certain rail station)
+	est = -1;
+	// If DC_EXEC is in flag, do not want to pass it to CheckFlatLandBelow, because of a nice bug
+	//  for detail info, see: https://sourceforge.net/tracker/index.php?func=detail&aid=1029064&group_id=103924&atid=636365
+	if (CmdFailed(ret = CheckFlatLandBelow(tile_org, w_org, h_org, flags&~DC_EXEC, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
+	cost = ret + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len;
+
+	// Make sure there are no similar stations around us.
+	st = GetStationAround(tile_org, w_org, h_org, est);
+	if (st == CHECK_STATIONS_ERR) return CMD_ERROR;
+
+	if (HASBIT(p2, 4)) {
+		// This is a custom station segment. Check that the size is permissable
+		StationSpec *statspec = GetCustomStation((p2 >> 16) & 0xF, (p2 >> 8) & 0xFF);
+		if (HASBIT(statspec->disallowed_platforms, numtracks - 1) ||
+			HASBIT(statspec->disallowed_lengths, plat_len - 1))
+			return CMD_ERROR;
+	}
+
+	// See if there is a deleted station close to us.
+	if (st == NULL) {
+		st = GetClosestStationFromTile(tile_org, 8, _current_player);
+		if (st != NULL && st->facilities) st = NULL;
+	}
+
+	if (st != NULL) {
+		// Reuse an existing station.
+		if (st->owner != OWNER_NONE && st->owner != _current_player)
+			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
+
+		if (st->train_tile != 0) {
+			// check if we want to expanding an already existing station?
+			if ((!_patches.ainew_active && _is_ai_player) || !_patches.join_stations)
+				return_cmd_error(STR_3005_TOO_CLOSE_TO_ANOTHER_RAILROAD);
+			if (!CanExpandRailroadStation(st, finalvalues, direction))
+				return CMD_ERROR;
+		}
+
+		//XXX can't we pack this in the "else" part of the if above?
+		if (!CheckStationSpreadOut(st, tile_org, w_org, h_org))
+			return CMD_ERROR;
+
+	}	else {
+		// Create a new station
+		st = AllocateStation();
+		if (st == NULL)
+			return CMD_ERROR;
+
+		st->town = ClosestTownFromTile(tile_org, (uint)-1);
+		if (_current_player < MAX_PLAYERS && flags&DC_EXEC)
+			SETBIT(st->town->have_ratings, _current_player);
+
+		if (!GenerateStationName(st, tile_org, 0))
+			return CMD_ERROR;
+
+		if (flags & DC_EXEC)
+			StationInitialize(st, tile_org);
+	}
+
+	if (flags & DC_EXEC) {
+		TileIndexDiff tile_delta;
+		byte *layout_ptr;
+		StationID station_index = st->index;
+		StationSpec *statspec;
+		byte segid = 0;
+
+		// Now really clear the land below the station
+		// It should never return CMD_ERROR.. but you never know ;)
+		//  (a bit strange function name for it, but it really does clear the land, when DC_EXEC is in flags)
+		if (CmdFailed(CheckFlatLandBelow(tile_org, w_org, h_org, flags, 5 << direction, _patches.nonuniform_stations ? &est : NULL))) return CMD_ERROR;
+
+		st->train_tile = finalvalues[0];
+		if (!st->facilities) st->xy = finalvalues[0];
+		st->facilities |= FACIL_TRAIN;
+		st->owner = _current_player;
+
+		st->trainst_w = finalvalues[1];
+		st->trainst_h = finalvalues[2];
+
+		st->build_date = _date;
+
+		tile_delta = direction ? TileDiffXY(0, 1) : TileDiffXY(1, 0);
+
+		statspec = HASBIT(p2, 4) != 0 ? GetCustomStation((p2 >> 16) & 0xF, (p2 >> 8) & 0xFF) : NULL;
+		if (statspec) {
+			/* Custom Station */
+			StationSegment *segment;
+			segid = StationSegmentAllocate(st, numtracks, plat_len);
+			segment = &st->segments[segid];
+
+			segment->tile      = tile_org;
+			segment->direction = direction;
+			segment->length    = plat_len;
+			segment->platforms = numtracks;
+			segment->sclass    = (p2 >> 16) &  0xF;
+			segment->cstation  = (p2 >>  8) & 0xFF;
+
+			segment->grfid     = statspec->grfid;
+			segment->gstation  = statspec->localidx;
+		}
+		layout_ptr = alloca(numtracks * plat_len);
+		GetStationLayout(layout_ptr, numtracks, plat_len, statspec);
+
+		st->topleft = StationGetTopLeft(st);
+		st->bottomright = StationGetBottomRight(st);
+
+		do {
+			TileIndex tile = tile_org;
+			int w = plat_len;
+			do {
+				ModifyTile(tile,
+					MP_SETTYPE(MP_STATION) | MP_MAPOWNER_CURRENT |
+					MP_MAP2 | MP_MAP5 | MP_MAP3LO | MP_MAP3HI,
+					station_index, /* map2 parameter */
+					p2 & 0xFF,     /* map3lo parameter */
+					segid,         /* map3hi parameter */
+					(*layout_ptr++) + direction   /* map5 parameter */
+				);
+
+				if (statspec && HASBIT(p2, 4)) { // Custom station
+					uint16 callback;
+					// Set random bits for this tile
+					StationSegmentRandomBitsSet(&st->segments[segid], tile, Random() & 0xF);
+
+					callback = GetStationCallBackResult(CBID_STATION_TILE_LAYOUT, statspec, st, tile);
+					if (callback != CALLBACK_FAILED) {
+						ModifyTile(tile,
+							MP_MAP5,
+							callback + direction   /* map5 parameter */
+						);
+					}
+
+					if (statspec->blocked & (1 << _m[tile].m5))
+						_m[tile].m3 |= 0x80;
+				}
+
+				tile += tile_delta;
+			} while (--w);
+			tile_org += tile_delta ^ TileDiffXY(1, 1); // perpendicular to tile_delta
+		} while (--numtracks);
+
+		UpdateStationVirtCoordDirty(st);
+		UpdateStationAcceptance(st, false);
+		InvalidateWindow(WC_STATION_LIST, st->owner);
+	}
+
+	return cost;
+}
 
 static int32 RemoveRailroadStation(Station *st, TileIndex tile, uint32 flags)
 {
@@ -1415,9 +1834,15 @@
 	} while (--h);
 
 	if (flags & DC_EXEC) {
+		int i;
+
 		st->train_tile = 0;
 		st->facilities &= ~FACIL_TRAIN;
 
+		if (st->num_segments > 0)
+			for (i = 0; i < st->num_segments; i++)
+				StationSegmentDelete(st, i);
+
 		UpdateStationVirtCoordDirty(st);
 		DeleteStationIfEmpty(st);
 	}
@@ -2129,6 +2554,7 @@
 
 
 extern uint16 _custom_sprites_base;
+extern GRFFile *_first_grffile;
 
 static void DrawTile_Station(TileInfo *ti)
 {
@@ -2139,7 +2565,7 @@
 	byte railtype = _m[ti->tile].m3 & 0xF;
 	const RailtypeInfo *rti = GetRailTypeInfo(railtype);
 	SpriteID offset;
-	uint32 relocation = 0;
+	uint32 relocation = 0, ground_relocation = 0;
 
 	{
 		uint owner = GetTileOwner(ti->tile);
@@ -2152,24 +2578,46 @@
 	if (ti->tileh != 0 && (ti->map5 < 0x4C || ti->map5 > 0x51))
 		DrawFoundation(ti, ti->tileh);
 
-	if (_m[ti->tile].m3 & 0x10) {
+	if (HASBIT(_m[ti->tile].m3, 4)) {
 		// look for customization
-		StationSpec *statspec = GetCustomStation(STAT_CLASS_DFLT, _m[ti->tile].m4);
-
-		//debug("Cust-o-mized %p", statspec);
-
-		if (statspec != NULL) {
-			Station *st = GetStation(_m[ti->tile].m2);
+		Station *st = GetStation(_m[ti->tile].m2);
+		if (st->num_segments > 0) {
+			StationSegment *segment = &st->segments[_m[ti->tile].m4];
+			StationSpec *statspec = GetCustomStation(segment->sclass, segment->cstation);
+
+			//debug("Cust-o-mized %p", statspec);
+
+			if (statspec != NULL) {
+				GRFFile *file;
+				relocation = GetCustomStationRelocation(statspec, st, 0, ti->tile);
+				//debug("Relocation %d", relocation);
+				t = &statspec->renderdata[ti->map5];
+
+				if (HASBIT(statspec->callbackmask, CBM_SPRITE_LAYOUT)) {
+					uint32 callback = GetStationCallBackResult(CBID_STATION_SPRITE_LAYOUT, statspec, st, ti->tile);
+					if (callback != CALLBACK_FAILED)
+						t = &statspec->renderdata[callback+segment->direction];
+				}
 
-			relocation = GetCustomStationRelocation(statspec, st, 0);
-			//debug("Relocation %d", relocation);
-			t = &statspec->renderdata[ti->map5];
+				for (file = _first_grffile; file != NULL; file = file->next) {
+					if (file->grfid == statspec->grfid) {
+						ground_relocation = file->sprite_offset+1;
+					}
+				}
+			}
 		}
 	}
 
 	if (t == NULL) t = &_station_display_datas[ti->map5];
 
 	image = t->ground_sprite;
+	if (HASBIT(image, 31)) {
+		/* Bit 31 indicates we should use the sprite from the grf file
+		 * instead of TTD's */
+		image &= 0xFFFF;
+		image += ground_relocation - 0x42D;
+	}
+
 	if (image & PALETTE_MODIFIER_COLOR)
 		image |= image_or_modificator;
 
@@ -2177,6 +2626,8 @@
 	offset = (image & SPRITE_MASK) < _custom_sprites_base ? rti->total_offset : railtype;
 	image += offset;
 
+	//printf("3:groundsprite = 0x%x\n", image);
+
 	// station_land array has been increased from 82 elements to 114
 	// but this is something else. If AI builds station with 114 it looks all weird
 	DrawGroundSprite(image);
@@ -2193,7 +2644,9 @@
 
 	foreach_draw_tile_seq(dtss, t->seq) {
 		image = dtss->image + relocation;
-		image += offset;
+		//printf("image: 0x%x\n", image);
+		if (relocation == 0)
+			image += offset;
 		if (_display_opt & DO_TRANS_BUILDINGS) {
 			MAKE_TRANSPARENT(image);
 		} else {
@@ -2203,6 +2656,7 @@
 		if ((byte)dtss->delta_z != 0x80) {
 			AddSortableSpriteToDraw(image, ti->x + dtss->delta_x, ti->y + dtss->delta_y, dtss->width, dtss->height, dtss->unk, ti->z + dtss->delta_z);
 		} else {
+			MAKE_TRANSPARENT(image);
 			AddChildSpriteScreen(image, dtss->delta_x, dtss->delta_y);
 		}
 	}
@@ -2230,6 +2684,53 @@
 	}
 }
 
+void DrawStationSprite(int x, int y, StationClass sclass, byte stat_id, uint railtype, byte direction)
+{
+	StationSpec *stat;
+	uint32 relocation;
+	DrawTileSprites *cust;
+	DrawTileSeqStruct const *seq;
+	const RailtypeInfo *rti = GetRailTypeInfo(railtype);
+	uint32 ormod, img;
+
+	ormod = PLAYER_SPRITE_COLOR(_local_player);
+
+	x += 33;
+	y += 17;
+
+	/* draw default station graphics of ID 0 */
+	if (stat_id == 0 && sclass == STAT_CLASS_DFLT) {
+		StationPickerDrawSprite(x, y, railtype, direction + 2);
+		return;
+	}
+
+	stat = GetCustomStation(sclass, stat_id);
+	assert(stat);
+	relocation = GetCustomStationRelocation(stat, NULL, 0, INVALID_TILE);
+
+	// emulate station tile - open with building
+	// add 1 to get the other direction
+	if (stat->tiles >= 3) {
+		cust = &stat->renderdata[2 + direction];
+	} else {
+		// Not all station layouts have a building
+		cust = &stat->renderdata[0 + direction];
+	}
+
+	img = cust->ground_sprite;
+	img += (img < _custom_sprites_base) ? rti->total_offset : railtype;
+	
+	if (img & PALETTE_MODIFIER_COLOR) img = (img & SPRITE_MASK);
+	DrawSprite(img | ormod, x, y);
+
+	foreach_draw_tile_seq(seq, cust->seq) {
+		Point pt = RemapCoords(seq->delta_x, seq->delta_y, seq->delta_z);
+		uint32 image = seq->image + relocation;
+		if((byte)seq->delta_z != 0x80)
+			DrawSprite((image & SPRITE_MASK) | ormod, x + pt.x, y + pt.y);
+	}
+}
+
 static uint GetSlopeZ_Station(TileInfo *ti)
 {
 	uint z = ti->z;
@@ -2278,6 +2779,9 @@
 		case TRANSPORT_RAIL:
 			if (i < 8) {
 				const byte tile_track_status_rail[8] = { 1, 2, 1, 2, 1, 2, 1, 2 };
+				/* m3 bit 7 indicates that tile is not passable */
+				if (HASBIT(_m[tile].m3, 7))
+					return 0;
 				j = tile_track_status_rail[i];
 			}
 			j += (j << 8);
@@ -3062,6 +3566,23 @@
 	SLE_END()
 };
 
+static uint16 SSRBLen(void *object)
+{
+	StationSegment *segment = object;
+	return segment->platforms * segment->length;
+}
+
+static const SaveLoad _station_segment_desc[] = {
+	SLE_VAR(StationSegment, tile,      SLE_UINT32),
+	SLE_VAR(StationSegment, direction, SLE_UINT8),
+	SLE_VAR(StationSegment, length,    SLE_UINT8),
+	SLE_VAR(StationSegment, platforms, SLE_UINT8),
+	SLE_CONDVARR(StationSegment, random_bits, SLE_UINT8, SSRBLen, 17, 255),
+	SLE_VAR(StationSegment, grfid,     SLE_UINT32), ///< GRF file the station is from.
+	SLE_VAR(StationSegment, gstation,  SLE_UINT8),  ///< id within GRF file.
+	SLE_END()
+};
+
 static const SaveLoad _station_desc[] = {
 	SLE_CONDVAR(Station, xy,           SLE_FILE_U16 | SLE_VAR_U32, 0, 5),
 	SLE_CONDVAR(Station, xy,           SLE_UINT32, 6, 255),
@@ -3102,13 +3623,16 @@
 
 	SLE_VAR(Station,last_vehicle,				SLE_UINT16),
 
-	SLE_CONDVAR(Station,class_id,				SLE_UINT8, 3, 255),
-	SLE_CONDVAR(Station,stat_id,				SLE_UINT8, 3, 255),
+	SLE_CONDVAR(NullStruct,null,				SLE_FILE_U8 | SLE_VAR_NULL, 3, 255),
+	SLE_CONDVAR(NullStruct,null,				SLE_FILE_U8 | SLE_VAR_NULL, 3, 255),
 	SLE_CONDVAR(Station,build_date,			SLE_UINT16, 3, 255),
 
 	SLE_CONDREF(Station,bus_stops,					REF_ROADSTOPS, 6, 255),
 	SLE_CONDREF(Station,truck_stops,				REF_ROADSTOPS, 6, 255),
 
+	SLE_CONDVAR(Station,random_bits,            SLE_UINT8, 17, 255),
+	SLE_CONDVAR(Station,num_segments,           SLE_UINT8, 17, 255),
+
 	// reserve extra space in savegame here. (currently 28 bytes)
 	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 32, 2, 255),
 
@@ -3228,8 +3752,89 @@
 	}
 }
 
+static void Save_STATION_SEGMENT( void )
+{
+	Station *st;
+	uint index = 0;
+
+	FOR_ALL_STATIONS(st) {
+		byte i;
+		if (st->xy == 0)
+			continue;
+		if (st->num_segments == 0)
+			continue;
+
+		for (i = 0; i < st->num_segments; i++) {
+			SlSetArrayIndex(index++);
+			SlObject(&st->segments[i], _station_segment_desc);
+			//SlSetArrayIndex(index++);
+			//SlArray(st->segments[i].random_bits, st->segments[i].platforms * st->segments[i].length, SLE_UINT8);
+		}
+	}
+}
+
+static void Load_STATION_SEGMENT( void )
+{
+	Station *st = GetStation(0);
+	byte i = 0;
+
+	while (SlIterateArray() != -1) {
+		if (i == st->num_segments) {
+			while (st->index + 1 < GetStationPoolSize() && st != NULL) {
+				st = GetStation(st->index + 1);
+				if (st->num_segments > 0)
+					break;
+			}
+			if (st == NULL)
+				break;
+			i = 0;
+		}
+		if (st->segments == NULL) {
+			st->segments = malloc(st->num_segments * sizeof(StationSegment));
+		}
+		SlObject(&st->segments[i], _station_segment_desc);
+		//st->segments[i].random_bits = malloc(st->segments[i].platforms * st->segments[i].length);
+		//SlIterateArray();
+		//SlArray(st->segments[i].random_bits, SlGetFieldLength(), SLE_UINT8);
+
+		{
+			/* Set up the segment's sclass and cstation parameters from the
+			 * currently loaded GRF list. */
+			StationClass class;
+			int id;
+			StationSegment *segment = &st->segments[i];
+
+			/* Default to normal station */
+			segment->sclass = 0;
+			segment->cstation = 0;
+
+			/* Loop through all available classes and IDs to find a match. */
+			for (class = 0; class < STAT_CLASS_MAX; class++) {
+				for (id = 0; id < _statspec_highest_id[class]; id++) {
+					if (_station_spec[class][id] && _station_spec[class][id]->grfid == segment->grfid && _station_spec[class][id]->localidx == segment->gstation) {
+						segment->sclass = class;
+						segment->cstation = id;
+						break;
+					}
+				}
+			}
+		}
+		i++;
+	}
+
+	// These variables are not saved and depend on station segments to be
+	// loaded.
+	FOR_ALL_STATIONS(st) {
+		if (st->xy != 0) {
+			st->topleft = StationGetTopLeft(st);
+			st->bottomright = StationGetBottomRight(st);
+		}
+	}
+}
+
 const ChunkHandler _station_chunk_handlers[] = {
 	{ 'STNS', Save_STNS,      Load_STNS,      CH_ARRAY },
-	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY | CH_LAST},
+	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY },
+	{ 'STSG', Save_STATION_SEGMENT, Load_STATION_SEGMENT, CH_ARRAY | CH_LAST },
 };
 
Index: engine.c
===================================================================
--- engine.c	(revision 2908)
+++ engine.c	(working copy)
@@ -17,6 +17,7 @@
 #include "saveload.h"
 #include "sprite.h"
 #include "variables.h"
+#include "newgrf_callbacks.h"
 
 enum {
 	ENGINE_AVAILABLE = 1,
@@ -308,190 +309,161 @@
 	_engine_custom_sprites[engine][cargo] = *group;
 }
 
-typedef SpriteGroup *(*resolve_callback)(const SpriteGroup *spritegroup,
-	const Vehicle *veh, uint16 callback_info, void *resolve_func); /* XXX data pointer used as function pointer */
-
-static const SpriteGroup* ResolveVehicleSpriteGroup(const SpriteGroup *spritegroup,
-	const Vehicle *veh, uint16 callback_info, resolve_callback resolve_func)
+int EvalDeterministicVehicle(int variable, byte parameter, int object)
 {
-	//debug("spgt %d", spritegroup->type);
-	switch (spritegroup->type) {
-		case SGT_REAL:
-		case SGT_CALLBACK:
-			return spritegroup;
-
-		case SGT_DETERMINISTIC: {
-			const DeterministicSpriteGroup *dsg = &spritegroup->g.determ;
-			const SpriteGroup *target;
-			int value = -1;
-
-			//debug("[%p] Having fun resolving variable %x", veh, dsg->variable);
-			if (dsg->variable == 0x0C) {
-				/* Callback ID */
-				value = callback_info & 0xFF;
-			} else if ((dsg->variable >> 6) == 0) {
-				/* General property */
-				value = GetDeterministicSpriteValue(dsg->variable);
-			} else {
-				/* Vehicle-specific property. */
-
-				if (veh == NULL) {
-					/* We are in a purchase list of something,
-					 * and we are checking for something undefined.
-					 * That means we should get the first target
-					 * (NOT the default one). */
-					if (dsg->num_ranges > 0) {
-						target = &dsg->ranges[0].group;
-					} else {
-						target = dsg->default_group;
-					}
-					return resolve_func(target, NULL, callback_info, resolve_func);
-				}
-
-				if (dsg->var_scope == VSG_SCOPE_PARENT) {
-					/* First engine in the vehicle chain */
-					if (veh->type == VEH_Train)
-						veh = GetFirstVehicleInChain(veh);
-				}
-
-				if (dsg->variable == 0x40 || dsg->variable == 0x41) {
-					if (veh->type == VEH_Train) {
-						const Vehicle *u = GetFirstVehicleInChain(veh);
-						byte chain_before = 0, chain_after = 0;
-
-						while (u != veh) {
-							chain_before++;
-							if (dsg->variable == 0x41 && u->engine_type != veh->engine_type)
-								chain_before = 0;
-							u = u->next;
-						}
-						while (u->next != NULL && (dsg->variable == 0x40 || u->next->engine_type == veh->engine_type)) {
-							chain_after++;
-							u = u->next;
-						};
-
-						value = chain_before | chain_after << 8
-						        | (chain_before + chain_after) << 16;
-					} else {
-						value = 1; /* 1 vehicle in the chain */
-					}
-
-				} else {
-					// TTDPatch runs on little-endian arch;
-					// Variable is 0x80 + offset in TTD's vehicle structure
-					switch (dsg->variable - 0x80) {
-#define veh_prop(id_, value_) case (id_): value = (value_); break
-						veh_prop(0x00, veh->type);
-						veh_prop(0x01, veh->subtype);
-						veh_prop(0x04, veh->index);
-						veh_prop(0x05, veh->index & 0xFF);
-						/* XXX? Is THIS right? */
-						veh_prop(0x0A, PackOrder(&veh->current_order));
-						veh_prop(0x0B, PackOrder(&veh->current_order) & 0xff);
-						veh_prop(0x0C, veh->num_orders);
-						veh_prop(0x0D, veh->cur_order_index);
-						veh_prop(0x10, veh->load_unload_time_rem);
-						veh_prop(0x11, veh->load_unload_time_rem & 0xFF);
-						veh_prop(0x12, veh->date_of_last_service);
-						veh_prop(0x13, veh->date_of_last_service & 0xFF);
-						veh_prop(0x14, veh->service_interval);
-						veh_prop(0x15, veh->service_interval & 0xFF);
-						veh_prop(0x16, veh->last_station_visited);
-						veh_prop(0x17, veh->tick_counter);
-						veh_prop(0x18, veh->max_speed);
-						veh_prop(0x19, veh->max_speed & 0xFF);
-						veh_prop(0x1F, veh->direction);
-						veh_prop(0x28, veh->cur_image);
-						veh_prop(0x29, veh->cur_image & 0xFF);
-						veh_prop(0x32, veh->vehstatus);
-						veh_prop(0x33, veh->vehstatus);
-						veh_prop(0x34, veh->cur_speed);
-						veh_prop(0x35, veh->cur_speed & 0xFF);
-						veh_prop(0x36, veh->subspeed);
-						veh_prop(0x37, veh->acceleration);
-						veh_prop(0x39, veh->cargo_type);
-						veh_prop(0x3A, veh->cargo_cap);
-						veh_prop(0x3B, veh->cargo_cap & 0xFF);
-						veh_prop(0x3C, veh->cargo_count);
-						veh_prop(0x3D, veh->cargo_count & 0xFF);
-						veh_prop(0x3E, veh->cargo_source); // Probably useless; so what
-						veh_prop(0x3F, veh->cargo_days);
-						veh_prop(0x40, veh->age);
-						veh_prop(0x41, veh->age & 0xFF);
-						veh_prop(0x42, veh->max_age);
-						veh_prop(0x43, veh->max_age & 0xFF);
-						veh_prop(0x44, veh->build_year);
-						veh_prop(0x45, veh->unitnumber);
-						veh_prop(0x46, veh->engine_type);
-						veh_prop(0x47, veh->engine_type & 0xFF);
-						veh_prop(0x48, veh->spritenum);
-						veh_prop(0x49, veh->day_counter);
-						veh_prop(0x4A, veh->breakdowns_since_last_service);
-						veh_prop(0x4B, veh->breakdown_ctr);
-						veh_prop(0x4C, veh->breakdown_delay);
-						veh_prop(0x4D, veh->breakdown_chance);
-						veh_prop(0x4E, veh->reliability);
-						veh_prop(0x4F, veh->reliability & 0xFF);
-						veh_prop(0x50, veh->reliability_spd_dec);
-						veh_prop(0x51, veh->reliability_spd_dec & 0xFF);
-						veh_prop(0x52, veh->profit_this_year);
-						veh_prop(0x53, veh->profit_this_year & 0xFFFFFF);
-						veh_prop(0x54, veh->profit_this_year & 0xFFFF);
-						veh_prop(0x55, veh->profit_this_year & 0xFF);
-						veh_prop(0x56, veh->profit_last_year);
-						veh_prop(0x57, veh->profit_last_year & 0xFF);
-						veh_prop(0x58, veh->profit_last_year);
-						veh_prop(0x59, veh->profit_last_year & 0xFF);
-						veh_prop(0x5A, veh->next == NULL ? INVALID_VEHICLE : veh->next->index);
-						veh_prop(0x5C, veh->value);
-						veh_prop(0x5D, veh->value & 0xFFFFFF);
-						veh_prop(0x5E, veh->value & 0xFFFF);
-						veh_prop(0x5F, veh->value & 0xFF);
-						veh_prop(0x60, veh->string_id);
-						veh_prop(0x61, veh->string_id & 0xFF);
-						/* 00h..07h=sub image? 40h=in tunnel; actually some kind of status
-						 * aircraft: >=13h when in flight
-						 * train, ship: 80h=in depot
-						 * rv: 0feh=in depot */
-						/* TODO veh_prop(0x62, veh->???); */
-
-						/* TODO: The rest is per-vehicle, I hope no GRF file looks so far.
-						 * But they won't let us have an easy ride so surely *some* GRF
-						 * file does. So someone needs to do this too. --pasky */
+	Vehicle *v;
+	if (object == -1) {
+		/* Build list */
+		switch (variable) {
+			case 0xC4: return _cur_year;       /* Build year */
+			case 0xDA: return INVALID_VEHICLE; /* Next vehicle */
+			default: return -1;
+		}
+	}
+	v = GetVehicle(object);
+
+	switch (variable) {
+		case 0x40:
+		case 0x41:
+		/* Get length of vehicle consist */
+		if (v->type == VEH_Train) {
+			Vehicle *u = GetFirstVehicleInChain(v);
+			byte chain_before = 0, chain_after = 0;
+
+			while (u != v) {
+				chain_before++;
+				if (variable == 0x41 && u->engine_type != v->engine_type)
+					chain_before = 0;
+				u = u->next;
+			}
 
-#undef veh_prop
-					}
-				}
+			while (u->next != NULL && (variable == 0x40 || u->next->engine_type == v->engine_type)) {
+				chain_after++;
+				u = u->next;
 			}
 
-			target = value != -1 ? EvalDeterministicSpriteGroup(dsg, value) : dsg->default_group;
-			//debug("Resolved variable %x: %d, %p", dsg->variable, value, callback);
-			return resolve_func(target, veh, callback_info, resolve_func);
+			return chain_before | chain_after << 8 | (chain_before + chain_after) << 16;
+		} else {
+			/* Road vehicles, aeroplanes and ships */
+			return 1;
 		}
-
-		case SGT_RANDOMIZED: {
-			const RandomizedSpriteGroup *rsg = &spritegroup->g.random;
-
-			if (veh == NULL) {
-				/* Purchase list of something. Show the first one. */
-				assert(rsg->num_groups > 0);
-				//debug("going for %p: %d", rsg->groups[0], rsg->groups[0].type);
-				return resolve_func(&rsg->groups[0], NULL, callback_info, resolve_func);
+		case 0x42: /* Consist's cargo */
+			return -1;
+		case 0x43: /* Player information */
+			return v->owner;
+		case 0x44: /* Aircraft information */
+			if (v->type == VEH_Aircraft)
+				/* Should also return airport type */
+				return (v->z_pos - TileHeight(v->tile)) << 16;
+			else
+				return -1;
+		case 0x45: /* Curve information, for e.g. tilting trains */
+			if (v->type == VEH_Train) {
+				return 0;
+			} else {
+				return 0;
 			}
-
-			if (rsg->var_scope == VSG_SCOPE_PARENT) {
-				/* First engine in the vehicle chain */
-				if (veh->type == VEH_Train)
-					veh = GetFirstVehicleInChain(veh);
+		case 0x60: /* Count vehicle (engine) ID occurance */
+			if (v->type == VEH_Train) {
+				byte count = 0;
+				while (v) {
+					if (v->engine_type == parameter)
+						count++;
+					v = v->next;
+				}
+				return count;
+			} else {
+				return 0;
 			}
+	}
 
-			return resolve_func(EvalRandomizedSpriteGroup(rsg, veh->random_bits), veh, callback_info, resolve_func);
-		}
-
-		default:
-			error("I don't know how to handle such a spritegroup %d!", spritegroup->type);
-			return NULL;
+	/* Determine value from vehicle struct */
+	switch (variable - 0x80) {
+		case 0x00: return v->type;
+		case 0x01: return v->subtype;
+		case 0x04: return v->index;
+		case 0x05: return v->index & 0xFF; /* XXX: Is THIS right? */
+		case 0x0A: return PackOrder(&v->current_order);
+		case 0x0B: return PackOrder(&v->current_order) & 0xFF;
+		case 0x0C: return v->num_orders;
+		case 0x0D: return v->cur_order_index;
+		case 0x10: return v->load_unload_time_rem;
+		case 0x11: return v->load_unload_time_rem & 0xFF;
+		case 0x12: return v->date_of_last_service;
+		case 0x13: return v->date_of_last_service & 0xFF;
+		case 0x14: return v->service_interval;
+		case 0x15: return v->service_interval & 0xFF;
+		case 0x16: return v->last_station_visited;
+		case 0x17: return v->tick_counter;
+		case 0x18: return v->max_speed;
+		case 0x19: return v->max_speed & 0xFF;
+		case 0x1F: return v->direction;
+		case 0x28: return v->cur_image;
+		case 0x29: return v->cur_image & 0xFF;
+		case 0x32: return v->vehstatus;
+		case 0x33: return v->vehstatus;
+		case 0x34: return v->cur_speed;
+		case 0x35: return v->cur_speed & 0xFF;
+		case 0x36: return v->subspeed;
+		case 0x37: return v->acceleration;
+		case 0x39: return v->cargo_type;
+		case 0x3A: return v->cargo_cap;
+		case 0x3B: return v->cargo_cap & 0xFF;
+		case 0x3C: return v->cargo_count;
+		case 0x3D: return v->cargo_count & 0xFF;
+		case 0x3E: return v->cargo_source; // Probably useless; so what
+		case 0x3F: return v->cargo_days;
+		case 0x40: return v->age;
+		case 0x41: return v->age & 0xFF;
+		case 0x42: return v->max_age;
+		case 0x43: return v->max_age & 0xFF;
+		case 0x44: return v->build_year;
+		case 0x45: return v->unitnumber;
+		case 0x46: return v->engine_type;
+		case 0x47: return v->engine_type & 0xFF;
+		case 0x48: return v->spritenum;
+		case 0x49: return v->day_counter;
+		case 0x4A: return v->breakdowns_since_last_service;
+		case 0x4B: return v->breakdown_ctr;
+		case 0x4C: return v->breakdown_delay;
+		case 0x4D: return v->breakdown_chance;
+		case 0x4E: return v->reliability;
+		case 0x4F: return v->reliability & 0xFF;
+		case 0x50: return v->reliability_spd_dec;
+		case 0x51: return v->reliability_spd_dec & 0xFF;
+		case 0x52: return v->profit_this_year;
+		case 0x53: return v->profit_this_year & 0xFFFFFF;
+		case 0x54: return v->profit_this_year & 0xFFFF;
+		case 0x55: return v->profit_this_year & 0xFF;
+		case 0x56: return v->profit_last_year;
+		case 0x57: return v->profit_last_year & 0xFF;
+		case 0x58: return v->profit_last_year;
+		case 0x59: return v->profit_last_year & 0xFF;
+		case 0x5A: return v->next == NULL ? INVALID_VEHICLE : v->next->index;
+		case 0x5C: return v->value;
+		case 0x5D: return v->value & 0xFFFFFF;
+		case 0x5E: return v->value & 0xFFFF;
+		case 0x5F: return v->value & 0xFF;
+		case 0x60: return v->string_id;
+		case 0x61: return v->string_id & 0xFF;
 	}
+
+	DEBUG(grf, 1)("EvalDeterministicVehicle: Unhandled variable `0x%x' in spritegroup", variable);
+	return -1;
+}
+
+uint32 EvalRandomBitsVehicle(int object)
+{
+	if (object == -1)
+		return 0;
+	return GetVehicle(object)->random_bits;
+}
+
+int EvalGetParentObjectVehicle(int object)
+{
+	if (object == -1)
+		return -1;
+	return GetFirstVehicleInChain(GetVehicle(object))->index;
 }
 
 static const SpriteGroup *GetVehicleSpriteGroup(byte engine, const Vehicle *v)
@@ -524,6 +496,7 @@
 	bool in_motion = 0;
 	int totalsets, spriteset;
 	int r;
+	int object;
 
 	if (v != NULL) {
 		int capacity = v->cargo_cap;
@@ -534,15 +507,18 @@
 		if (capacity == 0) capacity = 1;
 		loaded = (v->cargo_count * 100) / capacity;
 		in_motion = (v->cur_speed != 0);
+		object = v->index;
+	} else {
+		object = -1;
 	}
 
 	group = GetVehicleSpriteGroup(engine, v);
-	group = ResolveVehicleSpriteGroup(group, v, 0, (resolve_callback) ResolveVehicleSpriteGroup);
+	group = ResolveSpriteGroup(group, object, 0, 0, (resolve_callback) ResolveSpriteGroup);
 
 	if (group->type == SGT_REAL && group->g.real.sprites_per_set == 0 && cargo != GC_DEFAULT) {
 		// This group is empty but perhaps there'll be a default one.
-		group = ResolveVehicleSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], v, 0,
-		                                (resolve_callback) ResolveVehicleSpriteGroup);
+		group = ResolveSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], object, 0, 0,
+		                                (resolve_callback) ResolveSpriteGroup);
 	}
 
 	assert(group->type == SGT_REAL);
@@ -613,12 +589,12 @@
 		if (overset != NULL) group = overset;
 	}
 
-	group = ResolveVehicleSpriteGroup(group, v, callback_info, (resolve_callback) ResolveVehicleSpriteGroup);
+	group = ResolveSpriteGroup(group, v->index, callback_info, 0, (resolve_callback) ResolveSpriteGroup);
 
 	if (group->type == SGT_REAL && group->g.real.sprites_per_set == 0 && cargo != GC_DEFAULT) {
 		// This group is empty but perhaps there'll be a default one.
-		group = ResolveVehicleSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], v, callback_info,
-		                                (resolve_callback) ResolveVehicleSpriteGroup);
+		group = ResolveSpriteGroup(&_engine_custom_sprites[engine][GC_DEFAULT], v->index, callback_info, 0,
+		                                (resolve_callback) ResolveSpriteGroup);
 	}
 
 	if (group->type != SGT_CALLBACK)
@@ -635,17 +611,17 @@
 static byte _vsg_bits_to_reseed;
 
 static const SpriteGroup *TriggerVehicleSpriteGroup(const SpriteGroup *spritegroup,
-	Vehicle *veh, uint16 callback_info, resolve_callback resolve_func)
+	int object, uint16 callback_info, byte feature, resolve_callback resolve_func)
 {
 	if (spritegroup->type == SGT_RANDOMIZED) {
 		_vsg_bits_to_reseed |= RandomizedSpriteGroupTriggeredBits(
 			&spritegroup->g.random,
 			_vsg_random_triggers,
-			&veh->waiting_triggers
+			&GetVehicle(object)->waiting_triggers
 		);
 	}
 
-	return ResolveVehicleSpriteGroup(spritegroup, veh, callback_info, resolve_func);
+	return ResolveSpriteGroup(spritegroup, object, callback_info, feature, resolve_func);
 }
 
 static void DoTriggerVehicle(Vehicle *veh, VehicleTrigger trigger, byte base_random_bits, bool first)
@@ -656,12 +632,12 @@
 
 	_vsg_random_triggers = trigger;
 	_vsg_bits_to_reseed = 0;
-	group = TriggerVehicleSpriteGroup(GetVehicleSpriteGroup(veh->engine_type, veh), veh, 0,
+	group = TriggerVehicleSpriteGroup(GetVehicleSpriteGroup(veh->engine_type, veh), veh->index, 0, 0,
 	                                  (resolve_callback) TriggerVehicleSpriteGroup);
 
 	if (group->type == SGT_REAL && group->g.real.sprites_per_set == 0 && veh->cargo_type != GC_DEFAULT) {
 		// This group turned out to be empty but perhaps there'll be a default one.
-		group = TriggerVehicleSpriteGroup(&_engine_custom_sprites[veh->engine_type][GC_DEFAULT], veh, 0,
+		group = TriggerVehicleSpriteGroup(&_engine_custom_sprites[veh->engine_type][GC_DEFAULT], veh->index, 0, 0,
 		                                  (resolve_callback) TriggerVehicleSpriteGroup);
 	}
 
Index: sprite.c
===================================================================
--- sprite.c	(revision 2908)
+++ sprite.c	(working copy)
@@ -5,6 +5,9 @@
 #include "sprite.h"
 #include "variables.h"
 
+#include "debug.h"
+#include "newgrf.h"
+#include "functions.h"
 
 SpriteGroup *EvalDeterministicSpriteGroup(const DeterministicSpriteGroup *dsg, int value)
 {
@@ -57,13 +60,14 @@
 			 * callbacks aren't supported on our callpath. */
 			return 0;
 		default:
+			DEBUG(grf, 1)("GetDeterministicSpriteValue: Unhandled variable `0x%x'.", var);
 			return -1;
 	}
 }
 
-SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, byte random_bits)
+SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, uint32 random_bits)
 {
-	byte mask;
+	uint32 mask;
 	byte index;
 
 	/* Noone likes mangling with bits, but you don't get around it here.
@@ -96,3 +100,110 @@
 
 	return (rsg->num_groups - 1) << rsg->lowest_randbit;
 }
+
+/*
+ * NewGRF sprite resolver
+ */
+extern const EvalDeterministicProc
+	EvalDeterministicVehicle,
+	EvalDeterministicStation;
+
+extern const EvalRandomBitsProc
+	EvalRandomBitsVehicle,
+	EvalRandomBitsStation;
+
+extern const EvalGetParentObjectProc
+	EvalGetParentObjectVehicle;
+
+typedef struct {
+	EvalDeterministicProc* deterministic;
+	EvalRandomBitsProc* randombits;
+	EvalGetParentObjectProc* getparentobject;
+} EvalFeatureProcs;
+
+const EvalFeatureProcs evalfeature_procs[] = {
+	{ &EvalDeterministicVehicle, &EvalRandomBitsVehicle, &EvalGetParentObjectVehicle }, ///< Trains
+	{ &EvalDeterministicVehicle, &EvalRandomBitsVehicle, &EvalGetParentObjectVehicle }, ///< Road vehicles
+	{ &EvalDeterministicVehicle, &EvalRandomBitsVehicle, &EvalGetParentObjectVehicle }, ///< Ships
+	{ &EvalDeterministicVehicle, &EvalRandomBitsVehicle, &EvalGetParentObjectVehicle }, ///< Aircraft
+	{ &EvalDeterministicStation, &EvalRandomBitsStation, NULL                        }, ///< Stations
+	{ NULL, NULL, NULL, }, ///< Canals
+	{ NULL, NULL, NULL, }, ///< Bridges
+	{ NULL, NULL, NULL, }, ///< Town buildings
+};
+
+const SpriteGroup *ResolveSpriteGroup(const SpriteGroup *spritegroup, int object, uint16 callback_info, byte feature, resolve_callback resolve_func)
+{
+	switch (spritegroup->type) {
+		case SGT_REAL:
+		case SGT_CALLBACK:
+			DEBUG(grf, 1)("ResolveSpriteGroup: Real/Callback, returning what was received.");
+			return spritegroup;
+
+		case SGT_DETERMINISTIC: {
+			const DeterministicSpriteGroup *dsg = &spritegroup->g.determ;
+			const SpriteGroup *target;
+			int value = -1;
+			
+			if (dsg->variable == 0x0C) {
+				value = callback_info & 0xFF;
+				DEBUG(grf, 1)("ResolveSpriteGroup: Callback, result 0x%x.", value);
+			} else if (dsg->variable < 0x10) {
+				/* General property */
+				value = GetDeterministicSpriteValue(dsg->variable);
+				DEBUG(grf, 1)("ResolveSpriteGroup: Generic deterministic: var 0x%x, result 0x%x.", dsg->variable, value);
+			} else {
+				/* Object specific property */
+				if (dsg->var_scope == VSG_SCOPE_PARENT && evalfeature_procs[feature].getparentobject != NULL) {
+					/* Get parent object */
+					object = evalfeature_procs[feature].getparentobject(object);
+				}
+
+				if (evalfeature_procs[feature].deterministic != NULL) {
+					value = evalfeature_procs[feature].deterministic(dsg->variable, dsg->parameter, object);
+					DEBUG(grf, 1)("ResolveSpriteGroup: Deterministic feature `%x': var 0x%x, object 0x%x, result 0x%x.", feature, dsg->variable, object, value);
+				} else {
+					DEBUG(grf, 1)("ResolveSpriteGroup: Unhandled determinstic feature `%x'.", feature);
+				}
+			}
+
+			if (value == -1) {
+				if (dsg->num_ranges > 0) {
+					target = &dsg->ranges[0].group;
+				} else {
+					target = dsg->default_group;
+				}
+			} else {
+				target = EvalDeterministicSpriteGroup(dsg, value);
+			}
+
+			return resolve_func(target, object, callback_info, feature, resolve_func);
+		}
+
+		case SGT_RANDOMIZED: {
+			const RandomizedSpriteGroup *rsg = &spritegroup->g.random;
+			uint32 random_bits = 0;
+
+			if (object == -1) {
+				/* Purchase list */
+				assert(rsg->num_groups > 0);
+
+				return resolve_func(&rsg->groups[0], object, callback_info, feature, resolve_func);
+			}
+
+			if (rsg->var_scope == VSG_SCOPE_PARENT && evalfeature_procs[feature].getparentobject != NULL) {
+				/* Get parent object */
+				object = evalfeature_procs[feature].getparentobject(object);
+			}
+
+			if (evalfeature_procs[feature].randombits != NULL)
+				random_bits = evalfeature_procs[feature].randombits(object);
+
+			return resolve_func(EvalRandomizedSpriteGroup(rsg, random_bits), object, callback_info, feature, resolve_func);
+		}
+
+		default:
+			error("Unknown sprite group type `0x%x'.", spritegroup->type);
+			return NULL;
+	}
+}
Index: engine.h
===================================================================
--- engine.h	(revision 2908)
+++ engine.h	(working copy)
@@ -138,34 +138,6 @@
 	NUM_GLOBAL_CID  =  31
 };
 
-// This enum lists the implemented callbacks
-// Use as argument for the GetCallBackResult function (see comments there)
-enum CallbackID {
-	// Powered wagons, if the result is lower as 0x40 then the wagon is powered
-	// TODO: interpret the rest of the result, aka "visual effects"
-	CBID_WAGON_POWER = 0x10,
-
-	// Vehicle length, returns the amount of 1/8's the vehicle is shorter
-	// only for train vehicles
-	CBID_VEH_LENGTH = 0x11,
-
-	// Refit capacity, the passed vehicle needs to have its ->cargo_type set to
-	// the cargo we are refitting to, returns the new cargo capacity
-	CBID_REFIT_CAP = 0x15,
-};
-
-// bit positions for rvi->callbackmask, indicates which callbacks are used by an engine
-// (some callbacks are always used, and dont appear here)
-enum CallbackMask {
-	CBM_WAGON_POWER = 0,
-	CBM_VEH_LENGTH = 1,
-	CBM_REFIT_CAP = 3,
-};
-
-enum {
-	CALLBACK_FAILED = 0xFFFF
-};
-
 VARDEF const uint32 _default_refitmasks[NUM_VEHICLE_TYPES];
 VARDEF const CargoID _global_cargo_id[NUM_LANDSCAPE][NUM_CARGO];
 VARDEF const uint32 _landscape_global_cargo_mask[NUM_LANDSCAPE];
Index: sprite.h
===================================================================
--- sprite.h	(revision 2908)
+++ sprite.h	(working copy)
@@ -70,6 +70,7 @@
 	// Take this variable:
 	VarSpriteGroupScope var_scope;
 	byte variable;
+	byte parameter; ///< Used for variables between 0x60 and 0x7F inclusive.
 
 	// Do this with it:
 	byte shift_num;
@@ -147,10 +148,19 @@
 /* This takes randomized bitmask (probably associated with
  * vehicle/station/whatever) and chooses corresponding SpriteGroup
  * accordingly to the given RandomizedSpriteGroup. */
-SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, byte random_bits);
+SpriteGroup *EvalRandomizedSpriteGroup(const RandomizedSpriteGroup *rsg, uint32 random_bits);
 /* Triggers given RandomizedSpriteGroup with given bitmask and returns and-mask
  * of random bits to be reseeded, or zero if there were no triggers matched
  * (then they are |ed to @waiting_triggers instead). */
 byte RandomizedSpriteGroupTriggeredBits(const RandomizedSpriteGroup *rsg, byte triggers, byte *waiting_triggers);
 
+typedef int EvalDeterministicProc(int variable, byte parameter, int object);
+typedef uint32 EvalRandomBitsProc(int object);
+typedef int EvalGetParentObjectProc(int object);
+
+typedef SpriteGroup *(*resolve_callback)(const SpriteGroup *spritegroup,
+	int object, uint16 callback_info, byte feature, void *resolve_func); /* XXX data pointer used as function pointer */
+
+const SpriteGroup *ResolveSpriteGroup(const SpriteGroup *spritegroup, int object, uint16 callback_info, byte feature, resolve_callback resolve_func);
+
 #endif
Index: pbs.c
===================================================================
--- pbs.c	(revision 2908)
+++ pbs.c	(working copy)
@@ -10,6 +10,7 @@
 #include "npf.h"
 #include "pathfind.h"
 #include "depot.h"
+#include "bridge.h"
 
 /** @file pbs.c Path-Based-Signalling implementation file
  *  @see pbs.h */
@@ -69,6 +70,20 @@
 			}
 			break;
 		case MP_TUNNELBRIDGE:
+			if (IsTileBridgeEnd(tile)) { // Bridge End
+				if (GetBridgeEndTrackBits(tile)) { // Custom Bridgehead
+					byte encrt = GB(_m[tile].m2, 0, 4); // get current encoded info (see comments at top of file)
+					if (encrt == 0) // nothing reserved before
+						encrt = track + 1;
+					else if (encrt == (track^1) + 1) // opposite track reserved before
+						encrt |= 8;
+					_m[tile].m2 &= ~0xF;
+					_m[tile].m2 |= encrt;
+					break;
+				}
+				SETBIT(_m[tile].m4, 6);
+				break;
+			}
 			_m[tile].m4 |= (1 << track) & 3;
 			break;
 		case MP_STATION:
@@ -104,6 +119,14 @@
 				return res;
 			}
 		case MP_TUNNELBRIDGE:
+			if (IsTileBridgeEnd(tile)) { // Bridge End
+				if (GetBridgeEndTrackBits(tile)) { // Custom Bridgehead
+					byte res = encrt_to_reserved[GB(_m[tile].m2, 0, 4)];
+					assert(res != 0xFF);
+					return res;
+				}
+				return GB(_m[tile].m4, 6, 1) << GB(_m[tile].m5, 0, 1);
+			}
 			return (_m[tile].m4 & 3);
 		case MP_STATION:
 			// check if its reserved
@@ -136,6 +159,14 @@
 				return res;
 			}
 		case MP_TUNNELBRIDGE:
+			if (IsTileBridgeEnd(tile)) { // Bridge End
+				if (GetBridgeEndTrackBits(tile)) { // Custom Bridgehead
+					uint16 res = encrt_to_unavail[GB(_m[tile].m2, 0, 4)];
+					assert(res != 0xFFFF);
+					return res;
+				}
+				return (GB(_m[tile].m4, 6, 1) << GB(_m[tile].m5, 0, 1)) * 0x101;
+			}
 			return (_m[tile].m4 & 3) | ((_m[tile].m4 & 3) << 8);
 		case MP_STATION:
 			return HASBIT(_m[tile].m3, 6) ? TRACKDIR_BIT_MASK : 0;
@@ -173,6 +204,22 @@
 			}
 			break;
 		case MP_TUNNELBRIDGE:
+			if (IsTileBridgeEnd(tile)) { // Bridge End
+				if (GetBridgeEndTrackBits(tile)) { // Custom Bridgehead
+					byte encrt = GB(_m[tile].m2, 0, 4);
+					if (encrt == track + 1)
+						encrt = 0;
+					else if (encrt == track + 1 + 8)
+						encrt = (track^1) + 1;
+					else if (encrt == (track^1) + 1 + 8)
+						encrt &= 7;
+					_m[tile].m2 &= ~0xF;
+					_m[tile].m2 |= encrt;
+					break;
+				}
+				CLRBIT(_m[tile].m4, 6);
+				break;
+			}
 			_m[tile].m4 &= ~((1 << track) & 3);
 			break;
 		case MP_STATION:
Index: network.c
===================================================================
--- network.c	(revision 2908)
+++ network.c	(working copy)
@@ -539,9 +539,17 @@
 
 	if (_network_server) {
 		// We just lost one client :(
-		if (cs->status > STATUS_INACTIVE)
-			_network_game_info.clients_on--;
 		_network_clients_connected--;
+		if (cs->status > STATUS_INACTIVE) {
+			_network_game_info.clients_on--;
+
+			if (_network_game_info.clients_on == 0 && _network_pause_on_no_clients && _network_dedicated) {
+				// Pause game as no clients connected
+				DoCommandP(0, 1, 0, NULL, CMD_PAUSE);
+			
+				NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game paused (no clients)", NETWORK_SERVER_INDEX);
+			}
+		}
 
 		while ((cs + 1) != DEREF_CLIENT(MAX_CLIENTS) && (cs + 1)->socket != INVALID_SOCKET) {
 			*cs = *(cs + 1);
@@ -970,6 +978,14 @@
 	/* Try to register us to the master server */
 	_network_last_advertise_date = 0;
 	NetworkUDPAdvertise();
+
+	// Possible not the correct place for this
+	if (_network_dedicated && _network_pause_on_no_clients) {
+		// Pause server as there are no clients connected yet
+		DoCommandP(0, 1, 0, NULL, CMD_PAUSE);
+		
+		NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game paused (no clients)", NETWORK_SERVER_INDEX);
+	}
 	return true;
 }
 
Index: rail.h
===================================================================
--- rail.h	(revision 2908)
+++ rail.h	(working copy)
@@ -576,4 +576,14 @@
 	return HASBIT(GetRailTypeInfo(enginetype)->compatible_railtypes, tiletype);
 }
 
+/**
+ * Draws the ground sprite and track pieces.
+ * @param ti TileInfo, used to work out slopes and rail type.
+ * @param track TrackBits to draw.
+ * @param earth Flag whether to draw the ground below as brown.
+ * @param snow Flag whether to draw as snow.
+ * @param flat Always draw foundation to ensure flat tile.
+ */
+void DrawTrackBits(TileInfo *ti, TrackBits track, bool earth, bool snow, bool flat);
+
 #endif // RAIL_H
Index: network.h
===================================================================
--- network.h	(revision 2908)
+++ network.h	(working copy)
@@ -171,6 +171,7 @@
 
 VARDEF uint16 _network_max_join_time;             //! Time a client can max take to join
 VARDEF bool _network_pause_on_join;               //! Pause the game when a client tries to join (more chance of succeeding join)
+VARDEF bool _network_pause_on_no_clients; ///< Pause the game if there are no clients connected
 
 VARDEF uint16 _redirect_console_to_client;
 
Index: lang/romanian.txt
===================================================================
--- lang/romanian.txt	(revision 2908)
+++ lang/romanian.txt	(working copy)
@@ -946,6 +946,7 @@
 STR_CONFIG_PATCHES_OFF                                          :inactiv
 STR_CONFIG_PATCHES_ON                                           :activ
 STR_CONFIG_PATCHES_VEHICLESPEED                                 :{LTBLUE}Afiseaz viteza vehiculelor in bara de jos: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_WINDOWGRADIENT								:{LTBLUE}Deseneaz ferestre cu gradient: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_BUILDONSLOPES                                :{LTBLUE}Permite construirea pe coast si in pant: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_CATCHMENT                                    :{LTBLUE}Permite arii de cuprindere mai realistice: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Permite demolarea unui nr. mai mare constructii: {ORANGE}{STRING}
Index: lang/french.txt
===================================================================
--- lang/french.txt	(revision 2908)
+++ lang/french.txt	(working copy)
@@ -946,6 +946,7 @@
 STR_CONFIG_PATCHES_OFF                                          :Inactif
 STR_CONFIG_PATCHES_ON                                           :Actif
 STR_CONFIG_PATCHES_VEHICLESPEED                                 :{LTBLUE}Afficher vitesse du vhicule dans la barre d'tat: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_WINDOWGRADIENT								:{LTBLUE}Dessinez les fentres avec un gradient: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_BUILDONSLOPES                                :{LTBLUE}Construction ctire et sur pentes: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_CATCHMENT                                    :{LTBLUE}Autoriser des zones de dsserte plus ralistes : {ORANGE}{STRING}
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Permettre le retrait de plus d'lments possds par une ville: {ORANGE}{STRING}
@@ -971,6 +972,7 @@
 STR_CONFIG_PATCHES_BRIBE                                        :{LTBLUE}Permettre la corruption de la municipalit: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_NONUNIFORM_STATIONS                          :{LTBLUE}Gares non uniformes: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_NEW_PATHFINDING_ALL                          :{LTBLUE}Nouvelle recherche de chemin globale (NPF, crase NTP): {ORANGE}{STRING}
+STR_CONFIG_PATCHES_DIFFERING_RAIL_COSTS                         :{LTBLUE}Permettre Monoral et Maglev d'tre plus cher :{ORANGE}{STRING} 
 
 STR_CONFIG_PATCHES_SMALL_AIRPORTS                               :{LTBLUE}Toujours permettre les petits aroports: {ORANGE}{STRING}
 
@@ -1900,6 +1902,7 @@
 STR_6820_LOW                                                    :Bas
 STR_6821_MEDIUM                                                 :Moyen
 STR_6822_HIGH                                                   :lev
+STR_6822_VHIGH                                                  :Trs lev
 STR_6823_NONE                                                   :Aucune
 STR_6824_REDUCED                                                :Rduites
 STR_6825_NORMAL                                                 :Normales
Index: lang/dutch.txt
===================================================================
--- lang/dutch.txt	(revision 2908)
+++ lang/dutch.txt	(working copy)
@@ -946,6 +946,7 @@
 STR_CONFIG_PATCHES_OFF                                          :Uit
 STR_CONFIG_PATCHES_ON                                           :Aan
 STR_CONFIG_PATCHES_VEHICLESPEED                                 :{LTBLUE}Geef snelheid in statusbalk weer: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_WINDOWGRADIENT								:{LTBLUE}Teken windows met kleuroverloop: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_BUILDONSLOPES                                :{LTBLUE}Bouwen op hellingen toestaan: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_CATCHMENT                                    :{LTBLUE}Gebruik realistisch handelsgebied: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Sta verwijderen van meer stedelijke wegen, bruggen, tunnels, enz. toe: {ORANGE}{STRING}
Index: lang/german.txt
===================================================================
--- lang/german.txt	(revision 2908)
+++ lang/german.txt	(working copy)
@@ -947,6 +947,7 @@
 STR_CONFIG_PATCHES_OFF                                          :Aus
 STR_CONFIG_PATCHES_ON                                           :An
 STR_CONFIG_PATCHES_VEHICLESPEED                                 :{LTBLUE}Zeige Fahrzeuggeschwindigkeit in der Statusleiste: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_WINDOWGRADIENT								:{LTBLUE}Die Fenster mit einer Steigung zeichnen: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_BUILDONSLOPES                                :{LTBLUE}Erlaube das Bauen an Hngen und Ksten: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_CATCHMENT                                    :{LTBLUE}Aktiviere realistische Einzugsgebiete: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Erlaube die Entfernung von Industrien, weiteren Straen usw.: {ORANGE}{STRING}
Index: lang/american.txt
===================================================================
--- lang/american.txt	(revision 2908)
+++ lang/american.txt	(working copy)
@@ -946,6 +946,7 @@
 STR_CONFIG_PATCHES_OFF                                          :Off
 STR_CONFIG_PATCHES_ON                                           :On
 STR_CONFIG_PATCHES_VEHICLESPEED                                 :{LTBLUE}Show vehicle speed in status bar: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_WINDOWGRADIENT								:{LTBLUE}Draw windows with a gradient: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_BUILDONSLOPES                                :{LTBLUE}Allow building on slopes and coasts: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_CATCHMENT                                    :{LTBLUE}Allow more realistically sized catchment areas: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Allow removal of more town-owned roads, bridges, etc: {ORANGE}{STRING}
Index: lang/italian.txt
===================================================================
--- lang/italian.txt	(revision 2908)
+++ lang/italian.txt	(working copy)
@@ -946,6 +946,7 @@
 STR_CONFIG_PATCHES_OFF                                          :No
 STR_CONFIG_PATCHES_ON                                           :Si
 STR_CONFIG_PATCHES_VEHICLESPEED                                 :{LTBLUE}Mostra velocit veicoli sulla barra di stato: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_WINDOWGRADIENT								:{LTBLUE}Renda le finestre con una pendenza: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_BUILDONSLOPES                                :{LTBLUE}Consenti la costruzione sulle coste/pendii: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_CATCHMENT                                    :{LTBLUE}Permetti aree di carico/scarico pi realistiche: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Consenti la rimozione industrie, strade speciali, ecc.: {ORANGE}{STRING}
Index: lang/english.txt
===================================================================
--- lang/english.txt	(revision 2908)
+++ lang/english.txt	(working copy)
@@ -286,8 +286,10 @@
 STR_013E_CAPACITIES                                             :{BLACK}Capacities
 STR_013E_TOTAL_CARGO                                            :{BLACK}Total Cargo
 STR_013F_CAPACITY                                               :{BLACK}Capacity: {LTBLUE}{STRING1}
+STR_013F_CAPACITY_MULT                                          :{BLACK}Capacity: {LTBLUE}{STRING1} (x{NUM})
 STR_013F_TOTAL_CAPACITY_TEXT                                    :{BLACK}Total cargo capacity of this train:
 STR_013F_TOTAL_CAPACITY                                         :{LTBLUE}- {CARGO} ({SHORTCARGO})
+STR_013F_TOTAL_CAPACITY_MULT                                    :{LTBLUE}- {CARGO} ({SHORTCARGO}) (x{NUM})
 STR_0140_NEW_GAME                                               :{BLACK}New Game
 STR_0141_LOAD_GAME                                              :{BLACK}Load Game
 STR_SINGLE_PLAYER                                               :{BLACK}Single player
@@ -946,6 +948,7 @@
 STR_CONFIG_PATCHES_OFF                                          :Off
 STR_CONFIG_PATCHES_ON                                           :On
 STR_CONFIG_PATCHES_VEHICLESPEED                                 :{LTBLUE}Show vehicle speed in status bar: {ORANGE}{STRING1}
+STR_CONFIG_PATCHES_WINDOWGRADIENT								:{LTBLUE}Draw all windows with a gradient: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_BUILDONSLOPES                                :{LTBLUE}Allow building on slopes and coasts: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_CATCHMENT                                    :{LTBLUE}Allow more realistically sized catchment areas: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Allow removal of more town-owned roads, bridges, etc: {ORANGE}{STRING1}
@@ -971,6 +974,7 @@
 STR_CONFIG_PATCHES_BRIBE                                        :{LTBLUE}Allow bribing of the local authority: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_NONUNIFORM_STATIONS                          :{LTBLUE}Nonuniform stations: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_NEW_PATHFINDING_ALL                          :{LTBLUE}New global pathfinding (NPF, overrides NTP): {ORANGE}{STRING1}
+STR_CONFIG_PATCHES_FREIGHT_TRAINS                               :{LTBLUE}Multiply weight of freight to simulate heavy trains: {ORANGE}{STRING}
 
 STR_CONFIG_PATCHES_SMALL_AIRPORTS                               :{LTBLUE}Always allow small airports: {ORANGE}{STRING1}
 
@@ -1021,6 +1025,7 @@
 STR_CONFIG_PATCHES_ALLOW_SHARES                                 :{LTBLUE}Allow buying shares from other companies
 STR_CONFIG_PATCHES_DRAG_SIGNALS_DENSITY                         :{LTBLUE}When dragging, place signals every: {ORANGE}{STRING1} tile(s)
 STR_CONFIG_AUTO_PBS_PLACEMENT                                   :{LTBLUE}Allow automatic placement of pbs signals: {ORANGE}{STRING1}
+STR_CONFIG_PATCHES_DIFFERING_RAIL_COSTS                         :{LTBLUE}Allow monorail and maglev to cost more: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_TOOLBAR_POS                                  :{LTBLUE}Position of main toolbar: {ORANGE}{STRING1}
 STR_CONFIG_PATCHES_TOOLBAR_POS_LEFT                             :Left
 STR_CONFIG_PATCHES_TOOLBAR_POS_CENTER                           :Centre
@@ -1900,6 +1905,7 @@
 STR_6820_LOW                                                    :Low
 STR_6821_MEDIUM                                                 :Medium
 STR_6822_HIGH                                                   :High
+STR_6822_VHIGH                                                  :Very High
 STR_6823_NONE                                                   :None
 STR_6824_REDUCED                                                :Reduced
 STR_6825_NORMAL                                                 :Normal
@@ -1925,6 +1931,7 @@
 STR_6839_PERMISSIVE                                             :Permissive
 STR_683A_TOLERANT                                               :Tolerant
 STR_683B_HOSTILE                                                :Hostile
+STR_683C_VENDETTA                                               :Vendetta
 
 ##id 0x7000
 STR_7000                                                        :
@@ -2357,6 +2364,7 @@
 STR_UNKNOWN_DESTINATION                                         :unknown destination
 STR_8812_EMPTY                                                  :{LTBLUE}Empty
 STR_8813_FROM                                                   :{LTBLUE}{CARGO} from {STATION}
+STR_8813_FROM_MULT                                              :{LTBLUE}{CARGO} from {STATION} (x{NUM})
 STR_8814_TRAIN_IS_WAITING_IN_DEPOT                              :{WHITE}Train {COMMA} is waiting in depot
 STR_8815_NEW_VEHICLES                                           :{BLACK}New Vehicles
 STR_8816                                                        :{BLACK}-
Index: variables.h
===================================================================
--- variables.h	(revision 2908)
+++ variables.h	(working copy)
@@ -86,8 +86,10 @@
 typedef struct Patches {
 	bool modified_catchment;	//different-size catchment areas
 	bool vehicle_speed;			// show vehicle speed
+	bool window_gradients;			// draw windows with a gradient
 	bool build_on_slopes;		// allow building on slopes
 	bool auto_pbs_placement;// automatic pbs signal placement
+	bool differing_rail_costs;	//monorail costs 2x, maglev 3x
 	bool mammoth_trains;		// allow very long trains
 	bool join_stations;			// allow joining of train stations
 	bool full_load_any;			// new full load calculation, any cargo must be full
@@ -199,6 +201,7 @@
  	uint32 npf_crossing_penalty; /* The penalty for level crossings */
 
 	bool population_in_label; // Show the population of a town in his label?
+	uint8 freight_trains; ///< Multiply the weight of cargo to give semi-realistics weights...
 } Patches;
 
 VARDEF Patches _patches;
Index: tunnelbridge_cmd.c
===================================================================
--- tunnelbridge_cmd.c	(revision 2908)
+++ tunnelbridge_cmd.c	(working copy)
@@ -22,6 +22,7 @@
 #include "debug.h"
 #include "variables.h"
 #include "bridge.h"
+#include "rail.h"
 
 #include "table/bridge_land.h"
 #include "table/tunnel_land.h"
@@ -196,7 +197,7 @@
 	int bridge_len, odd_middle_part;
 	uint direction;
 	int i;
-	int32 cost, terraformcost, ret;
+	int32 cost, terraformcost, ret, rail_cost;
 	bool allow_on_slopes;
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
@@ -416,6 +417,21 @@
 		cost += ((int64)bridge_len * _price.build_bridge * b->price) >> 8;
 	}
 
+	if (_patches.differing_rail_costs){
+		if (rail_or_road == 2){ //road
+			rail_cost = _price.build_road;	  
+		} else if (railtype == 0x0){ //normal_rail
+			rail_cost = _price.build_rail;
+		} else if (railtype == 0x1) { //monorail
+			rail_cost = 2 * _price.build_rail;
+		} else if (railtype == 0x2) { //maglev
+			rail_cost = 3 * _price.build_rail;
+		} else { //shouldn happen
+			rail_cost = _price.build_road;
+		}
+		cost += bridge_len * rail_cost;
+	}
+		
 	return cost;
 }
 
@@ -452,7 +468,7 @@
 {
 	TileIndex end_tile;
 	int direction;
-	int32 cost, ret;
+	int32 cost, ret, rail_cost;
 	TileInfo ti;
 	uint z;
 
@@ -481,6 +497,16 @@
 
 	cost = 0;
 
+	if (_build_tunnel_railtype == 0x0){ //normal_rail
+		rail_cost = _price.build_rail;
+	} else if (_build_tunnel_railtype == 0x1) { //monorail
+		rail_cost = 2 * _price.build_rail;
+	} else if (_build_tunnel_railtype == 0x2) { //maglev
+		rail_cost = 3 * _price.build_rail;
+	} else{ //road (most likely)
+		rail_cost = _price.build_road;
+	}
+
 	FindLandscapeHeight(&ti, x2, y2);
 	end_tile = ti.tile;
 	z = ti.z;
@@ -507,6 +533,7 @@
 			return CMD_ERROR;
 
 		cost += _price.build_tunnel;
+		(_patches.differing_rail_costs) && (cost += rail_cost);
 		cost += (cost >> 3);
 
 		if (cost >= 400000000)
@@ -955,6 +982,8 @@
 };
 
 extern const byte _road_sloped_sprites[14];
+extern void DrawRoadBits(TileInfo *ti, byte road, byte ground_type, bool snow, bool flat);
+extern byte GetUpdatedRoadGroundType(TileIndex tile, byte ground_type, byte road);
 
 static void DrawBridgePillars(TileInfo *ti, int x, int y, int z)
 {
@@ -1057,6 +1086,24 @@
 		tmp = (ti->map5&3) + (tmp*2);
 
 		if (!(ti->map5 & 0x40)) {	// bridge ramps
+			switch (GB(ti->map5, 1, 2)) {
+				case TRANSPORT_RAIL: {
+					TrackBits track = GetBridgeEndTrackBits(ti->tile);
+					if (ti->tileh != 0 && track != 0) { // Custom bridgehead
+						DrawTrackBits(ti, track, false, ice, true);
+						return;
+					}
+				} break;
+				case TRANSPORT_ROAD: {
+					byte road = GetBridgeEndRoadBits(ti->tile);
+					if (ti->tileh != 0 && road != 0) { // Custom bridgehead
+						DrawRoadBits(ti, road, GB(_m[ti->tile].m4, 4, 3), ice, true); // 1 = on grass.
+						return;
+					}
+				} break;
+				default:
+					break;
+			}
 
 			if (!(BRIDGE_NO_FOUNDATION & (1 << ti->tileh))) {	// no foundations for 0, 3, 6, 9, 12
 				int f = GetBridgeFoundation(ti->tileh, ti->map5 & 0x1);	// pass direction
@@ -1184,6 +1231,15 @@
 	// swap directions if Y tunnel/bridge to let the code handle the X case only.
 	if (ti->map5 & 1) uintswap(x,y);
 
+	if (IsTileBridgeEnd(ti->tile)) {
+		// Bridge Ending
+		if (ti->tileh != 0) {
+			TransportType mode = GB(ti->map5, 1, 2);
+			if (mode == TRANSPORT_RAIL && GetBridgeEndTrackBits(ti->tile)) return z + 8;
+			if (mode == TRANSPORT_ROAD && GetBridgeEndRoadBits(ti->tile)) return z + 8;
+		}
+	}
+
 	// to the side of the tunnel/bridge?
 	if (IS_INT_INSIDE(y, 5, 10+1)) {
 		// tunnel?
@@ -1342,6 +1398,18 @@
 
 	// if it's a bridge with water below, call tileloop_water on it.
 	if ((_m[tile].m5 & 0xF8) == 0xC8) TileLoop_Water(tile);
+
+	if (IsTileBridgeEnd(tile) && (GB(_m[tile].m5, 1, 2) == TRANSPORT_ROAD) && (GetBridgeEndRoadBits(tile) != 0)) {
+		// Tile is a custom bridgehead road bridge.
+		byte old_ground_type = GB(_m[tile].m4, 4, 3);
+		if (old_ground_type < 6) {
+			byte new_ground_type = GetUpdatedRoadGroundType(tile, old_ground_type, GetBridgeEndRoadBits(tile));
+			if (old_ground_type != new_ground_type) {
+				SB(_m[tile].m4, 4, 3, new_ground_type);
+				MarkTileDirtyByTile(tile);
+			}
+		}
+	}
 }
 
 static void ClickTile_TunnelBridge(TileIndex tile)
@@ -1364,9 +1432,32 @@
 	} else if (m5 & 0x80) {
 		/* This is a bridge */
 		result = 0;
-		if (((m5 & 0x6U) >> 1) == mode) {
+		if ((TransportType)GB(m5, 1, 2) == mode) {
 			/* Transport over the bridge is compatible */
-			result = m5&1 ? 0x202 : 0x101;
+			if (IsTileBridgeEnd(tile)) {
+				switch ((TransportType)GB(m5, 1, 2)) {
+					case TRANSPORT_RAIL:
+						result = GetBridgeEndTrackBits(tile);
+						if (result == 3)
+							// Add 0x40 so the pathfinder knows the paths cross.
+							result |= 0x40;
+						break;
+					case TRANSPORT_ROAD: {
+						static const byte _road_trackbits[16] = {
+							0x0, 0x0, 0x0, 0x10, 0x0, 0x2, 0x8, 0x1A,
+							0x0, 0x4, 0x1, 0x15, 0x20, 0x26, 0x29, 0x3F,
+						};
+						result = _road_trackbits[GetBridgeEndRoadBits(tile)];
+					} break;
+					default: result = 0;
+				}
+				result |= result << 8;
+				if (!result)
+					result = HASBIT(m5, 0) ? 0x202 : 0x101;
+				return result;
+			} else {
+				result = HASBIT(m5, 0) ? 0x202 : 0x101;
+			}
 		}
 		if (m5 & 0x40) {
 			/* Bridge middle part */
Index: gfx.c
===================================================================
--- gfx.c	(revision 2908)
+++ gfx.c	(working copy)
@@ -112,7 +112,6 @@
 	_video_driver->make_dirty(left, top, width, height);
 }
 
-
 void GfxFillRect(int left, int top, int right, int bottom, int color)
 {
 	DrawPixelInfo *dpi = _cur_dpi;
@@ -2001,3 +2000,239 @@
 			return 1;
 	return (_color_list[_player_colors[player]].window_color_1b) | IS_PALETTE_COLOR;
 }
+
+// Start Gradient Patch
+// find the nearest color in the static pallette (<217?)
+// Use int, must be signed for the - later!
+static byte FindNearestColor( int r, int g, int b )
+{
+	byte best=0;
+	int dist=262144;//256^2*3
+	int i;
+	// End lookup at #217, this is where the animated palette starts
+	// fixme?! are there colors above some number that are not rotated, include these?
+	for (i=0; i<217; i++)
+	{
+		Colour* c = &_cur_palette[i];
+//		int d = abs((int)c->r - r)+abs((int)c->g - g)+abs((int)c->b - b);
+		int d = (c->r-r)*(c->r-r)+(c->g-g)*(c->g-g)+(c->b-b)*(c->b-b);
+
+		// worse match, continue
+		if (d>=dist)
+			continue;
+
+		// exact match: immediately return this color index
+		if (d==0) return i;
+
+		// better match, store
+		best = i;
+		dist = d;
+	}
+	return best;
+}
+
+#define GRADIENT_STEPS 64 //Has to be EVEN
+#define HGRADIENT_STEPS (GRADIENT_STEPS>>1)
+
+// This cache has for each base color a cache of the entire gradient+diffusion, in 64 steps
+typedef byte grad_t[8];
+
+static grad_t _gradient_cache[256][GRADIENT_STEPS] = {0};
+
+#define roundeddtoi(dbl) ((int)((dbl)+0.5))
+
+grad_t* GetGradient( byte color )
+{
+	grad_t* grad = _gradient_cache[color];
+	int i;
+	int r1, g1, b1, r2, g2, b2;
+	static double ooo = 1./(double)(HGRADIENT_STEPS-1);
+	Colour* c;
+
+	// Don't fill for color 0: it'll stay zero and fill the cache every time
+	if (color==0 || ((byte*)grad)[0]>0)
+		return grad;
+
+	c = &_cur_palette[color];
+	// c1 blends 50% to white
+	r1 = 128 + (c->r>>1);
+	g1 = 128 + (c->g>>1);
+	b1 = 128 + (c->b>>1);
+	// c2 blends to black
+	r2 = (3*c->r)>>2;
+	g2 = (3*c->g)>>2;
+	b2 = (3*c->b)>>2;
+
+	assert( GRADIENT_STEPS==(HGRADIENT_STEPS<<1) );
+
+	// First part of gradient
+	for (i=0; i<HGRADIENT_STEPS; i++)
+	{
+		int tr, tg, tb;
+		int ir, ig, ib;
+		int j;
+		byte* diff = (byte*)&grad[i];
+		double t = (double)i*ooo;
+		double it = 1. - t;
+
+		tr = roundeddtoi(it*r2 + t*c->r);
+		tg = roundeddtoi(it*g2 + t*c->g);
+		tb = roundeddtoi(it*b2 + t*c->b);
+		ir = tr;
+		ig = tg;
+		ib = tb;
+		// from c2 to c
+		for (j=0; j<sizeof(grad_t); j++)
+		{
+			diff[j] = FindNearestColor( ir, ig, ib );
+			ir = tr + ir - _cur_palette[diff[j]].r;
+			ig = tg + ig - _cur_palette[diff[j]].g;
+			ib = tb + ib - _cur_palette[diff[j]].b;
+		}
+	}
+	// Second part of gradient
+	for (i=0; i<HGRADIENT_STEPS; i++) {
+		int tr, tg, tb;
+		int ir, ig, ib;
+		int j;
+		byte* diff = (byte*)&grad[i+HGRADIENT_STEPS];
+		double t = (double)i*ooo;
+		double it = 1. - t;
+
+		tr = roundeddtoi(it*c->r + t*r1);
+		tg = roundeddtoi(it*c->g + t*g1);
+		tb = roundeddtoi(it*c->b + t*b1);
+		ir = tr;
+		ig = tg;
+		ib = tb;
+		// from c2 to c
+		for (j=0; j<sizeof(grad_t); j++)
+		{
+			diff[j] = FindNearestColor( ir, ig, ib );
+			ir = tr + ir - _cur_palette[diff[j]].r;
+			ig = tg + ig - _cur_palette[diff[j]].g;
+			ib = tb + ib - _cur_palette[diff[j]].b;
+		}
+	}
+	assert( ((byte*)grad)[0]!=0 );
+	return grad;
+}
+
+/* Fills a rect with a gradient based on the normal color */
+void GfxFillRectGradient(int left, int top, int right, int bottom, int color)
+{
+	DrawPixelInfo *dpi = _cur_dpi;
+	Pixel *dst;
+	grad_t* gradient;
+	double t, dt;
+	int ditheroff = 0; // iterating offset in dither buffer
+	int ditherlineoffset = 2; // Offset in dither buffer start pos per line
+
+//	bool dodither = (bottom-top)>=16; //use this line to NOT dither buttons and titlebars (stuff<16)
+	bool dodither = true; // dither all
+
+
+	const int otop = top;
+	const int oleft = left;
+	if (!_patches.window_gradients || !!(color & PALETTE_MODIFIER_GREYOUT) || !!(color & USE_COLORTABLE)) {
+		GfxFillRect( left, top, right, bottom, color );
+		return;
+	}
+
+	dt = GRADIENT_STEPS/(double)(bottom-top+1);
+	t=0;
+
+	if (dpi->zoom != 0) return;
+	if (left > right || top > bottom) return;
+	if (right < dpi->left || left >= dpi->left + dpi->width) return;
+	if (bottom < dpi->top || top >= dpi->top + dpi->height) return;
+
+	if ( (left -= dpi->left) < 0) { ditheroff = -left; left = 0; }
+	right = right - dpi->left + 1;
+	if (right > dpi->width) right = dpi->width;
+	right -= left;
+	assert(right > 0);
+
+	if ( (top -= dpi->top) < 0) { t -= top * dt; ditheroff-=ditherlineoffset*top; top = 0; }
+	bottom = bottom - dpi->top + 1;
+	if (bottom > dpi->height) bottom = dpi->height;
+	bottom -= top;
+	assert(bottom > 0);
+
+	dst = dpi->dst_ptr + top * dpi->pitch + left;
+
+	gradient = GetGradient( color&255 );
+
+	do {
+		byte* bg = (byte*)gradient;
+		int it = t;
+		assert(it>=0);
+		assert(it<GRADIENT_STEPS);
+		if (dodither) {
+			int todo = right; // todo is amount to do
+			byte* mybg = bg+it*sizeof(grad_t);
+			Pixel* mydst = dst;
+
+			// memcpy the 'rest' of the ditherbuffer (the part from offset to the end)
+			ditheroff%=sizeof(grad_t);
+			if (ditheroff) {
+				int rest = sizeof(grad_t)-ditheroff;
+				if (rest>todo)
+					rest = todo;
+				memcpy( dst, mybg+ditheroff, rest );
+				todo -= rest;
+				mydst += rest;
+			}
+
+			// fill the buffer with dithered blocks
+			for (; todo; mydst+=sizeof(grad_t)) {
+				int size = (todo<sizeof(grad_t))?todo:sizeof(grad_t);
+				memcpy(mydst, mybg, size);
+				todo -= size;
+			}
+			ditheroff += ditherlineoffset;
+		}
+		else
+			memset(dst, bg[it*sizeof(grad_t)], right);
+
+		dst += dpi->pitch;
+		t+=dt;
+	} while (--bottom);
+}
+
+/* Exact copy of DrawFrameRect, but calls the gradient version of GfxFillRect for the inner part */
+void DrawFrameRectGradient(int left, int top, int right, int bottom, int ctab, int flags)
+{
+	byte color_2 = _color_list[ctab].window_color_1a;
+	byte color_interior = _color_list[ctab].window_color_bga;
+	byte color_3 = _color_list[ctab].window_color_bgb;
+	byte color = _color_list[ctab].window_color_2;
+
+	if (!(flags & 0x8)) {
+		if (!(flags & 0x20)) {
+			GfxFillRect(left, top, left, bottom - 1, color);
+			GfxFillRect(left + 1, top, right - 1, top, color);
+			GfxFillRect(right, top, right, bottom - 1, color_2);
+			GfxFillRect(left, bottom, right, bottom, color_2);
+			if (!(flags & 0x10)) {
+				GfxFillRectGradient(left + 1, top + 1, right - 1, bottom - 1, color_interior);
+			}
+		} else {
+			GfxFillRect(left, top, left, bottom, color_2);
+			GfxFillRect(left + 1, top, right, top, color_2);
+			GfxFillRect(right, top + 1, right, bottom - 1, color);
+			GfxFillRect(left + 1, bottom, right, bottom, color);
+			if (!(flags & 0x10)) {
+				GfxFillRectGradient(left + 1, top + 1, right - 1, bottom - 1,
+					flags & 0x40 ? color_interior : color_3);
+			}
+		}
+	} else if (flags & 0x1) {
+		// transparency
+		GfxFillRect(left, top, right, bottom, 0x322 | USE_COLORTABLE);
+	} else {
+		GfxFillRectGradient(left, top, right, bottom, color_interior);
+	}
+}
+
+// End Gradient Patch
Index: gfx.h
===================================================================
--- gfx.h	(revision 2908)
+++ gfx.h	(working copy)
@@ -54,8 +54,10 @@
 void DrawStringRightAligned(int x, int y, StringID str, uint16 color);
 void DrawStringRightAlignedTruncated(int x, int y, StringID str, uint16 color, uint maxw);
 
+void GfxFillRectGradient(int left, int top, int right, int bottom, int color);
 void GfxFillRect(int left, int top, int right, int bottom, int color);
 void GfxDrawLine(int left, int top, int right, int bottom, int color);
+void DrawFrameRectGradient(int left, int top, int right, int bottom, int color, int flags);
 void DrawFrameRect(int left, int top, int right, int bottom, int color, int flags);
 uint16 GetDrawStringPlayerColor(byte player);
 
Index: saveload.c
===================================================================
--- saveload.c	(revision 2908)
+++ saveload.c	(working copy)
@@ -29,7 +29,7 @@
 #include <setjmp.h>
 
 enum {
-	SAVEGAME_MAJOR_VERSION = 16,
+	SAVEGAME_MAJOR_VERSION = 17,
 	SAVEGAME_MINOR_VERSION = 0,
 
 	SAVEGAME_LOADABLE_VERSION = (SAVEGAME_MAJOR_VERSION << 8) + SAVEGAME_MINOR_VERSION
@@ -533,6 +533,9 @@
 				length += SlCalcRefLen(); break;
 			case SL_ARR: case SL_CONDARR: /* Array */
 				length += SlCalcArrayLen(NULL, sld->length, sld->type); break;
+			case SL_CONDVARR: /* Variable length array */
+				assert(sld->length_handler != NULL);
+				length += sld->length_handler(object) * SlCalcConvLen(NULL, sld->type); break;
 			default: NOT_REACHED();
 			}
 		} else if (sld->cmd == SL_WRITEBYTE) {
@@ -582,6 +585,18 @@
 				break;
 			case SL_ARR: case SL_CONDARR: /* Array */
 				SlArray(ptr, sld->length, sld->type); break;
+			case SL_CONDVARR: /* Variable length array */
+				{
+					uint16 len = sld->length_handler(object);
+					void *array;
+					if (_sl.save) {
+						array = *(void**)ptr;
+					} else {
+						array = malloc(len * SlCalcConvLen(NULL, sld->type));
+						*(void**)ptr = array;
+					}
+					SlArray(array, len, sld->type);
+				} break;
 			default: NOT_REACHED();
 			}
 
Index: music/qtmidi.c
===================================================================
--- music/qtmidi.c	(revision 0)
+++ music/qtmidi.c	(revision 0)
@@ -0,0 +1,323 @@
+/*
+ * qtmidi.c - MIDI Player for OpenTTD using QuickTime (MacOS X).
+ *
+ * Copyright (C) 2005 Adrian Perez <the.lightman@gmail.com>
+ */
+
+
+/*
+ * OpenTTD includes.
+ */
+#include "../stdafx.h"
+#include "../openttd.h"
+#include "qtmidi.h"
+
+/*
+ * System includes. We need to workaround with some defines because there's
+ * stuff already defined in QuickTime headers.
+ */
+#define  bool        OSX_bool
+#define  Rect        OSX_Rect
+#define  Point       OSX_Point
+#define  SL_ERROR    OSX_SL_ERROR
+#define  WindowClass OSX_WindowClass
+#define  OTTD_Random OSX_OTTD_Random
+#include <CoreServices/CoreServices.h>
+#include <QuickTime/QuickTime.h>
+#undef   OTTD_Random
+#undef   WindowClass
+#undef   SL_ERROR
+#undef   Point
+#undef   Rect
+#undef   bool
+
+#include <assert.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#ifdef _DEBUG
+# define  DEBUG
+# define LOG(x) (__debug_printf x)
+
+# include <stdio.h>
+# include <stdarg.h>
+
+static void __debug_printf(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+	fflush(stderr);
+}
+
+#else  /* _DEBUG */
+# define  NDEBUG
+# define _NDEBUG
+# define LOG(x) ((void) 0)
+#endif /* _DEBUG */
+
+
+enum {
+	midiType = 'Midi'
+};
+
+
+/*
+ * Converts a Unix-like pathname (as given by OpenTTD) to a FSSpec struct
+ * that can be used with other MacOS X functions.
+ */
+static int PathToFSSpec(const char *path, FSSpec *spec)
+{
+	FSRef ref;
+	assert(spec);
+	assert(path);
+
+	if (noErr != FSPathMakeRef((UInt8*) path, &ref, NULL))
+		return 0;
+
+	return (noErr ==
+			FSGetCatalogInfo(&ref, kFSCatInfoNone, NULL, NULL, spec, NULL));
+}
+
+
+static void SetMIDITypeIfNeeded(const FSSpec *spec)
+{
+	FInfo info;
+	assert(spec);
+
+	if (noErr != FSpGetFInfo(spec, &info)) return;
+
+	/* Set file type to 'Midi' if the file is _not_ an alias. */
+	if ((info.fdType != midiType) && !(info.fdFlags & kIsAlias)) {
+		info.fdType = midiType;
+		FSpSetFInfo(spec, &info);
+	}
+}
+
+
+/*
+ * Loads a MIDI file and returns it as a QuickTime Movie structure.
+ */
+static int LoadMovieForMIDIFile(const char *path, Movie *moov)
+{
+	int fd;
+	int ret;
+	char magic[4];
+	FSSpec fsspec;
+	short refnum = 0;
+	short resid  = 0;
+
+	assert(path);
+	assert(moov);
+
+	LOG(("[qt] Loading '%s'...\n", path));
+
+	/*
+	 * XXX Manual check for MIDI header ('MThd'), as I don't know how to make
+	 * QuickTime load MIDI files without a .mid suffix without knowing it's
+	 * a MIDI file and setting the OSType of the file to the 'Midi' value.
+	 * Perhahaps ugly, but it seems that it does the Right Thing(tm).
+	 */
+	if ((fd = open(path, O_RDONLY, 0)) == -1)
+		return 0;
+	ret = read(fd, magic, 4);
+	close(fd);
+	if (ret < 4) return 0;
+
+	LOG(("[qt]   Header is '%c%c%c%c'\n", magic[0], magic[1], magic[2], magic[3]));
+	if (magic[0] != 'M' || magic[1] != 'T' || magic[2] != 'h' || magic[3] != 'd')
+		return 0;
+
+	if (!PathToFSSpec(path, &fsspec))
+		return 0;
+	SetMIDITypeIfNeeded(&fsspec);
+
+	if (noErr != OpenMovieFile(&fsspec, &refnum, fsRdPerm))
+		return 0;
+	LOG(("[qt]   File successfully opened\n"));
+
+	if (noErr != NewMovieFromFile(moov, refnum, &resid, NULL,
+				newMovieActive | newMovieDontAskUnresolvedDataRefs, NULL))
+	{
+		CloseMovieFile(refnum);
+		return 0;
+	}
+	LOG(("[qt]   Movie created ;-)\n"));
+
+	CloseMovieFile(refnum);
+	return 1;
+}
+
+
+static int _quicktime_started = 0;
+
+
+static void InitQuickTimeIfNeeded(void)
+{
+	OSStatus dummy;
+
+	if (_quicktime_started) return;
+
+	LOG(("[qt] Initializing... "));
+	/* Be polite: check wether QuickTime is available and initialize it. */
+	_quicktime_started =
+		(noErr == Gestalt(gestaltQuickTime, &dummy)) &&
+		(noErr == EnterMovies());
+	LOG(("%s\n", _quicktime_started ? ";-)" : ":_("));
+}
+
+
+/* Possible states of the QuickTime music driver. */
+enum
+{
+	QT_STATE_IDLE, /* No file loaded. */
+	QT_STATE_PLAY, /* File loaded, playing. */
+	QT_STATE_STOP, /* File loaded, stopped. */
+};
+
+/*
+ * Globals holding the current song (i.e: movie), volume and state of the
+ * driver.
+ */
+static Movie _quicktime_movie;
+static byte  _quicktime_volume = 127;
+static int   _quicktime_state  = QT_STATE_IDLE;
+
+
+/*
+ * Maps OpenTTD volume to QuickTime notion of volume.
+ *
+ * TODO Is this right??
+ */
+static inline short VolumeToQTVolume(byte vol)
+{
+	return (short) ((0x00FF & vol) << 1);
+}
+
+#define VOLUME VolumeToQTVolume(_quicktime_volume)
+
+
+static void StopSong(void);
+
+
+static const char* StartDriver(const char * const *parm)
+{
+	InitQuickTimeIfNeeded();
+	return (_quicktime_started) ? NULL : "can't initialize QuickTime";
+}
+
+
+static bool SongIsPlaying(void)
+{
+	if (!_quicktime_started) return true;
+
+	switch (_quicktime_state) {
+		case QT_STATE_IDLE:
+		case QT_STATE_STOP:
+			/* Do nothing. */
+			break;
+		case QT_STATE_PLAY:
+			MoviesTask(_quicktime_movie, 0);
+			/* Check wether movie ended. */
+			if (IsMovieDone(_quicktime_movie) ||
+					(GetMovieTime(_quicktime_movie, NULL) >=
+					 GetMovieDuration(_quicktime_movie)))
+				_quicktime_state = QT_STATE_STOP;
+	}
+
+	return (_quicktime_state == QT_STATE_PLAY);
+}
+
+
+static void StopDriver(void)
+{
+	if (!_quicktime_started) return;
+
+	LOG(("[qt] Exiting... \n"));
+	switch (_quicktime_state) {
+		case QT_STATE_IDLE:
+			LOG(("[qt]   Nothing to do (already idle)\n"));
+			/* Do nothing. */
+			break;
+		case QT_STATE_PLAY:
+			StopSong();
+		case QT_STATE_STOP:
+			DisposeMovie(_quicktime_movie);
+	}
+
+	ExitMovies();
+	LOG(("[qt] Successfully deinitialized\n"));
+}
+
+
+static void PlaySong(const char *filename)
+{
+	if (!_quicktime_started) return;
+
+	LOG(("[qt] Play song: '%s'\n", filename));
+	switch (_quicktime_state) {
+		case QT_STATE_PLAY:
+			LOG(("[qt]   Stopping previous tune...\n"));
+			StopSong();
+		case QT_STATE_STOP:
+			LOG(("[qt]   Disposing previous tune\n"));
+			DisposeMovie(_quicktime_movie);
+			_quicktime_state = QT_STATE_IDLE;
+		case QT_STATE_IDLE:
+			LoadMovieForMIDIFile(filename, &_quicktime_movie);
+			SetMovieVolume(_quicktime_movie, VOLUME);
+			StartMovie(_quicktime_movie);
+			_quicktime_state = QT_STATE_PLAY;
+	}
+}
+
+
+static void StopSong(void)
+{
+	if (!_quicktime_started) return;
+
+	LOG(("[qt] Stopping... "));
+	switch (_quicktime_state) {
+		case QT_STATE_IDLE:
+		case QT_STATE_STOP:
+			LOG(("already idle\n"));
+			/* Do nothing. */
+			break;
+		case QT_STATE_PLAY:
+			StopMovie(_quicktime_movie);
+			_quicktime_state = QT_STATE_STOP;
+			LOG(("ok\n"));
+	}
+}
+
+
+static void SetVolume(byte vol)
+{
+	if (!_quicktime_started) return;
+
+	_quicktime_volume = vol;
+
+	LOG(("[qt] Set volume to %u (%hi)\n", vol, VOLUME));
+	switch (_quicktime_state) {
+		case QT_STATE_IDLE:
+			/* Do nothing. */
+			break;
+		case QT_STATE_PLAY:
+		case QT_STATE_STOP:
+			SetMovieVolume(_quicktime_movie, VOLUME);
+	}
+}
+
+
+const HalMusicDriver _qtime_music_driver = {
+	StartDriver,
+	StopDriver,
+	PlaySong,
+	StopSong,
+	SongIsPlaying,
+	SetVolume,
+};
+
+
Index: music/qtmidi.h
===================================================================
--- music/qtmidi.h	(revision 0)
+++ music/qtmidi.h	(revision 0)
@@ -0,0 +1,16 @@
+/*
+ * qtmidi.h
+ * Copyright (C) 2005 Adrian Perez <the.lightman@gmail.com>
+ *
+ *  $Id$
+ */
+
+#ifndef MUSIC_MACOSX_QUICKTIME_H
+#define MUSIC_MACOSX_QUICKTIME_H
+
+#include "../hal.h"
+
+extern const HalMusicDriver _qtime_music_driver;
+
+#endif /* !MUSIC_MACOSX_QUICKTIME_H */
+
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 2908)
+++ train_cmd.c	(working copy)
@@ -21,6 +21,7 @@
 #include "debug.h"
 #include "waypoint.h"
 #include "vehicle_gui.h"
+#include "newgrf_callbacks.h"
 
 #define IS_FIRSTHEAD_SPRITE(spritenum) \
 	(is_custom_sprite(spritenum) ? IS_CUSTOM_FIRSTHEAD_SPRITE(spritenum) : _engine_sprite_add[spritenum] == 0)
@@ -48,7 +49,7 @@
 
 		// vehicle weight is the sum of the weight of the vehicle and the weight of its cargo
 		vweight += rvi->weight;
-		vweight += (_cargoc.weights[u->cargo_type] * u->cargo_count) / 16;
+		vweight += ((_cargoc.weights[u->cargo_type] * u->cargo_count) / 16) * (FreightWagonMult(u) ? _patches.freight_trains : 1);
 		// powered wagons have extra weight added
 		if (HASBIT(u->u.rail.flags, VRF_POWEREDWAGON))
 			vweight += RailVehInfo(v->engine_type)->pow_wag_weight;
@@ -94,18 +95,35 @@
 		// power is the sum of the powers of all engines and powered wagons in the consist
 		power += rvi_u->power;
 
+		// Set the vehicle's visual default effect
+		if (rvi_u->visual_effect == 0xFF) {
+			if (rvi_u->flags & RVI_WAGON) {
+				// Wagons have no effect by default
+				u->u.rail.visual_effect = 0x40;
+			} else if (rvi_u->engclass == 0) {
+				// Steam is offset by -4 pixels
+				u->u.rail.visual_effect = 4;
+			} else {
+				// Diesel fumes and sparks come from the centre
+				u->u.rail.visual_effect = 8;
+			}
+		} else {
+			// Default effect as specified by newgrf
+			u->u.rail.visual_effect = rvi_u->visual_effect;
+		}
+
 		// check if its a powered wagon
 		CLRBIT(u->u.rail.flags, VRF_POWEREDWAGON);
 		if ((rvi_v->pow_wag_power != 0) && (rvi_u->flags & RVI_WAGON) && UsesWagonOverride(u)) {
 			uint16 callback = CALLBACK_FAILED;
 
 			if (HASBIT(rvi_u->callbackmask, CBM_WAGON_POWER))
-				callback = GetCallBackResult(CBID_WAGON_POWER,  u->engine_type, u);
+				callback = GetCallBackResult(CBID_TRAIN_WAGON_POWER,  u->engine_type, u);
 
-			if (callback == CALLBACK_FAILED)
-				callback = rvi_u->visual_effect;
+			if (callback != CALLBACK_FAILED)
+				u->u.rail.visual_effect = callback;
 
-			if (callback < 0x40) {
+			if (u->u.rail.visual_effect < 0x40) {
 				/* wagon is powered */
 				SETBIT(u->u.rail.flags, VRF_POWEREDWAGON); // cache 'powered' status
 				power += rvi_v->pow_wag_power;
@@ -119,7 +137,7 @@
 		// check the vehicle length (callback)
 		veh_len = CALLBACK_FAILED;
 		if (HASBIT(rvi_u->callbackmask, CBM_VEH_LENGTH))
-			veh_len = GetCallBackResult(CBID_VEH_LENGTH,  u->engine_type, u);
+			veh_len = GetCallBackResult(CBID_TRAIN_WAGON_LENGTH,  u->engine_type, u);
 		if (veh_len == CALLBACK_FAILED)
 			veh_len = rvi_u->shorten_factor;
 		veh_len = clamp(veh_len, 0, u->next == NULL ? 7 : 5); // the clamp on vehicles not the last in chain is stricter, as too short wagons can break the 'follow next vehicle' code
@@ -1522,7 +1540,7 @@
 				/* Check the 'refit capacity' callback */
 				CargoID temp_cid = v->cargo_type;
 				v->cargo_type = new_cid;
-				amount = GetCallBackResult(CBID_REFIT_CAP, v->engine_type, v);
+				amount = GetCallBackResult(CBID_VEHICLE_REFIT_CAPACITY, v->engine_type, v);
 				v->cargo_type = temp_cid;
 			}
 
@@ -1722,8 +1740,8 @@
 }
 
 static const int8 _vehicle_smoke_pos[16] = {
-	-4, -4, -4, 0, 4, 4, 4, 0,
-	-4,  0,  4, 4, 4, 0,-4,-4,
+	1, 1,  1,  0, -1, -1, -1, 0,
+	1, 0, -1, -1, -1,  0,  1, 1,
 };
 
 static void HandleLocomotiveSmokeCloud(Vehicle *v)
@@ -1737,36 +1755,46 @@
 
 	do {
 		int engtype = v->engine_type;
+		int engclass;
+		int x, y;
+
+		// NEWGRF: Disable visual effect
+		if (v->u.rail.visual_effect & 0x40 || (((v->u.rail.visual_effect & 0x7F) < 0x10) && (RailVehInfo(engtype)->flags & RVI_WAGON)))
+			continue;
 
 		// no smoke?
-		if (RailVehInfo(engtype)->flags & 2 ||
-				GetEngine(engtype)->railtype > 0 ||
-				(v->vehstatus & VS_HIDDEN) || (v->u.rail.track & 0xC0))
+		if (GetEngine(engtype)->railtype > 0 ||
+			(v->vehstatus & VS_HIDDEN) || (v->u.rail.track & 0xC0))
 			continue;
 
-		switch (RailVehInfo(engtype)->engclass) {
+		if (((v->u.rail.visual_effect & 0x30) >> 4) == 0) {
+			engclass = RailVehInfo(engtype)->engclass;
+		} else {
+			engclass = ((v->u.rail.visual_effect & 0x30) >> 4) - 1;
+		}
+		
+		x = _vehicle_smoke_pos[v->direction] * ((v->u.rail.visual_effect & 0xF) - 8);
+		y = _vehicle_smoke_pos[v->direction + 8] * ((v->u.rail.visual_effect & 0xF) - 8);
+
+		switch (engclass) {
 		case 0:
 			// steam smoke.
 			if ( (v->tick_counter&0xF) == 0 && !IsTileDepotType(v->tile, TRANSPORT_RAIL) && !IsTunnelTile(v->tile)) {
-				CreateEffectVehicleRel(v,
-					(_vehicle_smoke_pos[v->direction]),
-					(_vehicle_smoke_pos[v->direction+8]),
-					10,
-					EV_STEAM_SMOKE);
+				CreateEffectVehicleRel(v, x, y, 10, EV_STEAM_SMOKE);
 			}
 			break;
 
 		case 1:
 			// diesel smoke
 			if (u->cur_speed <= 40 && !IsTileDepotType(v->tile, TRANSPORT_RAIL) && !IsTunnelTile(v->tile) && (uint16)Random() <= 0x1E00) {
-				CreateEffectVehicleRel(v, 0, 0, 10, EV_DIESEL_SMOKE);
+				CreateEffectVehicleRel(v, x, y, 10, EV_DIESEL_SMOKE);
 			}
 			break;
 
 		case 2:
 			// blue spark
 			if ( (v->tick_counter&0x3) == 0 && !IsTileDepotType(v->tile, TRANSPORT_RAIL) && !IsTunnelTile(v->tile) && (uint16)Random() <= 0x5B0) {
-				CreateEffectVehicleRel(v, 0, 0, 10, EV_ELECTRIC_SPARK);
+				CreateEffectVehicleRel(v, x, y, 10, EV_ELECTRIC_SPARK);
 			}
 			break;
 		}
Index: saveload.h
===================================================================
--- saveload.h	(revision 2908)
+++ saveload.h	(working copy)
@@ -121,12 +121,15 @@
 	SL_CONDVAR   = 0 | (1 << 2), // 4
 	SL_CONDREF   = 1 | (1 << 2), // 5
 	SL_CONDARR   = 2 | (1 << 2), // 6
+	SL_CONDVARR  = 7, ///< (Conditional) Variable length array
 	// non-normal save-load types
 	SL_WRITEBYTE = 8,
 	SL_INCLUDE   = 9,
 	SL_END       = 15
 };
 
+typedef uint16 SaveLoadVARRProc(void *object);
+
 /** SaveLoad type struct. Do NOT use this directly but use the SLE_ macros defined just below! */
 typedef struct SaveLoad {
 	byte cmd;             /// the action to take with the saved/loaded type, All types need different action
@@ -135,31 +138,33 @@
 	uint16 length;        /// (conditional) length of the variable (eg. arrays) (max array size is 65536 elements)
 	uint16 version_from;  /// save/load the variable starting from this savegame version
 	uint16 version_to;    /// save/load the variable until this savegame version
+	SaveLoadVARRProc *length_handler; ///< Procedure to calculate the length
 } SaveLoad;
 
 /* Simple variables, references (pointers) and arrays */
-#define SLE_VAR(base, variable, type) {SL_VAR, type, offsetof(base, variable), 0, 0, 0}
-#define SLE_REF(base, variable, type) {SL_REF, type, offsetof(base, variable), 0, 0, 0}
-#define SLE_ARR(base, variable, type, length) {SL_ARR, type, offsetof(base, variable), length, 0, 0}
+#define SLE_VAR(base, variable, type) {SL_VAR, type, offsetof(base, variable), 0, 0, 0, NULL}
+#define SLE_REF(base, variable, type) {SL_REF, type, offsetof(base, variable), 0, 0, 0, NULL}
+#define SLE_ARR(base, variable, type, length) {SL_ARR, type, offsetof(base, variable), length, 0, 0, NULL}
 /* Conditional variables, references (pointers) and arrays that are only valid for certain savegame versions */
-#define SLE_CONDVAR(base, variable, type, from, to) {SL_CONDVAR, type, offsetof(base, variable), 0, from, to}
-#define SLE_CONDREF(base, variable, type, from, to) {SL_CONDREF, type, offsetof(base, variable), 0, from, to}
-#define SLE_CONDARR(base, variable, type, length, from, to) {SL_CONDARR, type, offsetof(base, variable), length, from, to}
+#define SLE_CONDVAR(base, variable, type, from, to) {SL_CONDVAR, type, offsetof(base, variable), 0, from, to, NULL}
+#define SLE_CONDREF(base, variable, type, from, to) {SL_CONDREF, type, offsetof(base, variable), 0, from, to, NULL}
+#define SLE_CONDARR(base, variable, type, length, from, to) {SL_CONDARR, type, offsetof(base, variable), length, from, to, NULL}
+#define SLE_CONDVARR(base, variable, type, length_handler, from, to) {SL_CONDVARR, type, offsetof(base, variable), 0, from, to, length_handler}
 /* Translate values ingame to different values in the savegame and vv */
-#define SLE_WRITEBYTE(base, variable, game_value, file_value) {SL_WRITEBYTE, 0, offsetof(base, variable), 0, game_value, file_value}
+#define SLE_WRITEBYTE(base, variable, game_value, file_value) {SL_WRITEBYTE, 0, offsetof(base, variable), 0, game_value, file_value, NULL}
 /* Load common code and put it into each struct (currently only for vehicles */
-#define SLE_INCLUDE(base, variable, include_index) {SL_INCLUDE, 0, offsetof(base, variable), 0, include_index, 0}
+#define SLE_INCLUDE(base, variable, include_index) {SL_INCLUDE, 0, offsetof(base, variable), 0, include_index, 0, NULL}
 
 /* The same as the ones at the top, only the offset is given directly; used for unions */
-#define SLE_VARX(offset, type) {SL_VAR, type, offset, 0, 0, 0}
-#define SLE_REFX(offset, type) {SL_REF, type, offset, 0, 0, 0}
-#define SLE_CONDVARX(offset, type, from, to) {SL_CONDVAR, type, offset, 0, from, to}
-#define SLE_CONDREFX(offset, type, from, to) {SL_CONDREF, type, offset, 0, from, to}
-#define SLE_WRITEBYTEX(offset, something) {SL_WRITEBYTE, 0, offset, 0, something, 0}
-#define SLE_INCLUDEX(offset, type) {SL_INCLUDE, type, offset, 0, 0, 0}
+#define SLE_VARX(offset, type) {SL_VAR, type, offset, 0, 0, 0, NULL}
+#define SLE_REFX(offset, type) {SL_REF, type, offset, 0, 0, 0, NULL}
+#define SLE_CONDVARX(offset, type, from, to) {SL_CONDVAR, type, offset, 0, from, to, NULL}
+#define SLE_CONDREFX(offset, type, from, to) {SL_CONDREF, type, offset, 0, from, to, NULL}
+#define SLE_WRITEBYTEX(offset, something) {SL_WRITEBYTE, 0, offset, 0, something, 0, NULL}
+#define SLE_INCLUDEX(offset, type) {SL_INCLUDE, type, offset, 0, 0, 0, NULL}
 
 /* End marker */
-#define SLE_END() {SL_END, 0, 0, 0, 0, 0}
+#define SLE_END() {SL_END, 0, 0, 0, 0, 0, NULL}
 
 void SlSetArrayIndex(uint index);
 int SlIterateArray(void);
Index: table/engines.h
===================================================================
--- table/engines.h	(revision 2908)
+++ table/engines.h	(working copy)
@@ -285,127 +285,127 @@
 };
 
 RailVehicleInfo _rail_vehicle_info[NUM_TRAIN_ENGINES] = {
-	// image_index  max_speed (kph)      running_cost_base                 callbackmask    shortened factor
+	// image_index  max_speed (kph)      running_cost_base                 callbackmask      shortened factor
 	// |  flags     |        power (hp)  |    running_cost_class           |   powered wagons power
 	// |  |    base_cost     |    weight      |    capacity                |   |   powered wagons weight
-	// |  |    |    |        |    |      |    |    |    cargo_type         |   |   |   visual effects
-	// |  |    |    |        |    |      |    |    |    |                  |   |   |   |   |
-	{  2, 0,   7,  64,     300,  47,    50,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   0 */
-	{ 19, 0,   8,  80,     600,  65,    65,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   1 */
-	{  2, 0,  10,  72,     400,  85,    90,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   2 */
-	{  0, 0,  15,  96,     900, 130,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   3 */
-	{  1, 0,  19, 112,    1000, 140,   145,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   4 */
-	{ 12, 0,  16, 120,    1400,  95,   125,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   5 */
-	{ 14, 0,  20, 152,    2000, 120,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   6 */
-	{  3, 0,  14,  88,    1100, 145,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   7 */
-	{  0, 0,  13, 112,    1000, 131,   120,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   8 */
-	{  1, 0,  19, 128,    1200, 162,   140,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   9 */
-	{  0, 0,  22, 144,    1600, 170,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*  10 */
-	{  8, 1,  11, 112,   600/2,32/2,  85/2,   1,  38,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  11 */
-	{ 10, 1,  14, 120,   700/2,38/2,  70/2,   1,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  12 */
-	{  4, 0,  15, 128,    1250,  72,    95,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  13 */
-	{  5, 0,  17, 144,    1750, 101,   120,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  14 */
-	{  4, 0,  18, 160,    2580, 112,   140,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  15 */
-	{ 14, 0,  23,  96,    4000, 150,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  16 */
-	{ 12, 0,  16, 112,    2400, 120,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  17 */
-	{ 13, 0,  30, 112,    6600, 207,   155,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  18 */
-	{ 15, 0,  18, 104,    1500, 110,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  19 */
-	{ 16, 1,  35, 160,  3500/2,95/2, 205/2,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  20 */
-	{ 18, 0,  21, 104,    2200, 120,   145,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  21 */
-	{  6, 1,  20, 200,  4500/2,70/2, 190/2,   1,   4,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  22 */
-	{ 20, 0,  26, 160,    3600,  84,   180,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  23 */
-	{ 20, 0,  30, 176,    5000,  82,   205,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  24 */
-	{ 21, 1,  40, 240,  7000/2,90/2, 240/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  25 */
-	{ 23, 1,  43, 264,  8000/2,95/2, 250/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  26 */
-	{ 33, 2, 247,   0,       0,  25,     0,   0,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  27 */
-	{ 35, 2, 228,   0,       0,  21,     0,   0,  30,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  28 */
-	{ 34, 2, 176,   0,       0,  18,     0,   0,  30,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  29 */
-	{ 36, 2, 200,   0,       0,  24,     0,   0,  30,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  30 */
-	{ 37, 2, 192,   0,       0,  20,     0,   0,  25,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  31 */
-	{ 38, 2, 190,   0,       0,  21,     0,   0,  25,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  32 */
-	{ 39, 2, 182,   0,       0,  19,     0,   0,  30,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  33 */
-	{ 40, 2, 181,   0,       0,  16,     0,   0,  30,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  34 */
-	{ 41, 2, 179,   0,       0,  19,     0,   0,  30,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  35 */
-	{ 42, 2, 196,   0,       0,  18,     0,   0,  20,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  36 */
-	{ 43, 2, 255,   0,       0,  30,     0,   0,  20,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  37 */
-	{ 44, 2, 191,   0,       0,  22,     0,   0,  25,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  38 */
-	{ 45, 2, 196,   0,       0,  18,     0,   0,  20,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  39 */
-	{ 46, 2, 179,   0,       0,  19,     0,   0,  30,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  40 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  25,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  41 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  25,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  42 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  21,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  43 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  30,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  44 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  30,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  45 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  30,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  46 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  20,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  47 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  25,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  48 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  25,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  49 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  20,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  50 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  22,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  51 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  25,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  52 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  30,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  53 */
-	{ 25, 0,  52, 304,    9000,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  54 */
-	{ 26, 1,  60, 336, 10000/2,85/2, 240/2,   2,  25,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  55 */
-	{ 26, 0,  53, 320,    5000,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  56 */
-	{ 60, 2, 247,   0,       0,  25,     0,   0,  45,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  57 */
-	{ 62, 2, 228,   0,       0,  21,     0,   0,  35,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  58 */
-	{ 61, 2, 176,   0,       0,  18,     0,   0,  35,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  59 */
-	{ 63, 2, 200,   0,       0,  24,     0,   0,  35,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  60 */
-	{ 64, 2, 192,   0,       0,  20,     0,   0,  30,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  61 */
-	{ 65, 2, 190,   0,       0,  21,     0,   0,  30,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  62 */
-	{ 66, 2, 182,   0,       0,  19,     0,   0,  35,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  63 */
-	{ 67, 2, 181,   0,       0,  16,     0,   0,  35,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  64 */
-	{ 68, 2, 179,   0,       0,  19,     0,   0,  35,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  65 */
-	{ 69, 2, 196,   0,       0,  18,     0,   0,  25,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  66 */
-	{ 70, 2, 255,   0,       0,  30,     0,   0,  25,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  67 */
-	{ 71, 2, 191,   0,       0,  22,     0,   0,  30,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  68 */
-	{ 72, 2, 196,   0,       0,  18,     0,   0,  25,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  69 */
-	{ 73, 2, 179,   0,       0,  19,     0,   0,  35,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  70 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  30,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  71 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  30,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  72 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  26,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  73 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  35,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  74 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  35,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  75 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  35,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  76 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  25,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  77 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  30,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  78 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  30,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  79 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  25,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  80 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  27,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  81 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  30,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  82 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  35,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  83 */
-	{ 28, 0,  70, 400,   10000, 105,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  84 */
-	{ 29, 0,  74, 448,   12000, 120,   253,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  85 */
-	{ 30, 0,  82, 480,   15000, 130,   254,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  86 */
-	{ 31, 1,  95, 640, 20000/2,150/2,255/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  87 */
-	{ 28, 0,  70, 480,   10000, 120,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  88 */
-	{ 60, 2, 247,   0,       0,  25,     0,   0,  47,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  89 */
-	{ 62, 2, 228,   0,       0,  21,     0,   0,  37,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  90 */
-	{ 61, 2, 176,   0,       0,  18,     0,   0,  37,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  91 */
-	{ 63, 2, 200,   0,       0,  24,     0,   0,  37,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  92 */
-	{ 64, 2, 192,   0,       0,  20,     0,   0,  32,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  93 */
-	{ 65, 2, 190,   0,       0,  21,     0,   0,  32,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  94 */
-	{ 66, 2, 182,   0,       0,  19,     0,   0,  37,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  95 */
-	{ 67, 2, 181,   0,       0,  16,     0,   0,  37,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  96 */
-	{ 68, 2, 179,   0,       0,  19,     0,   0,  37,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  97 */
-	{ 69, 2, 196,   0,       0,  18,     0,   0,  27,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  98 */
-	{ 70, 2, 255,   0,       0,  30,     0,   0,  27,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  99 */
-	{ 71, 2, 191,   0,       0,  22,     0,   0,  32,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /* 100 */
-	{ 72, 2, 196,   0,       0,  18,     0,   0,  27,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /* 101 */
-	{ 73, 2, 179,   0,       0,  19,     0,   0,  37,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /* 102 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  32,   CT_WATER        ,  0,  0,  0,  0,  0 }, /* 103 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  32,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /* 104 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  28,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /* 105 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  37,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /* 106 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  37,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /* 107 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  37,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /* 108 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  27,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /* 109 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  32,   CT_COLA         ,  0,  0,  0,  0,  0 }, /* 110 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  32,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /* 111 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  27,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /* 112 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  29,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /* 113 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  32,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /* 114 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  37,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /* 115 */
+	// |  |    |    |        |    |      |    |    |    cargo_type         |   |   |    visual effects
+	// |  |    |    |        |    |      |    |    |    |                  |   |   |    |    |
+	{  2, 0,   7,  64,     300,  47,    50,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   0 */
+	{ 19, 0,   8,  80,     600,  65,    65,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   1 */
+	{  2, 0,  10,  72,     400,  85,    90,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   2 */
+	{  0, 0,  15,  96,     900, 130,   130,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   3 */
+	{  1, 0,  19, 112,    1000, 140,   145,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   4 */
+	{ 12, 0,  16, 120,    1400,  95,   125,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   5 */
+	{ 14, 0,  20, 152,    2000, 120,   135,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   6 */
+	{  3, 0,  14,  88,    1100, 145,   130,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   7 */
+	{  0, 0,  13, 112,    1000, 131,   120,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   8 */
+	{  1, 0,  19, 128,    1200, 162,   140,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*   9 */
+	{  0, 0,  22, 144,    1600, 170,   130,   0,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  10 */
+	{  8, 1,  11, 112,   600/2,32/2,  85/2,   1,  38,   CT_PASSENGERS   ,  0,  0,  0, 0xFF,  0 }, /*  11 */
+	{ 10, 1,  14, 120,   700/2,38/2,  70/2,   1,  40,   CT_PASSENGERS   ,  0,  0,  0, 0xFF,  0 }, /*  12 */
+	{  4, 0,  15, 128,    1250,  72,    95,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  13 */
+	{  5, 0,  17, 144,    1750, 101,   120,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  14 */
+	{  4, 0,  18, 160,    2580, 112,   140,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  15 */
+	{ 14, 0,  23,  96,    4000, 150,   135,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  16 */
+	{ 12, 0,  16, 112,    2400, 120,   105,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  17 */
+	{ 13, 0,  30, 112,    6600, 207,   155,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  18 */
+	{ 15, 0,  18, 104,    1500, 110,   105,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  19 */
+	{ 16, 1,  35, 160,  3500/2,95/2, 205/2,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  20 */
+	{ 18, 0,  21, 104,    2200, 120,   145,   1,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  21 */
+	{  6, 1,  20, 200,  4500/2,70/2, 190/2,   1,   4,   CT_MAIL         ,  0,  0,  0, 0xFF,  0 }, /*  22 */
+	{ 20, 0,  26, 160,    3600,  84,   180,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  23 */
+	{ 20, 0,  30, 176,    5000,  82,   205,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  24 */
+	{ 21, 1,  40, 240,  7000/2,90/2, 240/2,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  25 */
+	{ 23, 1,  43, 264,  8000/2,95/2, 250/2,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  26 */
+	{ 33, 2, 247,   0,       0,  25,     0,   0,  40,   CT_PASSENGERS   ,  0,  0,  0, 0xFF,  0 }, /*  27 */
+	{ 35, 2, 228,   0,       0,  21,     0,   0,  30,   CT_MAIL         ,  0,  0,  0, 0xFF,  0 }, /*  28 */
+	{ 34, 2, 176,   0,       0,  18,     0,   0,  30,   CT_COAL         ,  0,  0,  0, 0xFF,  0 }, /*  29 */
+	{ 36, 2, 200,   0,       0,  24,     0,   0,  30,   CT_OIL          ,  0,  0,  0, 0xFF,  0 }, /*  30 */
+	{ 37, 2, 192,   0,       0,  20,     0,   0,  25,   CT_LIVESTOCK    ,  0,  0,  0, 0xFF,  0 }, /*  31 */
+	{ 38, 2, 190,   0,       0,  21,     0,   0,  25,   CT_GOODS        ,  0,  0,  0, 0xFF,  0 }, /*  32 */
+	{ 39, 2, 182,   0,       0,  19,     0,   0,  30,   CT_GRAIN        ,  0,  0,  0, 0xFF,  0 }, /*  33 */
+	{ 40, 2, 181,   0,       0,  16,     0,   0,  30,   CT_WOOD         ,  0,  0,  0, 0xFF,  0 }, /*  34 */
+	{ 41, 2, 179,   0,       0,  19,     0,   0,  30,   CT_IRON_ORE     ,  0,  0,  0, 0xFF,  0 }, /*  35 */
+	{ 42, 2, 196,   0,       0,  18,     0,   0,  20,   CT_STEEL        ,  0,  0,  0, 0xFF,  0 }, /*  36 */
+	{ 43, 2, 255,   0,       0,  30,     0,   0,  20,   CT_VALUABLES    ,  0,  0,  0, 0xFF,  0 }, /*  37 */
+	{ 44, 2, 191,   0,       0,  22,     0,   0,  25,   CT_FOOD         ,  0,  0,  0, 0xFF,  0 }, /*  38 */
+	{ 45, 2, 196,   0,       0,  18,     0,   0,  20,   CT_PAPER        ,  0,  0,  0, 0xFF,  0 }, /*  39 */
+	{ 46, 2, 179,   0,       0,  19,     0,   0,  30,   CT_COPPER_ORE   ,  0,  0,  0, 0xFF,  0 }, /*  40 */
+	{ 47, 2, 199,   0,       0,  25,     0,   0,  25,   CT_WATER        ,  0,  0,  0, 0xFF,  0 }, /*  41 */
+	{ 48, 2, 182,   0,       0,  18,     0,   0,  25,   CT_FRUIT        ,  0,  0,  0, 0xFF,  0 }, /*  42 */
+	{ 49, 2, 185,   0,       0,  19,     0,   0,  21,   CT_RUBBER       ,  0,  0,  0, 0xFF,  0 }, /*  43 */
+	{ 50, 2, 176,   0,       0,  19,     0,   0,  30,   CT_SUGAR        ,  0,  0,  0, 0xFF,  0 }, /*  44 */
+	{ 51, 2, 178,   0,       0,  20,     0,   0,  30,   CT_COTTON_CANDY ,  0,  0,  0, 0xFF,  0 }, /*  45 */
+	{ 52, 2, 192,   0,       0,  20,     0,   0,  30,   CT_TOFFEE       ,  0,  0,  0, 0xFF,  0 }, /*  46 */
+	{ 53, 2, 190,   0,       0,  21,     0,   0,  20,   CT_BUBBLES      ,  0,  0,  0, 0xFF,  0 }, /*  47 */
+	{ 54, 2, 182,   0,       0,  24,     0,   0,  25,   CT_COLA         ,  0,  0,  0, 0xFF,  0 }, /*  48 */
+	{ 55, 2, 181,   0,       0,  21,     0,   0,  25,   CT_CANDY        ,  0,  0,  0, 0xFF,  0 }, /*  49 */
+	{ 56, 2, 183,   0,       0,  21,     0,   0,  20,   CT_TOYS         ,  0,  0,  0, 0xFF,  0 }, /*  50 */
+	{ 57, 2, 196,   0,       0,  18,     0,   0,  22,   CT_BATTERIES    ,  0,  0,  0, 0xFF,  0 }, /*  51 */
+	{ 58, 2, 193,   0,       0,  18,     0,   0,  25,   CT_FIZZY_DRINKS ,  0,  0,  0, 0xFF,  0 }, /*  52 */
+	{ 59, 2, 191,   0,       0,  18,     0,   0,  30,   CT_PLASTIC      ,  0,  0,  0, 0xFF,  0 }, /*  53 */
+	{ 25, 0,  52, 304,    9000,  95,   230,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  54 */
+	{ 26, 1,  60, 336, 10000/2,85/2, 240/2,   2,  25,   CT_PASSENGERS   ,  0,  0,  0, 0xFF,  0 }, /*  55 */
+	{ 26, 0,  53, 320,    5000,  95,   230,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  56 */
+	{ 60, 2, 247,   0,       0,  25,     0,   0,  45,   CT_PASSENGERS   ,  0,  0,  0, 0xFF,  0 }, /*  57 */
+	{ 62, 2, 228,   0,       0,  21,     0,   0,  35,   CT_MAIL         ,  0,  0,  0, 0xFF,  0 }, /*  58 */
+	{ 61, 2, 176,   0,       0,  18,     0,   0,  35,   CT_COAL         ,  0,  0,  0, 0xFF,  0 }, /*  59 */
+	{ 63, 2, 200,   0,       0,  24,     0,   0,  35,   CT_OIL          ,  0,  0,  0, 0xFF,  0 }, /*  60 */
+	{ 64, 2, 192,   0,       0,  20,     0,   0,  30,   CT_LIVESTOCK    ,  0,  0,  0, 0xFF,  0 }, /*  61 */
+	{ 65, 2, 190,   0,       0,  21,     0,   0,  30,   CT_GOODS        ,  0,  0,  0, 0xFF,  0 }, /*  62 */
+	{ 66, 2, 182,   0,       0,  19,     0,   0,  35,   CT_GRAIN        ,  0,  0,  0, 0xFF,  0 }, /*  63 */
+	{ 67, 2, 181,   0,       0,  16,     0,   0,  35,   CT_WOOD         ,  0,  0,  0, 0xFF,  0 }, /*  64 */
+	{ 68, 2, 179,   0,       0,  19,     0,   0,  35,   CT_IRON_ORE     ,  0,  0,  0, 0xFF,  0 }, /*  65 */
+	{ 69, 2, 196,   0,       0,  18,     0,   0,  25,   CT_STEEL        ,  0,  0,  0, 0xFF,  0 }, /*  66 */
+	{ 70, 2, 255,   0,       0,  30,     0,   0,  25,   CT_VALUABLES    ,  0,  0,  0, 0xFF,  0 }, /*  67 */
+	{ 71, 2, 191,   0,       0,  22,     0,   0,  30,   CT_FOOD         ,  0,  0,  0, 0xFF,  0 }, /*  68 */
+	{ 72, 2, 196,   0,       0,  18,     0,   0,  25,   CT_PAPER        ,  0,  0,  0, 0xFF,  0 }, /*  69 */
+	{ 73, 2, 179,   0,       0,  19,     0,   0,  35,   CT_COPPER_ORE   ,  0,  0,  0, 0xFF,  0 }, /*  70 */
+	{ 47, 2, 199,   0,       0,  25,     0,   0,  30,   CT_WATER        ,  0,  0,  0, 0xFF,  0 }, /*  71 */
+	{ 48, 2, 182,   0,       0,  18,     0,   0,  30,   CT_FRUIT        ,  0,  0,  0, 0xFF,  0 }, /*  72 */
+	{ 49, 2, 185,   0,       0,  19,     0,   0,  26,   CT_RUBBER       ,  0,  0,  0, 0xFF,  0 }, /*  73 */
+	{ 50, 2, 176,   0,       0,  19,     0,   0,  35,   CT_SUGAR        ,  0,  0,  0, 0xFF,  0 }, /*  74 */
+	{ 51, 2, 178,   0,       0,  20,     0,   0,  35,   CT_COTTON_CANDY ,  0,  0,  0, 0xFF,  0 }, /*  75 */
+	{ 52, 2, 192,   0,       0,  20,     0,   0,  35,   CT_TOFFEE       ,  0,  0,  0, 0xFF,  0 }, /*  76 */
+	{ 53, 2, 190,   0,       0,  21,     0,   0,  25,   CT_BUBBLES      ,  0,  0,  0, 0xFF,  0 }, /*  77 */
+	{ 54, 2, 182,   0,       0,  24,     0,   0,  30,   CT_COLA         ,  0,  0,  0, 0xFF,  0 }, /*  78 */
+	{ 55, 2, 181,   0,       0,  21,     0,   0,  30,   CT_CANDY        ,  0,  0,  0, 0xFF,  0 }, /*  79 */
+	{ 56, 2, 183,   0,       0,  21,     0,   0,  25,   CT_TOYS         ,  0,  0,  0, 0xFF,  0 }, /*  80 */
+	{ 57, 2, 196,   0,       0,  18,     0,   0,  27,   CT_BATTERIES    ,  0,  0,  0, 0xFF,  0 }, /*  81 */
+	{ 58, 2, 193,   0,       0,  18,     0,   0,  30,   CT_FIZZY_DRINKS ,  0,  0,  0, 0xFF,  0 }, /*  82 */
+	{ 59, 2, 191,   0,       0,  18,     0,   0,  35,   CT_PLASTIC      ,  0,  0,  0, 0xFF,  0 }, /*  83 */
+	{ 28, 0,  70, 400,   10000, 105,   250,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  84 */
+	{ 29, 0,  74, 448,   12000, 120,   253,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  85 */
+	{ 30, 0,  82, 480,   15000, 130,   254,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  86 */
+	{ 31, 1,  95, 640, 20000/2,150/2,255/2,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  87 */
+	{ 28, 0,  70, 480,   10000, 120,   250,   2,   0,   0               ,  0,  0,  0, 0xFF,  0 }, /*  88 */
+	{ 60, 2, 247,   0,       0,  25,     0,   0,  47,   CT_PASSENGERS   ,  0,  0,  0, 0xFF,  0 }, /*  89 */
+	{ 62, 2, 228,   0,       0,  21,     0,   0,  37,   CT_MAIL         ,  0,  0,  0, 0xFF,  0 }, /*  90 */
+	{ 61, 2, 176,   0,       0,  18,     0,   0,  37,   CT_COAL         ,  0,  0,  0, 0xFF,  0 }, /*  91 */
+	{ 63, 2, 200,   0,       0,  24,     0,   0,  37,   CT_OIL          ,  0,  0,  0, 0xFF,  0 }, /*  92 */
+	{ 64, 2, 192,   0,       0,  20,     0,   0,  32,   CT_LIVESTOCK    ,  0,  0,  0, 0xFF,  0 }, /*  93 */
+	{ 65, 2, 190,   0,       0,  21,     0,   0,  32,   CT_GOODS        ,  0,  0,  0, 0xFF,  0 }, /*  94 */
+	{ 66, 2, 182,   0,       0,  19,     0,   0,  37,   CT_GRAIN        ,  0,  0,  0, 0xFF,  0 }, /*  95 */
+	{ 67, 2, 181,   0,       0,  16,     0,   0,  37,   CT_WOOD         ,  0,  0,  0, 0xFF,  0 }, /*  96 */
+	{ 68, 2, 179,   0,       0,  19,     0,   0,  37,   CT_IRON_ORE     ,  0,  0,  0, 0xFF,  0 }, /*  97 */
+	{ 69, 2, 196,   0,       0,  18,     0,   0,  27,   CT_STEEL        ,  0,  0,  0, 0xFF,  0 }, /*  98 */
+	{ 70, 2, 255,   0,       0,  30,     0,   0,  27,   CT_VALUABLES    ,  0,  0,  0, 0xFF,  0 }, /*  99 */
+	{ 71, 2, 191,   0,       0,  22,     0,   0,  32,   CT_FOOD         ,  0,  0,  0, 0xFF,  0 }, /* 100 */
+	{ 72, 2, 196,   0,       0,  18,     0,   0,  27,   CT_PAPER        ,  0,  0,  0, 0xFF,  0 }, /* 101 */
+	{ 73, 2, 179,   0,       0,  19,     0,   0,  37,   CT_COPPER_ORE   ,  0,  0,  0, 0xFF,  0 }, /* 102 */
+	{ 47, 2, 199,   0,       0,  25,     0,   0,  32,   CT_WATER        ,  0,  0,  0, 0xFF,  0 }, /* 103 */
+	{ 48, 2, 182,   0,       0,  18,     0,   0,  32,   CT_FRUIT        ,  0,  0,  0, 0xFF,  0 }, /* 104 */
+	{ 49, 2, 185,   0,       0,  19,     0,   0,  28,   CT_RUBBER       ,  0,  0,  0, 0xFF,  0 }, /* 105 */
+	{ 50, 2, 176,   0,       0,  19,     0,   0,  37,   CT_SUGAR        ,  0,  0,  0, 0xFF,  0 }, /* 106 */
+	{ 51, 2, 178,   0,       0,  20,     0,   0,  37,   CT_COTTON_CANDY ,  0,  0,  0, 0xFF,  0 }, /* 107 */
+	{ 52, 2, 192,   0,       0,  20,     0,   0,  37,   CT_TOFFEE       ,  0,  0,  0, 0xFF,  0 }, /* 108 */
+	{ 53, 2, 190,   0,       0,  21,     0,   0,  27,   CT_BUBBLES      ,  0,  0,  0, 0xFF,  0 }, /* 109 */
+	{ 54, 2, 182,   0,       0,  24,     0,   0,  32,   CT_COLA         ,  0,  0,  0, 0xFF,  0 }, /* 110 */
+	{ 55, 2, 181,   0,       0,  21,     0,   0,  32,   CT_CANDY        ,  0,  0,  0, 0xFF,  0 }, /* 111 */
+	{ 56, 2, 183,   0,       0,  21,     0,   0,  27,   CT_TOYS         ,  0,  0,  0, 0xFF,  0 }, /* 112 */
+	{ 57, 2, 196,   0,       0,  18,     0,   0,  29,   CT_BATTERIES    ,  0,  0,  0, 0xFF,  0 }, /* 113 */
+	{ 58, 2, 193,   0,       0,  18,     0,   0,  32,   CT_FIZZY_DRINKS ,  0,  0,  0, 0xFF,  0 }, /* 114 */
+	{ 59, 2, 191,   0,       0,  18,     0,   0,  37,   CT_PLASTIC      ,  0,  0,  0, 0xFF,  0 }, /* 115 */
 };
 
 ShipVehicleInfo _ship_vehicle_info[NUM_SHIP_ENGINES] = {
Index: road_cmd.c
===================================================================
--- road_cmd.c	(revision 2908)
+++ road_cmd.c	(working copy)
@@ -17,6 +17,7 @@
 #include "depot.h"
 #include "pbs.h"
 #include "debug.h"
+#include "bridge.h"
 
 /* When true, GetTrackStatus for roads will treat roads under reconstruction
  * as normal roads instead of impassable. This is used when detecting whether
@@ -187,6 +188,31 @@
 		if (!EnsureNoVehicleZ(tile, TilePixelHeight(tile)))
 			return CMD_ERROR;
 
+		if (IsTileBridgeEnd(tile)) {
+			byte current_road;
+			if (!IsTileOwner(tile, _current_player) ||
+					ti.tileh == 0 ||
+					(GB(_m[tile].m5, 1, 2) != TRANSPORT_ROAD) ||
+					!EnsureNoVehicle(tile))
+				return CMD_ERROR;
+
+			current_road = GetBridgeEndRoadBits(tile);
+			if (!(current_road & pieces))
+				return CMD_ERROR; // Road bit isn't there
+
+			if (flags & DC_EXEC) {
+				UnsetBridgeEndRoadBits(tile, pieces);
+				MarkTileDirtyByTile(tile);
+			}
+
+			cost = _price.remove_road;
+			if (!(current_road & ~pieces)) {
+				// If removing the last piece add the cost of terraforming, and the normal road piece.
+				cost += _price.terraform + _price.build_road;
+			}
+			return cost;
+		}
+
 		if ((ti.map5 & 0xE9) == 0xE8) {
 			if (pieces & 10) goto return_error;
 		} else if ((ti.map5 & 0xE9) == 0xE9) {
@@ -359,7 +385,7 @@
 int32 CmdBuildRoad(int x, int y, uint32 flags, uint32 p1, uint32 p2)
 {
 	TileInfo ti;
-	int32 cost;
+	int32 cost = 0;
 	byte pieces = (byte)p1, existing = 0;
 	TileIndex tile;
 
@@ -423,6 +449,41 @@
 		if (IsSteepTileh(ti.tileh)) // very steep tile
 				return_cmd_error(STR_1000_LAND_SLOPED_IN_WRONG_DIRECTION);
 
+		if (IsTileBridgeEnd(tile)) {
+			if (!IsTileOwner(tile, _current_player) ||
+					ti.tileh == 0 ||
+					(GB(_m[tile].m5, 1, 2) != TRANSPORT_ROAD) || // Must be road bridge
+					!EnsureNoVehicle(tile))
+				return CMD_ERROR;
+
+			existing = GetBridgeEndRoadBits(tile);
+			if (existing & pieces)
+				return CMD_ERROR; // Road bit is already there
+
+			if (!(HASBIT(_m[tile].m5, 0))) { // X
+				if (!(ti.tileh & 9) && HASBIT(pieces, 0)) return CMD_ERROR; // Top left
+				if (!(ti.tileh & 6) && HASBIT(pieces, 2)) return CMD_ERROR; // Buttom rght
+			} else {
+				if (!(ti.tileh & 3) && HASBIT(pieces, 1)) return CMD_ERROR; // Bottom left
+				if (!(ti.tileh & 12) && HASBIT(pieces, 3)) return CMD_ERROR; // Top right
+			}
+
+			if (existing == 0) {
+				if (!((HASBIT(_m[tile].m5, 0) ? 5 : 10) & pieces)) {
+					cost += _price.build_road;
+					pieces |= HASBIT(_m[tile].m5, 0) ? 5 : 10;
+				}
+				// Charge for raising the land.
+				cost += _price.terraform;
+			}
+
+			if (flags & DC_EXEC) {
+				SetBridgeEndRoadBits(tile, pieces);
+				MarkTileDirtyByTile(tile);
+			}
+			return cost + _price.build_road;
+		}
+
 		/* is this middle part of a bridge? */
 		if ((ti.map5 & 0xC0) != 0xC0)
 				goto do_clear;
@@ -770,59 +831,74 @@
 	0,  0
 };
 
-static void DrawTile_Road(TileInfo *ti)
-{
-	uint32 image;
-	uint16 m2;
-
-	if ( (ti->map5 & 0xF0) == 0) { // if it is a road the upper 4 bits are 0
-		const DrawRoadTileStruct *drts;
+/**
+ * Draws the ground sprite and road pieces.
+ * @param ti TileInfo, used to work out slopes.
+ * @param road RoadBits to draw.
+ * @param ground_type Type of ground to draw.
+ * - ground_type = 0 bare land.
+ * - ground_type = 1 grass.
+ * - ground_type = 2 pavement.
+ * - ground_type = 3 pavement with streetlights.
+ * - ground_type = 5 pavement with trees.
+ * - ground_type = 6 grass with road works.
+ * - ground_type = 7 pavement with road works.
+ * @param snow Flag whether to draw as snow (or desert).
+ * @param flag Always draw foundation to ensure flat tile..
+ */
+void DrawRoadBits(TileInfo *ti, byte road, byte ground_type, bool snow, bool flat) {
+	const DrawRoadTileStruct *drts;
+	PalSpriteID image = 0;
 
-		if (ti->tileh != 0) {
-			int f = GetRoadFoundation(ti->tileh, ti->map5 & 0xF);
-			if (f) DrawFoundation(ti, f);
-
-			// default sloped sprites..
-			if (ti->tileh != 0) {
-				image = _road_sloped_sprites[ti->tileh - 1] + 0x53F;
-			} else  {
-				image = _road_tile_sprites_1[ti->map5 & 0xF];
-			}
+	if (ti->tileh != 0) {
+		int foundation;
+		if (flat) {
+			foundation = ti->tileh;
 		} else {
-			image = _road_tile_sprites_1[ti->map5 & 0xF];
+			foundation = GetRoadFoundation(ti->tileh, road);
 		}
 
-		m2 = GB(_m[ti->tile].m4, 4, 3);
+		if (foundation) DrawFoundation(ti, foundation);
 
-		if (m2 == 0) image |= PALETTE_TO_BARE_LAND;
+		// default sloped sprites..
+		if (ti->tileh != 0) image = _road_sloped_sprites[ti->tileh - 1] + 0x53F;
+	}
 
-		if (_m[ti->tile].m4 & 0x80) {
-			image += 19;
-		} else if (m2 > 1 && m2 != 6) {
-			image -= 19; /* pavement along the road? */
-		}
+	if (image == 0) image = _road_tile_sprites_1[road];
+	if (ground_type == 0) image |= PALETTE_TO_BARE_LAND;
+	if (snow) image += 19;
+	if (ground_type > 1 && ground_type != 6) image -= 19; // pavement along road
 
-		DrawGroundSprite(image);
+	DrawGroundSprite(image);
 
-		if (!(_display_opt & DO_FULL_DETAIL) || _cur_dpi->zoom == 2)
-			return;
+	if (!(_display_opt & DO_FULL_DETAIL) || _cur_dpi->zoom == 2)
+		return;
 
-		if (m2 >= 6) {
-			// roadwork
-			DrawGroundSprite(0x586 + ((ti->map5&8)!=0 ? 0 : 1));
-			return;
-		}
+	if (ground_type >= 6) {
+		// Road works
+		DrawGroundSprite(0x586 + (HASBIT(road, 4) ? 0 : 1));
+		return;
+	}
 
-		drts = _road_display_table[m2][ti->map5 & 0xF];
+	drts = _road_display_table[ground_type][road];
 
-		while ((image = drts->image) != 0) {
-			int x = ti->x | drts->subcoord_x;
-			int y = ti->y | drts->subcoord_y;
-			byte z = ti->z;
-			if (ti->tileh != 0)	z = GetSlopeZ(x, y);
-			AddSortableSpriteToDraw(image, x, y, 2, 2, 0x10, z);
-			drts++;
-		}
+	while ((image = drts->image) != 0) {
+		int x = ti->x | drts->subcoord_x;
+		int y = ti->y | drts->subcoord_y;
+		byte z = ti->z;
+		if (ti->tileh != 0) z = GetSlopeZ(x, y);
+		AddSortableSpriteToDraw(image, x, y, 2, 2, 0x10, z);
+		drts++;
+	}
+}
+
+static void DrawTile_Road(TileInfo *ti)
+{
+	uint32 image;
+	uint16 m2;
+
+	if ( (ti->map5 & 0xF0) == 0) { // if it is a road the upper 4 bits are 0
+		DrawRoadBits(ti, GB(ti->map5, 0, 4), GB(_m[ti->tile].m4, 4, 3), HASBIT(_m[ti->tile].m4, 7), false);
 	} else if ( (ti->map5 & 0xE0) == 0) { // railroad crossing
 		int f = GetRoadFoundation(ti->tileh, ti->map5 & 0xF);
 		if (f) DrawFoundation(ti, f);
@@ -986,11 +1062,53 @@
 	{3,2},
 };
 
+/**
+ * Updates the ground type of road tiles (also used by custom bridgeheads)
+ * @param tile Tile.
+ * @param ground_type Existing ground of road.
+ * @param Road bits.
+ * @return New ground type to use.
+ */
+byte GetUpdatedRoadGroundType(TileIndex tile, byte ground_type, byte road)
+{
+	Town *t = ClosestTownFromTile(tile, (uint)-1);
+	int grp = 0;
+
+	if (t != NULL) {
+		grp = GetTownRadiusGroup(t, tile);
+		if (t->road_build_months != 0 &&
+				!(DistanceManhattan(t->xy, tile) >= 8 && grp == 0) &&
+				(road == 5 || road == 10)) {
+			if (EnsureNoVehicle(tile) && CHANCE16(1,20)) {
+				ground_type |= ground_type <= 2 ? 7 : 6;
+				SndPlayTileFx(SND_21_JACKHAMMER, tile);
+				CreateEffectVehicleAbove(
+						TileX(tile) * 16 + 7,
+						TileY(tile) * 16 + 7,
+						0,
+						EV_BULLDOZER);
+				return ground_type;
+			}
+		}
+	}
+
+	{
+		const byte *p = (_opt.landscape == LT_CANDY) ? _town_road_types_2[grp] : _town_road_types[grp];
+		if (ground_type == p[0])
+			return ground_type;
+		if (ground_type == p[1]) {
+			return p[0];
+		} else if (ground_type == 0) {
+			return p[1];
+		} else {
+			return 0;
+		}
+	}
+}
 
 static void TileLoop_Road(TileIndex tile)
 {
-	Town *t;
-	int grp;
+	byte old_ground_type;
 
 	if (_opt.landscape == LT_HILLY) {
 		// Fix snow style if the road is above the snowline
@@ -1009,47 +1127,11 @@
 	if (_m[tile].m5 & 0xE0)
 		return;
 
-	if (GB(_m[tile].m4, 4, 3) < 6) {
-		t = ClosestTownFromTile(tile, (uint)-1);
-
-		grp = 0;
-		if (t != NULL) {
-			grp = GetTownRadiusGroup(t, tile);
-
-			// Show an animation to indicate road work
-			if (t->road_build_months != 0 &&
-					!(DistanceManhattan(t->xy, tile) >= 8 && grp == 0) &&
-					(_m[tile].m5==5 || _m[tile].m5==10)) {
-				if (GetTileSlope(tile, NULL) == 0 && EnsureNoVehicle(tile) && CHANCE16(1,20)) {
-					_m[tile].m4 |= (GB(_m[tile].m4, 4, 3) <=  2 ? 7 : 6) << 4;
-
-					SndPlayTileFx(SND_21_JACKHAMMER, tile);
-					CreateEffectVehicleAbove(
-						TileX(tile) * 16 + 7,
-						TileY(tile) * 16 + 7,
-						0,
-						EV_BULLDOZER);
-					MarkTileDirtyByTile(tile);
-					return;
-				}
-			}
-		}
-
-		{
-			const byte *p = (_opt.landscape == LT_CANDY) ? _town_road_types_2[grp] : _town_road_types[grp];
-			byte b = GB(_m[tile].m4, 4, 3);
-
-			if (b == p[0])
-				return;
-
-			if (b == p[1]) {
-				b = p[0];
-			} else if (b == 0) {
-				b = p[1];
-			} else {
-				b = 0;
-			}
-			_m[tile].m4 = (_m[tile].m4 & ~0x70) | (b << 4);
+	old_ground_type = GB(_m[tile].m4, 4, 3);
+	if (old_ground_type < 6) {
+		byte new_ground_type = GetUpdatedRoadGroundType(tile, old_ground_type, GB(_m[tile].m5, 0, 4));
+		if (old_ground_type != new_ground_type) {
+			SB(_m[tile].m4, 4, 3, new_ground_type);
 			MarkTileDirtyByTile(tile);
 		}
 	} else {
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 2908)
+++ rail_cmd.c	(working copy)
@@ -23,6 +23,9 @@
 #include "npf.h"
 #include "rail.h"
 #include "railtypes.h" // include table for railtypes
+#include "bridge.h"
+#include "variables.h"
+#include "newgrf_callbacks.h"
 
 extern uint16 _custom_sprites_base;
 
@@ -287,6 +290,51 @@
 
 	switch (GetTileType(tile)) {
 		case MP_TUNNELBRIDGE:
+			if (IsTileBridgeEnd(tile)) { // Bridge Ending
+				TrackBits current_trackbits;
+
+				if (!IsTileOwner(tile, _current_player) || // Must be same owner.
+						tileh == 0 || // Flat land means the bridge is sloped, so we can't build on it.
+						(GB(_m[tile].m5, 1, 2) != TRANSPORT_RAIL) || // Must be railway bridge.
+						((RailType)GB(_m[tile].m3, 0, 4) != (RailType)p1) || // Wrong track type.
+						!EnsureNoVehicle(tile))
+					return CMD_ERROR;
+
+				current_trackbits = GetBridgeEndTrackBits(tile);
+				if (current_trackbits & trackbit)
+					return CMD_ERROR; // Track bit is already there
+
+				if (!(HASBIT(m5, 0))) { // X
+					if (!(tileh & 9) && (trackbit & (TRACK_BIT_UPPER | TRACK_BIT_LEFT | TRACK_BIT_DIAG2))) return CMD_ERROR; // Top left
+					if (!(tileh & 6) && (trackbit & (TRACK_BIT_LOWER | TRACK_BIT_RIGHT | TRACK_BIT_DIAG2))) return CMD_ERROR; // Bottom right
+				} else { // Y
+					if (!(tileh & 3) && (trackbit & (TRACK_BIT_LOWER | TRACK_BIT_LEFT | TRACK_BIT_DIAG1))) return CMD_ERROR; // Bottom left
+					if (!(tileh & 12) && (trackbit & (TRACK_BIT_UPPER | TRACK_BIT_RIGHT | TRACK_BIT_DIAG1))) return CMD_ERROR; // Top right
+				}
+
+				if (current_trackbits == 0) {
+					if (!((HASBIT(m5, 0) ? 2 : 1) & trackbit)) {
+						// We are building a piece other than the normal bridge end track. Charge extra for it.
+						cost += _price.build_rail;
+						trackbit |= HASBIT(m5, 0) ? 2 : 1;
+					}
+					// Charge for raising the land.
+					cost += _price.terraform;
+				}
+
+				if (flags & DC_EXEC) {
+					bool reserved = false;
+					if (current_trackbits == 0) {
+						reserved = PBSTileReserved(tile);
+						if (reserved)
+							PBSClearTrack(tile, HASBIT(m5, 0));
+					}
+					SetBridgeEndTrackBits(tile, trackbit);
+					if (reserved)
+						PBSReserveTrack(tile, HASBIT(m5, 0));
+				}
+				break;
+			}
 			if ((m5 & 0xC0) != 0xC0 || // not bridge middle part?
 					(m5 & 0x01 ? TRACK_BIT_DIAG1 : TRACK_BIT_DIAG2) != trackbit) { // wrong direction?
 				// Get detailed error message
@@ -384,7 +432,7 @@
 		SetSignalsOnBothDir(tile, track);
 	}
 
-	return cost + _price.build_rail;
+	return cost + _price.build_rail * (1 + (_patches.differing_rail_costs ? p1 : 0));
 }
 
 static const byte _signals_table[] = {
@@ -441,6 +489,37 @@
 			if (!EnsureNoVehicleZ(tile, TilePixelHeight(tile)))
 				return CMD_ERROR;
 
+			if (IsTileBridgeEnd(tile)) { // Bridge Ending
+				TrackBits current_trackbits;
+				bool reserved = false;
+
+				if (!IsTileOwner(tile, _current_player) || // Must be same owner.
+						tileh == 0 || // Flat land means the bridge is sloped, so we can't build on it.
+						(GB(_m[tile].m5, 1, 2) != 0) || // Must be railway bridge.
+						((RailType)GB(_m[tile].m3, 0, 4) != (RailType)p1) || // Wrong track type.
+						!EnsureNoVehicle(tile))
+					return CMD_ERROR;
+
+				current_trackbits = GetBridgeEndTrackBits(tile);
+				if (!(current_trackbits & trackbit))
+					return CMD_ERROR; // Track bit isn't there
+
+				if (!(current_trackbits & ~trackbit)) {
+					// If removing the last piece add the cost of terraforming, and the normal rail piece.
+					cost += _price.terraform + _price.build_rail;
+					reserved = PBSTileReserved(tile);
+				}
+
+				if (flags & DC_EXEC) {
+					if (reserved)
+						PBSClearTrack(tile, HASBIT(m5, 0));
+					UnsetBridgeEndTrackBits(tile, trackbit);
+					if (reserved)
+						PBSReserveTrack(tile, HASBIT(m5, 0));
+				}
+				break;
+			}
+
 			if ((_m[tile].m5 & 0xF8) != 0xE0)
 				return CMD_ERROR;
 
@@ -1367,76 +1446,96 @@
 	AddSortableSpriteToDraw(image, ti->x + x, ti->y + y, xsize, ysize, zsize, ti->z + z);
 }
 
-static void DrawTile_Track(TileInfo *ti)
-{
-	byte m5;
+/**
+ * Draws the ground sprite and track pieces.
+ * @param ti TileInfo, used to work out slopes and rail type.
+ * @param track TrackBits to draw.
+ * @param earth Flag whether to draw the ground below as brown.
+ * @param snow Flag whether to draw as snow.
+ * @param flag Always draw foundation to ensure flat tile..
+ */
+void DrawTrackBits(TileInfo *ti, TrackBits track, bool earth, bool snow, bool flat) {
 	const RailtypeInfo *rti = GetRailTypeInfo(GetRailType(ti->tile));
-	uint32 image;	//XXX ok why the hell is SpriteID 16 bit when all the drawing routines need 32?
-
-	_drawtile_track_palette = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(GetTileOwner(ti->tile)));
-
-	m5 = (byte)ti->map5;
-	if (!(m5 & RAIL_TYPE_SPECIAL)) {
-		bool special;
+	PalSpriteID image;
+	bool special = false;
 
-		m5 &= TRACK_BIT_MASK;
+	// Select the sprite to use.
+	(image = rti->base_sprites.track_y, track == TRACK_BIT_DIAG2) ||
+	(image++,                           track == TRACK_BIT_DIAG1) ||
+	(image++,                           track == TRACK_BIT_UPPER) ||
+	(image++,                           track == TRACK_BIT_LOWER) ||
+	(image++,                           track == TRACK_BIT_RIGHT) ||
+	(image++,                           track == TRACK_BIT_LEFT) ||
+	(image++,                           track == (TRACK_BIT_DIAG1 | TRACK_BIT_DIAG2)) ||
+
+	(image = rti->base_sprites.track_ns, track == (TRACK_BIT_UPPER | TRACK_BIT_LOWER)) ||
+	(image++,                            track == (TRACK_BIT_LEFT | TRACK_BIT_RIGHT)) ||
+
+	(special = true, false) ||
+	(image = rti->base_sprites.ground, !(track & (TRACK_BIT_RIGHT | TRACK_BIT_UPPER | TRACK_BIT_DIAG1))) ||
+	(image++,                          !(track & (TRACK_BIT_LEFT | TRACK_BIT_LOWER | TRACK_BIT_DIAG1))) ||
+	(image++,                          !(track & (TRACK_BIT_LEFT | TRACK_BIT_UPPER | TRACK_BIT_DIAG2))) ||
+	(image++,                          !(track & (TRACK_BIT_RIGHT | TRACK_BIT_LOWER | TRACK_BIT_DIAG2))) ||
+	(image++, true);
 
-		special = false;
+	if (ti->tileh != 0) {
+		int foundation;
+		if (flat) {
+			foundation = ti->tileh;
+		} else {
+			foundation = GetRailFoundation(ti->tileh, track);
+		}
 
-		// select the sprite to use based on the map5 byte.
-		(image = rti->base_sprites.track_y, m5 == TRACK_BIT_DIAG2) ||
-		(image++,				m5 == TRACK_BIT_DIAG1) ||
-		(image++,				m5 == TRACK_BIT_UPPER) ||
-		(image++,				m5 == TRACK_BIT_LOWER) ||
-		(image++,				m5 == TRACK_BIT_RIGHT) ||
-		(image++,				m5 == TRACK_BIT_LEFT) ||
-		(image++,				m5 == (TRACK_BIT_DIAG1|TRACK_BIT_DIAG2)) ||
+		if (foundation)
+			DrawFoundation(ti, foundation);
 
-		(image = rti->base_sprites.track_ns, m5 == (TRACK_BIT_UPPER|TRACK_BIT_LOWER)) ||
-		(image++,				m5 == (TRACK_BIT_LEFT|TRACK_BIT_RIGHT)) ||
+		// default sloped sprites..
+		if (ti->tileh != 0) image = _track_sloped_sprites[ti->tileh - 1] + rti->base_sprites.track_y;
+	}
 
-		(special=true, false) ||
+	if (earth) {
+		image = (image & SPRITE_MASK) | PALETTE_TO_BARE_LAND; // Use brown palette
+	} else if (snow) {
+		image += rti->snow_offset;
+	}
 
-		(image = rti->base_sprites.ground, !(m5 & (TRACK_BIT_RIGHT|TRACK_BIT_UPPER|TRACK_BIT_DIAG1))) ||
-		(image++,				!(m5 & (TRACK_BIT_LEFT|TRACK_BIT_LOWER|TRACK_BIT_DIAG1))) ||
-		(image++,				!(m5 & (TRACK_BIT_LEFT|TRACK_BIT_UPPER|TRACK_BIT_DIAG2))) ||
-		(image++,				!(m5 & (TRACK_BIT_RIGHT|TRACK_BIT_LOWER|TRACK_BIT_DIAG2))) ||
-		(image++, true);
+	DrawGroundSprite(image);
 
-		if (ti->tileh != 0) {
-			int f = GetRailFoundation(ti->tileh, ti->map5 & 0x3F);
-			if (f) DrawFoundation(ti, f);
+	/* Draw track pieces individually for junctions */
+	if (special) {
+		if (track & TRACK_BIT_DIAG1) DrawGroundSprite(rti->base_sprites.single_y);
+		if (track & TRACK_BIT_DIAG2) DrawGroundSprite(rti->base_sprites.single_x);
+		if (track & TRACK_BIT_UPPER) DrawGroundSprite(rti->base_sprites.single_n);
+		if (track & TRACK_BIT_LOWER) DrawGroundSprite(rti->base_sprites.single_s);
+		if (track & TRACK_BIT_LEFT)  DrawGroundSprite(rti->base_sprites.single_w);
+		if (track & TRACK_BIT_RIGHT) DrawGroundSprite(rti->base_sprites.single_e);
+	}
 
-			// default sloped sprites..
-			if (ti->tileh != 0) image = _track_sloped_sprites[ti->tileh - 1] + rti->base_sprites.track_y;
-		}
+	if (_debug_pbs_level >= 1) {
+		byte pbs = PBSTileReserved(ti->tile);
+		if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(rti->base_sprites.single_y | PALETTE_CRASH);
+		if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(rti->base_sprites.single_x | PALETTE_CRASH);
+		if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(rti->base_sprites.single_n | PALETTE_CRASH);
+		if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(rti->base_sprites.single_s | PALETTE_CRASH);
+		if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(rti->base_sprites.single_w | PALETTE_CRASH);
+		if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(rti->base_sprites.single_e | PALETTE_CRASH);
+	}
+}
 
-		if ((_m[ti->tile].m2 & RAIL_MAP2LO_GROUND_MASK) == RAIL_GROUND_BROWN) {
-			image = (image & SPRITE_MASK) | PALETTE_TO_BARE_LAND; // use a brown palette
-		 } else if ((_m[ti->tile].m2 & RAIL_MAP2LO_GROUND_MASK) == RAIL_GROUND_ICE_DESERT) {
-			image += rti->snow_offset;
-		}
+static void DrawTile_Track(TileInfo *ti)
+{
+	byte m5;
+	const RailtypeInfo *rti = GetRailTypeInfo(GetRailType(ti->tile));
+	uint32 image;	//XXX ok why the hell is SpriteID 16 bit when all the drawing routines need 32?
 
-		DrawGroundSprite(image);
+	_drawtile_track_palette = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(GetTileOwner(ti->tile)));
 
-		if (special) {
-			if (m5 & TRACK_BIT_DIAG1) DrawGroundSprite(rti->base_sprites.single_y);
-			if (m5 & TRACK_BIT_DIAG2) DrawGroundSprite(rti->base_sprites.single_x);
-			if (m5 & TRACK_BIT_UPPER) DrawGroundSprite(rti->base_sprites.single_n);
-			if (m5 & TRACK_BIT_LOWER) DrawGroundSprite(rti->base_sprites.single_s);
-			if (m5 & TRACK_BIT_LEFT)  DrawGroundSprite(rti->base_sprites.single_w);
-			if (m5 & TRACK_BIT_RIGHT) DrawGroundSprite(rti->base_sprites.single_e);
-		}
+	m5 = (byte)ti->map5;
+	if (!(m5 & RAIL_TYPE_SPECIAL)) {
+		bool earth = (_m[ti->tile].m2 & RAIL_MAP2LO_GROUND_MASK) == RAIL_GROUND_BROWN;
+		bool snow = (_m[ti->tile].m2 & RAIL_MAP2LO_GROUND_MASK) == RAIL_GROUND_ICE_DESERT;
 
-		if (_debug_pbs_level >= 1) {
-			byte pbs = PBSTileReserved(ti->tile);
-			if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(rti->base_sprites.single_y | PALETTE_CRASH);
-			if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(rti->base_sprites.single_x | PALETTE_CRASH);
-			if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(rti->base_sprites.single_n | PALETTE_CRASH);
-			if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(rti->base_sprites.single_s | PALETTE_CRASH);
-			if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(rti->base_sprites.single_w | PALETTE_CRASH);
-			if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(rti->base_sprites.single_e | PALETTE_CRASH);
-		}
+		DrawTrackBits(ti, m5 & TRACK_BIT_MASK, earth, snow, false);
 
 		if (_display_opt & DO_FULL_DETAIL) {
 			_detailed_track_proc[_m[ti->tile].m2 & RAIL_MAP2LO_GROUND_MASK](ti);
@@ -1503,7 +1602,13 @@
 				DrawTileSeqStruct const *seq;
 				// emulate station tile - open with building
 				DrawTileSprites *cust = &stat->renderdata[2 + (m5 & 0x1)];
-				uint32 relocation = GetCustomStationRelocation(stat, ComposeWaypointStation(ti->tile), 0);
+				uint32 relocation = GetCustomStationRelocation(stat, ComposeWaypointStation(ti->tile), 0, ti->tile);
+
+				if (HASBIT(stat->callbackmask, CBM_SPRITE_LAYOUT)) {
+					uint32 callback = GetStationCallBackResult(CBID_STATION_SPRITE_LAYOUT, stat, NULL, ti->tile);
+					if (callback != CALLBACK_FAILED)
+						cust = &stat->renderdata[callback + (m5 & 0x1)];
+				}
 
 				/* We don't touch the 0x8000 bit. In all this
 				 * waypoint code, it is used to indicate that
Index: vehicle.c
===================================================================
--- vehicle.c	(revision 2908)
+++ vehicle.c	(working copy)
@@ -58,12 +58,15 @@
 
 bool VehicleNeedsService(const Vehicle *v)
 {
-	if (_patches.no_servicing_if_no_breakdowns && _opt.diff.vehicle_breakdowns == 0)
-		return false;
-
 	if (v->vehstatus & VS_CRASHED)
 		return false; /* Crashed vehicles don't need service anymore */
 
+	if (GetPlayer(v->owner)->engine_replacement[v->engine_type] != INVALID_ENGINE)
+		return true; /* Vehicle is due to be replaced */
+
+	if (_patches.no_servicing_if_no_breakdowns && _opt.diff.vehicle_breakdowns == 0)
+		return false;
+
 	return _patches.servint_ispercent ?
 		(v->reliability < GetEngine(v->engine_type)->reliability * (100 - v->service_interval) / 100) :
 		(v->date_of_last_service + v->service_interval < _date);
@@ -106,6 +109,11 @@
 	return v;
 }
 
+bool FreightWagonMult(const Vehicle *v)
+{
+	return _patches.freight_trains > 1 && v->cargo_type != CT_PASSENGERS && v->cargo_type != CT_MAIL;
+}
+
 static inline uint Correct_Z(uint tileh)
 {
 	// needs z correction for slope-type graphics that have the NORTHERN tile lowered
Index: vehicle.h
===================================================================
--- vehicle.h	(revision 2908)
+++ vehicle.h	(working copy)
@@ -70,6 +70,7 @@
 	byte railtype;
 
 	byte flags;
+	byte visual_effect;
 
 	byte pbs_status;
 	TileIndex pbs_end_tile;
@@ -300,6 +301,7 @@
 void VehicleInTheWayErrMsg(Vehicle *v);
 Vehicle *FindVehicleBetween(TileIndex from, TileIndex to, byte z);
 TileIndex GetVehicleOutOfTunnelTile(const Vehicle *v);
+bool FreightWagonMult(const Vehicle *v);
 
 bool UpdateSignalsOnSegment(TileIndex tile, byte direction);
 void SetSignalsOnBothDir(TileIndex tile, byte track);
Index: landscape.c
===================================================================
--- landscape.c	(revision 2908)
+++ landscape.c	(working copy)
@@ -209,9 +209,9 @@
 
 	TileInfo ti2;
 	FindLandscapeHeight(&ti2, ti->x, ti->y-1);
-	if(hasFoundation( &ti2, true )) sprite_base += 22;		// foundation in NW direction
+	if(hasFoundation( &ti2, true ) || (IsTileType(ti2.tile, MP_TUNNELBRIDGE) && (ti2.map5 & 0xC1) == 0xC1)) sprite_base += 22;		// foundation in NW direction
 	FindLandscapeHeight(&ti2, ti->x-1, ti->y);
-	if(hasFoundation( &ti2, false )) sprite_base += 22*2;	// foundation in NE direction
+	if(hasFoundation( &ti2, false ) || (IsTileType(ti2.tile, MP_TUNNELBRIDGE) && (ti2.map5 & 0xC1) == 0xC0)) sprite_base += 22*2;	// foundation in NE direction
 
 	if (f < 15) {
 		// leveled foundation
Index: bridge.h
===================================================================
--- bridge.h	(revision 2908)
+++ bridge.h	(working copy)
@@ -5,6 +5,9 @@
 #ifndef BRIDGE_H
 #define BRIDGE_H
 
+#include "macros.h"
+#include "rail.h"
+
 /** Struct containing information about a single bridge type
  */
 typedef struct Bridge {
@@ -19,4 +22,49 @@
 
 extern const Bridge _bridge[MAX_BRIDGES];
 
+/**
+ * Gets track bits on the given Bridge End tile.
+ * @param tile Tile.
+ * @return Track bits that are on the tile.
+ */
+static inline TrackBits GetBridgeEndTrackBits(TileIndex tile)
+{
+	return GB(_m[tile].m4, 0, 6);
+}
+
+/**
+ * Sets track bits on the given Bridge End tile.
+ * @param tile Tile.
+ * @param track Track bits to set.
+ */
+static inline void SetBridgeEndTrackBits(TileIndex tile, TrackBits track)
+{
+	_m[tile].m4 |= track & 0x3F;
+}
+
+/**
+ * Removes track bits from the given Bridge End tile.
+ * @param tile Tile.
+ * @param track Track bits to remove.
+ */
+static inline void UnsetBridgeEndTrackBits(TileIndex tile, TrackBits track)
+{
+	_m[tile].m4 &= ~(track & 0x3F);
+}
+
+static inline byte GetBridgeEndRoadBits(TileIndex tile)
+{
+	return GB(_m[tile].m4, 0, 4);
+}
+
+static inline void SetBridgeEndRoadBits(TileIndex tile, byte road)
+{
+	_m[tile].m4 |= road & 0x0F;
+}
+
+static inline void UnsetBridgeEndRoadBits(TileIndex tile, byte road)
+{
+	_m[tile].m4 &= ~(road & 0x0F);
+}
+
 #endif /* BRIDGE_H */
Index: economy.c
===================================================================
--- economy.c	(revision 2908)
+++ economy.c	(working copy)
@@ -775,8 +775,10 @@
 			uint mod = _price_category[i] == 1 ? _opt.diff.vehicle_costs : _opt.diff.construction_cost;
 			if (mod < 1) {
 				price = price * 3 >> 2;
-			} else if (mod > 1) {
+			} else if (mod == 2) {
 				price = price * 9 >> 3;
+			} else if (mod == 3) {
+			        price = price * 27 >> 4;
 			}
 		}
 		((int32*)&_price)[i] = price;
Index: town_cmd.c
===================================================================
--- town_cmd.c	(revision 2908)
+++ town_cmd.c	(working copy)
@@ -1892,11 +1892,12 @@
 }
 
 /*	penalty for removing town-owned stuff */
-static const int _default_rating_settings [3][3] = {
+static const int _default_rating_settings [4][3] = {
 	// ROAD_REMOVE, TUNNELBRIDGE_REMOVE, INDUSTRY_REMOVE
 	{  0, 128, 384},	// Permissive
 	{ 48, 192, 480},	// Neutral
 	{ 96, 384, 768},	// Hostile
+	{ 144,448,1030},        // Vendetta
 };
 
 bool CheckforTownRating(TileIndex tile, uint32 flags, Town *t, byte type)
Index: widget.c
===================================================================
--- widget.c	(revision 2908)
+++ widget.c	(working copy)
@@ -184,7 +184,7 @@
 		case WWT_PANEL_2: {
 			int img;
 
-			DrawFrameRect(r.left, r.top, r.right, r.bottom, wi->color, (clicked) ? FR_LOWERED : 0);
+			DrawFrameRectGradient(r.left, r.top, r.right, r.bottom, wi->color, (clicked) ? FR_LOWERED : 0);
 
 			if ((img = wi->unkA) != 0) { // has an image
 				if ((wi->type & WWT_MASK) == WWT_PANEL_2 && clicked) img++; // show diff image when clicked
@@ -196,7 +196,7 @@
 
 		case WWT_CLOSEBOX: /* WWT_TEXTBTN */
 		case WWT_4: {
-			DrawFrameRect(r.left, r.top, r.right, r.bottom, wi->color, (clicked) ? FR_LOWERED : 0);
+			DrawFrameRectGradient(r.left, r.top, r.right, r.bottom, wi->color, (clicked) ? FR_LOWERED : 0);
 			}
 		/* fall through */
 
@@ -212,7 +212,7 @@
 
 		case WWT_6: {
 			StringID str;
-			DrawFrameRect(r.left, r.top, r.right, r.bottom, wi->color, FR_LOWERED | FR_DARKENED);
+			DrawFrameRectGradient(r.left, r.top, r.right, r.bottom, wi->color, FR_LOWERED | FR_DARKENED);
 
 			if ((str = wi->unkA) != 0) {
 				DrawString(r.left+2, r.top+1, str, 0);
@@ -349,7 +349,7 @@
 			c2 = _color_list[wi->color&0xF].window_color_2;
 
 			// draw "shaded" background
-			GfxFillRect(r.left+10, r.top, r.right-10, r.bottom, c2);
+			GfxFillRectGradient(r.left+10, r.top, r.right-10, r.bottom, c2);
 			GfxFillRect(r.left+10, r.top, r.right-10, r.bottom, c1 | PALETTE_MODIFIER_GREYOUT);
 
 			// draw shaded lines
@@ -360,7 +360,7 @@
 
 			// draw actual scrollbar
 			pt = HandleScrollbarHittest(&w->hscroll, r.left, r.right);
-			DrawFrameRect(pt.x, r.top, pt.y, r.bottom, wi->color, (w->flags4 & (WF_SCROLL_MIDDLE | WF_HSCROLL)) == (WF_SCROLL_MIDDLE | WF_HSCROLL) ? FR_LOWERED : 0);
+			DrawFrameRectGradient(pt.x, r.top, pt.y, r.bottom, wi->color, (w->flags4 & (WF_SCROLL_MIDDLE | WF_HSCROLL)) == (WF_SCROLL_MIDDLE | WF_HSCROLL) ? FR_LOWERED : 0);
 
 			break;
 		}
@@ -417,10 +417,10 @@
 		case WWT_CAPTION: {
 			assert(r.bottom - r.top == 13); // XXX - to ensure the same sizes are used everywhere!
 			DrawFrameRect(r.left, r.top, r.right, r.bottom, wi->color, FR_BORDERONLY);
-			DrawFrameRect(r.left+1, r.top+1, r.right-1, r.bottom-1, wi->color, (w->caption_color == 0xFF) ? FR_LOWERED | FR_DARKENED : FR_LOWERED | FR_DARKENED | FR_BORDERONLY);
+			DrawFrameRectGradient(r.left+1, r.top+1, r.right-1, r.bottom-1, wi->color, (w->caption_color == 0xFF) ? FR_LOWERED | FR_DARKENED : FR_LOWERED | FR_DARKENED | FR_BORDERONLY);
 
 			if (w->caption_color != 0xFF) {
-				GfxFillRect(r.left+2, r.top+2, r.right-2, r.bottom-2, _color_list[_player_colors[w->caption_color]].window_color_1b);
+				GfxFillRectGradient(r.left+2, r.top+2, r.right-2, r.bottom-2, _color_list[_player_colors[w->caption_color]].window_color_1b);
 			}
 
 			DrawStringCentered( (r.left+r.right+1)>>1, r.top+2, wi->unkA, 0x84);
Index: Makefile
===================================================================
--- Makefile	(revision 2908)
+++ Makefile	(working copy)
@@ -709,6 +709,7 @@
 
 ifdef OSX
 OBJC_SOURCES += os/macosx/macos.m
+C_SOURCES    += music/qtmidi.c
 endif
 
 OBJS = $(C_SOURCES:%.c=%.o) $(CXX_SOURCES:%.cpp=%.o) $(OBJC_SOURCES:%.m=%.o)
Index: settings.c
===================================================================
--- settings.c	(revision 2908)
+++ settings.c	(working copy)
@@ -778,6 +778,7 @@
 	{"frame_freq",			SDT_UINT8 | SDT_NOSAVE,	(void*)0,			&_network_frame_freq,		NULL},
 	{"max_join_time",		SDT_UINT16,	(void*)500,	&_network_max_join_time,	NULL},
 	{"pause_on_join",		SDT_BOOL, (void*)false, &_network_pause_on_join, NULL},
+	{"pause_on_no_clients", SDT_BOOL, (void*)false, &_network_pause_on_no_clients, NULL},
 	{"server_bind_ip",	SDT_STRINGBUF | (lengthof(_network_server_bind_ip_host) << 16),	"0.0.0.0",	&_network_server_bind_ip_host,	NULL},
 	{"server_port",			SDT_UINT,	(void*)NETWORK_DEFAULT_PORT,	&_network_server_port,	NULL},
 	{"server_advertise",SDT_BOOL, (void*)false, &_network_advertise, NULL},
@@ -829,6 +830,7 @@
 //  of stuff.
 static const SettingDesc patch_player_settings[] = {
 	{"vehicle_speed",				SDT_BOOL,		(void*)true,	&_patches.vehicle_speed,				NULL},
+	{"window_gradients",			SDT_BOOL,		(void*)false,	&_patches.window_gradients,				NULL},
 
 	{"lost_train_days",			SDT_UINT16, (void*)180,		&_patches.lost_train_days,			NULL},
 	{"train_income_warn",		SDT_BOOL,		(void*)true,	&_patches.train_income_warn,		NULL},
@@ -861,6 +863,7 @@
 const SettingDesc patch_settings[] = {
 	{"build_on_slopes",			SDT_BOOL,		(void*)true,	&_patches.build_on_slopes,			NULL},
 	{"auto_pbs_placement",	SDT_BOOL,		(void*)true,	&_patches.auto_pbs_placement,		NULL},
+	{"differing_rail_costs", SDT_BOOL,      (void*)true,            &_patches.differing_rail_costs,         NULL},
 	{"mammoth_trains",			SDT_BOOL,		(void*)true,	&_patches.mammoth_trains,				NULL},
 	{"join_stations",				SDT_BOOL,		(void*)true,	&_patches.join_stations,				NULL},
 	{"station_spread",			SDT_UINT8,	(void*)12,		&_patches.station_spread,				NULL},
@@ -891,6 +894,7 @@
 	{"realistic_acceleration",SDT_BOOL, (void*)false,	&_patches.realistic_acceleration,	NULL},
 	{"forbid_90_deg",				SDT_BOOL, 	(void*)false, &_patches.forbid_90_deg,					NULL},
 	{"improved_load",				SDT_BOOL,		(void*)false,	&_patches.improved_load,				NULL},
+	{"freight_trains",				SDT_UINT8,	(void*)1,			&_patches.freight_trains,				NULL},
 
 	{"max_trains",					SDT_UINT16,	(void*)500,		&_patches.max_trains,						NULL},
 	{"max_roadveh",					SDT_UINT16,	(void*)500,		&_patches.max_roadveh,					NULL},
Index: waypoint.c
===================================================================
--- waypoint.c	(revision 2908)
+++ waypoint.c	(working copy)
@@ -345,13 +345,23 @@
 {
 	Waypoint *wp = GetWaypointByTile(tile);
 	static Station stat;
+	static byte random_bits = 0;
 
 	stat.train_tile = stat.xy = wp->xy;
 	stat.town = GetTown(wp->town_index);
 	stat.string_id = wp->string == STR_NULL ? /* FIXME? */ 0 : wp->string;
 	stat.build_date = wp->build_date;
-	stat.class_id = 6;
-	stat.stat_id = wp->stat_id;
+	//stat.class_id = 6;
+	//stat.stat_id = wp->stat_id;
+	stat.num_segments = 1;
+	stat.segments = realloc(stat.segments, sizeof(StationSegment));
+	stat.segments[0].sclass = STAT_CLASS_WAYP;
+	stat.segments[0].cstation = wp->stat_id;
+	stat.segments[0].tile = tile;
+	stat.segments[0].platforms = 1;
+	stat.segments[0].length = 1;
+	stat.segments[0].direction = _m[tile].m5 & 1;
+	stat.segments[0].random_bits = &random_bits;
 
 	return &stat;
 }
@@ -382,7 +392,7 @@
 
 	stat = GetCustomStation(STAT_CLASS_WAYP, stat_id - 1);
 	assert(stat);
-	relocation = GetCustomStationRelocation(stat, NULL, 1);
+	relocation = GetCustomStationRelocation(stat, NULL, 1, INVALID_TILE);
 	// emulate station tile - open with building
 	// add 1 to get the other direction
 	cust = &stat->renderdata[2];
Index: train_gui.c
===================================================================
--- train_gui.c	(revision 2908)
+++ train_gui.c	(working copy)
@@ -1079,6 +1079,10 @@
 			SetDParam(1, num);
 			SetDParam(2, v->cargo_source);
 			str = STR_8813_FROM;
+			if (FreightWagonMult(v)) {
+				SetDParam(3, _patches.freight_trains);
+				str = STR_8813_FROM_MULT;
+			}
 		}
 		DrawString(x, y, str, 0);
 	}
@@ -1105,7 +1109,12 @@
 	if (v->cargo_cap != 0) {
 		SetDParam(0, _cargoc.names_long[v->cargo_type]);
 		SetDParam(1, v->cargo_cap);
-		DrawString(x, y, STR_013F_CAPACITY, 0);
+		if (FreightWagonMult(v)) {
+			SetDParam(2, _patches.freight_trains);
+			DrawString(x, y, STR_013F_CAPACITY_MULT, 0);
+		} else {
+			DrawString(x, y, STR_013F_CAPACITY, 0);
+		}
 	}
 }
 
@@ -1219,7 +1228,12 @@
 				SetDParam(1, tot_cargo[i][0]);	// {CARGO} #2
 				SetDParam(2, i);								// {SHORTCARGO} #1
 				SetDParam(3, tot_cargo[i][1]);	// {SHORTCARGO} #2
-				DrawString(x, y, STR_013F_TOTAL_CAPACITY, 0);
+				if (_patches.freight_trains > 1 && i != CT_PASSENGERS && i != CT_MAIL) {
+					SetDParam(4, _patches.freight_trains);
+					DrawString(x, y, STR_013F_TOTAL_CAPACITY_MULT, 0);
+				} else {
+					DrawString(x, y, STR_013F_TOTAL_CAPACITY, 0);
+				}
 			}
 		} while (++i != NUM_CARGO);
 	}
Index: station.h
===================================================================
--- station.h	(revision 2908)
+++ station.h	(working copy)
@@ -46,6 +46,24 @@
 	struct RoadStop *prev;
 } RoadStop;
 
+/**
+ * Describes an individually built block of a custom station.
+ */
+typedef struct StationSegment {
+	TileIndex tile;     ///< Top-left tile of the segment.
+	bool direction;     ///< Direction of the tracks. 0 = x, 1 = y
+	byte length;        ///< Length of the platforms.
+	byte platforms;     ///< Number of platforms.
+
+	byte sclass;        ///< Custom station class.
+	byte cstation;      ///< Custom station number.
+	byte *random_bits;  ///< pointer to array of 4 random bits for *each tile*.
+
+	/* These are used to tie the station to the grf file */
+	uint32 grfid;       ///< GRF ID
+	uint8 gstation;     ///< station number
+} StationSegment;
+
 struct Station {
 	TileIndex xy;
 	RoadStop *bus_stops;
@@ -70,8 +88,8 @@
 	// trainstation width/height
 	byte trainst_w, trainst_h;
 
-	byte class_id; // custom graphics station class
-	byte stat_id; // custom graphics station id in the @class_id class
+	//byte class_id; // custom graphics station class
+	//byte stat_id; // custom graphics station id in the @class_id class
 	uint16 build_date;
 
 	//uint16 airport_flags;
@@ -88,6 +106,22 @@
 	byte truck_stop_status_obsolete;
 	byte bus_stop_status_obsolete;
 	byte blocked_months_obsolete;
+
+	/**
+	 * Random data for NewGRF
+	 */
+	byte random_bits;
+	/**
+	 * Number of custom station segments to this station.
+	 */
+	byte num_segments;
+	/**
+	 * Array of custom station segments.
+	 * Dynamically allocated.
+	 */
+	StationSegment *segments;
+	TileIndex topleft;     ///< Top left coordinate of station. Not saved.
+	TileIndex bottomright; ///< Bottom right coordinate of station. Not saved.
 };
 
 enum {
@@ -198,9 +232,9 @@
 typedef byte *StationLayout;
 
 typedef enum StationClass {
-	STAT_CLASS_NONE, // unused station slot or so
-	STAT_CLASS_DFLT, // default station class
-	STAT_CLASS_WAYP, // waypoints
+	//STAT_CLASS_NONE, // unused station slot or so
+	STAT_CLASS_DFLT = 0, // default station class
+	STAT_CLASS_WAYP = 1, // waypoints
 
 	/* TODO: When we actually support custom classes, they are
 	 * going to be allocated dynamically (with some classid->sclass
@@ -219,11 +253,11 @@
 	/* Bitmask of platform numbers/lengths available for the station.  Bits
 	 * 0..6 correspond to 1..7, while bit 7 corresponds to >7 platforms or
 	 * lenght. */
-	byte allowed_platforms;
-	byte allowed_lengths;
+	byte disallowed_platforms;
+	byte disallowed_lengths;
 
 	/* Custom sprites */
-	byte tiles;
+	uint16 tiles;
 	/* 00 = plain platform
 	 * 02 = platform with building
 	 * 04 = platform with roof, left side
@@ -231,7 +265,7 @@
 	 *
 	 * These numbers are used for stations in NE-SW direction, or these
 	 * numbers plus one for stations in the NW-SE direction.  */
-	DrawTileSprites renderdata[8];
+	DrawTileSprites *renderdata;
 
 	/* Custom layouts */
 	/* The layout array is organized like [lenghts][platforms], both being
@@ -250,12 +284,38 @@
 	 * default OTTD station layout should be used for stations of these
 	 * dimensions. */
 	StationLayout **layouts;
+	/* @name
+	 * Name for the station */
+	char *name;
+	/* @cargotriggers  Cargo types for random triggers (12)
+	 * This sets which cargo types should trigger re-randomizing. The cargo
+	 * types are given as a bitmask of the bits from column 3 (type B) in
+	 * CargoTypes. If nothing is set (the default), the no random triggers
+	 * will happen, to conserve CPU time. */
+	uint32 cargotriggers;
+	/* @flags General Flags (13)
+	 * bit 0 - use different sprite set for ground sprites (var. 10 is 1
+	 *         for ground sprites, 0 otherwise)
+	 * bit 1 - when calculating the cargo amount to display, divide the
+	 *         amount by the station size (to simulate cargo distributed
+	 *         over the area of the station) */
+	byte flags;
+	byte callbackmask;
+	/* Bit mask of tile types that cannot pass traffic */
+	byte blocked;
 
 	/* Sprite offsets for renderdata->seq->image. spritegroup[0] is default
 	 * whilst spritegroup[1] is "GC_PURCHASE". */
 	SpriteGroup spritegroup[2];
 } StationSpec;
 
+int AllocateCustomStationClass(uint32 classid);
+void SetCustomStationClassName(int classid, const char *name);
+StringID GetCustomStationClassName(int classid);
+StringID CustomStationGetStationName(StationSpec *spec);
+int GetNumCustomStationClasses(void);
+StringID *BuildCustomStationClassDropdown(void);
+
 /* Here, @stid is local per-GRFFile station index. If spec->localidx is not yet
  * set, it gets new dynamically allocated global index and spec->localidx is
  * set to @stid, otherwise we take it as that we are replacing it and try to
@@ -267,8 +327,9 @@
 /* Get sprite offset for a given custom station and station structure (may be
  * NULL if ctype is set - that means we are in a build dialog). The station
  * structure is used for variational sprite groups. */
-uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte ctype);
+uint32 GetCustomStationRelocation(StationSpec *spec, Station *stat, byte ctype, TileIndex tile);
 int GetCustomStationsCount(StationClass sclass);
+void DrawStationSprite(int x, int y, StationClass sclass, byte image, uint railtype, byte direction);
 
 RoadStop * GetRoadStopByTile(TileIndex tile, RoadStopType type);
 static inline int GetRoadStopType(TileIndex tile)
@@ -283,7 +344,7 @@
 
 static inline bool IsTrainStationTile(TileIndex tile)
 {
-	return IsTileType(tile, MP_STATION) && IS_BYTE_INSIDE(_m[tile].m5, 0, 8);
+	return IsTileType(tile, MP_STATION) && IS_BYTE_INSIDE(_m[tile].m5, 0, 8) && !HASBIT(_m[tile].m3, 7);
 }
 
 static inline bool IsCompatibleTrainStationTile(TileIndex tile, TileIndex ref)
Index: rail_gui.c
===================================================================
--- rail_gui.c	(revision 2908)
+++ rail_gui.c	(working copy)
@@ -20,12 +20,16 @@
 #include "waypoint.h"
 #include "debug.h"
 #include "variables.h"
+#include "newgrf_callbacks.h"
 
 static uint _cur_railtype;
 static bool _remove_button_clicked;
 static byte _build_depot_direction;
 static byte _waypoint_count=1;
 static byte _cur_waypoint_type;
+static byte _station_count=0;
+static byte _cur_station_type;
+static byte _cur_station_class = 0;
 
 struct {
 	byte orientation;
@@ -137,7 +141,8 @@
 {
 	if (success) {
 		SndPlayTileFx(SND_20_SPLAT_2, tile);
-		ResetObjectToPlace();
+		if (_cur_station_type == 0 && _cur_station_class == 0)
+			ResetObjectToPlace();
 	}
 }
 
@@ -151,7 +156,7 @@
 	} else {
 		// TODO: Custom station selector GUI. Now we just try using first custom station
 		// (and fall back to normal stations if it isn't available).
-		DoCommandP(tile, _railstation.orientation | (_railstation.numtracks<<8) | (_railstation.platlength<<16),_cur_railtype|1<<4, CcStation,
+		DoCommandP(tile, _railstation.orientation | (_railstation.numtracks<<8) | (_railstation.platlength<<16),_cur_railtype | (_cur_station_class != 0 || _cur_station_type != 0) << 4 | _cur_station_type << 8 | _cur_station_class << 16, CcStation,
 				CMD_BUILD_RAILROAD_STATION | CMD_NO_WATER | CMD_AUTO | CMD_MSG(STR_100F_CAN_T_BUILD_RAILROAD_STATION));
 	}
 }
@@ -269,6 +274,7 @@
 
 static void BuildRailClick_Station(Window *w)
 {
+	_station_count = GetCustomStationsCount(_cur_station_class);
 	if (HandlePlacePushButton(w, 12, SPR_CURSOR_RAIL_STATION, 1, PlaceRail_Station)) ShowStationBuilder();
 }
 
@@ -596,7 +602,7 @@
 
 	// TODO: Custom station selector GUI. Now we just try using first custom station
 	// (and fall back to normal stations if it isn't available).
-	DoCommandP(TileXY(sx, sy), _railstation.orientation | (w << 8) | (h << 16), _cur_railtype | 1 << 4, CcStation,
+	DoCommandP(TileXY(sx, sy), _railstation.orientation | (w << 8) | (h << 16), _cur_railtype | (_cur_station_class != 0 || _cur_station_type != 0) << 4 | _cur_station_type << 8 | _cur_station_class << 16, CcStation,
 		CMD_BUILD_RAILROAD_STATION | CMD_NO_WATER | CMD_AUTO | CMD_MSG(STR_100F_CAN_T_BUILD_RAILROAD_STATION));
 }
 
@@ -606,6 +612,8 @@
 	case WE_PAINT: {
 		int rad;
 		uint bits;
+		byte i;
+		StationSpec *stat = GetCustomStation(_cur_station_class, _cur_station_type);
 
 		if (WP(w,def_d).close) return;
 
@@ -617,6 +625,8 @@
 			bits |= (1<<(12-1)) << (_railstation.platlength);
 		}
 		bits |= (1<<20) << (_station_show_coverage);
+		if (IS_BYTE_INSIDE(_cur_station_type - w->vscroll.pos, 0, 5))
+			bits |= (1<<22) << (_cur_station_type - w->vscroll.pos);
 		w->click_state = bits;
 
 		if (_railstation.dragdrop) {
@@ -640,18 +650,56 @@
 			SETBIT(w->disabled_state, bits + 5);
 			SETBIT(w->disabled_state, bits + 12);
 		}
+		/* Update buttons for allowed platforms/lengths */
+		if (stat != NULL) {
+			for (bits = 0; bits < 7; bits++) {
+				if (HASBIT(stat->disallowed_platforms, bits)) SETBIT(w->disabled_state, bits + 5);
+				if (HASBIT(stat->disallowed_lengths,   bits)) SETBIT(w->disabled_state, bits + 12);
+			}
+		}
+		for (i = 0; i < 5; i++) {
+			stat = GetCustomStation(_cur_station_class, i + w->vscroll.pos);
+			if (stat == NULL) {
+				// Stations that don't exist
+				if (_cur_station_class == 0 && i + w->vscroll.pos == 0) {
+					CLRBIT(w->disabled_state, i + 22);
+				} else {
+					SETBIT(w->disabled_state, i + 22);
+				}
+			} else {
+				// Callback 0x13
+				uint16 callback = 1;
+				if (HASBIT(stat->callbackmask, CBM_AVAILABILITY)) {
+					callback = GetStationCallBackResult(CBID_STATION_AVAILABILITY, stat, NULL, INVALID_TILE);
+				}
+				if (callback == 0) {
+					SETBIT(w->disabled_state, i + 22);
+				} else {
+					CLRBIT(w->disabled_state, i + 22);
+				}
+			}
+		}
 
 		DrawWindowWidgets(w);
 
-		StationPickerDrawSprite(39, 42, _cur_railtype, 2);
-		StationPickerDrawSprite(107, 42, _cur_railtype, 3);
+		//StationPickerDrawSprite(39, 132, _cur_railtype, 2);
+		//StationPickerDrawSprite(107, 132, _cur_railtype, 3);
 
-		DrawStringCentered(74, 15, STR_3002_ORIENTATION, 0);
-		DrawStringCentered(74, 76, STR_3003_NUMBER_OF_TRACKS, 0);
-		DrawStringCentered(74, 101, STR_3004_PLATFORM_LENGTH, 0);
-		DrawStringCentered(74, 141, STR_3066_COVERAGE_AREA_HIGHLIGHT, 0);
-
-		DrawStationCoverageAreaText(2, 166, (uint)-1, rad);
+		DrawStringCentered(74, 105, STR_3002_ORIENTATION, 0);
+		DrawStringCentered(74, 166, STR_3003_NUMBER_OF_TRACKS, 0);
+		DrawStringCentered(74, 191, STR_3004_PLATFORM_LENGTH, 0);
+		DrawStringCentered(74, 231, STR_3066_COVERAGE_AREA_HIGHLIGHT, 0);
+
+		DrawStationCoverageAreaText(2, 256, (uint)-1, rad);
+
+		/* Custom Station GUI */
+		for (i = 0; i < 5; i++) {
+			byte offset = (_cur_station_type == w->vscroll.pos + i ? 1 : 0);
+			if (w->vscroll.pos + i >= _station_count) break;
+			DrawString(10 + offset, 34 + offset + i * 14, CustomStationGetStationName(GetCustomStation(_cur_station_class, i + w->vscroll.pos)), 0x10);
+		}
+		DrawStationSprite( 6, 115, _cur_station_class, _cur_station_type, _cur_railtype, 0);
+		DrawStationSprite(74, 115, _cur_station_class, _cur_station_type, _cur_railtype, 1);
 	} break;
 
 	case WE_CLICK: {
@@ -701,9 +749,39 @@
 			SndPlayFx(SND_15_BEEP);
 			SetWindowDirty(w);
 			break;
+
+		case 22:
+		case 23:
+		case 24:
+		case 25:
+		case 26:
+			if ((e->click.widget - 22 + w->vscroll.pos) < _station_count)
+				_cur_station_type = e->click.widget - 22 + w->vscroll.pos;
+			SndPlayFx(SND_15_BEEP);
+			SetWindowDirty(w);
+			break;
+		case 28:
+		case 29:
+			ShowDropDownMenu(w, BuildCustomStationClassDropdown(), _cur_station_class, 29, 2, true);
+			break;
 		}
 	} break;
 
+	case WE_DROPDOWN_SELECT:
+		switch (e->dropdown.button) {
+			case 29: /* CustomStationClassDropDown */
+				if (_cur_station_class != e->dropdown.index) {
+					_cur_station_class = e->dropdown.index;
+					_cur_station_type = 0;
+					_station_count = GetCustomStationsCount(_cur_station_class);
+					w->vscroll.count = _station_count;
+					w->vscroll.pos = _cur_station_type;
+				}
+				SndPlayFx(SND_15_BEEP);
+				SetWindowDirty(w);
+				break;
+		} break;
+
 	case WE_MOUSELOOP: {
 		if (WP(w,def_d).close) {
 			DeleteWindow(w);
@@ -722,36 +800,44 @@
 static const Widget _station_builder_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,     7,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,     7,    11,   147,     0,    13, STR_3000_RAIL_STATION_SELECTION, STR_018C_WINDOW_TITLE_DRAG_THIS},
-{      WWT_PANEL,   RESIZE_NONE,     7,     0,   147,    14,   199, 0x0,					STR_NULL},
-{      WWT_PANEL,   RESIZE_NONE,    14,     7,    72,    26,    73, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
-{      WWT_PANEL,   RESIZE_NONE,    14,    75,   140,    26,    73, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
-
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,    87,    98, STR_00CB_1,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,    87,    98, STR_00CC_2,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,    87,    98, STR_00CD_3,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,    87,    98, STR_00CE_4,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,    87,    98, STR_00CF_5,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,    87,    98, STR_0335_6,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,    87,    98, STR_0336_7,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
-
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,   112,   123, STR_00CB_1,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,   112,   123, STR_00CC_2,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,   112,   123, STR_00CD_3,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,   112,   123, STR_00CE_4,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,   112,   123, STR_00CF_5,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,   112,   123, STR_0335_6,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,   112,   123, STR_0336_7,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{      WWT_PANEL,   RESIZE_NONE,     7,     0,   147,    14,   289, 0x0,					STR_NULL},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,    72,   116,   163, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
+{      WWT_PANEL,   RESIZE_NONE,    14,    75,   140,   116,   163, 0x0,					STR_304E_SELECT_RAILROAD_STATION},
+
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,   177,   188, STR_00CB_1,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,   177,   188, STR_00CC_2,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,   177,   188, STR_00CD_3,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,   177,   188, STR_00CE_4,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,   177,   188, STR_00CF_5,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,   177,   188, STR_0335_6,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,   177,   188, STR_0336_7,	STR_304F_SELECT_NUMBER_OF_PLATFORMS},
+
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    22,    36,   202,   213, STR_00CB_1,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,    51,   202,   213, STR_00CC_2,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    52,    66,   202,   213, STR_00CD_3,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    67,    81,   202,   213, STR_00CE_4,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    82,    96,   202,   213, STR_00CF_5,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    97,   111,   202,   213, STR_0335_6,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   112,   126,   202,   213, STR_0336_7,	STR_3050_SELECT_LENGTH_OF_RAILROAD},
 
 //{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    14,    73,   137,   148, STR_02DB_OFF, STR_3065_DON_T_HIGHLIGHT_COVERAGE},
 //{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    74,   133,   137,   148, STR_02DA_ON, STR_3064_HIGHLIGHT_COVERAGE_AREA},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,   111,   126,   137, STR_DRAG_DROP, STR_STATION_DRAG_DROP},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    14,    73,   152,   163, STR_02DB_OFF, STR_3065_DON_T_HIGHLIGHT_COVERAGE},
-{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    74,   133,   152,   163, STR_02DA_ON, STR_3064_HIGHLIGHT_COVERAGE_AREA},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    37,   111,   216,   227, STR_DRAG_DROP, STR_STATION_DRAG_DROP},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    14,    73,   242,   253, STR_02DB_OFF, STR_3065_DON_T_HIGHLIGHT_COVERAGE},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,    74,   133,   242,   253, STR_02DA_ON, STR_3064_HIGHLIGHT_COVERAGE_AREA},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    32,    45, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    46,    59, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    60,    73, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    74,    87, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     7,   128,    88,   101, 0x0, STR_WAYPOINT_GRAPHICS_TIP},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   129,   140,    32,   101, 0x0, STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{          WWT_6,   RESIZE_NONE,    14,     7,   140,    17,    28, STR_0225, STR_WAYPOINT_GRAPHICS_TIP},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   129,   139,    18,    27, STR_0225, STR_WAYPOINT_GRAPHICS_TIP},
 {   WIDGETS_END},
 };
 
 static const WindowDesc _station_builder_desc = {
-	-1, -1, 148, 200,
+	-1, -1, 148, 290,
 	WC_BUILD_STATION,WC_BUILD_TOOLBAR,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET,
 	_station_builder_widgets,
@@ -760,7 +846,9 @@
 
 static void ShowStationBuilder(void)
 {
-	AllocateWindowDesc(&_station_builder_desc);
+	Window *w = AllocateWindowDesc(&_station_builder_desc);
+	w->vscroll.cap = 5;
+	w->vscroll.count = _station_count;
 }
 
 static void BuildTrainDepotWndProc(Window *w, WindowEvent *e)
Index: newgrf_callbacks.h
===================================================================
--- newgrf_callbacks.h	(revision 0)
+++ newgrf_callbacks.h	(revision 0)
@@ -0,0 +1,264 @@
+/* $id$ */
+
+#ifndef NEWGRF_CALLBACKS_H
+#define NEWGRF_CALLBACKS_H
+
+/**
+ * @file newgrf_callbacks.h
+ * Provides Callback IDs and masks.
+ */
+
+/**
+ * List of callbacks.
+ * The names are formatted as CBID_<CLASS>_<CALLBACK>
+ */
+enum CallbackID {
+	/**
+	 * Powered wagons, if the result is lower as 0x40 then the wagon is powered.
+	 */
+	CBID_TRAIN_WAGON_POWER          = 0x10,
+
+	/**
+	 * Wagon length.
+	 * @return The amount of "1/8s" the vehicle is shorter by.
+	 */
+	CBID_TRAIN_WAGON_LENGTH         = 0x11,
+
+	/**
+	 * Load amount.
+	 * Used instead of property 0x07 when the consist is changed.
+	 */
+	CBID_VEHICLE_LOAD_AMOUNT        = 0x12,
+
+	/**
+	 * Station availability.
+	 * Controls whether the station should be available in the construction
+	 * window.
+	 */
+	CBID_STATION_AVAILABILITY       = 0x13,
+	/**
+	 * Station sprite layout.
+	 * Selects an entry from the sprite layout of a station.
+	 */
+	CBID_STATION_SPRITE_LAYOUT      = 0x14,
+
+	/**
+	 * Refit capacity. The passed vehicle needs to have its ->cargo_type set to
+	 * the cargo we are refitting to.
+	 * @return The new cargo capacity.
+	 */
+	CBID_VEHICLE_REFIT_CAPACITY     = 0x15,
+
+	CBID_TRAIN_ARTICULATED          = 0x16,
+
+	CBID_HOUSE_CONSTRUCTION         = 0x17,
+
+	CBID_GENERIC_AI_CONSTRUCTION    = 0x18,
+
+	CBID_VEHICLE_CARGO_DISPLAY      = 0x19,
+
+	CBID_HOUSE_NEXT_ANIM_FRAME      = 0x1A,
+	CBID_HOUSE_ANIM_CONTROL         = 0x1B,
+	CBID_HOUSE_STATE_CHANGE         = 0x1C,
+
+	CBID_TRAIN_WAGON_ATTACH         = 0x1D,
+
+	CBID_HOUSE_COLOUR_REMAP         = 0x1E,
+	CBID_HOUSE_CARGO_ACCEPTANCE     = 0x1F,
+	CBID_HOUSE_ANIM_FRAME_LEN       = 0x20,
+	CBID_HOUSE_TRIGGER_DESTRUCTION  = 0x21,
+
+	CBID_INDUSTRY_AVAILABILITY      = 0x22,
+
+	CBID_TRAIN_ADDITIONAL_TEXT      = 0x23,
+
+	/**
+	 * Custom station layout.
+	 * Called once for each tile of a station being built. This callback is
+	 * always used.
+	 * @return New tile type to build. Returned values are 00, 02, 04 or 06.
+	 */
+	CBID_STATION_TILE_LAYOUT        = 0x24,
+
+	CBID_INDUSTRY_ANIM_CONTROL      = 0x25,
+	CBID_INDUSTRY_NEXT_ANIM_FRAME   = 0x26,
+	CBID_INDUSTRY_ANIM_FRAME_LEN    = 0x27,
+	CBID_INDUSTRY_LOCATION_PERM     = 0x28,
+	CBID_INDUSTRY_PROD_CHANGE       = 0x29,
+
+	CBID_HOUSE_CARGO_TYPES          = 0x2A,
+
+	CBID_INDUSTRY_CARRGO_ACCEPTANCE = 0x2B,
+	CBID_INDUSTRY_CARGO_TYPES       = 0x2C,
+
+	CBID_VEHICLE_COLOUR_REMAP       = 0x2D,
+
+	CBID_HOUSE_CARGO_GENERATION     = 0x2E,
+
+	CBID_INDUSTRY_SLOPE_CHECK       = 0x2F,
+	CBID_INDUSTRY_FOUNDATIONS       = 0x30,
+};
+
+/**
+ * Callback masks related to vehicles.
+ * Value is the bit position.
+ */
+enum VehicleCallbackMask {
+	CBM_WAGON_POWER  = 0, ///< Powered wagons (trains only)
+	CBM_VEH_LENGTH   = 1, ///< Wagon length (trains only)
+	CBM_LOAD_AMOUNT  = 2, ///< Load amount
+	CBM_REFIT_CAP    = 3, ///< Refitted capacity
+	CBM_ARTICULATED  = 4, ///< Build articulated engines (trains only)
+	CBM_CARGO_SUFFIX = 5, ///< Show suffix after cargo name
+	CBM_COLOUR_REMAP = 6, ///< Colour mapping for vehicle
+};
+
+/**
+ * Callback masks related to stations.
+ * Value is the bit position.
+ */
+enum StationCallbackMask {
+	CBM_AVAILABILITY  = 0, ///< Whether to make station available.
+	CBM_SPRITE_LAYOUT = 1, ///< Use callback to select sprite layout.
+};
+
+/**
+ * Result of a failed callback.
+ */
+enum {
+	CALLBACK_FAILED = 0xFFFF
+};
+
+#endif /* NEWGRF_CALLBACKS_H */
+/* $id$ */
+
+#ifndef NEWGRF_CALLBACKS_H
+#define NEWGRF_CALLBACKS_H
+
+/**
+ * @file newgrf_callbacks.h
+ * Provides Callback IDs and masks.
+ */
+
+/**
+ * List of callbacks.
+ * The names are formatted as CBID_<CLASS>_<CALLBACK>
+ */
+enum CallbackID {
+	/**
+	 * Powered wagons, if the result is lower as 0x40 then the wagon is powered.
+	 */
+	CBID_TRAIN_WAGON_POWER          = 0x10,
+
+	/**
+	 * Wagon length.
+	 * @return The amount of "1/8s" the vehicle is shorter by.
+	 */
+	CBID_TRAIN_WAGON_LENGTH         = 0x11,
+
+	/**
+	 * Load amount.
+	 * Used instead of property 0x07 when the consist is changed.
+	 */
+	CBID_VEHICLE_LOAD_AMOUNT        = 0x12,
+
+	/**
+	 * Station availability.
+	 * Controls whether the station should be available in the construction
+	 * window.
+	 */
+	CBID_STATION_AVAILABILITY       = 0x13,
+	/**
+	 * Station sprite layout.
+	 * Selects an entry from the sprite layout of a station.
+	 */
+	CBID_STATION_SPRITE_LAYOUT      = 0x14,
+
+	/**
+	 * Refit capacity. The passed vehicle needs to have its ->cargo_type set to
+	 * the cargo we are refitting to.
+	 * @return The new cargo capacity.
+	 */
+	CBID_VEHICLE_REFIT_CAPACITY     = 0x15,
+
+	CBID_TRAIN_ARTICULATED          = 0x16,
+
+	CBID_HOUSE_CONSTRUCTION         = 0x17,
+
+	CBID_GENERIC_AI_CONSTRUCTION    = 0x18,
+
+	CBID_VEHICLE_CARGO_DISPLAY      = 0x19,
+
+	CBID_HOUSE_NEXT_ANIM_FRAME      = 0x1A,
+	CBID_HOUSE_ANIM_CONTROL         = 0x1B,
+	CBID_HOUSE_STATE_CHANGE         = 0x1C,
+
+	CBID_TRAIN_WAGON_ATTACH         = 0x1D,
+
+	CBID_HOUSE_COLOUR_REMAP         = 0x1E,
+	CBID_HOUSE_CARGO_ACCEPTANCE     = 0x1F,
+	CBID_HOUSE_ANIM_FRAME_LEN       = 0x20,
+	CBID_HOUSE_TRIGGER_DESTRUCTION  = 0x21,
+
+	CBID_INDUSTRY_AVAILABILITY      = 0x22,
+
+	CBID_TRAIN_ADDITIONAL_TEXT      = 0x23,
+
+	/**
+	 * Custom station layout.
+	 * Called once for each tile of a station being built. This callback is
+	 * always used.
+	 * @return New tile type to build. Returned values are 00, 02, 04 or 06.
+	 */
+	CBID_STATION_TILE_LAYOUT        = 0x24,
+
+	CBID_INDUSTRY_ANIM_CONTROL      = 0x25,
+	CBID_INDUSTRY_NEXT_ANIM_FRAME   = 0x26,
+	CBID_INDUSTRY_ANIM_FRAME_LEN    = 0x27,
+	CBID_INDUSTRY_LOCATION_PERM     = 0x28,
+	CBID_INDUSTRY_PROD_CHANGE       = 0x29,
+
+	CBID_HOUSE_CARGO_TYPES          = 0x2A,
+
+	CBID_INDUSTRY_CARRGO_ACCEPTANCE = 0x2B,
+	CBID_INDUSTRY_CARGO_TYPES       = 0x2C,
+
+	CBID_VEHICLE_COLOUR_REMAP       = 0x2D,
+
+	CBID_HOUSE_CARGO_GENERATION     = 0x2E,
+
+	CBID_INDUSTRY_SLOPE_CHECK       = 0x2F,
+	CBID_INDUSTRY_FOUNDATIONS       = 0x30,
+};
+
+/**
+ * Callback masks related to vehicles.
+ * Value is the bit position.
+ */
+enum VehicleCallbackMask {
+	CBM_WAGON_POWER  = 0, ///< Powered wagons (trains only)
+	CBM_VEH_LENGTH   = 1, ///< Wagon length (trains only)
+	CBM_LOAD_AMOUNT  = 2, ///< Load amount
+	CBM_REFIT_CAP    = 3, ///< Refitted capacity
+	CBM_ARTICULATED  = 4, ///< Build articulated engines (trains only)
+	CBM_CARGO_SUFFIX = 5, ///< Show suffix after cargo name
+	CBM_COLOUR_REMAP = 6, ///< Colour mapping for vehicle
+};
+
+/**
+ * Callback masks related to stations.
+ * Value is the bit position.
+ */
+enum StationCallbackMask {
+	CBM_AVAILABILITY  = 0, ///< Whether to make station available.
+	CBM_SPRITE_LAYOUT = 1, ///< Use callback to select sprite layout.
+};
+
+/**
+ * Result of a failed callback.
+ */
+enum {
+	CALLBACK_FAILED = 0xFFFF
+};
+
+#endif /* NEWGRF_CALLBACKS_H */
Index: tile.h
===================================================================
--- tile.h	(revision 2908)
+++ tile.h	(working copy)
@@ -102,6 +102,13 @@
 	return IsTileType(tile, MP_TUNNELBRIDGE) && (_m[tile].m5 & 0xF0) == 0;
 }
 
+static inline bool IsTileBridgeEnd(TileIndex tile)
+{
+	return IsTileType(tile, MP_TUNNELBRIDGE) &&
+		HASBIT(_m[tile].m5, 7) &&
+		!HASBIT(_m[tile].m5, 6);
+}
+
 static inline Owner GetTileOwner(TileIndex tile)
 {
 	assert(tile < MapSize());
Index: settings_gui.c
===================================================================
--- settings_gui.c	(revision 2908)
+++ settings_gui.c	(working copy)
@@ -296,19 +296,19 @@
 	{  0,   2,  1, STR_6816_LOW},
 	{  0,   3,  1, STR_26816_NONE},
 	{100, 500, 50, STR_NULL},
-	{  2,   4,  1, STR_NULL},
-	{  0,   2,  1, STR_6820_LOW},
+	{  2,   10, 1, STR_NULL},
+	{  0,   3,  1, STR_6820_LOW},
 	{  0,   4,  1, STR_681B_VERY_SLOW},
 	{  0,   2,  1, STR_6820_LOW},
 	{  0,   2,  1, STR_6823_NONE},
 	{  0,   3,  1, STR_6826_X1_5},
-	{  0,   2,  1, STR_6820_LOW},
+	{  0,   3,  1, STR_6820_LOW},
 	{  0,   3,  1, STR_682A_VERY_FLAT},
 	{  0,   3,  1, STR_VERY_LOW},
 	{  0,   1,  1, STR_682E_STEADY},
 	{  0,   1,  1, STR_6834_AT_END_OF_LINE_AND_AT_STATIONS},
 	{  0,   1,  1, STR_6836_OFF},
-	{  0,   2,  1, STR_6839_PERMISSIVE},
+	{  0,   3,  1, STR_6839_PERMISSIVE},
 };
 
 static inline bool GetBitAndShift(uint32 *b)
@@ -666,6 +666,7 @@
 
 static const PatchEntry _patches_ui[] = {
 	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_VEHICLESPEED,		"vehicle_speed",		&_patches.vehicle_speed,						0,  0,  0, NULL},
+	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_WINDOWGRADIENT,		"window_gradients",		&_patches.window_gradients,						0,  0,  0, NULL},
 	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_LONGDATE,				"long_date",				&_patches.status_long_date,					0,  0,  0, NULL},
 	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_SHOWFINANCES,		"show_finances",		&_patches.show_finances,						0,  0,  0, NULL},
 	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_AUTOSCROLL,			"autoscroll",				&_patches.autoscroll,								0,  0,  0, NULL},
@@ -690,6 +691,7 @@
 	{PE_BOOL,		0, STR_CONFIG_PATCHES_SMALL_AIRPORTS,		"always_small_airport", &_patches.always_small_airport,			0,  0,  0, NULL},
 	{PE_UINT8,	PF_PLAYERBASED, STR_CONFIG_PATCHES_DRAG_SIGNALS_DENSITY, "drag_signals_density", &_patches.drag_signals_density, 1, 20,  1, NULL},
 	{PE_BOOL,		0, STR_CONFIG_AUTO_PBS_PLACEMENT, "auto_pbs_placement", &_patches.auto_pbs_placement, 1, 20,  1, NULL},
+	{PE_BOOL,               0, STR_CONFIG_PATCHES_DIFFERING_RAIL_COSTS, "differing_rail_costs", &_patches.differing_rail_costs, 0, 0, 0, NULL},
 
 };
 
@@ -721,6 +723,7 @@
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_AIRCRAFT, "servint_aircraft", &_patches.servint_aircraft, 5,800,  5, &InValidateDetailsWindow},
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_SHIPS,		"servint_ships",    &_patches.servint_ships,		5,800,  5, &InValidateDetailsWindow},
 	{PE_BOOL,   0,         STR_CONFIG_PATCHES_NOSERVICE,        "no_servicing_if_no_breakdowns", &_patches.no_servicing_if_no_breakdowns, 0, 0, 0, NULL},
+	{PE_UINT8,  0,         STR_CONFIG_PATCHES_FREIGHT_TRAINS,   "freight_trains",                &_patches.freight_trains,                1, 32, 1, NULL},
 };
 
 static const PatchEntry _patches_stations[] = {
Index: console_cmds.c
===================================================================
--- console_cmds.c	(revision 2908)
+++ console_cmds.c	(working copy)
@@ -1362,6 +1362,9 @@
 	IConsoleVarRegister("pause_on_join",         &_network_pause_on_join, ICONSOLE_VAR_BOOLEAN, "Set if the server should pause gameplay while a client is joining. This might help slow users");
 	IConsoleVarHookAdd("pause_on_join",          ICONSOLE_HOOK_ACCESS, ConHookServerOnly);
 
+	IConsoleVarRegister("pause_on_no_clients",   &_network_pause_on_no_clients, ICONSOLE_VAR_BOOLEAN, "Set if the server should pause gameplay when there are no clients connected.");
+	IConsoleVarHookAdd("pause_on_no_clients",    ICONSOLE_HOOK_ACCESS, ConHookServerOnly);
+
 	IConsoleVarRegister("autoclean_companies",   &_network_autoclean_companies, ICONSOLE_VAR_BOOLEAN, "Automatically shut down inactive companies to free them up for other players. Customize with 'autoclean_(un)protected'");
 	IConsoleVarHookAdd("autoclean_companies",    ICONSOLE_HOOK_ACCESS, ConHookServerOnly);
 
Index: network_server.c
===================================================================
--- network_server.c	(revision 2908)
+++ network_server.c	(working copy)
@@ -750,8 +750,9 @@
 			}
 		}
 
-		if (_network_pause_on_join) {
+		if (_network_pause_on_join && !(_network_pause_on_no_clients && _network_dedicated && _network_game_info.clients_on == 1)) {
 			/* Now pause the game till the client is in sync */
+			/* If pause on no clients is enabled and this is the first client, then it will already be paused */
 			DoCommandP(0, 1, 0, NULL, CMD_PAUSE);
 
 			NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game paused (incoming client)", NETWORK_SERVER_INDEX);
@@ -957,7 +958,7 @@
 		/* Now he is! Unpause the game */
 		cs->status = STATUS_ACTIVE;
 
-		if (_network_pause_on_join) {
+		if (_network_pause_on_join || (_network_pause_on_no_clients && _network_dedicated && _network_game_info.clients_on == 1)) {
 			DoCommandP(0, 0, 0, NULL, CMD_PAUSE);
 			NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game unpaused", NETWORK_SERVER_INDEX);
 		}
Index: sound.c
===================================================================
--- sound.c	(revision 2908)
+++ sound.c	(working copy)
@@ -23,6 +23,8 @@
 static FileEntry* _files;
 
 #define SOUND_SLOT 31
+#define PANNING_LEVELS 16
+#define PANNING_LEVELS_SHIFT 3
 
 
 static void OpenBankFile(const char *filename)
@@ -132,15 +134,18 @@
 }
 
 // Low level sound player
-static void StartSound(uint sound, uint panning, uint volume)
+static void StartSound(uint sound, int panning, uint volume)
 {
 	MixerChannel* mc;
+	uint left_vol, right_vol;
 
 	if (volume == 0) return;
 	mc = MxAllocateChannel(_mixer);
 	if (mc == NULL) return;
 	if (!SetBankSource(mc, sound)) return;
-	MxSetChannelVolume(mc, volume << 8, volume << 8);
+	left_vol = (volume * PANNING_LEVELS) - (volume * panning);
+	right_vol = (volume * PANNING_LEVELS) + (volume * panning);
+	MxSetChannelVolume(mc, left_vol << PANNING_LEVELS_SHIFT, right_vol << PANNING_LEVELS_SHIFT);
 	MxActivateChannel(mc);
 }
 
@@ -185,11 +190,11 @@
 		if (vp != NULL &&
 				IS_INSIDE_1D(x, vp->virtual_left, vp->virtual_width) &&
 				IS_INSIDE_1D(y, vp->virtual_top, vp->virtual_height)) {
-			int left = ((x - vp->virtual_left) >> vp->zoom) + vp->left;
+			int left = (x - vp->virtual_left);
 
 			StartSound(
 				_sound_idx[sound],
-				clamp(left / 71, 0, 8),
+				clamp(left / (vp->virtual_width / ((PANNING_LEVELS << 1) + 1)) - PANNING_LEVELS, -PANNING_LEVELS, PANNING_LEVELS),
 				(_sound_base_vol[sound] * msf.effect_vol * _vol_factor_by_zoom[vp->zoom]) >> 15
 			);
 			return;
@@ -219,7 +224,7 @@
 {
 	StartSound(
 		_sound_idx[sound],
-		4,
+		0,
 		(_sound_base_vol[sound] * msf.effect_vol) >> 7
 	);
 }
Index: driver.c
===================================================================
--- driver.c	(revision 2908)
+++ driver.c	(working copy)
@@ -14,6 +14,7 @@
 #include "music/null_m.h"
 #include "music/os2_m.h"
 #include "music/win32_m.h"
+#include "music/qtmidi.h"
 
 #include "sound/null_s.h"
 #include "sound/sdl_s.h"
@@ -51,6 +52,9 @@
 #ifdef WIN32
 	M("win32",   "Win32 MIDI Driver",       &_win32_music_driver),
 #endif
+#ifdef __APPLE__
+	M("qt",      "QuickTime MIDI Driver",   &_qtime_music_driver),
+#endif
 #ifdef UNIX
 #if !defined(__MORPHOS__) && !defined(__AMIGA__)
 	M("extmidi", "External MIDI Driver",    &_extmidi_music_driver),
Index: newgrf.c
===================================================================
--- newgrf.c	(revision 2908)
+++ newgrf.c	(working copy)
@@ -764,22 +764,7 @@
 				classid |= *(buf++) << 8;
 				classid |= *(buf++);
 
-				switch (classid) {
-					case 'DFLT':
-						stat->sclass = STAT_CLASS_DFLT;
-						break;
-					case 'WAYP':
-						stat->sclass = STAT_CLASS_WAYP;
-						break;
-					default:
-						/* TODO: No support for custom
-						 * classes for now, so stuff
-						 * everything to the single
-						 * default one. --pasky */
-						stat->sclass = STAT_CLASS_DFLT;
-						//stat->sclass = STAT_CLASS_CUSTOM;
-						break;
-				}
+				stat->sclass = AllocateCustomStationClass(classid);
 			}
 			break;
 		}
@@ -789,17 +774,12 @@
 				StationSpec *stat = &_cur_grffile->stations[stid + i];
 				int t;
 
-				stat->tiles = grf_load_byte(&buf);
+				stat->tiles = grf_load_extended(&buf);
+				stat->renderdata = realloc(stat->renderdata, stat->tiles * sizeof(DrawTileSprites));
 				for (t = 0; t < stat->tiles; t++) {
 					DrawTileSprites *dts = &stat->renderdata[t];
 					int seq_count = 0;
 
-					if (t >= 8) {
-						grfmsg(GMS_WARN, "StationChangeInfo: Sprite %d>=8, skipping.", t);
-						grf_load_dword(&buf); // at least something
-						continue;
-					}
-
 					dts->ground_sprite = grf_load_dword(&buf);
 					if (!dts->ground_sprite) {
 						static const DrawTileSeqStruct empty = {0x80, 0, 0, 0, 0, 0, 0};
@@ -837,6 +817,7 @@
 				int t;
 
 				stat->tiles = srcstat->tiles;
+				stat->renderdata = realloc(stat->renderdata, stat->tiles * sizeof(DrawTileSprites));
 				for (t = 0; t < stat->tiles; t++) {
 					DrawTileSprites *dts = &stat->renderdata[t];
 					DrawTileSprites *sdts = &srcstat->renderdata[t];
@@ -857,9 +838,10 @@
 						// no relative bounding box support
 						dts->seq = realloc((void*)dts->seq, ++seq_count * sizeof(DrawTileSeqStruct));
 						dtss = (DrawTileSeqStruct*) &dts->seq[seq_count - 1];
+						sdtss = &sdts->seq[seq_count - 1];
 						*dtss = *sdtss;
 						if ((byte) dtss->delta_x == 0x80) break;
-						sdtss++;
+						//sdtss++;
 					}
 				}
 			}
@@ -867,11 +849,11 @@
 		}
 		case 0x0b:
 		{	/* Callback */
-			/* TODO */
 			FOR_EACH_OBJECT {
-				grf_load_byte(&buf);
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+				
+				stat->callbackmask = grf_load_byte(&buf);
 			}
-			ret = 1;
 			break;
 		}
 		case 0x0C:
@@ -879,7 +861,7 @@
 			FOR_EACH_OBJECT {
 				StationSpec *stat = &_cur_grffile->stations[stid + i];
 
-				stat->allowed_platforms = ~grf_load_byte(&buf);
+				stat->disallowed_platforms = grf_load_byte(&buf);
 			}
 			break;
 		}
@@ -888,7 +870,7 @@
 			FOR_EACH_OBJECT {
 				StationSpec *stat = &_cur_grffile->stations[stid + i];
 
-				stat->allowed_lengths = ~grf_load_byte(&buf);
+				stat->disallowed_lengths = grf_load_byte(&buf);
 			}
 			break;
 		}
@@ -966,7 +948,7 @@
 		{	/* Pylon placement */
 			/* TODO; makes sense only for electrified tracks */
 			FOR_EACH_OBJECT {
-				grf_load_word(&buf);
+				grf_load_byte(&buf);
 			}
 			ret = 1;
 			break;
@@ -975,11 +957,40 @@
 		{	/* Cargo types for random triggers */
 			/* TODO */
 			FOR_EACH_OBJECT {
-				grf_load_dword(&buf);
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+
+				stat->cargotriggers = grf_load_dword(&buf);
+			}
+			break;
+		}
+		case 0x13:
+		{	/* General Flags (13) */
+			FOR_EACH_OBJECT {
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+
+				byte flags = grf_load_byte(&buf);
+				if ((flags & 3) != flags)
+					grfmsg(GMS_WARN, "StationChangeInfo: Unsupported flags %x, ignoring.", flags & ~3);
+				stat->flags = flags & 3;
+			}
+			break;
+		}
+		case 0x14:
+		{	/* Catenary placement */
+			FOR_EACH_OBJECT {
+				grf_load_byte(&buf);
 			}
 			ret = 1;
 			break;
 		}
+		case 0x15:
+		{	/* Blocked tile */
+			FOR_EACH_OBJECT {
+				StationSpec *stat = &_cur_grffile->stations[stid + i];
+				stat->blocked = grf_load_byte(&buf);
+			}
+			break;
+		}
 		default:
 			ret = 1;
 			break;
@@ -1053,70 +1064,80 @@
 
 	while (numprops-- && buf < bufend) {
 		uint8 prop = grf_load_byte(&buf);
+		bool ignoring = false;
 
-		if (feature == GSF_STATION)
-			// stations don't share those common properties
-			goto run_handler;
-
-		switch (prop) {
-		case 0x00: { /* Introduction date */
-			FOR_EACH_OBJECT {
-				uint16 date = grf_load_word(&buf);
-
-				ei[i].base_intro = date;
-			}
-		}	break;
-		case 0x02: { /* Decay speed */
-			FOR_EACH_OBJECT {
-				uint8 decay = grf_load_byte(&buf);
-
-				ei[i].unk2 &= 0x80;
-				ei[i].unk2 |= decay & 0x7f;
-			}
-		}	break;
-		case 0x03: { /* Vehicle life */
-			FOR_EACH_OBJECT {
-				uint8 life = grf_load_byte(&buf);
-
-				ei[i].lifelength = life;
-			}
-		}	break;
-		case 0x04: { /* Model life */
-			FOR_EACH_OBJECT {
-				uint8 life = grf_load_byte(&buf);
-
-				ei[i].base_life = life;
-			}
-		}	break;
-		case 0x06: { /* Climates available */
-			FOR_EACH_OBJECT {
-				uint8 climates = grf_load_byte(&buf);
+		switch (feature) {
+			case GSF_TRAIN:
+			case GSF_ROAD:
+			case GSF_SHIP:
+			case GSF_AIRCRAFT:
+				/* Common properties for vehicles */
+				switch (prop) {
+					case 0x00: { /* Introduction date */
+						FOR_EACH_OBJECT {
+							uint16 date = grf_load_word(&buf);
+
+							ei[i].base_intro = date;
+						}
+					}	break;
+					case 0x02: { /* Decay speed */
+						FOR_EACH_OBJECT {
+							uint8 decay = grf_load_byte(&buf);
+
+							ei[i].unk2 &= 0x80;
+							ei[i].unk2 |= decay & 0x7f;
+						}
+					}	break;
+					case 0x03: { /* Vehicle life */
+						FOR_EACH_OBJECT {
+							uint8 life = grf_load_byte(&buf);
+
+							ei[i].lifelength = life;
+						}
+					}	break;
+					case 0x04: { /* Model life */
+						FOR_EACH_OBJECT {
+							uint8 life = grf_load_byte(&buf);
+
+							ei[i].base_life = life;
+						}
+					}	break;
+					case 0x06: { /* Climates available */
+						FOR_EACH_OBJECT {
+							uint8 climates = grf_load_byte(&buf);
+
+							ei[i].railtype_climates &= 0xf0;
+							ei[i].railtype_climates |= climates;
+						}
+					}	break;
+					case 0x07: { /* Loading speed */
+						/* TODO */
+						/* Hyronymus explained me what does
+						 * this mean and insists on having a
+						 * credit ;-). --pasky */
+						/* TODO: This needs to be supported by
+						 * LoadUnloadVehicle() first. */
+						FOR_EACH_OBJECT {
+							grf_load_byte(&buf);
+						}
+						ignoring = true;
+						break;
+					}
 
-				ei[i].railtype_climates &= 0xf0;
-				ei[i].railtype_climates |= climates;
-			}
-		}	break;
-		case 0x07: { /* Loading speed */
-			/* TODO */
-			/* Hyronymus explained me what does
-			 * this mean and insists on having a
-			 * credit ;-). --pasky */
-			/* TODO: This needs to be supported by
-			 * LoadUnloadVehicle() first. */
-			FOR_EACH_OBJECT {
-				grf_load_byte(&buf);
-			}
-			goto ignoring;
-		}
-		default: {
-run_handler:
-			if (handler[feature](engine, numinfo, prop, &buf, bufend - buf)) {
-ignoring:
-				grfmsg(GMS_NOTICE, "VehicleChangeInfo: Ignoring property %x (not implemented).", prop);
-			}
-			break;
-		}
+					default:
+						if (handler[feature](engine, numinfo, prop, &buf, bufend - buf))
+							ignoring = true;
+						break;
+				}
+				break;
+			default:
+				if (handler[feature](engine, numinfo, prop, &buf, bufend - buf))
+					ignoring = true;
+				break;
 		}
+
+		if (ignoring)
+			grfmsg(GMS_NOTICE, "VehicleChangeInfo: Ignoring property %x (not implemented).", prop);
 	}
 }
 
@@ -1253,11 +1274,18 @@
 
 		dg->var_scope = numloaded == 0x82 ? VSG_SCOPE_PARENT : VSG_SCOPE_SELF;
 		dg->variable = grf_load_byte(&buf);
+		/* Variables 0x60 - 0x7F include an extra parameter */
+		if (IS_BYTE_INSIDE(dg->variable, 0x60, 0x80))
+			dg->parameter = grf_load_byte(&buf);
 
 		dg->shift_num = grf_load_byte(&buf);
 		dg->and_mask = grf_load_byte(&buf);
 		dg->operation = dg->shift_num >> 6; /* w00t */
-		dg->shift_num &= 0x3F;
+		if (HASBIT(dg->shift_num, 5)) {
+			/* Advanced varaction2 */
+			printf("ADVANCED\n");
+		}
+		dg->shift_num &= 0x1F;
 		if (dg->operation != DSG_OP_NONE) {
 			dg->add_val = grf_load_byte(&buf);
 			dg->divmod_val = grf_load_byte(&buf);
@@ -1273,6 +1301,7 @@
 				dg->ranges[i].group = NewCallBackResult(groupid);
 			} else if (groupid >= _cur_grffile->spritegroups_count) {
 				/* This doesn't exist for us. */
+				printf("Doesn't exist for us?\n");
 				grf_load_word(&buf); // skip range
 				i--; dg->num_ranges--;
 				continue;
@@ -1438,7 +1467,7 @@
 	uint8 cidcount;
 	int c, i;
 
-	check_length(len, 7, "VehicleMapSpriteGroup");
+	check_length(len, 6, "VehicleMapSpriteGroup");
 	feature = buf[1];
 	idcount = buf[2] & 0x7F;
 	wagover = (buf[2] & 0x80) == 0x80;
@@ -1499,7 +1528,7 @@
 				stat->spritegroup[0] = _cur_grffile->spritegroups[groupid];
 				stat->grfid = _cur_grffile->grfid;
 				SetCustomStation(stid, stat);
-				stat->sclass = STAT_CLASS_NONE;
+				//stat->sclass = STAT_CLASS_NONE;
 			}
 		}
 		return;
@@ -1600,6 +1629,19 @@
 	}
 }
 
+static inline void SetCustomStationName(byte stid, const char *name)
+{
+	if (strlen(name) == 0)
+		return;
+
+	if (_cur_grffile->stations[stid].name != NULL) {
+		/* Name already exists, let's replace it. */
+		free(_cur_grffile->stations[stid].name);
+	}
+
+	_cur_grffile->stations[stid].name = strdup(name);
+}
+
 /* Action 0x04 */
 static void VehicleNewName(byte *buf, int len)
 {
@@ -1631,24 +1673,17 @@
 	lang     = grf_load_byte(&buf);
 	num      = grf_load_byte(&buf);
 	id       = (lang & 0x80) ? grf_load_word(&buf) : grf_load_byte(&buf);
-
-	if (feature > 3) {
-		DEBUG(grf, 7) ("VehicleNewName: Unsupported feature %d, skipping", feature);
-		return;
-	}
-
-	id      += _vehshifts[feature];
 	endid    = id + num;
 
-	DEBUG(grf, 6) ("VehicleNewName: About to rename engines %d..%d (feature %d) in language 0x%x.",
-	               id, endid, feature, lang);
+	DEBUG(grf, 6) ("VehicleNewName: About to rename engines %x..%x (feature %x) in language 0x%x.",
+	               id, endid - 1, feature, lang);
 
-	if (lang & 0x80) {
+	if ((lang & 0x80) && (id < 0xC400)) {
 		grfmsg(GMS_WARN, "VehicleNewName: No support for changing in-game texts. Skipping.");
 		return;
 	}
 
-	if (!(lang & 3)) {
+	if (!(lang & 3 || lang == 0x48)) {
 		/* XXX: If non-English name, silently skip it. */
 		DEBUG(grf, 7) ("VehicleNewName: Skipping non-English name.");
 		return;
@@ -1660,8 +1695,33 @@
 		int ofs = strlen(name) + 1;
 
 		if (ofs < 128) {
-			DEBUG(grf, 8) ("VehicleNewName: %d <- %s", id, name);
-			SetCustomEngineName(id, name);
+			DEBUG(grf, 8) ("VehicleNewName: %x <- %s", id, name);
+			switch (id & 0xFF00) {
+				case 0x0000:
+					if (!(lang & 0x80)) {
+						/* New vehicle name (uses a byte value, so top bit is zero) */
+						if (feature > 3) {
+							DEBUG(grf, 7) ("VehicleNewName: Unsupported feature %d, skipping", feature);
+							return;
+						}
+						SetCustomEngineName(id + _vehshifts[feature], name);
+						break;
+					}
+					DEBUG(grf, 7) ("VehicleNewName: Unsupported ID (%x)", id);
+					break;
+				case 0xC400: /* Station Class */
+					SetCustomStationClassName(_cur_grffile->stations[id & 0xFF].sclass, name);
+					break;
+				case 0xC500: /* Station Name */
+					SetCustomStationName(id & 0xFF, name);
+					break;
+				case 0xC900: /* House name */
+				case 0xD000: /* Miscellaneous text */
+				case 0xDC00: /* Miscellaneous persistent text (should be saved) */
+				default:
+					DEBUG(grf, 7) ("VehicleNewName: Unsupported ID (%x)", id);
+					break;
+			}
 		} else {
 			DEBUG(grf, 7) ("VehicleNewName: Too long a name (%d)", ofs);
 		}
@@ -1812,6 +1872,8 @@
 			break;
 		case 7: result = !param_val; /* GRFID is not active (only for param-num=88) */
 			break;
+		case 8: result = !!param_val;
+			break;
 		default:
 			grfmsg(GMS_WARN, "Unsupported test %d. Ignoring.", condtype);
 			return;
@@ -2054,6 +2116,14 @@
 				res = (int32)src1 << src2;
 			break;
 
+		case 0x07:
+			res = src1 & src2;
+			break;
+
+		case 0x08:
+			res = src1 | src2;
+			break;
+
 		default:
 			grfmsg(GMS_ERROR, "ParamSet: Unknown operation %d, skipping.", oper);
 			return;
@@ -2127,14 +2197,15 @@
 	                   | (1 << 0x18)  /* newrvs */
 	                   | (1 << 0x19)  /* newships */
 	                   | (1 << 0x1A)  /* newplanes */
-			               | (1 << 0x1B); /* signalsontrafficside */
+			               | (1 << 0x1B) /* signalsontrafficside */
 	                   /* Uncomment following if you want to fool the GRF file.
 	                    * Some GRF files will refuse to load without this
 	                    * but you can still squeeze something from them even
 	                    * without the support - i.e. USSet. --pasky */
-			               //| (1 << 0x1C); /* electrifiedrailway */
+			               | (1 << 0x1C); /* electrifiedrailway */
 
 	_ttdpatch_flags[2] = (1 << 0x0D)  /* buildonslopes */
+	                   | (1 << 0x12)  /* newstations */
 	                   | (1 << 0x16)  /* canals */
 	                   | (1 << 0x17); /* newstartyear */
 }
