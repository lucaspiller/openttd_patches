Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 2724)
+++ station_cmd.c	(working copy)
@@ -23,6 +23,7 @@
 #include "sprite.h"
 #include "depot.h"
 #include "pbs.h"
+#include "network.h"
 
 enum {
 	/* Max stations: 64000 (64 * 1000) */
@@ -448,8 +449,8 @@
 	st->airport_tile = st->dock_tile = st->train_tile = 0;
 	st->bus_stops = st->truck_stops = NULL;
 	st->had_vehicle_of_type = 0;
-	st->time_since_load = 255;
-	st->time_since_unload = 255;
+	st->time_since_load = INVALID_TIME;
+	st->time_since_unload = INVALID_TIME;
 	st->delete_ctr = 0;
 	st->facilities = 0;
 
@@ -459,11 +460,14 @@
 		ge->waiting_acceptance = 0;
 		ge->days_since_pickup = 0;
 		ge->enroute_from = INVALID_STATION;
-		ge->rating = 175;
+		ge->rating = RATING_START_VALUE;
 		ge->last_speed = 0;
-		ge->last_age = 0xFF;
+		ge->last_age = INVALID_AGE;
 		ge->feeder_profit = 0;
+		ge->last_vehicle_speed = 0;
+		ge->last_vehicle_type = INVALID_VEHICLE;
 	}
+	InitializeStationStats(st);
 
 	_global_station_sort_dirty = true; // build a new station
 }
@@ -2520,46 +2524,166 @@
 static void UpdateStationRating(Station *st)
 {
 	GoodsEntry *ge;
-	int rating;
+	RatingStats *rs;
 	StationID index;
-	int waiting;
+	int rating, waiting, lv_type, speed, old_rating, points, point_clamp;
 	bool waiting_changed = false;
+	byte age, days;
 
 	byte_inc_sat(&st->time_since_load);
 	byte_inc_sat(&st->time_since_unload);
 
 	ge = st->goods;
+	rs = st->rating_stats;
+
 	do {
 		if (ge->enroute_from != INVALID_STATION) {
-			byte_inc_sat(&ge->enroute_time);
-			byte_inc_sat(&ge->days_since_pickup);
-
 			rating = 0;
+			old_rating = 0;
+			points = 0;
+			lv_type = ge->last_vehicle_type;
+			if (lv_type == INVALID_VEHICLE && st->last_vehicle != INVALID_VEHICLE)
+				lv_type = GetVehicle(st->last_vehicle)->type;
 
+			speed = ge->last_speed;
+			if (_patches.nsr_speed)
 			{
-				int b = ge->last_speed;
-				if ((b-=85) >= 0)
-					rating += b >> 2;
+				points = ge->last_vehicle_speed;
+				if (points == 0)
+					points = speed;
+				rs->last_speed = points;
+				switch (lv_type)
+				{
+					case VEH_Train:
+						if (points <= RP_T_SPEED_CAP) // "normal" trains
+							points += (ge == &st->goods[CT_PASSENGERS]) ? RP_T_SPEED_PASS_BONUS : RP_T_SPEED_CARGO_BONUS;
+						else // monorail + maglev, currently too few trains to be worth more distinction
+							points /= RP_SPEED_MULT;
+						break;
+					case VEH_Road:
+						points *= 3 / 2;
+						points += (ge == &st->goods[CT_PASSENGERS]) ? RP_R_SPEED_PASS_BONUS : RP_R_SPEED_CARGO_BONUS;
+						break;
+					case VEH_Ship:
+						rs->last_speed = points / 2;
+						if (ge != &st->goods[CT_PASSENGERS])
+							points *= RP_SPEED_MULT;
+						break;
+					case VEH_Aircraft:
+						rs->last_speed = (points * 64) / 5; // * 8 * 16 / 10
+						if (ge != &st->goods[CT_PASSENGERS])
+							points *= RP_SPEED_MULT;
+						break;
+					default:	
+						points = 0;
+				}
+				// max 170 >> 2 = 42 points for speedrating
+				rating += clamp(points, 0, RP_MAX_SPEED_POINTS) >> 2;
 			}
+			else
+			{
+				if ((speed -= 85) >= 0)
+					rating += speed >> 2;
+				rs->last_speed = ge->last_speed;
+			}
+			rs->ratings[RATING_SPEED] = rating - old_rating;
+			old_rating = rating;
 
+			age = ge->last_age;
+			if (_patches.nsr_age)
 			{
-				byte age = ge->last_age;
+				if (ge == &st->goods[CT_PASSENGERS]) {
+					switch (lv_type)	// scale age to RP_MAX_AGE years
+					{
+						case VEH_Train:		point_clamp = RP_AGE_T_CLAMP;	break;
+						case VEH_Road:			point_clamp = RP_AGE_R_CLAMP;	break;
+						case VEH_Ship:			point_clamp = RP_AGE_S_CLAMP;	break;
+						case VEH_Aircraft:	point_clamp = RP_AGE_A_CLAMP;	break;
+						default:					point_clamp = RP_MAX_AGE;
+					}
+					points = clamp(points, 0, point_clamp) * RP_MAX_AGE / point_clamp;
+					switch (age) // give bonus to rating for low age
+					{ // uses real age, not scaled age
+						case 0:	rating += RP_AGE_BONUS_0;	break;
+						case 1:	rating += RP_AGE_BONUS_1;	break;
+						case 2:	rating += RP_AGE_BONUS_2;	break;
+						case 3:	rating += RP_AGE_BONUS_3;	break;
+						case 4:	rating += RP_AGE_BONUS_4;	break;
+						case 5:	rating += RP_AGE_BONUS_5;	break;
+					}
+				} else { // non passengers dont care for vehicle-age
+					rating += RP_AGE_BONUS_0;
+					points = 0;
+				}
+				rating += (RP_MAX_AGE_POINTS - points);
+			}
+			else
+			{
 				(age >= 3) ||
 				(rating += 10, age >= 2) ||
 				(rating += 10, age >= 1) ||
 				(rating += 13, true);
 			}
+			rs->last_age = age;
+			rs->ratings[RATING_AGE] = rating - old_rating;
+			old_rating = rating;
 
 			{
 				if (st->owner != OWNER_NONE && !IS_HUMAN_PLAYER(st->owner))
 							rating += _rating_boost[_opt.diff.competitor_intelligence];
 			}
 
-			if (st->owner < MAX_PLAYERS && HASBIT(st->town->statues, st->owner))
-				rating += 26;
+			if (_patches.nsr_town_rating)
+			{
+				if (st->owner < MAX_PLAYERS)
+				{
+					if (HASBIT(st->town->statues, st->owner))	rating += RP_OTHER_STATUE;
+					// if townratings are not changed this will be within -20..+20
+					rating += (st->town->ratings[st->owner] / RP_OTHER_LA_MULT);
+				} else {
+					if (st->owner == OWNER_NONE)
+						rating += 26; // oilrigs dont have owner... for now give maxpoints till i know what i want to do here ;)
+				}
+			}
+			else
+			{
+				if (st->owner < MAX_PLAYERS && HASBIT(st->town->statues, st->owner))
+					rating += 26;
+			}
+			rs->ratings[RATING_OTHER] = rating - old_rating;
+			old_rating = rating;
 
+			days = ge->days_since_pickup;
+			if (_patches.nsr_wait_days)
 			{
-				byte days = ge->days_since_pickup;
+				if (ge == &st->goods[CT_PASSENGERS])
+					points = days * 2; // double wait effect for Passengers
+				else
+					points = days;
+				switch (lv_type)	// scale waitdays to RP_MAX_DAYS days
+				{
+					case VEH_Train:		point_clamp = RP_DAYS_T_CLAMP;	break;
+					case VEH_Road:			point_clamp = RP_DAYS_R_CLAMP;	break;
+					case VEH_Ship:			point_clamp = RP_DAYS_S_CLAMP;	break;
+					case VEH_Aircraft:	point_clamp = RP_DAYS_A_CLAMP;	break;
+					default:					point_clamp = RP_MAX_DAYS;
+				}
+				points = clamp(points, 0, point_clamp) * RP_MAX_DAYS / point_clamp;
+				rating += (RP_MAX_DAYS_POINTS - points * RP_MAX_DAYS_POINTS / RP_MAX_DAYS);
+				switch (days) // give bonus for short wait-time
+				{ // uses real days, not scaled days
+					case 0:	rating += RP_DAYS_BONUS_0;	break;
+					case 1:	rating += RP_DAYS_BONUS_1;	break;
+					case 2:	rating += RP_DAYS_BONUS_2;	break;
+					case 3:	rating += RP_DAYS_BONUS_3;	break;
+					case 4:	rating += RP_DAYS_BONUS_4;	break;
+					case 5:	rating += RP_DAYS_BONUS_5;	break;
+					case 6:	rating += RP_DAYS_BONUS_6;	break;
+					case 7:	rating += RP_DAYS_BONUS_7;	break;
+				}
+			}
+			else
+			{
 				if (st->last_vehicle != INVALID_VEHICLE &&
 						GetVehicle(st->last_vehicle)->type == VEH_Ship)
 							days >>= 2;
@@ -2569,9 +2693,42 @@
 				(rating += 45, days > 3) ||
 				(rating += 35, true);
 			}
+			rs->days_since_pickup = ge->days_since_pickup;
+			rs->ratings[RATING_PICKUP] = rating - old_rating;
+			old_rating = rating;
 
+			byte_inc_sat(&ge->enroute_time);
+			byte_inc_sat(&ge->days_since_pickup);
+
+			waiting = ge->waiting_acceptance & MAX_CARGO_WAITING;
+			if (_patches.nsr_wait_cargo)
 			{
-				waiting = ge->waiting_acceptance & 0xFFF;
+				if (ge == &st->goods[CT_PASSENGERS])
+					points = waiting * 2;
+				else
+					points = waiting;
+				switch (lv_type) // scale points to RP_MAX_WAIT
+				{
+					case VEH_Train:		point_clamp = RP_WAIT_T_CLAMP;		break;
+					case VEH_Road:			point_clamp = RP_WAIT_R_CLAMP;		break;
+					case VEH_Ship:			point_clamp = RP_WAIT_S_CLAMP;		break;
+					case VEH_Aircraft:	point_clamp = RP_WAIT_A_CLAMP;		break;
+					default:					point_clamp = RP_MAX_WAIT;
+				}
+				points = clamp(points, 0, point_clamp) * RP_MAX_WAIT / point_clamp;
+				rating += RP_MAX_WAIT_POINTS - points;
+				switch (points) // give bonus for low waiting cargo
+				{ // uses scaled waiting
+					case 0: rating += RP_WAIT_BONUS_0;	break;
+					case 1: rating += RP_WAIT_BONUS_1;	break;
+					case 2: rating += RP_WAIT_BONUS_2;	break;
+					case 3: rating += RP_WAIT_BONUS_3;	break;
+					case 4: rating += RP_WAIT_BONUS_4;	break;
+					case 5: rating += RP_WAIT_BONUS_5;	break;
+				}
+			}
+			else
+			{
 				(rating -= 90, waiting > 1500) ||
 				(rating += 55, waiting > 1000) ||
 				(rating += 35, waiting > 600) ||
@@ -2579,9 +2736,13 @@
 				(rating += 20, waiting > 100) ||
 				(rating += 10, true);
 			}
+			rs->waiting = waiting;
+			rs->ratings[RATING_WAITING] = rating - old_rating;
+			old_rating = rating;
 
 			{
 				int or = ge->rating; // old rating
+				rs->ratings[RATING_TOTAL] = rating;
 
 				// only modify rating in steps of -2, -1, 0, 1 or 2
 				ge->rating = rating = or + clamp(clamp(rating, 0, 255) - or, -2, 2);
@@ -2604,9 +2765,10 @@
 				}
 
 				if (waiting_changed)
-					ge->waiting_acceptance = (ge->waiting_acceptance & ~0xFFF) + waiting;
+					ge->waiting_acceptance = (ge->waiting_acceptance & ~MAX_CARGO_WAITING) + waiting;
 			}
 		}
+		rs++;
 	} while (++ge != endof(st->goods));
 
 	index = st->index;
@@ -2615,6 +2777,8 @@
 		InvalidateWindow(WC_STATION_VIEW, index);
 	else
 		InvalidateWindowWidget(WC_STATION_VIEW, index, 5);
+
+	InvalidateWindow(WC_STATION_RATING_DETAIL, index);
 }
 
 /* called for every station each tick */
@@ -2656,12 +2820,55 @@
 
 }
 
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted)
+{
+	times_counted -= 1; // number of calculated averages till now is one less than actually counted times
+	if (times_counted == 0)
+		return lastamount;
+	average = (uint32)((uint64)(((uint64)average * (uint64)times_counted + (uint64)lastamount) / ((uint64)times_counted + 1)));
+	return average;
+}
+
 void StationMonthlyLoop(void)
 {
+	Station *st;
+	StationStats *sts;
+	GoodsEntry *ge;
+
+ 	FOR_ALL_STATIONS(st) {
+		if (st->months_counted != STS_NO_MONTHS_COUNTED)
+		{
+			for (ge = st->goods; ge != endof(st->goods); ge++) {
+				if (ge->months_counted != STS_NO_MONTHS_COUNTED) 
+				{
+					// set current months stats to 0 after storing value for last month
+					// do this for all stats (currently In/Out/Transfer)
+					// also determine new min/max-values
+					for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+						sts->month_min = min(sts->month_min, sts->this_month);
+						sts->month_max = max(sts->month_max, sts->this_month);
+						sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, ge->months_counted);
+						sts->last_month = sts->this_month;
+						sts->this_month = 0;
+					}
+					ge->months_counted++; // one more month counted
+				}
+			}
+			// update vehicle-counts and min/max
+			for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, st->months_counted);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			st->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, st->index);
+	}
 }
 
-
-void ModifyStationRatingAround(TileIndex tile, byte owner, int amount, uint radius)
+void ModifyStationRatingAround(TileIndex tile, PlayerID owner, int amount, uint radius)
 {
 	Station *st;
 	GoodsEntry *ge;
@@ -2689,6 +2896,7 @@
 	st->goods[type].enroute_time = 0;
 	st->goods[type].enroute_from = st->index;
 	InvalidateWindow(WC_STATION_VIEW, st->index);
+	InvalidateWindow(WC_STATION_STATS, st->index);
 }
 
 /** Rename a station
@@ -2867,7 +3075,7 @@
 	int j;
 
 	FOR_ALL_STATIONS(st) {
-		if (st->xy == 0) {
+		if (st->xy == INVALID_TILE || st->xy == 0) {
 			st->town = ClosestTownFromTile(tile, (uint)-1);
 			st->sign.width_1 = 0;
 			if (!GenerateStationName(st, tile, 2))
@@ -2881,7 +3089,7 @@
 			_m[tile].m2 = st->index;
 
 			st->owner = OWNER_NONE;
-      st->airport_flags = 0;
+			st->airport_flags = 0;
 			st->airport_type = AT_OILRIG;
 			st->xy = tile;
 			st->bus_stops = NULL;
@@ -2890,8 +3098,8 @@
 			st->dock_tile = tile;
 			st->train_tile = 0;
 			st->had_vehicle_of_type = 0;
-			st->time_since_load = 255;
-			st->time_since_unload = 255;
+			st->time_since_load = INVALID_TIME;
+			st->time_since_unload = INVALID_TIME;
 			st->delete_ctr = 0;
 			st->last_vehicle = INVALID_VEHICLE;
 			st->facilities = FACIL_AIRPORT | FACIL_DOCK;
@@ -2900,9 +3108,9 @@
 				st->goods[j].waiting_acceptance = 0;
 				st->goods[j].days_since_pickup = 0;
 				st->goods[j].enroute_from = INVALID_STATION;
-				st->goods[j].rating = 175;
+				st->goods[j].rating = RATING_START_VALUE;
 				st->goods[j].last_speed = 0;
-				st->goods[j].last_age = 255;
+				st->goods[j].last_age = INVALID_AGE;
 			}
 
 			UpdateStationVirtCoordDirty(st);
@@ -3078,12 +3286,23 @@
 	SLE_CONDREF(Station,bus_stops,					REF_ROADSTOPS, 6, 255),
 	SLE_CONDREF(Station,truck_stops,				REF_ROADSTOPS, 6, 255),
 
+	// station stats data
+//	SLE_CONDVAR(Station,months_counted,	SLE_UINT16, xx, 255),
+
 	// reserve extra space in savegame here. (currently 28 bytes)
 	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 32, 2, 255),
 
 	SLE_END()
 };
 
+// station stats data
+//	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,average,	SLE_UINT32, xx, 255),
+//	SLE_END()
+//};
+
 static const SaveLoad _goods_desc[] = {
 	SLE_VAR(GoodsEntry,waiting_acceptance,SLE_UINT16),
 	SLE_VAR(GoodsEntry,days_since_pickup,	SLE_UINT8),
@@ -3095,22 +3314,33 @@
 	SLE_VAR(GoodsEntry,last_age,					SLE_UINT8),
 	SLE_CONDVAR(GoodsEntry,feeder_profit,			SLE_INT32, 14, 255),
 
+	// station stats data
+//	SLE_CONDVAR(GoodsEntry,months_counted,	SLE_UINT16, xx, 255),
+
 	SLE_END()
 };
 
 
 static void SaveLoad_STNS(Station *st)
 {
-	int i;
+	int i; //, j;
 
 	SlObject(st, _station_desc);
 	for (i = 0; i != NUM_CARGO; i++) {
 		SlObject(&st->goods[i], _goods_desc);
+//		for (j = 0; j < STS_AMNT_TYPES; j++)
+//			SlObject(&st->goods[i].cargo_amount[j], _stats_desc);
 
+		// initialize new station rating values
+		st->goods[i].last_vehicle_speed = st->goods[i].last_speed;
+		st->goods[i].last_vehicle_type = INVALID_VEHICLE;
+
 		/* In older versions, enroute_from had 0xFF as INVALID_STATION, is now 0xFFFF */
-		if (_sl.full_version < 0x700 && st->goods[i].enroute_from == 0xFF)
-			st->goods[i].enroute_from = 0xFFFF;
+		if (_sl.full_version < 0x700 && st->goods[i].enroute_from == INVALID_STATION_OLD)
+			st->goods[i].enroute_from = INVALID_STATION;
 	}
+//	for (i = 0; i < STS_VEH_TYPES; i++) 
+//		SlObject(&st->vehicles[i], _stats_desc);
 }
 
 static void Save_STNS(void)
@@ -3118,7 +3348,7 @@
 	Station *st;
 	// Write the stations
 	FOR_ALL_STATIONS(st) {
-		if (st->xy != 0) {
+		if ( (st->xy != INVALID_TILE) && (st->xy != 0) ) {
 			SlSetArrayIndex(st->index);
 			SlAutolength((AutolengthProc*)SaveLoad_STNS, st);
 		}
@@ -3136,6 +3366,7 @@
 
 		st = GetStation(index);
 		SaveLoad_STNS(st);
+		InitializeStationStats(st);
 
 		// this means it's an oldstyle savegame without support for nonuniform stations
 		if (st->train_tile && st->trainst_h == 0) {
@@ -3202,3 +3433,108 @@
 	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY | CH_LAST},
 };
 
+void SearchVehiclesForStation(Station *st)
+{
+	Vehicle *v;
+	int i;
+	Order* ord;
+	
+	ord = NULL;
+	if (st->xy == INVALID_TILE || st->xy == 0) return;
+	for(i = 0; i < STS_VEH_TYPES; i++) st->veh_scheduled[i] = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ||       //Trains (first engine, that contains the orders)
+			( (v->type == VEH_Road) && (v->subtype == SUBTYPE_NONE) ) ||       //Road vehicles (subtype should always be 0 anyway)
+			( (v->type == VEH_Ship) && (v->subtype == SUBTYPE_NONE) ) ||       //Ships, subtype should be 0 anyway)
+			( (v->type == VEH_Aircraft) && (
+				(v->subtype == SUBTYPE_NONE) ||                            //Choppers
+				(v->subtype == SUBTYPE_AIRCRAFT) ) ) ) &&                               //Fixed-wing stuff
+			( (v->owner == st->owner) || (v->owner == _local_player) ) )	// station owner or current player for oilrigs
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == st->index && ord->type == OT_GOTO_STATION) {
+					switch (v->type) {
+						case VEH_Train:
+							st->veh_scheduled[STS_VEH_TRAIN]++;
+							break;
+						case VEH_Road:
+							st->veh_scheduled[STS_VEH_ROAD]++;
+							if (v->cargo_type == CT_PASSENGERS)
+								st->veh_scheduled[STS_VEH_BUS]++;
+							else
+								st->veh_scheduled[STS_VEH_TRUCK]++;
+							break;
+						case VEH_Ship:
+							st->veh_scheduled[STS_VEH_SHIP]++;
+							break;
+						case VEH_Aircraft:
+							st->veh_scheduled[STS_VEH_AIRCRAFT]++;
+							break;
+						default:
+							NOT_REACHED();
+					}
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	}
+}
+
+int32 CmdResetStationCheat(int NOT_USED_x, int NOT_USED_y, uint32 NOT_USED_flags, uint32 station, uint32 NOT_USED_p2)
+{
+	Station *st = GetStation(station);
+	GoodsEntry *ge;
+#ifndef _DEBUG
+	if (_networking) return CMD_ERROR;
+#endif
+
+	// Reset all goods at station
+	for(ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->last_speed = 0;
+		ge->waiting_acceptance = 0;
+		ge->days_since_pickup = 0;
+		ge->enroute_from = INVALID_STATION;
+		ge->enroute_time = 0;
+		ge->rating = RATING_START_VALUE;
+		ge->last_age = INVALID_AGE;
+		ge->feeder_profit = 0;
+	}
+	st->had_vehicle_of_type = 0;
+	st->time_since_load = INVALID_TIME;
+	st->time_since_unload = INVALID_TIME;
+	st->last_vehicle = INVALID_VEHICLE;
+
+	UpdateStationAcceptance(st, false);
+	return 0;
+}
+
+void InitializeStationStats(Station *st)
+{
+	StationStats *sts;
+	GoodsEntry *ge;
+
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->months_counted = STS_NO_MONTHS_COUNTED;
+		for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+			sts->average = 0;
+			sts->last_month = 0;
+			sts->month_max = 0;
+			sts->month_min = STS_INIT_MINIMUM;
+			sts->this_month = 0;
+		}
+	}
+	st->months_counted = STS_NO_MONTHS_COUNTED;
+	for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = STS_INIT_MINIMUM;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForStation(st);
+}
Index: engine.h
===================================================================
--- engine.h	(revision 2724)
+++ engine.h	(working copy)
@@ -271,4 +271,16 @@
 	return &_road_vehicle_info[e - ROAD_ENGINES_INDEX];
 }
 
+static inline CargoID GetGlobalCargoID(byte current_landscape, byte cargo_id)
+{
+	assert(current_landscape < NUM_LANDSCAPE && cargo_id < NUM_CARGO);
+	return _global_cargo_id[current_landscape][cargo_id];
+}
+
+static inline CargoID GetLocalCargoID(byte global_cargo_id)
+{
+	assert(global_cargo_id < NUM_GLOBAL_CID);
+	return _local_cargo_id_ctype[global_cargo_id];
+}
+
 #endif
Index: aircraft_cmd.c
===================================================================
--- aircraft_cmd.c	(revision 2724)
+++ aircraft_cmd.c	(working copy)
@@ -1266,6 +1266,13 @@
 		return;
 
 	st = GetStation(v->u.air.targetairport);
+	if ((v->subtype == SUBTYPE_NONE) || (v->subtype == SUBTYPE_AIRCRAFT))
+	{
+		st->vehicles[STS_VEH_AIRCRAFT].this_month++;
+		if (st->months_counted == STS_NO_MONTHS_COUNTED) st->months_counted = 1;
+	}
+	InvalidateWindow(WC_STATION_STATS, st->index);
+	
 	v->last_station_visited = v->u.air.targetairport;
 
 	/* Check if station was ever visited before */
Index: vehicle_gui.c
===================================================================
--- vehicle_gui.c	(revision 2724)
+++ vehicle_gui.c	(working copy)
@@ -16,6 +16,9 @@
 #include "gfx.h"
 #include "variables.h"
 #include "vehicle_gui.h"
+#include "station.h"
+#include "waypoint.h"
+#include "depot.h"
 
 Sorting _sorting;
 
@@ -63,6 +66,7 @@
 		switch (w->window_class) {
 		case WC_TRAINS_LIST: case WC_ROADVEH_LIST:
 		case WC_SHIPS_LIST:  case WC_AIRCRAFT_LIST:
+		case WC_VEHICLES_LIST:
 			WP(w, vehiclelist_d).flags |= VL_REBUILD;
 			SetWindowDirty(w);
 			break;
@@ -78,6 +82,7 @@
 		switch (w->window_class) {
 		case WC_TRAINS_LIST: case WC_ROADVEH_LIST:
 		case WC_SHIPS_LIST:  case WC_AIRCRAFT_LIST:
+		case WC_VEHICLES_LIST:
 			WP(w, vehiclelist_d).flags |= VL_RESORT;
 			SetWindowDirty(w);
 			break;
@@ -85,61 +90,6 @@
 		}
 }
 
-void BuildVehicleList(vehiclelist_d *vl, int type, int owner, int station)
-{
-	int subtype = (type != VEH_Aircraft) ? TS_Front_Engine : 2;
-	int n = 0;
-	int i;
-
-	if (!(vl->flags & VL_REBUILD)) return;
-
-	/* Create array for sorting */
-	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
-	if (_vehicle_sort == NULL)
-		error("Could not allocate memory for the vehicle-sorting-list");
-
-	DEBUG(misc, 1) ("Building vehicle list for player %d station %d...",
-		owner, station);
-
-	if (station != -1) {
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == type && v->subtype <= subtype) {
-				const Order *order;
-
-				FOR_VEHICLE_ORDERS(v, order) {
-					if (order->type == OT_GOTO_STATION && order->station == station) {
-						_vehicle_sort[n].index = v->index;
-						_vehicle_sort[n].owner = v->owner;
-						++n;
-						break;
-					}
-				}
-			}
-		}
-	} else {
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == type && v->subtype <= subtype && v->owner == owner) {
-				_vehicle_sort[n].index = v->index;
-				_vehicle_sort[n].owner = v->owner;
-				++n;
-			}
-		}
-	}
-
-	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
-	if (n!=0 && vl->sort_list == NULL)
-		error("Could not allocate memory for the vehicle-sorting-list");
-	vl->list_length = n;
-
-	for (i = 0; i < n; ++i)
-		vl->sort_list[i] = _vehicle_sort[i];
-
-	vl->flags &= ~VL_REBUILD;
-	vl->flags |= VL_RESORT;
-}
-
 void SortVehicleList(vehiclelist_d *vl)
 {
 	if (!(vl->flags & VL_RESORT)) return;
@@ -1065,3 +1015,104 @@
 {
 	memset(&_sorting, 0, sizeof(_sorting));
 }
+
+void BuildVehicleListMasked(vehiclelist_d *vl, DisplayListOption *listopt, int owner)
+{
+	const byte landscape = _opt.landscape;
+	int i, n = 0;
+	uint64 cmask;
+
+	if (!(vl->flags & VL_REBUILD)) return;
+
+	/* Create array for sorting */
+	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
+	if (_vehicle_sort == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+
+	DEBUG(misc, 1) ("Building vehicle list for player %d station at %d...",
+		owner, listopt->xy);
+	
+	if (listopt->xy != INVALID_TILE) {  // Build List for a station/waypoint/depot (other?)
+		const Vehicle *v;
+
+		assert(listopt->xy < MapSize()); // not really needed, you will get an empty list when xy is outside the mapbounds
+
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->type_mask, v->type)
+				&& ((v->subtype == TS_Front_Engine)
+					|| (v->type == VEH_Aircraft && v->subtype == SUBTYPE_AIRCRAFT))) {
+				if (listopt->cargo_mask == CARGO_MASK_ALL) {
+					cmask = CARGO_MASK_ALL;
+				} else {
+					const Vehicle *u = v;
+					cmask = 0;
+					for (u = v; u != NULL; u = u->next) { // check cargotypes of all vehicles of the consist (trains/aircraft)
+					// vehicles that cant carry any cargo may have cargotype 0 == CT_PASSENGERS,
+					// so we have to make sure we only get those that could really carry cargo
+					// think we should make them have INVALID_CARGO cargotype instead... (Asterix)
+						if (u->cargo_cap != 0)
+							cmask |= HASBIT(_landscape_global_cargo_mask[landscape], u->cargo_type);
+					}
+				}
+				if (listopt->cargo_mask & cmask) {
+					const Order *order;
+
+					FOR_VEHICLE_ORDERS(v, order) { // check if consist is scheduled for this map-position
+						if (order->type == OT_GOTO_STATION && GetStation(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						} else if (order->type == OT_GOTO_WAYPOINT && GetWaypoint(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						} else if (order->type == OT_GOTO_DEPOT && GetDepot(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						}
+					} // Vehicle Orders
+				}
+			}
+		} // All Vehicles
+	} else {
+		Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->type_mask, v->type) && (v->owner == owner)
+				&& ((v->subtype == TS_Front_Engine)
+					|| (v->type == VEH_Aircraft && v->subtype == SUBTYPE_AIRCRAFT))) {
+				if (listopt->cargo_mask == CARGO_MASK_ALL) {
+					_vehicle_sort[n].index = v->index;
+					_vehicle_sort[n].owner = v->owner;
+					++n;
+				} else {
+					Vehicle *u = v;
+					cmask = 0;
+					for (u = v; u != NULL; u = u->next) { // check cargotypes of all vehicles of the consist (trains/aircraft)
+						if (u->cargo_cap != 0)
+							cmask |= HASBIT(_landscape_global_cargo_mask[landscape], u->cargo_type);
+					}
+					if (listopt->cargo_mask & cmask) {
+						_vehicle_sort[n].index = v->index;
+						_vehicle_sort[n].owner = v->owner;
+						++n;
+					}
+				}
+			}
+		} // All Vehicles
+	}
+
+	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
+	if (n != 0 && vl->sort_list == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+	vl->list_length = n;
+
+	for (i = 0; i < n; ++i)
+		vl->sort_list[i] = _vehicle_sort[i];
+
+	vl->flags &= ~VL_REBUILD;
+	vl->flags |= VL_RESORT;
+}
Index: vehicle_gui.h
===================================================================
--- vehicle_gui.h	(revision 2724)
+++ vehicle_gui.h	(working copy)
@@ -4,6 +4,7 @@
 #define VEHICLE_GUI_H
 
 #include "vehicle.h"
+#include "window.h"
 
 struct vehiclelist_d;
 
@@ -15,7 +16,15 @@
 void RebuildVehicleLists(void);
 void ResortVehicleLists(void);
 
-void BuildVehicleList(struct vehiclelist_d *vl, int type, int owner, int station);
+/** builds a list of all vehicles that comply with the criteria given
+  *
+  * @param vl: the list to be build/rebuild
+  * @param listopt: struct with the listoptions
+  * @param owner: the owner of the vehicles that are added to the list
+  *
+  * @see DisplayListOption
+  */
+void BuildVehicleListMasked(struct vehiclelist_d *vl, DisplayListOption *listopt, int owner);
 void SortVehicleList(struct vehiclelist_d *vl);
 
 int CDECL GeneralOwnerSorter(const void *a, const void *b);
@@ -57,6 +66,7 @@
 	Listing roadveh;
 	Listing ship;
 	Listing train;
+	Listing masked;
 } Sorting;
 
 extern Sorting _sorting;
@@ -75,5 +85,9 @@
 void DrawAircraftPurchaseInfo(int x, int y, EngineID engine_number);
 void DrawShipPurchaseInfo(int x, int y, EngineID engine_number);
 
+void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection);
+void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection);
+void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection);
+void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection);
 
 #endif /* VEHICLE_GUI_H */
Index: misc_gui.c
===================================================================
--- misc_gui.c	(revision 2724)
+++ misc_gui.c	(working copy)
@@ -1706,14 +1706,15 @@
 	{CE_BOOL, 0, STR_CHEAT_SETUP_PROD,			&_cheats.setup_prod.value,			&_cheats.setup_prod.been_used,			NULL,											0, 0, 0},
 	{CE_UINT8, 0, STR_CHEAT_SWITCH_CLIMATE, &_opt.landscape, 								&_cheats.switch_climate.been_used,	&ClickChangeClimateCheat,-1, 4, 1},
 	{CE_UINT8, 0, STR_CHEAT_CHANGE_DATE,		&_cur_year,											&_cheats.change_date.been_used,			&ClickChangeDateCheat,	 -1, 1, 1},
+	{CE_BOOL, 0, STR_CHEAT_RESET_STATION,			&_cheats.reset_station.value,			&_cheats.reset_station.been_used,			&ClickResetStationCheat,											0, 0, 0},
 };
 
 
 static const Widget _cheat_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   399,     0,    13, STR_CHEATS,	STR_018C_WINDOW_TITLE_DRAG_THIS},
-{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_NULL},
-{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_CHEATS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_CHEATS_TIP},
 {   WIDGETS_END},
 };
 
@@ -1848,7 +1849,7 @@
 	}
 }
 static const WindowDesc _cheats_desc = {
-	240, 22, 400, 160,
+	240, 22, 400, 174,
 	WC_CHEATS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
 	_cheat_widgets,
Index: lang/english.txt
===================================================================
--- lang/english.txt	(revision 2724)
+++ lang/english.txt	(working copy)
@@ -1058,6 +1058,12 @@
 STR_CONFIG_PATCHES_QUERY_CAPT                                   :{WHITE}Change setting value
 STR_CONFIG_PATCHES_SERVICE_INTERVAL_INCOMPATIBLE                :{WHITE}Some or all of the default service interval(s) below are incompatible with the chosen setting! 5-90% and 30-800 days are valid
 
+STR_CONFIG_PATCHES_NSR_SPEED                                    :{LTBLUE}Enable new rating for Vehicle-Speed: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_AGE                                      :{LTBLUE}Enable new rating for Vehicle-Age: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_WAIT_DAYS                                :{LTBLUE}Enable new rating for days since last pickup: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_WAIT_CARGO                               :{LTBLUE}Enable new rating for Cargo/Passengers waiting: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_TOWN_RATING                              :{LTBLUE}Enable new rating for Local Authority Acceptance: {ORANGE}{STRING}
+
 STR_TEMPERATE_LANDSCAPE                                         :Temperate landscape
 STR_SUB_ARCTIC_LANDSCAPE                                        :Sub-arctic landscape
 STR_SUB_TROPICAL_LANDSCAPE                                      :Sub-tropical landscape
@@ -1075,6 +1081,7 @@
 STR_CHEAT_SWITCH_CLIMATE                                        :{LTBLUE}Switch climate: {ORANGE} {STRING}
 STR_CHEAT_CHANGE_DATE                                           :{LTBLUE}Change date: {ORANGE} {DATE_SHORT}
 STR_CHEAT_SETUP_PROD                                            :{LTBLUE}Enable modifying production values: {ORANGE}{STRING1}
+STR_CHEAT_RESET_STATION                                         :{LTBLUE}Enable Resetting of Stations: {ORANGE}{STRING}
 
 STR_HEADING_FOR_WAYPOINT                                        :{LTBLUE}Heading for {WAYPOINT}
 STR_HEADING_FOR_WAYPOINT_VEL                                    :{LTBLUE}Heading for {WAYPOINT}, {VELOCITY}
@@ -2706,6 +2713,51 @@
 STR_BUILD_DATE                                                  :{BLACK}Built: {LTBLUE}{DATE_LONG}
 STR_MULTIPLAYER_PAUSED                                          :{WHITE}Game is paused.{}Command cannot be executed
 
+STR_RESET_STATION                                               :{BLACK}* RESET *
+STR_RESET_STATION_TIP                                           :{BLACK}When pressing this button the Station is reset, as if it was newly built.
+STR_CAN_T_RESET_STATION                                         :{WHITE}Can't reset station...
+
+STR_STATION_STATS                                               :{BLACK}Statistics
+STR_STATION_GOODS_IN                                            :{BLACK}In
+STR_STATION_GOODS_OUT                                           :{BLACK}Out
+STR_STATION_GOODS_TRANSFER                                      :{BLACK}Transit
+STR_VEHICLES                                                    :{BLACK}Vehicles
+STR_SCHEDULED                                                   :{BLACK}Scheduled
+STR_VEHICLES_MONTH                                              :{BLACK}Last Month
+STR_VEHICLES_CURRENT                                            :{BLACK}Current Month
+STR_TRAINS                                                      :{BLACK}Trains
+STR_RVS                                                         :{BLACK}Road Vehicles
+STR_BUSSES                                                      :{BLACK}Buses
+STR_TRUCKS                                                      :{BLACK}Trucks
+STR_SHIPS                                                       :{BLACK}Ships
+STR_AIRCRAFT                                                    :{BLACK}Aircraft
+STR_NUMBER                                                      :{YELLOW}{COMMA}
+STR_STATION_MONTHS                                              :{BLACK}Cargo amount [This Month (Last Month) ]
+STR_CNUMBERS                                                    :{WHITE}{COMMA} {TINYFONT}{BLACK}({YELLOW}{COMMA}{BLACK})
+STR_VEHICLES_MONTHS_AVERAGE                                     :{BLACK}Average / Min / Max
+STR_MONTHS_COUNTED_NUM                                          :{BLACK}Months Counted: {GOLD}{COMMA}
+STR_MONTHS_TINY                                                 :{TINYFONT}{BLACK}Months
+STR_STATION_MONTHS_AVERAGE                                      :{BLACK}Cargo amount [Average (Min/Max) per Month]
+STR_TOGGLE_MINMAX                                               :{BLACK}Toggle  -This/Last Month-   or   -Average/Min/Max-   Stats
+STR_RESET_STATISTICS                                            :{BLACK}Reset Statistics
+STR_AVERAGENUMBERS                                              :{SILVER}{COMMA} {BLACK}{TINYFONT}({ORANGE}{COMMA}{BLACK}/{LTBLUE}{COMMA}{BLACK})
+STR_BLACK_SLASH                                                 :{BLACK}/
+STR_TINY_GOLD_NUMBER                                            :{TINYFONT}{GOLD}{COMMA}
+STR_SILVER_NUMBER                                               :{SILVER}{COMMA}
+STR_ORANGE_NUMBER                                               :{ORANGE}{COMMA}
+STR_LTBLUE_NUMBER                                               :{LTBLUE}{COMMA}
+STR_WHITE_NUMBER                                                :{WHITE}{COMMA}
+STR_STS_NOT_SCHEDULED                                           :{BLACK}Not Scheduled
+STR_AVERAGE                                                     :{BLACK}Average
+STR_MINIMUM                                                     :{BLACK}Minimum
+STR_MAXIMUM                                                     :{BLACK}Maximum
+STR_STS_VEHICLES_LAST_YEAR                                      :{BLACK}Last Year
+STR_STS_VEHICLES_THIS_YEAR                                      :{BLACK}This Year
+STR_STS_YEARS_COUNTED_NUM                                       :{BLACK}Years Counted: {GOLD}{COMMA}
+STR_STS_TOGGLE_MONTH_YEAR                                       :{BLACK}Toggle  -Monthly-   or   -Yearly-   Stats
+STR_STATION_COVERAGE                                            :{BLACK}Coverage
+STR_VEHICLE_CARGO_LIST                                          :{BLACK}Show List of Scheduled Vehicles for this Cargo-Type
+
 STR_PERFORMANCE_DETAIL                                          :{WHITE}Detailed performance rating
 STR_PERFORMANCE_DETAIL_KEY                                      :{BLACK}Detail
 STR_PERFORMANCE_DETAIL_AMOUNT_CURRENCY                          :{BLACK}({CURRCOMPACT}/{CURRCOMPACT})
@@ -2806,3 +2858,26 @@
 STR_PURCHASE_INFO_COST_SPEED                                    :{BLACK}Cost: {GOLD}{CURRENCY}{BLACK} Speed: {GOLD}{VELOCITY}
 STR_PURCHASE_INFO_AIRCRAFT_CAPACITY                             :{BLACK}Capacity: {GOLD}{COMMA} passengers, {COMMA} bags of mail
 STR_PURCHASE_INFO_PWAGPOWER_PWAGWEIGHT                          :{BLACK}Powered Wagons: {GOLD}+{COMMA}hp{BLACK} Weight: {GOLD}+{COMMA}t
+
+STR_STATION_RATING_DETAIL                                          :{WHITE}Detailed service ratings - {1:STATIONFEATURES}
+STR_STATION_RATING_DETAIL_KEY                                      :{BLACK}Detail
+STR_STATION_RATING_DETAIL_SCORES                                   :{BLACK}({NUM}/{NUM})
+STR_STATION_RATING_DETAIL_PERCENT                                  :{WHITE}{NUM}%
+STR_STATION_RATING_DETAIL_INT                                      :{BLACK}{NUM}
+STR_STATION_RATING_DETAIL_WAITING                                  :{BLACK}Waiting cargo:
+STR_STATION_RATING_DETAIL_WAITING_EX                               :{BLACK}{STRING}
+STR_STATION_RATING_DETAIL_SPEED                                    :{BLACK}Last speed:
+STR_STATION_RATING_DETAIL_SPEED_EX                                 :{BLACK}{NUM}
+STR_STATION_RATING_DETAIL_AGE                                      :{BLACK}Last age:
+STR_STATION_RATING_DETAIL_AGE_EX                                   :{BLACK}{COMMA} year(s)
+STR_STATION_RATING_DETAIL_PICKUP                                   :{BLACK}Days since pickup:
+STR_STATION_RATING_DETAIL_PICKUP_EX                                :{BLACK}{COMMA} day(s)
+STR_STATION_RATING_DETAIL_OTHER                                    :{BLACK}Other ratings:
+STR_STATION_RATING_DETAIL_TOTAL                                    :{BLACK}Total rating:
+STR_STATION_RATING_DETAIL_SPEED_TIP                                :{BLACK}Maximum speed of the last vehicle entering the station (internal value, clipped at 255)
+STR_STATION_RATING_DETAIL_AGE_TIP                                  :{BLACK}Age of the last vehicle entering the station
+STR_STATION_RATING_DETAIL_PICKUP_TIP                               :{BLACK}Number of days since the last cargo pickup
+STR_STATION_RATING_DETAIL_WAITING_TIP                              :{BLACK}Cargo waiting at the station
+STR_STATION_RATING_DETAIL_OTHER_TIP                                :{BLACK}Other ratings are mainly if the town of the station has a statue of the company owner
+STR_STATION_RATING_DETAIL_TOTAL_TIP                                :{BLACK}Total rating - The station rating is updated according to this value in small increments
+STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP                         :{BLACK}Click here to toggle cargo type
Index: variables.h
===================================================================
--- variables.h	(revision 2724)
+++ variables.h	(working copy)
@@ -214,6 +214,12 @@
  	uint32 npf_crossing_penalty; /* The penalty for level crossings */
 
 	bool population_in_label; // Show the population of a town in his label?
+
+	bool nsr_speed;			// new station rating: vehicle speed
+	bool nsr_age;			// new station rating: vehicle age
+	bool nsr_wait_days;		// new station rating: days since last pickup
+	bool nsr_wait_cargo;	// new station rating: amount of cargo waiting
+	bool nsr_town_rating;	// new station rating: include local authority rating
 } Patches;
 
 VARDEF Patches _patches;
@@ -239,6 +245,7 @@
 	Cheat switch_climate;
 	Cheat change_date;				//changes date ingame
 	Cheat setup_prod;				//setup raw-material production in game
+	Cheat reset_station;		// allow resetting of Stations
 } Cheats;
 
 VARDEF Cheats _cheats;
@@ -333,6 +340,8 @@
 
 VARDEF char _ini_videodriver[16], _ini_musicdriver[16], _ini_sounddriver[16];
 
+VARDEF bool _show_average_stats; // show Average Stats for Station-Stats?
+
 // debug features
 VARDEF char _savedump_path[64];
 VARDEF uint _savedump_first, _savedump_freq, _savedump_last;
Index: roadveh_cmd.c
===================================================================
--- roadveh_cmd.c	(revision 2724)
+++ roadveh_cmd.c	(working copy)
@@ -796,6 +796,14 @@
 
 static void RoadVehArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_ROAD].this_month++;
+	if (st->months_counted == STS_NO_MONTHS_COUNTED) st->months_counted = 1;
+	if (v->cargo_type == CT_PASSENGERS)
+		st->vehicles[STS_VEH_BUS].this_month++;
+	else
+		st->vehicles[STS_VEH_TRUCK].this_month++;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	if (v->engine_type < 123) {
 		/* Check if station was ever visited before */
 		if (!(st->had_vehicle_of_type & HVOT_BUS)) {
Index: openttd.h
===================================================================
--- openttd.h	(revision 2724)
+++ openttd.h	(working copy)
@@ -77,6 +77,9 @@
 typedef uint16 EngineID; //! All enginenumbers should be of this type
 typedef uint16 UnitID;   //! All unitnumber stuff is of this type (or anyway, should be)
 
+typedef uint64 CargoMask;
+typedef uint32 TypeMask;
+
 typedef uint32 WindowNumber;
 typedef byte WindowClass;
 
@@ -270,7 +273,7 @@
 
 	NUM_CARGO = 12,
 
-	CT_INVALID = 0xFF
+	CT_INVALID = 0xFF,
 };
 
 typedef uint AcceptedCargo[NUM_CARGO];
@@ -446,6 +449,10 @@
 	WC_HIGHSCORE = 0x4D,
 	WC_ENDSCREEN = 0x4E,
 	WC_SIGN_LIST = 0x4F,
+	WC_STATION_STATS = 0x50,
+	WC_WAYPOINT_STATS = 0x51,
+	WC_STATION_RATING_DETAIL = 0x52,
+	WC_VEHICLES_LIST = 0x53
 };
 
 
Index: station_gui.c
===================================================================
--- station_gui.c	(revision 2724)
+++ station_gui.c	(working copy)
@@ -15,7 +15,11 @@
 #include "command.h"
 #include "variables.h"
 #include "vehicle_gui.h"
+#include "engine.h"
+#include "depot.h"
 
+extern int _traininfo_vehicle_pitch;
+
 static void StationsWndShowStationRating(int x, int y, int type, uint acceptance, int rating)
 {
 	static const byte _rating_colors[NUM_CARGO] = {152,32,15,174,208,194,191,55,184,10,191,48};
@@ -287,9 +291,35 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   210,   221, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   129,   192,   210,   221, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   210,   221, STR_STATION_COVERAGE,	STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_expanded_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,	STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,	STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,	STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,	STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,   197, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   198,   209, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   198,   209, STR_3033_ACCEPTS,	STR_3056_SHOW_LIST_OF_ACCEPTED_CARGO},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   198,   209, STR_0130_RENAME,	STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,   198,   209, STR_TRAIN,	STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY,	STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE,	STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP,	STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   210,   221, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   210,   221, STR_RESET_STATION,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   210,   221, STR_STATION_COVERAGE,	STR_NULL},
+{   WIDGETS_END},
+};
+
 static const Widget _station_view_widgets[] = {
 {    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -305,9 +335,35 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   110,   121, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   129,   192,   110,   121, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   110,   121, STR_STATION_COVERAGE,	STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,	STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,	STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,	STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,	STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,    97, 0x0,	STR_NULL},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,    98,   109, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,    98,   109, STR_3032_RATINGS,	STR_3054_SHOW_STATION_RATINGS},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,    98,   109, STR_0130_RENAME,	STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,    98,   109, STR_TRAIN,	STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY,	STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE,	STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP,	STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   110,   121, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   110,   121, STR_RESET_STATION,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   110,   121, STR_STATION_COVERAGE,	STR_NULL},
+{   WIDGETS_END},
+};
+
 static void DrawStationViewWindow(Window *w)
 {
 	Station *st;
@@ -324,7 +380,7 @@
 
 	num = 1;
 	for(i=0; i!=NUM_CARGO; i++) {
-		if ((st->goods[i].waiting_acceptance & 0xFFF) != 0) {
+		if ((st->goods[i].waiting_acceptance & MAX_CARGO_WAITING) != 0) {
 			num++;
 			if (st->goods[i].enroute_from != station_id)
 				num++;
@@ -332,7 +388,11 @@
 	}
 	SetVScrollCount(w, num);
 
-	w->disabled_state = st->owner == _local_player ? 0 : (1 << 9);
+	// 9 = Rename Station, 16 = Reset station
+	if (_cheats.reset_station.value)
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 16);
+	else
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9);
 
 	if (!(st->facilities & FACIL_TRAIN)) SETBIT(w->disabled_state,  10);
 	if (!(st->facilities & FACIL_TRUCK_STOP) &&
@@ -351,7 +411,7 @@
 	if (--pos < 0) {
 		str = STR_00D0_NOTHING;
 		for(i=0; i!=NUM_CARGO; i++)
-			if (st->goods[i].waiting_acceptance & 0xFFF)
+			if (st->goods[i].waiting_acceptance & MAX_CARGO_WAITING)
 				str = STR_EMPTY;
 		SetDParam(0, str);
 		DrawString(x, y, STR_0008_WAITING, 0);
@@ -360,7 +420,7 @@
 
 	i = 0;
 	do {
-		uint waiting = (st->goods[i].waiting_acceptance & 0xFFF);
+		uint waiting = (st->goods[i].waiting_acceptance & MAX_CARGO_WAITING);
 		if (waiting == 0)
 			continue;
 
@@ -398,7 +458,8 @@
 		}
 	} while (pos > -5 && ++i != 12);
 
-	if (IsWindowOfPrototype(w, _station_view_widgets)) {
+	if (IsWindowOfPrototype(w, _station_view_widgets) ||
+		IsWindowOfPrototype(w, _station_view_cheat_widgets) ) {
 		char *b = _userstring;
 
 		b = InlineString(b, STR_000C_ACCEPTS);
@@ -437,7 +498,36 @@
 	}
 }
 
+int32 ClickResetStationCheat(int32 cheat_activated, int32 NOT_USED)
+{ // switch all open station-view-windows to new widget-set when cheat toggled
+	Window *w;
 
+	for (w = _windows; w != _last_window; ++w) {
+		if (w->window_class == WC_STATION_VIEW) {
+			/* toggle height/widget set */
+			SetWindowDirty(w);
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (cheat_activated != 0) { // Reset button enabled?
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+				} else {
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+				}
+				w->height = ST_VIEW_EXP_HEIGHT;
+			} else {
+				if (cheat_activated != 0) { // Reset button enabled?
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+				} else {
+					AssignWidgetToWindow(w, _station_view_widgets);
+				}
+				w->height = ST_VIEW_HEIGHT;
+			}
+			SetWindowDirty(w);
+		}
+	}
+	return 0;
+}
+
 static void StationViewWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -447,42 +537,46 @@
 
 	case WE_CLICK:
 		switch(e->click.widget) {
-		case 7:
+		case 7: { // go to Location of station
 			ScrollMainWindowToTile(GetStation(w->window_number)->xy);
 			break;
-
-		case 8:
+		}
+		case 8: { // toggle rating/acceptance
 			SetWindowDirty(w);
 
 			/* toggle height/widget set */
-			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)) {
-				AssignWidgetToWindow(w, _station_view_widgets);
-				w->height = 110;
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_widgets);
+				w->height = ST_VIEW_HEIGHT;
 			} else {
-				AssignWidgetToWindow(w, _station_view_expanded_widgets);
-				w->height = 210;
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+				w->height = ST_VIEW_EXP_HEIGHT;
 			}
 
 			SetWindowDirty(w);
 			break;
-
-		case 9: {
+		}
+		case 9: { // Rename Station
 			SetDParam(0, w->window_number);
 			ShowQueryString(STR_STATION, STR_3030_RENAME_STATION_LOADING, 31, 180, w->window_class, w->window_number);
 		} break;
-
 		case 10: { /* Show a list of scheduled trains to this station */
 			const Station *st = GetStation(w->window_number);
 			ShowPlayerTrains(st->owner, w->window_number);
 			break;
 		}
-
 		case 11: { /* Show a list of scheduled road-vehicles to this station */
 			const Station *st = GetStation(w->window_number);
 			ShowPlayerRoadVehicles(st->owner, w->window_number);
 			break;
 		}
-
 		case 12: { /* Show a list of scheduled aircraft to this station */
 			const Station *st = GetStation(w->window_number);
 			/* Since oilrigs have no owners, show the scheduled aircraft of current player */
@@ -490,7 +584,6 @@
 			ShowPlayerAircraft(owner, w->window_number);
 			break;
 		}
-
 		case 13: { /* Show a list of scheduled ships to this station */
 			const Station *st = GetStation(w->window_number);
 			/* Since oilrigs/bouys have no owners, show the scheduled ships of current player */
@@ -498,9 +591,30 @@
 			ShowPlayerShips(owner, w->window_number);
 			break;
 		}
+		case 14: { // Show Statistics for Station
+			ShowStationStatsWindow(w->window_number);
+			break;
 		}
+		case 15: { // Show Details for Station Rating
+			const Station *st = GetStation(w->window_number);
+			ShowStationRatingDetail(st->index);
+			break;
+		}
+		case 16: { // Reset Station
+			Station *st = GetStation(w->window_number);
+			if (_cheats.reset_station.value) {
+				DoCommandP(st->xy, w->window_number, 0, NULL,
+					CMD_RESET_STATION_CHEAT | CMD_MSG(STR_CAN_T_RESET_STATION));
+				SetWindowDirty(w);
+			}
+			InitializeStationStats(st);
+			break;
+ 		}
+		case 17: { //ToDo: show station coverage
+			break;
+		}
+		} // end of switch(e->click.widget)
 		break;
-
 	case WE_ON_EDIT_TEXT: {
 		if (e->edittext.str[0] != '\0') {
 			Station* st = GetStation(w->window_number);
@@ -515,34 +629,784 @@
 		WindowNumber wno =
 			(w->window_number << 16) | GetStation(w->window_number)->owner;
 
+		// Destroy vehicle-windows related to this window, too
 		DeleteWindowById(WC_TRAINS_LIST, wno);
 		DeleteWindowById(WC_ROADVEH_LIST, wno);
 		DeleteWindowById(WC_SHIPS_LIST, wno);
 		DeleteWindowById(WC_AIRCRAFT_LIST, wno);
+		DeleteWindowById(WC_STATION_STATS, w->window_number);
 		break;
 	}
 	}
 }
 
-
 static const WindowDesc _station_view_desc = {
-	-1, -1, 249, 110,
+	-1, -1, 249, ST_VIEW_HEIGHT,
 	WC_STATION_VIEW,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
 	_station_view_widgets,
 	StationViewWndProc
 };
 
-void ShowStationViewWindow(int station)
+// alternate widget-set if reset-station-cheat is enabled
+static const WindowDesc _station_view_cheat_desc = {
+	-1, -1, 249, ST_VIEW_HEIGHT,
+	WC_STATION_VIEW,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_view_cheat_widgets,
+	StationViewWndProc
+};
+
+void ShowStationViewWindow(StationID station)
 {
 	Window *w;
 	byte color;
 
-	w = AllocateWindowDescFront(&_station_view_desc, station);
+	if (_cheats.reset_station.value)
+		w = AllocateWindowDescFront(&_station_view_cheat_desc, station);
+	else
+		w = AllocateWindowDescFront(&_station_view_desc, station);
 	if (w) {
 		color = GetStation(w->window_number)->owner;
+		if (color != OWNER_NONE)
+			w->caption_color = color;
+		w->vscroll.cap = 5;
+	}
+}
+
+void StationStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _station_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   398,     0,    13, STR_300A_0, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   399,   410,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    91,   410,    14,    25, STR_TOGGLE_MINMAX, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,    26,    37, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    38,    49, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    50,    61, STR_RVS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    62,    73, STR_BUSSES, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    74,    85, STR_TRUCKS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    85,    97, STR_SHIPS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    98,   109, STR_AIRCRAFT, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    91,   410,    38,   109, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,   110,   135, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   398,   136,   191, 0x0,0x0},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   399,   410,   136,   191, 0x0, STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WIDGETS_END},
+};
+
+WindowDesc _station_view_stats = {
+	-1, -1, 411, 192,
+	WC_STATION_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_stats_widgets,
+	StationStatsWndProc
+};
+
+void DrawStationStatWindow(Window *w, Station *st)
+{
+	int i, y, numcargo = 0, pos;
+	GoodsEntry *ge;
+	
+	// count number of goods at station (months_counted will be 0 if good not delivered/picked up)
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		if (ge->months_counted != STS_NO_MONTHS_COUNTED) numcargo++;
+	}
+	SetVScrollCount(w, numcargo);
+		
+	//Get the Station name
+	SetDParam(0, st->index);
+	
+	//and the little carrier type images
+	SetDParam(1, st->facilities);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawStringCentered(45, 28, STR_VEHICLES, 0);
+
+	//Part 1:       Find the number of carriers on the station
+	y = 27;
+	if (_show_average_stats) {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(275, y, STR_VEHICLES_MONTHS_AVERAGE, 0);
+		SetDParam(0, max(st->months_counted - 1,0));
+		DrawStringRightAligned(405, y, STR_MONTHS_COUNTED_NUM, 0);
+	} else {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(295, y, STR_VEHICLES_MONTH, 0);
+		DrawStringRightAligned(395, y, STR_VEHICLES_CURRENT, 0);	
+	}
+
+	y = 38;
+	for (i = 0; i < STS_VEH_TYPES; i++) {
+		if (w->custom[i] != 0) {
+			SetDParam(0, w->custom[i]);
+			DrawStringRightAligned(150, y+i*12, STR_NUMBER, 0);
+			CLRBIT(w->disabled_state, i+7);
+		} else {
+			SETBIT(w->disabled_state, i+7);
+		}
+		if (_show_average_stats) {
+			if (st->vehicles[i].average != 0 || st->vehicles[i].month_max !=0) {
+				SetDParam(0, st->vehicles[i].average / AVERAGE_MULTIPLIER);
+				DrawStringRightAligned(235, y+i*12, STR_SILVER_NUMBER, 0);
+				DrawStringRightAligned(245, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_min);
+				DrawStringRightAligned(290, y+i*12, STR_ORANGE_NUMBER, 0);
+				DrawStringRightAligned(300, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_max);
+				DrawStringRightAligned(350, y+i*12, STR_LTBLUE_NUMBER, 0);
+			}
+		} else {
+			if (st->vehicles[i].last_month != 0) {
+				SetDParam(0, st->vehicles[i].last_month);
+				DrawStringRightAligned(295, y+i*12, STR_NUMBER, 0);
+			}
+			if (st->vehicles[i].this_month) {
+				SetDParam(0, st->vehicles[i].this_month);
+				DrawStringRightAligned(395, y+i*12, STR_WHITE_NUMBER, 0);
+			}
+		}
+	}
+	
+	y = 124;
+	if (_show_average_stats) {
+		DrawString(5, y-10, STR_STATION_MONTHS_AVERAGE, 0);
+		DrawStringRightAligned(100, y+2, STR_MONTHS_TINY, 0);
+	} else {
+		DrawString(5, y-10, STR_STATION_MONTHS, 0);
+	}
+	DrawStringRightAligned(200, y, STR_STATION_GOODS_IN, 0);
+	DrawStringRightAligned(305, y, STR_STATION_GOODS_OUT, 0);
+	DrawStringRightAligned(395, y, STR_STATION_GOODS_TRANSFER, 0);
+	
+	y += 5;
+	pos = w->vscroll.pos;
+	for (i = 0; i < NUM_CARGO; i++) {
+		ge = &st->goods[i];
+		if (ge->months_counted != 0 && ((--pos < 0) && (pos >= -4)) )
+		{
+			StationStats *sts = ge->cargo_amount;
+			//Print the cargo name
+			y += 12;
+			SetDParam(0, _cargoc.names_s[i]);
+			DrawString(3, y, STR_02BD, 0);
+			if (_show_average_stats) {
+				SetDParam(0, ge->months_counted - 1);
+				DrawStringRightAligned(100, y, STR_TINY_GOLD_NUMBER, 0);
+				if (sts[STS_AMOUNT_IN].average != 0 || sts[STS_AMOUNT_IN].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_IN].month_min);
+					SetDParam(2, sts[STS_AMOUNT_IN].month_max);
+					DrawStringRightAligned(200, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].average != 0 || sts[STS_AMOUNT_OUT].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_OUT].month_min);
+					SetDParam(2, sts[STS_AMOUNT_OUT].month_max);
+					DrawStringRightAligned(305, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].average != 0 || sts[STS_AMOUNT_TRANSFER].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].month_min);
+					SetDParam(2, sts[STS_AMOUNT_TRANSFER].month_max);
+					DrawStringRightAligned(395, y, STR_AVERAGENUMBERS, 0);
+				}
+			} else {
+				if (sts[STS_AMOUNT_IN].this_month != 0 || sts[STS_AMOUNT_IN].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].this_month);
+					SetDParam(1, sts[STS_AMOUNT_IN].last_month);
+					DrawStringRightAligned(200, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].this_month != 0 || sts[STS_AMOUNT_OUT].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].this_month);
+					SetDParam(1, sts[STS_AMOUNT_OUT].last_month);
+					DrawStringRightAligned(305, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].this_month != 0 || sts[STS_AMOUNT_TRANSFER].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].this_month);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].last_month);
+					DrawStringRightAligned(395, y, STR_CNUMBERS, 0);
+				}
+			}
+		}
+	}
+}
+
+void StationStatsWndProc(Window *w, WindowEvent *e)
+{
+	Station *st = GetStation(w->window_number);
+	switch(e->event)
+	{
+	case WE_TICK: {
+//		static int counter = 0;
+//		if (++counter % 40) return;
+		int i;
+		
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+		InvalidateWindow(WC_STATION_STATS, w->window_number);
+		break;
+	}
+	case WE_PAINT: {
+		DrawStationStatWindow(w, st);
+		break;
+		}
+	case WE_CLICK: {
+		switch (e->click.widget)
+		{
+			case 4:			// Reset Statistics
+				if (st->owner == _current_player) {
+					InitializeStationStats(st);
+					InvalidateWindow(WC_STATION_STATS, w->window_number);
+				}
+				break;
+			case 5:			// Toggle Average and This Month
+				_show_average_stats ^= 1;
+				InvalidateWindow(WC_STATION_STATS, w->window_number);
+				break;
+			case 7:			//Trains
+				ShowPlayerTrains(st->owner, st->index);
+				break;
+			case 8: 		//Road Vehicles
+				ShowPlayerRoadVehicles(st->owner, st->index);
+				break;
+			case 9:			// Buses
+				ShowPlayerVehicles(st->owner, st->index, 1 << VEH_Road, 1 << GC_PASSENGERS, st->xy);
+				break;
+			case 10:		// Trucks
+				ShowPlayerVehicles(st->owner, st->index, 1 << VEH_Road, CARGO_MASK_ALL &~(1 << GC_PASSENGERS), st->xy);
+				break;
+			case 11: 		//Ships
+				ShowPlayerShips(st->owner, st->index);
+				break;
+			case 12: 		//Aircraft
+				ShowPlayerAircraft(st->owner, st->index);
+				break;
+		}
+	} break;
+	case WE_DESTROY: {
+//		DeleteWindowById(WC_TRAINS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_ROADVEH_LIST, st->owner + ( (st->index + 1) << 8) + 64 + 128);
+//		DeleteWindowById(WC_SHIPS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_AIRCRAFT_LIST, st->owner + ( (st->index + 1) << 8));
+	} break;
+	}
+}
+
+void ShowStationStatsWindow(StationID station)
+{
+	Window *w;
+	byte color;
+
+	Station *st = GetStation(station);
+
+	w = AllocateWindowDescFront(&_station_view_stats, st->index);
+	if (w) {
+		int i;
+		color = st->owner;
 		if (color != 0x10)
 			w->caption_color = color;
+		w->vscroll.cap = 4;
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+	}
+}
+
+static void StationRatingDetailWndProc(Window *w, WindowEvent *e)
+{
+	// String IDs to display
+	static const uint16 rating_str[] = {
+		STR_STATION_RATING_DETAIL_WAITING,
+		STR_STATION_RATING_DETAIL_SPEED,
+		STR_STATION_RATING_DETAIL_AGE,
+		STR_STATION_RATING_DETAIL_PICKUP,
+		STR_STATION_RATING_DETAIL_OTHER,
+		STR_STATION_RATING_DETAIL_TOTAL
+	};
+	// More string IDs to display
+	static const uint16 rating_str_ex[] = {
+		STR_STATION_RATING_DETAIL_WAITING_EX,
+		STR_STATION_RATING_DETAIL_SPEED_EX,
+		STR_STATION_RATING_DETAIL_AGE_EX,
+		STR_STATION_RATING_DETAIL_PICKUP_EX,
+		STR_NULL,
+		STR_NULL
+	};
+	static const int rating_max_score[] = {40, 42, 33, 130, 26, 255};
+
+	switch(e->event) {
+	case WE_PAINT: {
+		int i, x, cur_x, val;
+		byte cargo;
+		uint16 y = 16;
+		int color_done, color_notdone;
+		int max_score;
+		Station *st = GetStation(w->window_number);
+		RatingStats *rs;
+
+		// Disable cargo types that don't have ratings and click first cargo
+		w->disabled_state = 0;
+		for (i=0; i!=NUM_CARGO; i++) {
+			if(st->goods[i].enroute_from == INVALID_STATION) {
+				SETBIT(w->disabled_state, i + 9);
+				CLRBIT(w->click_state, i + 9);
+			} else if(w->click_state == 0) {
+				SETBIT(w->click_state, i + 9);
+			}
+		}
+		if(w->click_state == 0)
+			SETBIT(w->disabled_state, 21);
+
+		// Draw standard stuff
+		SetDParam(0, st->index);
+		SetDParam(1, st->facilities);
+		DrawWindowWidgets(w);
+
+		// Paint the cargo icons
+		cur_x = 9;
+		for (i = 0; i != NUM_CARGO; i++) {
+			if(st->goods[i].enroute_from != INVALID_STATION)
+				DrawSprite(_cargoc.sprites[i], cur_x, y);
+			cur_x += 28;
+		}
+
+		// The colors used to show how the progress is going
+		color_done = _color_list[6].window_color_1b;
+		color_notdone = _color_list[4].window_color_1b;
+
+		// No cargo type selected
+		if(w->click_state == 0)
+			break;
+
+		// The type of cargo of which we check the detail service rating
+		cargo = FindFirstBit(w->click_state) - 9;
+		
+		if (cargo < NUM_CARGO) 
+			w->listopt.cargo_mask = 1 << GetGlobalCargoID(_opt_ptr->landscape, cargo);
+		else
+			w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = VEHICLE_TYPE_ALL;
+		w->listopt.xy = st->xy;
+
+		rs = &st->rating_stats[cargo];
+
+		y += 18;
+
+		for(i=0; i<NUM_RATINGS; i++) {
+			DrawString(7, y, rating_str[i], 0);
+
+			// Draw the raw values
+			switch(i) {
+				case RATING_WAITING:
+					SetDParam(1, rs->waiting);
+					SetDParam(0, _cargoc.names_long[cargo]);
+					break;
+				case RATING_SPEED:
+					SetDParam(0, rs->last_speed);
+					break;
+				case RATING_AGE:
+					SetDParam(0, rs->last_age);
+					break;
+				case RATING_PICKUP:
+					SetDParam(0, rs->days_since_pickup);
+					break;
+				default:
+					break;
+			}
+
+			if(rating_str_ex[i] != STR_NULL)
+				DrawStringRightAligned(205, y, rating_str_ex[i], 0);
+
+			// Calculate the %-bar
+			val = rs->ratings[i];
+
+			max_score = rating_max_score[i];
+			if (val > max_score) x = 50;
+			else if (val <= 0) x = 0;
+			else x = ((val * 50) / max_score);
+
+			// Draw the bar
+			if (x != 0)
+				GfxFillRect(210, y-2, x + 210, y+10, color_done);
+			if (x != 50)
+				GfxFillRect(x + 210, y-2, 50 + 210, y+10, color_notdone);
+
+			// Calculate the %
+			if (val > max_score) x = 100;
+			else x = ((val * 100) / max_score);
+
+			// Draw it
+			SetDParam(0, x);
+			DrawStringCentered(235, y, STR_STATION_RATING_DETAIL_PERCENT, 0);
+
+			// Draw the score and max_score
+			SetDParam(0, val);
+			SetDParam(1, max_score);
+			DrawString(265, y, STR_STATION_RATING_DETAIL_SCORES, 0);
+
+			y += 20;
+		}
+
+		break;
+	}
+
+	case WE_CLICK:
+		// Check which button is clicked
+		if (IS_INT_INSIDE(e->click.widget, 9, 21)) {
+			// Is it no on disable?
+			if ((w->disabled_state & (1 << e->click.widget)) == 0) {
+				Station *st = GetStation(w->window_number);
+				Window *w2 = FindWindowById(WC_VEHICLES_LIST, (st->index << 16) | st->owner);
+				vehiclelist_d *vl;
+				w->click_state = 1 << e->click.widget;
+				w->listopt.cargo_mask = 1 << GetGlobalCargoID(_opt_ptr->landscape, FindFirstBit(w->click_state) - 9);
+				SetWindowDirty(w);
+				if (w2) {
+					vl = &WP(w2, vehiclelist_d);
+					vl->flags |= VL_REBUILD;
+					w2->listopt.cargo_mask = w->listopt.cargo_mask;
+					SetWindowDirty(w2);
+				}
+			}
+		} else if (e->click.widget == 21) {
+			Station *st = GetStation(w->window_number);
+			ShowPlayerVehicles(st->owner, st->index, w->listopt.type_mask, w->listopt.cargo_mask, w->listopt.xy);
+			w->click_state = 1 << (GetLocalCargoID(FindFirstBit(w->listopt.cargo_mask)) + 9);
+			SetWindowDirty(w);
+		}
+		break;
+
+	case WE_CREATE:
+		{
+			w->hidden_state = 0;
+			w->disabled_state = 0;
+			w->click_state = 0;
+
+			SetWindowDirty(w);
+		}
+		break;
+	}
+}
+
+static const Widget _station_rating_detail_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   325,     0,    13, STR_STATION_RATING_DETAIL,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   326,   337,     0,    13, 0x0, STR_STICKY_BUTTON},
+
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    28,    47, 0x0,STR_STATION_RATING_DETAIL_WAITING_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    48,    67, 0x0,STR_STATION_RATING_DETAIL_SPEED_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    68,    87, 0x0,STR_STATION_RATING_DETAIL_AGE_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    88,   107, 0x0,STR_STATION_RATING_DETAIL_PICKUP_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,   108,   127, 0x0,STR_STATION_RATING_DETAIL_OTHER_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,   128,   147, 0x0,STR_STATION_RATING_DETAIL_TOTAL_TIP},
+
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     1,    28,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    29,    56,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    57,    84,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    85,   112,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   113,   140,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   141,   168,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   169,   196,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   197,   224,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   225,   252,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   253,   280,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   281,   308,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   309,   336,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   336,    148,   160, STR_VEHICLE_CARGO_LIST, 0x0},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _station_rating_detail_desc = {
+	-1, -1, 338, 161,
+	WC_STATION_RATING_DETAIL,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_rating_detail_widgets,
+	StationRatingDetailWndProc
+};
+
+void ShowStationRatingDetail(StationID station)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_station_rating_detail_desc, station);
+	if (w) {
+		color = GetStation(w->window_number)->owner;
+		if (color != 0x10)
+			w->caption_color = color;
 		w->vscroll.cap = 5;
 	}
 }
+
+static void PlayerVehiclesWndProc(Window *w, WindowEvent *e)
+{
+	int station = (int)w->window_number >> 16;
+	int owner = w->window_number & 0xff;
+	vehiclelist_d *vl = &WP(w, vehiclelist_d);
+
+	switch(e->event) {
+	case WE_PAINT: {
+		int x = 2;
+		int y = PLY_WND_PRC__OFFSET_TOP_WIDGET;
+		int max;
+		int i;
+
+		BuildVehicleListMasked(vl, &w->listopt, owner);
+		SortVehicleList(vl);
+
+		SetVScrollCount(w, vl->list_length);
+		// disable 'Sort By' tooltip on Unsorted sorting criteria
+		if (vl->sort_type == SORT_BY_UNSORTED)
+			w->disabled_state |= (1 << 3);
+
+		/* draw the widgets */
+		{
+			const Player *p = GetPlayer((owner != OWNER_NONE) ? owner : _current_player);
+			if (station == -1) {
+				/* Company Name -- (###) Trains */
+				SetDParam(0, p->name_1);
+				SetDParam(1, p->name_2);
+				SetDParam(2, w->vscroll.count);
+				w->widget[1].unkA = STR_VEHICLES;
+			} else {
+				/* Station Name -- (###) Trains */
+				SetDParam(0, station);
+				SetDParam(1, w->vscroll.count);
+				w->widget[1].unkA = STR_SCHEDULED;
+			}
+			DrawWindowWidgets(w);
+		}
+		/* draw sorting criteria string */
+		DrawString(85, 15, _vehicle_sort_listing[vl->sort_type], 0x10);
+		/* draw arrow pointing up/down for ascending/descending sorting */
+		DoDrawString(vl->flags & VL_DESC ? "\xAA" : "\xA0", 69, 15, 0x10);
+
+		max = min(w->vscroll.pos + w->vscroll.cap, vl->list_length);
+		for (i = w->vscroll.pos; i < max; ++i) {
+			Vehicle *v = GetVehicle(vl->sort_list[i].index);
+			StringID str;
+
+			assert(v->owner == owner || v->owner == _current_player);
+
+			switch (v->type) {
+				case VEH_Train:
+				{
+					DrawTrainImage(
+						v, x + 21, y + 6 + _traininfo_vehicle_pitch, w->hscroll.cap, 0, INVALID_VEHICLE);
+
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_RAIL) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_TRAIN_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 21, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Road:
+				{
+					DrawRoadVehImage(v, x + 22, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_ROAD) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_ROADVEH_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 24, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Aircraft:
+				{
+					DrawAircraftImage(v, x + 19, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsAircraftHangarTile(v->tile) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_AIRCRAFT_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 19, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Ship:
+				{
+					DrawShipImage(v, x + 19, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_WATER) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_SHIP_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 12, y, STR_01AB, 0);
+					}
+					break;
+				}
+				default:
+					continue;
+			}
+			DrawVehicleProfitButton(v, x, y + 13);
+			SetDParam(0, v->profit_this_year);
+			SetDParam(1, v->profit_last_year);
+			DrawString(x + 21, y + 18, STR_0198_PROFIT_THIS_YEAR_LAST_YEAR, 0);
+
+			y += PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		}
+		break;
+	}
+
+	case WE_CLICK: {
+		switch(e->click.widget) {
+		case 3: /* Flip sorting method ascending/descending */
+			vl->flags ^= VL_DESC;
+			vl->flags |= VL_RESORT;
+			_sorting.masked.order = !!(vl->flags & VL_DESC);
+			SetWindowDirty(w);
+			break;
+
+		case 4: case 5:/* Select sorting criteria dropdown menu */
+			ShowDropDownMenu(w, _vehicle_sort_listing, vl->sort_type, 5, 0, 0);
+			return;
+
+		case 7: { /* Matrix to show vehicles */
+			uint32 id_v = (e->click.pt.y - PLY_WND_PRC__OFFSET_TOP_WIDGET) / PLY_WND_PRC__SIZE_OF_ROW_BIG;
+
+			if (id_v >= w->vscroll.cap) { return;} // click out of bounds
+
+			id_v += w->vscroll.pos;
+			{
+				Vehicle *v;
+				if (id_v >= vl->list_length) return; // click out of list bound
+				v = GetVehicle(vl->sort_list[id_v].index);
+
+				assert(v->owner == owner);
+				
+				switch (v->type)
+				{
+				case VEH_Train:
+					ShowTrainViewWindow(v);
+					break;
+				case VEH_Ship:
+					ShowShipViewWindow(v);
+					break;
+				case VEH_Road:
+					ShowRoadVehViewWindow(v);
+					break;
+				case VEH_Aircraft:
+					ShowAircraftViewWindow(v);
+					break;
+				}
+			}
+		} break;
+		}
+	}	break;
+
+	case WE_DROPDOWN_SELECT: /* we have selected a dropdown item in the list */
+		if (vl->sort_type != e->dropdown.index) {
+			// value has changed -> resort
+			vl->flags |= VL_RESORT;
+			vl->sort_type = e->dropdown.index;
+			_sorting.masked.criteria = vl->sort_type;
+
+			// enable 'Sort By' if a sorter criteria is chosen
+			if (vl->sort_type != SORT_BY_UNSORTED)
+				CLRBIT(w->disabled_state, 3);
+		}
+		SetWindowDirty(w);
+		break;
+
+	case WE_CREATE: /* set up resort timer */
+		vl->sort_list = NULL;
+		vl->flags = VL_REBUILD | (_sorting.train.order << (VL_DESC - 1));
+		vl->sort_type = _sorting.masked.criteria;
+		vl->resort_timer = DAY_TICKS * PERIODIC_RESORT_DAYS;
+		break;
+
+	case WE_DESTROY:
+		free(vl->sort_list);
+		break;
+
+	case WE_TICK: /* resort the list every 20 seconds orso (10 days) */
+		if (--vl->resort_timer == 0) {
+			DEBUG(misc, 1) ("Periodic resort trains list player %d station %d",
+				owner, station);
+			vl->resort_timer = DAY_TICKS * PERIODIC_RESORT_DAYS;
+			vl->flags |= VL_RESORT;
+			SetWindowDirty(w);
+		}
+		break;
+
+	case WE_RESIZE:
+		/* Update the scroll + matrix */
+		w->hscroll.cap += e->sizing.diff.x / 29;
+		w->vscroll.cap += e->sizing.diff.y / PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		break;
+	}
+}
+
+static const Widget _player_vehicles_widgets[] = {
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,							STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,  RESIZE_RIGHT,    14,    11,   312,     0,    13, STR_VEHICLES,				STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,     RESIZE_LR,    14,   313,   324,     0,    13, 0x0,										STR_STICKY_BUTTON},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    80,    14,    25, SRT_SORT_BY,						STR_SORT_ORDER_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,    81,   232,    14,    25, 0x0,										STR_SORT_CRITERIA_TIP},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   233,   243,    14,    25, STR_0225,							STR_SORT_CRITERIA_TIP},
+{      WWT_PANEL,  RESIZE_RIGHT,    14,   244,   324,    14,    25, 0x0,										STR_NULL},
+{     WWT_MATRIX,     RESIZE_RB,    14,     0,   312,    26,   207, 0x701,									STR_883D_TRAINS_CLICK_ON_TRAIN_FOR},
+{  WWT_SCROLLBAR,    RESIZE_LRB,    14,   313,   324,    26,   207, 0x0,										STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_PANEL,    RESIZE_RTB,    14,     0,   312,   208,   219, 0x0,										STR_NULL},
+{  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   313,   324,   208,   219, 0x0,										STR_RESIZE_BUTTON},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _player_vehicles_desc = {
+	-1, -1, 325, 220,
+	WC_VEHICLES_LIST,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE,
+	_player_vehicles_widgets,
+	PlayerVehiclesWndProc
+};
+
+void ShowPlayerVehicles(PlayerID player, StationID station, TypeMask type_mask, CargoMask cargo_mask, TileIndex xy)
+{
+	Window *w;
+
+	w = AllocateWindowDescFront(&_player_vehicles_desc, (station << 16) | player);
+	if (w) {
+		w->listopt.cargo_mask = cargo_mask;
+		w->listopt.type_mask = type_mask;
+		w->listopt.xy = xy;
+
+		w->caption_color = (player != OWNER_NONE) ? player : _current_player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 5; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_BIG * 3); /* Minimum of 4 vehicles */
+	} else {
+		w = FindWindowById(WC_VEHICLES_LIST, (station << 16) | player);
+		if (w) {
+			vehiclelist_d *vl;
+			vl = &WP(w, vehiclelist_d);
+			vl->flags |= VL_REBUILD;
+			w->listopt.cargo_mask = cargo_mask;
+			w->listopt.type_mask = type_mask;
+			w->listopt.xy = xy;
+			SetWindowDirty(w);
+		}
+	}
+}
Index: aircraft_gui.c
===================================================================
--- aircraft_gui.c	(revision 2724)
+++ aircraft_gui.c	(working copy)
@@ -61,7 +61,7 @@
 	y += 10;
 }
 
-static void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetAircraftImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -927,7 +927,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Aircraft, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1123,6 +1123,13 @@
 	}
 
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Aircraft;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = w->window_number;
 		w->vscroll.cap = 4;
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 2724)
+++ train_cmd.c	(working copy)
@@ -2333,6 +2333,9 @@
 			v->index,
 			0);
 	}
+	if (v->subtype == TS_Front_Engine) st->vehicles[STS_VEH_TRAIN].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
 
 	// Did we reach the final destination?
 	if (v->current_order.type == OT_GOTO_STATION &&
@@ -2821,8 +2824,20 @@
 					assert(v->u.rail.track);
 				}
 
-				if (v->subtype == TS_Front_Engine)
-				TrainMovedChangeSignals(gp.new_tile, enterdir);
+				if (v->subtype == TS_Front_Engine) {
+					TrainMovedChangeSignals(gp.new_tile, enterdir);
+					if (v->current_order.type == OT_GOTO_WAYPOINT && v->tile == v->dest_tile) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[WPS_ORDER_MONTH].this_month++;
+						wp->vehicles[WPS_ORDER_YEAR].this_month++;
+					} else if (IsRailWaypoint(_m[v->tile].m5)) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[WPS_PATHFIND_MONTH].this_month++;
+						wp->vehicles[WPS_PATHFIND_YEAR].this_month++;
+					}
+				}	
 
 				/* Signals can only change when the first
 				 * (above) or the last vehicle moves. */
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 2724)
+++ rail_cmd.c	(working copy)
@@ -2165,8 +2165,7 @@
 	if (IsTileDepotType(tile, TRANSPORT_RAIL))
 		ShowTrainDepotWindow(tile);
 	else if (IsRailWaypoint(_m[tile].m5))
-		ShowRenameWaypointWindow(GetWaypointByTile(tile));
-
+		ShowWaypointStatsWindow(GetWaypointByTile(tile));
 }
 
 static void GetTileDesc_Track(TileIndex tile, TileDesc *td)
Index: vehicle.h
===================================================================
--- vehicle.h	(revision 2724)
+++ vehicle.h	(working copy)
@@ -147,7 +147,7 @@
 
 struct Vehicle {
 	byte type;	// type, ie roadven,train,ship,aircraft,special
-	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)(Filled with values from EffectVehicles or TrainSubTypes)
+	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)
 
 	VehicleID index;	// NOSAVE: Index in vehicle array
 
Index: misc.c
===================================================================
--- misc.c	(revision 2724)
+++ misc.c	(working copy)
@@ -468,6 +468,7 @@
 void TownsMonthlyLoop(void);
 void IndustryMonthlyLoop(void);
 void StationMonthlyLoop(void);
+void WaypointMonthlyLoop(void);
 
 void PlayersYearlyLoop(void);
 void TrainsYearlyLoop(void);
@@ -550,6 +551,7 @@
 		TownsMonthlyLoop();
 		IndustryMonthlyLoop();
 		StationMonthlyLoop();
+		WaypointMonthlyLoop();
 #ifdef ENABLE_NETWORK
 		if (_network_server)
 			NetworkServerMonthlyLoop();
Index: economy.c
===================================================================
--- economy.c	(revision 2724)
+++ economy.c	(working copy)
@@ -1353,6 +1353,9 @@
 				unloading_time += v->cargo_count; /* TTDBUG: bug in original TTD */
 				profit += DeliverGoods(v->cargo_count, v->cargo_type, v->cargo_source, last_visited, v->cargo_days);
 				result |= 1;
+				ge->cargo_amount[STS_AMOUNT_IN].this_month += v->cargo_count;
+				if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 				v->cargo_count = 0;
 			} else if (u->current_order.flags & ( OF_UNLOAD | OF_TRANSFER) ) {
 				/* unload goods and let it wait at the station */
@@ -1366,6 +1369,9 @@
 
 				v_profit_total += v_profit;
 
+				ge->cargo_amount[STS_AMOUNT_TRANSFER].this_month += v->cargo_count;
+				if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 
 				unloading_time += v->cargo_count;
 				if ((t=ge->waiting_acceptance & 0xFFF) == 0) {
@@ -1396,14 +1402,21 @@
 
 		/* update stats */
 		ge->days_since_pickup = 0;
+		ge->last_vehicle_type = u->type;
+
+		// TODO: use max-speed of whole consist for trains
 		t = u->max_speed;
 		if (u->type == VEH_Road) t >>=1;
 		if (u->type == VEH_Train) t = u->u.rail.cached_max_speed;
 
+		
+		ge->last_vehicle_speed = t;
 		// if last speed is 0, we treat that as if no vehicle has ever visited the station.
 		ge->last_speed = t < 255 ? t : 255;
+		// TODO: use age of oldest wagon of this type
 		ge->last_age = _cur_year - v->build_year;
 
+
 		// If there's goods waiting at the station, and the vehicle
 		//  has capacity for it, load it on the vehicle.
 		if ((count=ge->waiting_acceptance & 0xFFF) != 0 &&
@@ -1434,6 +1447,11 @@
 			ge->waiting_acceptance -= cap;
 			v->profit_this_year -= feeder_profit_share;
 			ge->feeder_profit -= feeder_profit_share;
+
+			ge->cargo_amount[STS_AMOUNT_OUT].this_month += cap;
+			if (ge->months_counted == 0) ge->months_counted = 1;
+			InvalidateWindow(WC_STATION_STATS, st->index);
+
 			unloading_time += cap;
 			st->time_since_load = 0;
 
Index: ship_cmd.c
===================================================================
--- ship_cmd.c	(revision 2724)
+++ ship_cmd.c	(working copy)
@@ -446,6 +446,10 @@
 
 static void ShipArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_SHIP].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	/* Check if station was ever visited before */
 	if (!(st->had_vehicle_of_type & HVOT_SHIP)) {
 		uint32 flags;
Index: main_gui.c
===================================================================
--- main_gui.c	(revision 2724)
+++ main_gui.c	(working copy)
@@ -24,6 +24,7 @@
 #include "signs.h"
 #include "waypoint.h"
 #include "variables.h"
+#include "station.h"
 
 #include "network_data.h"
 #include "network_client.h"
@@ -308,22 +309,22 @@
 
 static void MenuClickShowTrains(int index)
 {
-	ShowPlayerTrains(index, -1);
+	ShowPlayerTrains(index, INVALID_STATION);
 }
 
 static void MenuClickShowRoad(int index)
 {
-	ShowPlayerRoadVehicles(index, -1);
+	ShowPlayerRoadVehicles(index, INVALID_STATION);
 }
 
 static void MenuClickShowShips(int index)
 {
-	ShowPlayerShips(index, -1);
+	ShowPlayerShips(index, INVALID_STATION);
 }
 
 static void MenuClickShowAir(int index)
 {
-	ShowPlayerAircraft(index, -1);
+	ShowPlayerAircraft(index, INVALID_STATION);
 }
 
 static void MenuClickBuildRail(int index)
@@ -1895,10 +1896,10 @@
 		case WKC_F10:ShowOperatingProfitGraph(); break;
 		case WKC_F11: ShowCompanyLeagueTable(); break;
 		case WKC_F12: ShowBuildIndustryWindow(); break;
-		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, -1); break;
-		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, -1); break;
-		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, -1); break;
-		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, -1); break;
+		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, INVALID_STATION); break;
 		case WKC_SHIFT | WKC_F5: ToolbarZoomInClick(w); break;
 		case WKC_SHIFT | WKC_F6: ToolbarZoomOutClick(w); break;
 		case WKC_SHIFT | WKC_F7: ShowBuildRailToolbar(_last_built_railtype,-1); break;
Index: roadveh_gui.c
===================================================================
--- roadveh_gui.c	(revision 2724)
+++ roadveh_gui.c	(working copy)
@@ -61,7 +61,7 @@
 	y += 10;
 }
 
-static void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetRoadVehImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -806,7 +806,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Road, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -998,6 +998,13 @@
 		w = AllocateWindowDescFront(&_other_player_roadveh_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Road;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = player;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: order_cmd.c
===================================================================
--- order_cmd.c	(revision 2724)
+++ order_cmd.c	(working copy)
@@ -351,6 +351,25 @@
 			/* Increase amount of orders */
 			u->num_orders++;
 
+			// count vehicles scheduled for station
+			if (new_order.type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(new_order.station)->veh_scheduled++;
+			} else {
+				Station *st = GetStation(new_order.station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]++;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]++;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]++;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]++;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]++;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]++;
+						break;
+				}
+			}
+
 			/* If the orderlist was empty, assign it */
 			if (u->orders == NULL) u->orders = v->orders;
 
@@ -432,12 +451,25 @@
 			GetVehicleOrder(v, sel_ord - 1)->next = order->next;
 		}
 
-		/* Give the item free */
-		order->type = OT_NOTHING;
-		order->next = NULL;
-
 		u = GetFirstVehicleFromSharedList(v);
 		while (u != NULL) {
+			if (order->type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(order->station)->veh_scheduled--;
+			} else {
+				Station *st = GetStation(order->station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]--;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]--;
+						break;
+				}
+			}
 			u->num_orders--;
 
 			if (sel_ord < u->cur_order_index)
@@ -462,6 +494,10 @@
 			u = u->next_shared;
 		}
 
+		/* Give the item free */
+		order->type = OT_NOTHING;
+		order->next = NULL;
+
 		RebuildVehicleLists();
 	}
 
@@ -1036,6 +1072,24 @@
 
 	order = NULL;
 	while (cur != NULL) {
+		// decrease vehicles scheduled for station
+		if (cur->type == OT_GOTO_WAYPOINT) {
+			GetWaypoint(cur->station)->veh_scheduled--;
+		} else {
+			Station *st = GetStation(cur->station);
+			switch (v->type)
+			{
+				case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+				case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+				case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+				case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+					if (v->cargo_type == CT_PASSENGERS)
+						st->veh_scheduled[STS_VEH_BUS]--;
+					else
+						st->veh_scheduled[STS_VEH_TRUCK]--;
+					break;
+			}
+		}
 		if (order != NULL) {
 			order->type = OT_NOTHING;
 			order->next = NULL;
Index: settings.c
===================================================================
--- settings.c	(revision 2724)
+++ settings.c	(working copy)
@@ -859,6 +859,11 @@
 	{"full_load_any",				SDT_BOOL,		(void*)true,	&_patches.full_load_any,				NULL},
 	{"modified_catchment", 	SDT_BOOL,		(void*)true,	&_patches.modified_catchment,		NULL},
 
+	{"nsr_speed",	SDT_BOOL,	(void*)true,	&_patches.nsr_speed,	NULL},
+	{"nsr_age",	SDT_BOOL,	(void*)true,	&_patches.nsr_age,	NULL},
+	{"nsr_wait_days",	SDT_BOOL,	(void*)true,	&_patches.nsr_wait_days,	NULL},
+	{"nsr_wait_cargo",	SDT_BOOL,	(void*)true,	&_patches.nsr_wait_cargo,	NULL},
+	{"nsr_town_rating",	SDT_BOOL,	(void*)true,	&_patches.nsr_town_rating,	NULL},
 
 	{"inflation",						SDT_BOOL,		(void*)true,	&_patches.inflation,						NULL},
 	{"selectgoods",					SDT_BOOL,		(void*)true,	&_patches.selectgoods,					NULL},
Index: waypoint.c
===================================================================
--- waypoint.c	(revision 2724)
+++ waypoint.c	(working copy)
@@ -17,6 +17,7 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 #include "table/track_land.h"
+#include "gui.h"
 
 enum {
 	/* Max waypoints: 64000 (8 * 8000) */
@@ -46,7 +47,7 @@
 	Waypoint *wp;
 
 	FOR_ALL_WAYPOINTS(wp) {
-		if (wp->xy == 0) {
+		if (wp->xy == INVALID_TILE || wp->xy == 0) {
 			uint index = wp->index;
 
 			memset(wp, 0, sizeof(Waypoint));
@@ -139,7 +140,7 @@
 	uint thres = 8, cur_dist;
 
 	FOR_ALL_WAYPOINTS(wp) {
-		if (wp->deleted && wp->xy) {
+		if (wp->deleted > 0 && wp->xy != INVALID_TILE) {
 			cur_dist = DistanceManhattan(tile, wp->xy);
 			if (cur_dist < thres) {
 				thres = cur_dist;
@@ -208,6 +209,7 @@
 		wp->deleted = 0;
 		wp->xy = tile;
 		wp->build_date = _date;
+		InitializeWaypointStats(wp);
 
 		if (wp->town_index == STR_NULL)
 			MakeDefaultWaypointName(wp);
@@ -224,7 +226,7 @@
 {
 	Order order;
 
-	wp->xy = 0;
+	wp->xy = INVALID_TILE;
 
 	order.type = OT_GOTO_WAYPOINT;
 	order.station = wp->index;
@@ -418,7 +420,7 @@
 
 	/* Convert the old 'town_or_string', to 'string' / 'town' / 'town_cn' */
 	FOR_ALL_WAYPOINTS(wp) {
-		if (wp->xy == 0)
+		if (wp->xy == INVALID_TILE)
 			continue;
 
 		wp->town_index = ClosestTownFromTile(wp->xy, (uint)-1)->index;
@@ -447,18 +449,36 @@
 	SLE_CONDVAR(Waypoint, build_date, SLE_UINT16, 3, 255),
 	SLE_CONDVAR(Waypoint, stat_id, SLE_UINT8, 3, 255),
 
+//	save waypoint stats... change xx to savegame-revision
+//	SLE_CONDVAR(Waypoint,months_counted,	SLE_UINT16, xx, 255),
+
 	SLE_END()
 };
 
+//	save waypoint stats... change xx to savegame-revision
+//static const SaveLoad _stats_desc[] = {
+//	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, xx, 255),
+//	SLE_CONDVAR(StationStats,average,	SLE_UINT32, xx, 255),
+//	SLE_END()
+//};
+
 static void Save_WAYP(void)
 {
 	Waypoint *wp;
+//	int i;
 
 	FOR_ALL_WAYPOINTS(wp) {
 		if (wp->xy != 0) {
 			SlSetArrayIndex(wp->index);
 			SlObject(wp, _waypoint_desc);
 		}
+// save waypoint stats
+//		for (i = 0; i < STS_VEH_TYPES; i++) 
+//			SlObject(&wp->vehicles[i], _stats_desc);
+
 	}
 }
 
@@ -474,9 +494,227 @@
 
 		wp = GetWaypoint(index);
 		SlObject(wp, _waypoint_desc);
+		InitializeWaypointStats(wp);
 	}
 }
 
 const ChunkHandler _waypoint_chunk_handlers[] = {
 	{ 'CHKP', Save_WAYP, Load_WAYP, CH_ARRAY | CH_LAST},
 };
+
+void WaypointMonthlyLoop(void)
+{
+	Waypoint *wp;
+	StationStats *sts;
+	int i;
+
+ 	FOR_ALL_WAYPOINTS(wp) {
+		if (wp->months_counted != STS_NO_MONTHS_COUNTED)
+		{
+			// update vehicle-counts and min/max
+			for (i = WPS_MONTHLY_STATS_START; i < WPS_MONTHLY_STATS_END; i++) {
+				sts = &wp->vehicles[i];
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, wp->months_counted);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			if (wp->months_counted == (wp->months_counted / 12) * 12)
+			{ // do this once a year to have yearly stats
+				for (i = WPS_YEARLY_STATS_START; i < WPS_YEARLY_STATS_END; i++) {
+					sts = &wp->vehicles[i];
+					sts->month_min = min(sts->month_min, sts->this_month);
+					sts->month_max = max(sts->month_max, sts->this_month);
+					sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, wp->months_counted / 12);
+					sts->last_month = sts->this_month;
+					sts->this_month = 0;
+				}
+			}
+			wp->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, wp->index);
+	}
+}
+
+void SearchVehiclesForWaypoint(Waypoint *wp)
+{
+	Vehicle *v;
+	Order* ord = NULL;
+
+	if (wp->xy == INVALID_TILE || wp->xy == 0) return;
+	wp->veh_scheduled = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (v->owner == GetTileOwner(wp->xy)) &&
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ) //Trains (first engine, that contains the orders)
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == wp->index && ord->type == OT_GOTO_WAYPOINT) {
+					wp->veh_scheduled++;
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	} 
+}
+
+void InitializeWaypointStats(Waypoint *wp)
+{
+	StationStats *sts;
+
+	wp->months_counted = STS_NO_MONTHS_COUNTED;
+	for (sts = wp->vehicles; sts != endof(wp->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = STS_INIT_MINIMUM;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForWaypoint(wp);
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _waypoint_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   288,     0,    13, STR_WAYPOINT_VIEWPORT, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   289,   300,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   150,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   151,   300,    14,    25, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   300,    26,    37, STR_STS_TOGGLE_MONTH_YEAR, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   300,    38,   140, 0x0, 0x0},
+{      WIDGETS_END},
+};
+
+WindowDesc _waypoint_view_stats = {
+	-1, -1, 301, 141,
+	WC_WAYPOINT_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_waypoint_stats_widgets,
+	WaypointStatsWndProc
+};
+
+void DrawWaypointStatWindow(Window *w, Waypoint *wp)
+{
+	int i, j;
+	enum {
+		STAT_LINE_START = 40,
+		STAT_LINE_PREVIOUS = 60,
+		STAT_LINE_THIS = 72,
+		STAT_LINE_AVERAGE = 90,
+		STAT_LINE_MIN = 102,
+		STAT_LINE_MAX = 114,
+		STAT_LINE_COUNTED = 130,
+		STAT_COLUMN_TEXT = 10,
+		STAT_COLUMN_SCHEDULED = 170,
+		STAT_COLUMN_NOT_SCHEDULED = 290,
+		COL_DIF = STAT_COLUMN_NOT_SCHEDULED - STAT_COLUMN_SCHEDULED,
+	};
+
+	//Get the Station name
+	SetDParam(0, wp->index);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_START,	STR_SCHEDULED, 0);
+	if (w->listopt.type_mask == STS_SHOW_YEARLY_STATS) {
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_PREVIOUS,	STR_STS_VEHICLES_LAST_YEAR, 0);
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_THIS,	STR_STS_VEHICLES_THIS_YEAR, 0);
+		SetDParam(0, max((wp->months_counted - 1) / 12 ,0));
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_COUNTED,	STR_STS_YEARS_COUNTED_NUM, 0);
+	} else {
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_PREVIOUS,	STR_VEHICLES_MONTH, 0);
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_THIS,	STR_VEHICLES_CURRENT, 0);
+		SetDParam(0, max(wp->months_counted - 1,0));
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_COUNTED,	STR_MONTHS_COUNTED_NUM, 0);
+	}
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_AVERAGE,	STR_AVERAGE, 0);
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_MIN,	STR_MINIMUM, 0);
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_MAX,	STR_MAXIMUM, 0);
+
+	SetDParam(0, wp->veh_scheduled);
+	DrawStringRightAligned(STAT_COLUMN_SCHEDULED, STAT_LINE_START, STR_NUMBER, 0);
+	DrawStringRightAligned(STAT_COLUMN_NOT_SCHEDULED, STAT_LINE_START, STR_STS_NOT_SCHEDULED, 0);
+	if (wp->veh_scheduled != 0) {
+		CLRBIT(w->disabled_state, 5);
+	} else {
+		SETBIT(w->disabled_state, 5);
+	}
+
+	j = (w->listopt.type_mask == STS_SHOW_YEARLY_STATS) ? WPS_YEARLY_STATS_START : WPS_MONTHLY_STATS_START;
+	for (i = 0; i < WPS_STATS_TYPES / 2; i++)
+	{
+		SetDParam(0, wp->vehicles[i+j].last_month);
+		DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_PREVIOUS, STR_NUMBER, 0);
+		SetDParam(0, wp->vehicles[i+j].this_month);
+		DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_THIS, STR_WHITE_NUMBER, 0);
+
+		if (wp->months_counted > ((w->listopt.type_mask == STS_SHOW_YEARLY_STATS) ? 12 : 1)) {
+			SetDParam(0, wp->vehicles[i+j].average / AVERAGE_MULTIPLIER);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_AVERAGE, STR_SILVER_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_min);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_MIN, STR_ORANGE_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_max);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_MAX, STR_LTBLUE_NUMBER, 0);
+		}
+	}
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e)
+{
+	Waypoint *wp = GetWaypoint(w->window_number);
+	switch(e->event)
+	{
+		case WE_TICK: {
+			w->custom[0] = wp->veh_scheduled;
+			InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+			break;
+		}
+		case WE_PAINT: {
+			DrawWaypointStatWindow(w, wp);
+			break;
+			}
+		case WE_CLICK: {
+			switch (e->click.widget)
+			{
+			case 4:	// Reset Statistics
+				if (GetTileOwner(wp->xy) == _current_player) {
+					InitializeWaypointStats(wp);
+					InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+				}
+				break;
+			case 5:	// Show Trains
+				ShowWaypointTrains(GetTileOwner(wp->xy), wp->index);
+				break;
+			case 6:	// Toggle Monthly/Yearly Stats
+				if (w->listopt.type_mask == STS_SHOW_YEARLY_STATS)
+					w->listopt.type_mask = STS_SHOW_MONTHLY_STATS;
+				else
+					w->listopt.type_mask = STS_SHOW_YEARLY_STATS;
+				InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+				break;
+			}
+		} break;
+		case WE_DESTROY: {
+			DeleteWindowById(WC_TRAINS_LIST, GetTileOwner(wp->xy) + ( (wp->index + 1) << 8));
+		} break;
+	}
+}
+
+void ShowWaypointStatsWindow(Waypoint *wp)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_waypoint_view_stats, wp->index);
+	if (w) {
+		color = GetTileOwner(wp->xy);
+		w->listopt.type_mask = STS_SHOW_MONTHLY_STATS;
+		if (color != OWNER_NONE) w->caption_color = color;
+	}
+}
Index: waypoint.h
===================================================================
--- waypoint.h	(revision 2724)
+++ waypoint.h	(working copy)
@@ -4,7 +4,23 @@
 #define WAYPOINT_H
 
 #include "pool.h"
+#include "station.h"
 
+enum {
+	WPS_STATS_TYPES = 4,
+
+	WPS_MONTHLY_STATS_START = 0,
+	WPS_MONTHLY_STATS_END = 2,
+
+	WPS_YEARLY_STATS_START = 2,
+	WPS_YEARLY_STATS_END = 4,
+
+	WPS_ORDER_MONTH = 0, // reached WP by order
+	WPS_PATHFIND_MONTH = 1, // reached WP by normal pathfinding
+	WPS_ORDER_YEAR = 2, // yearly stats by order
+	WPS_PATHFIND_YEAR =3 , // yearly stats by pathfinding
+};
+
 struct Waypoint {
 	TileIndex xy;
 	uint16 index;
@@ -13,12 +29,20 @@
 	byte town_cn;          // The Nth waypoint for this town (consecutive number)
 	StringID string;       // If this is zero, town + town_cn is used for naming
 
+	StationStats vehicles[WPS_STATS_TYPES];
+	uint16 veh_scheduled;
+	uint16 months_counted;
+
 	ViewportSign sign;
 	uint16 build_date;
 	byte stat_id;
 	byte deleted;          // this is a delete counter. when it reaches 0, the waypoint struct is deleted.
 };
 
+void InitializeWaypointStats(Waypoint *wp);
+void ShowWaypointStatsWindow(Waypoint *wp);
+void ShowWaypointTrains(int player, int waypoint);
+
 enum {
 	RAIL_TYPE_WAYPOINT = 0xC4,
 	RAIL_WAYPOINT_TRACK_MASK = 1,
Index: train_gui.c
===================================================================
--- train_gui.c	(revision 2724)
+++ train_gui.c	(working copy)
@@ -18,6 +18,7 @@
 #include "engine.h"
 #include "vehicle_gui.h"
 #include "depot.h"
+#include "waypoint.h"
 
 int _traininfo_vehicle_pitch = 0;
 
@@ -330,7 +331,7 @@
 	}
 }
 
-static void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection)
+void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection)
 {
 	int max_x = x + count * 29;
 
@@ -1287,7 +1288,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Train, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1483,6 +1484,13 @@
 		w = AllocateWindowDescFront(&_other_player_trains_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Train;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = player;
 		w->hscroll.cap = 10;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
@@ -1492,3 +1500,27 @@
 		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
 	}
 }
+
+void ShowWaypointTrains(int player, int waypoint)
+{
+	Window *w;
+
+	if (player == _local_player) {
+		w = AllocateWindowDescFront(&_player_trains_desc, (waypoint << 16) | player);
+	} else {
+		w = AllocateWindowDescFront(&_other_player_trains_desc, (waypoint << 16) | player);
+	}
+	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Train;
+		w->listopt.xy = GetWaypoint(waypoint)->xy;
+
+		w->caption_color = player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 7; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_SMALL;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
+	}
+}
Index: station.h
===================================================================
--- station.h	(revision 2724)
+++ station.h	(working copy)
@@ -9,6 +9,110 @@
 #include "tile.h"
 #include "vehicle.h"
 
+enum {
+	RP_NUM_TYPES = 4,
+};
+
+enum {
+	RP_T_SPEED_CAP = 300,
+	RP_T_SPEED_PASS_BONUS = -85,
+	RP_T_SPEED_CARGO_BONUS = -60,
+	RP_SPEED_MULT = 2,
+	RP_R_SPEED_PASS_BONUS = -20,
+	RP_R_SPEED_CARGO_BONUS = 5,
+	RP_S_SPEED_MULT = 2,
+	RP_MAX_SPEED_POINTS = 170,
+
+	RP_AGE_BONUS_0 = 13,
+	RP_AGE_BONUS_1 = 9,
+	RP_AGE_BONUS_2 = 6,
+	RP_AGE_BONUS_3 = 4,
+	RP_AGE_BONUS_4 = 2,
+	RP_AGE_BONUS_5 = 1,
+	RP_AGE_T_CLAMP = 15,
+	RP_AGE_R_CLAMP = 8,
+	RP_AGE_S_CLAMP = 20,
+	RP_AGE_A_CLAMP = 12,
+	RP_MAX_AGE = 20,
+	RP_MAX_AGE_POINTS = 20,
+
+	RP_OTHER_STATUE = 6,
+	RP_OTHER_LA_MULT = 50,
+
+	RP_DAYS_T_CLAMP = 28,
+	RP_DAYS_R_CLAMP = 56,
+	RP_DAYS_S_CLAMP = 112,
+	RP_DAYS_A_CLAMP = 14,
+	RP_MAX_DAYS = 28,
+	RP_DAYS_BONUS_0 = 18,
+	RP_DAYS_BONUS_1 = 17,
+	RP_DAYS_BONUS_2 = 16,
+	RP_DAYS_BONUS_3 = 10,
+	RP_DAYS_BONUS_4 = 9,
+	RP_DAYS_BONUS_5 = 8,
+	RP_DAYS_BONUS_6 = 2,
+	RP_DAYS_BONUS_7 = 1,
+	RP_MAX_DAYS_POINTS = 112,
+
+	RP_WAIT_T_CLAMP = 1800,
+	RP_WAIT_R_CLAMP = 900,
+	RP_WAIT_S_CLAMP = 1500,
+	RP_WAIT_A_CLAMP = 1200,
+	RP_MAX_WAIT = 120,
+	RP_MAX_WAIT_POINTS = 30,
+	RP_WAIT_BONUS_0 = 10,
+	RP_WAIT_BONUS_1 = 7,
+	RP_WAIT_BONUS_2 = 5,
+	RP_WAIT_BONUS_3 = 3,
+	RP_WAIT_BONUS_4 = 2,
+	RP_WAIT_BONUS_5 = 1,
+
+	MAX_CARGO_WAITING = 0xFFF,
+};
+
+enum {
+	STS_NO_MONTHS_COUNTED = 0,
+	STS_AMOUNT_IN = 0,
+	STS_AMOUNT_OUT = 1,
+	STS_AMOUNT_TRANSFER = 2,
+	STS_VEH_TRAIN = 0,
+	STS_VEH_ROAD = 1,
+	STS_VEH_BUS = 2,
+	STS_VEH_TRUCK = 3,
+	STS_VEH_SHIP = 4,
+	STS_VEH_AIRCRAFT = 5,
+	STS_VEH_TYPES = 6,
+	STS_AMNT_TYPES = 3,
+	AVERAGE_MULTIPLIER = 10000, // controls how much digits behind comma are stored for average
+	STS_SHOW_MONTHLY_STATS = 0,
+	STS_SHOW_YEARLY_STATS = 1,
+	STS_SHOW_AVERAGE_STATS = 1,
+	STS_INIT_MINIMUM = 0xFFFF,
+};
+
+enum {
+	ST_VIEW_HEIGHT         = 122,
+	ST_VIEW_EXP_HEIGHT     = 222,
+};
+
+enum {
+	RATING_WAITING = 0,
+	RATING_SPEED = 1,
+	RATING_AGE = 2,
+	RATING_PICKUP = 3,
+	RATING_OTHER = 4,
+	RATING_TOTAL = 5,
+	NUM_RATINGS = 6,
+};
+
+typedef struct StationStats {
+	uint16 this_month;
+	uint16 last_month;
+	uint16 month_min;
+	uint16 month_max;
+	uint32 average;
+} StationStats;
+
 typedef struct GoodsEntry {
 	uint16 waiting_acceptance;
 	byte days_since_pickup;
@@ -17,7 +121,12 @@
 	byte enroute_time;
 	byte last_speed;
 	byte last_age;
+
+	StationStats cargo_amount[STS_AMNT_TYPES];
+	uint16 months_counted;
 	int32 feeder_profit;
+	int last_vehicle_type;
+	uint16 last_vehicle_speed;
 } GoodsEntry;
 
 typedef enum RoadStopType {
@@ -26,10 +135,14 @@
 } RoadStopType;
 
 enum {
-	INVALID_STATION = 0xFFFF,
-	INVALID_SLOT = 0xFFFF,
-	NUM_SLOTS = 2,
-	ROAD_STOP_LIMIT = 8,
+	INVALID_STATION     = 0xFFFF,
+	INVALID_STATION_OLD = 0xFF,
+	INVALID_SLOT        = 0xFFFF,
+	INVALID_AGE         = 0xFF,
+	INVALID_TIME        = 0xFF,
+	NUM_SLOTS           = 2,
+	ROAD_STOP_LIMIT     = 8,
+	RATING_START_VALUE  = 175,
 };
 
 typedef uint16 StationID;
@@ -46,6 +159,14 @@
 	struct RoadStop *prev;
 } RoadStop;
 
+typedef struct RatingStats {
+	uint16 last_speed;
+	byte last_age;
+	byte days_since_pickup;
+	uint16 waiting;
+	int16 ratings[NUM_RATINGS];
+} RatingStats;
+
 struct Station {
 	TileIndex xy;
 	RoadStop *bus_stops;
@@ -80,7 +201,12 @@
 
 	VehicleID last_vehicle;
 	GoodsEntry goods[NUM_CARGO];
+	RatingStats rating_stats[NUM_CARGO];
 
+	StationStats vehicles[STS_VEH_TYPES];
+	uint16 veh_scheduled[STS_VEH_TYPES];
+	uint16 months_counted;
+
 	/* Stuff that is no longer used, but needed for conversion */
 	TileIndex bus_tile_obsolete;
 	TileIndex lorry_tile_obsolete;
@@ -123,11 +249,18 @@
 	CA_AIR_INTER = 8,
 };
 
-void ModifyStationRatingAround(TileIndex tile, byte owner, int amount, uint radius);
+void ModifyStationRatingAround(TileIndex tile, PlayerID owner, int amount, uint radius);
 
+void SearchVehiclesForStation(Station *st);
+void ShowStationStatsWindow(StationID station);
+void InitializeStationStats(Station *st);
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted);
+void ShowPlayerVehicles(PlayerID player, StationID station, TypeMask type_mask, CargoMask cargo_mask, TileIndex xy);
+
 TileIndex GetStationTileForVehicle(const Vehicle *v, const Station *st);
 
-void ShowStationViewWindow(int station);
+void ShowStationViewWindow(StationID station);
+void ShowStationRatingDetail(StationID station);
 void UpdateAllStationVirtCoord(void);
 
 VARDEF SortStruct *_station_sort;
@@ -324,4 +457,6 @@
 	return (_m[tile].m5 - 0x43) & 3;
 }
 
+int32 ClickResetStationCheat(int32 cheat_activated, int32 NOT_USED);
+
 #endif /* STATION_H */
Index: settings_gui.c
===================================================================
--- settings_gui.c	(revision 2724)
+++ settings_gui.c	(working copy)
@@ -718,6 +718,12 @@
 	{PE_BOOL,		0, STR_CONFIG_PATCHES_SERVICEATHELIPAD, "service_at_helipad", &_patches.serviceathelipad,					0,  0,  0, NULL},
 	{PE_BOOL, 0, STR_CONFIG_PATCHES_CATCHMENT, "modified_catchment", &_patches.modified_catchment, 0, 0, 0, NULL},
 
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_SPEED, "nsr_speed", &_patches.nsr_speed,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_AGE, "nsr_age", &_patches.nsr_age,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_TOWN_RATING, "nsr_town_rating", &_patches.nsr_town_rating,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_WAIT_DAYS, "nsr_wait_days", &_patches.nsr_wait_days,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_WAIT_CARGO, "nsr_wait_cargo", &_patches.nsr_wait_cargo,					0,  0,  0, NULL},
+
 };
 
 static const PatchEntry _patches_economy[] = {
Index: ship_gui.c
===================================================================
--- ship_gui.c	(revision 2724)
+++ ship_gui.c	(working copy)
@@ -62,7 +62,7 @@
 	y += 10;
 }
 
-static void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetShipImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -909,7 +909,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Ship, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1104,6 +1104,13 @@
 		w = AllocateWindowDescFront(&_other_player_ships_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Ship;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = w->window_number;
 		w->vscroll.cap = 4;
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: window.h
===================================================================
--- window.h	(revision 2724)
+++ window.h	(working copy)
@@ -37,6 +37,40 @@
    That was all.. good luck, and enjoy :) -- TrueLight */
 
 enum {
+	SUBTYPE_AIRCRAFT = 2,
+	SUBTYPE_NONE     = 0,
+	CARGO_MASK_ALL   = 0xFFFFFFFFFFFFFFFFll,
+	VEHICLE_TYPE_ALL = 0xF0000,
+};
+
+/** Options for building vehicle-lists
+  * stored in the window-struct and used in BuildVehicleList()
+  * 
+  * xy:         xy-value of the station/waypoint/depot the vehicle should be scheduled for
+  *             use INVALID_STATION if you dont want vehicles scheduled for a specific destination
+  * cargo_mask: 64-bit mask using global cargo ids
+  *             determines which vehicles should be selected by cargo-type
+  *             use CARGO_MASK_ALL if you dont want to distinguish by cargo-type
+  * type_mask:  32-bit mask that controls varios parts of the list
+  *             currently implemented:
+  *             Vehicle type: uses bits 16 to 19 (VEH_Train = 16, VEH_Aircraft = 19)
+  *                           to determine which vehicletypes should be selected
+  *                           use VEHICLE_TYPE_ALL if you dont want to distinguish by vehicletype
+  *             also used for statistics-windows to store whether to show monthly, yearly or average statistics
+  *
+  *             planned:
+  *             vehicle-age: select only yehicles older/newer/at given age
+  *             more specific vehicle type: e.g. select a specific Train-Engine to be shown only
+  *             flags: should age be same/higher/lower as given value?
+  *                    include or exclude given vehicle?
+  */
+typedef struct DisplayListOptions {
+	TileIndex xy;
+	CargoMask cargo_mask;
+	TypeMask type_mask;
+} DisplayListOption;
+
+enum {
 	RESIZE_NONE   = 0,
 
 	RESIZE_LEFT   = 1,
@@ -307,6 +341,8 @@
 
 	Message message;
 	byte custom[WINDOW_CUSTOM_SIZE];
+	
+	DisplayListOption listopt; // Options for displaying vehicle-lists
 };
 
 typedef struct {
Index: command.c
===================================================================
--- command.c	(revision 2724)
+++ command.c	(working copy)
@@ -159,6 +159,8 @@
 
 DEF_COMMAND(CmdReplaceVehicle);
 
+DEF_COMMAND(CmdResetStationCheat);
+
 /* The master command table */
 static const Command _command_proc_table[] = {
 	{CmdBuildRailroadTrack,                  0}, /*   0 */
@@ -300,6 +302,8 @@
 	{CmdGiveMoney,                           0}, /* 113 */
 	{CmdChangePatchSetting,         CMD_SERVER}, /* 114 */
 	{CmdReplaceVehicle,                      0}, /* 115 */
+
+	{CmdResetStationCheat,                   0}, /* 116 */
 };
 
 /* This function range-checks a cmd, and checks if the cmd is not NULL */
Index: command.h
===================================================================
--- command.h	(revision 2724)
+++ command.h	(working copy)
@@ -136,6 +136,8 @@
 	CMD_CHANGE_PATCH_SETTING = 114,
 
 	CMD_REPLACE_VEHICLE = 115,
+
+	CMD_RESET_STATION_CHEAT = 116,
 };
 
 enum {
