Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 2456)
+++ station_cmd.c	(working copy)
@@ -19,6 +19,7 @@
 #include "airport.h"
 #include "sprite.h"
 #include "depot.h"
+#include "pbs.h"
 
 enum {
 	/* Max stations: 64000 (64 * 1000) */
@@ -459,7 +460,10 @@
 		ge->last_age = 0xFF;
 		ge->feeder_profit = 0;
 	}
+	InitializeStationStats(st);
 
+	st->airport_queue = new_VQueue();
+
 	_global_station_sort_dirty = true; // build a new station
 }
 
@@ -1781,6 +1785,8 @@
 		InvalidateWindow(WC_STATION_LIST, st->owner);
 	}
 
+	st->airport_queue = new_VQueue();
+
 	return cost;
 }
 
@@ -2154,6 +2160,18 @@
 		} else {
 			AddChildSpriteScreen(image, dtss->delta_x, dtss->delta_y);
 		}
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(0x3ED | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(0x3EE | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(0x3EF | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(0x3F0 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(0x3F2 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 | PALETTE_CRASH);
+}
+#endif
 	}
 }
 
@@ -2417,6 +2435,12 @@
 	DeleteDestinationFromVehicleOrder(order);
 
 	DeleteSubsidyWithStation(index);
+
+	st->airport_queue->clear;
+	free(st->airport_queue);
+	// Freed by above?
+	//free(st->airport_queue);
+
 }
 
 void DeleteAllPlayerStations(void)
@@ -2608,8 +2632,55 @@
 
 }
 
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted)
+{
+	if (times_counted == 0)
+		return lastamount;
+	average = (uint32)((uint64)(((uint64)average * (uint64)times_counted + (uint64)lastamount) / ((uint64)times_counted + 1)));
+	return average;
+}
+
 void StationMonthlyLoop(void)
 {
+	Station *st;
+	StationStats *sts;
+	GoodsEntry *ge;
+
+ 	FOR_ALL_STATIONS(st) {
+		// if we have stats for this station the number of counted months is >0
+		if (st->months_counted > 0)
+		{
+			for (ge = st->goods; ge != endof(st->goods); ge++) {
+				// if we have stats for this good, the number of months counted is >0
+				if (ge->months_counted > 0) 
+				{
+					// set current months stats to 0 after storing value for last month
+					// do this for all stats (currently In/Out/Transfer)
+					// also determine new min/max-values
+					for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+						if (sts->month_max == 0) sts->month_min = sts->this_month;
+						sts->month_min = min(sts->month_min, sts->this_month);
+						sts->month_max = max(sts->month_max, sts->this_month);
+						sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, ge->months_counted - 1);
+						sts->last_month = sts->this_month;
+						sts->this_month = 0;
+					}
+					ge->months_counted++; // one more month counted
+				}
+			}
+			// update vehicle-counts and min/max
+			for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+				if (sts->month_max == 0) sts->month_min = sts->this_month;
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, st->months_counted - 1);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			st->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, st->index);
+	}
 }
 
 
@@ -2641,6 +2712,7 @@
 	st->goods[type].enroute_time = 0;
 	st->goods[type].enroute_from = st->index;
 	InvalidateWindow(WC_STATION_VIEW, st->index);
+	InvalidateWindow(WC_STATION_STATS, st->index);
 }
 
 /** Rename a station
@@ -2833,7 +2905,7 @@
 			_map2[tile] = st->index;
 
 			st->owner = OWNER_NONE;
-      st->airport_flags = 0;
+			st->airport_flags = 0;
 			st->airport_type = AT_OILRIG;
 			st->xy = tile;
 			st->bus_stops = NULL;
@@ -3029,12 +3101,25 @@
 	SLE_CONDREF(Station,bus_stops,					REF_ROADSTOPS, 6, 255),
 	SLE_CONDREF(Station,truck_stops,				REF_ROADSTOPS, 6, 255),
 
+	// station stats data is stored here since savegame format 14
+	SLE_CONDVAR(Station,months_counted,	SLE_UINT16, 14, 255),
+
 	// reserve extra space in savegame here. (currently 28 bytes)
 	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 32, 2, 255),
 
 	SLE_END()
 };
 
+// station stats data since savegame format 15
+static const SaveLoad _stats_desc[] = {
+	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,average,	SLE_UINT32, 15, 255),
+	SLE_END()
+};
+
 static const SaveLoad _goods_desc[] = {
 	SLE_VAR(GoodsEntry,waiting_acceptance,SLE_UINT16),
 	SLE_VAR(GoodsEntry,days_since_pickup,	SLE_UINT8),
@@ -3046,22 +3131,29 @@
 	SLE_VAR(GoodsEntry,last_age,					SLE_UINT8),
 	SLE_CONDVAR(GoodsEntry,feeder_profit,			SLE_INT32, 14, 255),
 
+	// station stats data is stored here since savegame format 15
+//	SLE_CONDVAR(GoodsEntry,months_counted,	SLE_UINT16, 15, 255),
+
 	SLE_END()
 };
 
 
 static void SaveLoad_STNS(Station *st)
 {
-	int i;
+	int i; //, j;
 
 	SlObject(st, _station_desc);
 	for (i = 0; i != NUM_CARGO; i++) {
 		SlObject(&st->goods[i], _goods_desc);
+//		for (j = 0; j < STS_AMNT_TYPES; j++)
+//			SlObject(&st->goods[i].cargo_amount[j], _stats_desc);
 
 		/* In older versions, enroute_from had 0xFF as INVALID_STATION, is now 0xFFFF */
 		if (_sl.full_version < 0x700 && st->goods[i].enroute_from == 0xFF)
 			st->goods[i].enroute_from = 0xFFFF;
 	}
+//	for (i = 0; i < STS_VEH_TYPES; i++) 
+//		SlObject(&st->vehicles[i], _stats_desc);
 }
 
 static void Save_STNS(void)
@@ -3087,6 +3179,7 @@
 
 		st = GetStation(index);
 		SaveLoad_STNS(st);
+		InitializeStationStats(st);
 
 		// this means it's an oldstyle savegame without support for nonuniform stations
 		if (st->train_tile && st->trainst_h == 0) {
@@ -3114,6 +3207,8 @@
 				InitializeRoadStop(st->truck_stops, NULL, st->lorry_tile_obsolete, st->index);
 			}
 		}
+
+	st->airport_queue = new_VQueue();
 	}
 
 	/* This is to ensure all pointers are within the limits of _stations_size */
@@ -3153,3 +3248,83 @@
 	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY | CH_LAST},
 };
 
+void SearchVehiclesForStation(Station *st)
+{
+	Vehicle *v;
+	int i;
+	Order* ord;
+	
+	ord = NULL;
+	if (st->xy == 0) return;
+	for(i = 0; i < STS_VEH_TYPES; i++) st->veh_scheduled[i] = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+	
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ||       //Trains (first engine, that contains the orders)
+			( (v->type == VEH_Road) && (v->subtype == 0) ) ||       //Road vehicles (subtype should always be 0 anyway)
+			( (v->type == VEH_Ship) && (v->subtype == 0) ) ||       //Ships, subtype should be 0 anyway)
+			( (v->type == VEH_Aircraft) && (
+				(v->subtype == 0) ||                            //Choppers
+				(v->subtype == 2) ) ) ) &&                               //Fixed-wing stuff
+			(v->owner == st->owner) ) 
+//			(v->owner == _local_player) ) 
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == st->index && ord->type == OT_GOTO_STATION) {
+					switch (v->type) {
+						case VEH_Train:
+							st->veh_scheduled[STS_VEH_TRAIN]++;
+							break;
+						case VEH_Road:
+							st->veh_scheduled[STS_VEH_ROAD]++;
+                            if (v->cargo_type == CT_PASSENGERS)
+								st->veh_scheduled[STS_VEH_BUS]++;
+							else
+								st->veh_scheduled[STS_VEH_TRUCK]++;
+							break;
+						case VEH_Ship:
+							st->veh_scheduled[STS_VEH_SHIP]++;
+							break;
+						case VEH_Aircraft:
+							st->veh_scheduled[STS_VEH_AIRCRAFT]++;
+							break;
+						default:
+							NOT_REACHED();
+					}
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	}
+}
+
+
+void InitializeStationStats(Station *st)
+{
+	StationStats *sts;
+	GoodsEntry *ge;
+
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->months_counted = 0;
+		for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+			sts->average = 0;
+			sts->last_month = 0;
+			sts->month_max = 0;
+			sts->month_min = 65535;
+			sts->this_month = 0;
+		}
+	}
+	st->months_counted = 0;
+	for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = 65535;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForStation(st);
+}
Index: functions.h
===================================================================
--- functions.h	(revision 2456)
+++ functions.h	(working copy)
@@ -27,7 +27,7 @@
 
 bool IsValidTile(TileIndex tile);
 
-static inline Point RemapCoords(int x, int y, int z)
+static inline Point RemapCoords(int x, int y, uint32 z)
 {
 #if !defined(NEW_ROTATION)
 	Point pt;
Index: aircraft_cmd.c
===================================================================
--- aircraft_cmd.c	(revision 2456)
+++ aircraft_cmd.c	(working copy)
@@ -15,6 +15,7 @@
 #include "player.h"
 #include "airport.h"
 #include "vehicle_gui.h"
+#include "queue.h"
 
 static bool AirportMove(Vehicle *v, const AirportFTAClass *Airport);
 static bool AirportSetBlocks(Vehicle *v, AirportFTA *current_pos, const AirportFTAClass *Airport);
@@ -25,7 +26,7 @@
 static void CrashAirplane(Vehicle *v);
 
 static void AircraftNextAirportPos_and_Order(Vehicle *v);
-static byte GetAircraftFlyingAltitude(const Vehicle *v);
+static uint32 GetAircraftFlyingAltitude(Vehicle *v);
 
 static const SpriteID _aircraft_sprite[] = {
 	0x0EB5, 0x0EBD, 0x0EC5, 0x0ECD,
@@ -457,7 +458,6 @@
 			if (p2 != 0) return CMD_ERROR;
 			// the aircraft has to search for a hangar on its own
 			station = FindNearestHangar(v);
-
 			next_airport_has_hangar = false;
 			if (station == INVALID_STATION) return CMD_ERROR;
 			st = GetStation(station);
@@ -721,7 +721,7 @@
 	EndVehicleMove(u);
 }
 
-static void SetAircraftPosition(Vehicle *v, int x, int y, int z)
+static void SetAircraftPosition(Vehicle *v, int x, int y, uint32 z)
 {
 	Vehicle *u;
 	int yt;
@@ -787,17 +787,30 @@
 	SndPlayVehicleFx(AircraftVehInfo(v->engine_type)->sfx, v);
 }
 
-static bool UpdateAircraftSpeed(Vehicle *v)
+static int UpdateAircraftSpeed(Vehicle *v)
 {
-	uint spd = v->acceleration * 2;
+	uint16 spd = v->acceleration * 2;
 	byte t;
+	uint16 new_speed;
+	
+	new_speed = v->max_speed * _patches.aircraft_speed_coeff;
 
-	v->subspeed = (t=v->subspeed) + (byte)spd;
-	spd = min( v->cur_speed + (spd >> 8) + (v->subspeed < t), v->max_speed);
+	// Don't fo faster than max
+	if(v->u.air.desired_speed > new_speed) {
+		v->u.air.desired_speed = new_speed;
+	}
 
+	//spd = v->cur_speed + v->acceleration;
+	v->subspeed = (t=v->subspeed) + (uint16)spd;
+	spd = min( v->cur_speed + (spd >> 8) + (v->subspeed < t), new_speed);
+
 	// adjust speed for broken vehicles
-	if(v->vehstatus&VS_AIRCRAFT_BROKEN) spd = min(spd, 27);
+	if(v->vehstatus&VS_AIRCRAFT_BROKEN) spd = min(spd, v->max_speed / 3 * _patches.aircraft_speed_coeff);
 
+	// If landing, do not speed up!
+	if((v->u.air.state == LANDING || v->u.air.state == ENDLANDING) && spd > 15 * _patches.aircraft_speed_coeff)
+		spd = min(v->cur_speed, spd);
+
 	//updates statusbar only if speed have changed to save CPU time
 	if (spd != v->cur_speed) {
 		v->cur_speed = spd;
@@ -805,6 +818,7 @@
 			InvalidateWindowWidget(WC_VEHICLE_VIEW, v->index, STATUS_BAR);
 	}
 
+
 	if (!(v->direction & 1)) {
 		spd = spd * 3 >> 2;
 	}
@@ -812,33 +826,74 @@
 	if (spd == 0)
 		return false;
 
-	if ((byte)++spd == 0)
+	if ((uint32)++spd == 0)
 		return true;
 
-	v->progress = (t = v->progress) - (byte)spd;
 
-	return (t < v->progress);
+//	v->progress = (t = v->progress) - (uint16)spd;
+
+//	return (t < v->progress);
+	spd += v->progress;
+	v->progress = (byte)spd;
+	return (spd >> 8);
 }
 
 // get Aircraft running altitude
-static byte GetAircraftFlyingAltitude(const Vehicle *v)
+static uint32 GetAircraftFlyingAltitude(Vehicle *v)
 {
-	switch (v->max_speed) {
-		case 37: return 162;
-		case 74: return 171;
-		default: return 180;
+//	uint16 maxz = 150;
+//	if(v->max_speed > 75 * _patches.aircraft_speed_coeff) {
+//		maxz = 4 * v->max_speed - 600;
+//	} else if(v->max_speed * _patches.aircraft_speed_coeff > 255) {
+//		maxz = 255;
+//	} else {
+//		maxz = 150;
+//	}
+	uint32 queue_adjust = 0;
+	uint32 maxz;
+	if(v->queue_item != NULL)
+		queue_adjust = 32 * v->queue_item->queue->getPos(v->queue_item->queue, v)-1;
+	
+	maxz = 162;
+	if(v->max_speed > 37 * _patches.aircraft_speed_coeff) {
+		maxz = 171;
+		if(v->max_speed > 74 * _patches.aircraft_speed_coeff) {
+			maxz = 180;
+		}
 	}
+
+	return maxz + queue_adjust;
 }
 
+/* returns true if staying in the same tile */
+bool GetNewAircraftPos(Vehicle *v, GetNewVehiclePosResult *gp, int tilesMoved)
+{
+	static const int8 _delta_coord[16] = {
+		-1,-1,-1, 0, 1, 1, 1, 0, /* x */
+		-1, 0, 1, 1, 1, 0,-1,-1, /* y */
+	};
+
+	int x = v->x_pos + _delta_coord[v->direction] * tilesMoved;
+	int y = v->y_pos + _delta_coord[v->direction + 8] * tilesMoved;
+
+	gp->x = x;
+	gp->y = y;
+	gp->old_tile = v->tile;
+	gp->new_tile = TILE_FROM_XY(x,y);
+	return gp->old_tile == gp->new_tile;
+}
+
 static bool AircraftController(Vehicle *v)
 {
 	Station *st;
 	const AirportMovingData *amd;
 	Vehicle *u;
-	byte z,dirdiff,newdir,maxz,curz;
+	byte dirdiff,newdir;
 	GetNewVehiclePosResult gp;
-	uint dist;
+	uint dist, desired_dist;
 	int x,y;
+	int tilesMoved;
+	uint32 z,maxz,curz;
 
 	st = GetStation(v->u.air.targetairport);
 
@@ -867,7 +922,7 @@
 			}
 		} else {
 			u->cur_speed = 32;
-			if (UpdateAircraftSpeed(v)) {
+			if (UpdateAircraftSpeed(v) >= 1) {
 				v->tile = 0;
 
 				// Reached altitude?
@@ -883,7 +938,7 @@
 
 	// Helicopter landing.
 	if (amd->flag & AMED_HELI_LOWER) {
-		if (UpdateAircraftSpeed(v)) {
+		if (UpdateAircraftSpeed(v) >= 1) {
 			if (st->airport_tile == 0) {
 				// FIXME - AircraftController -> if station no longer exists, do not land
 				// helicopter will circle until sign disappears, then go to next order
@@ -920,6 +975,61 @@
 	// Get distance from destination pos to current pos.
 	dist = myabs(x + amd->x - v->x_pos) +  myabs(y + amd->y - v->y_pos);
 
+	// If target airport is VERY busy (queue larger than 5), always add to queue
+	if(st->airport_queue->size > 5  && v->u.air.state == FLYING)
+	{
+		// If it's already in the queue, don't re-add it
+		// Otherwise, add it to queue - but don't add helicopters!
+		// otherwise, helicopters will be part of the queue and can't land separately!
+		if(!(v->queue_item != NULL) && (_patches.aircraft_queueing == true && v->subtype != 0)) {
+			// Add to queue
+			assert(st->airport_queue->push(st->airport_queue, v));
+		}
+	}
+
+	// If the aircraft is flying and is within range of an airport, add it to the queue
+	if(dist < 1000 && v->u.air.state == FLYING)  
+	{
+		// If it's already in the queue, don't re-add it
+		// Otherwise, add it to queue - but don't add helicopters!
+		// otherwise, helicopters will be part of the queue and can't land separately!
+		if(!(v->queue_item != NULL) && (_patches.aircraft_queueing == true && v->subtype != 0)) {
+			// Add to queue
+			st->airport_queue->push(st->airport_queue, v);
+		}
+	}
+
+	// Calculate desired distance
+	if(v->queue_item != NULL)
+		desired_dist = v->queue_item->queue->getPos(v->queue_item->queue, v) * 250;
+	else
+		desired_dist = st->airport_queue->size * 250;
+
+	// Try to reach desired distance
+	if(myabs(desired_dist - dist) < 10) {
+		// At or close to desired distance, maintain a good cruising speed
+		v->u.air.desired_speed = min(v->max_speed * _patches.aircraft_speed_coeff, 36 * _patches.aircraft_speed_coeff);
+	} else {
+		if(dist < desired_dist && v->queue_item != NULL) {
+			// Too close, slow down, but only if not near end of queue
+			if(v->queue_item->queue->getPos(v->queue_item->queue, v) > 2)
+				v->u.air.desired_speed = min(v->max_speed * _patches.aircraft_speed_coeff, 15 * _patches.aircraft_speed_coeff);
+			else
+				v->u.air.desired_speed = v->u.air.desired_speed = min(v->max_speed * _patches.aircraft_speed_coeff, 36 * _patches.aircraft_speed_coeff);
+		} else {
+			// Too far, speed up
+			v->u.air.desired_speed = v->max_speed * _patches.aircraft_speed_coeff;
+		}
+	}
+
+	if(v->u.air.state == FLYING) {
+		if(v->cur_speed > v->u.air.desired_speed){
+			v->cur_speed--;
+		} else {
+			v->cur_speed++;
+		}
+	}
+
 	// Need exact position?
 	if (!(amd->flag & AMED_EXACTPOS) && dist <= (uint)((amd->flag&AMED_SLOWTURN)?8:4))
 		return true;
@@ -940,7 +1050,7 @@
 			return true;
 		}
 
-		if (!UpdateAircraftSpeed(v))
+		if (UpdateAircraftSpeed(v) < 1)
 			return false;
 
 		v->direction = (v->direction+((dirdiff&7)<5?1:-1)) & 7;
@@ -954,7 +1064,11 @@
 	if (!(amd->flag & AMED_NOSPDCLAMP) && v->cur_speed > 12)
 		v->cur_speed = 12;
 
-	if (!UpdateAircraftSpeed(v))
+	//if (!UpdateAircraftSpeed(v))
+	//	return false;
+
+	tilesMoved = UpdateAircraftSpeed(v);
+	if(tilesMoved < 1)
 		return false;
 
 	// Decrease animation counter.
@@ -976,7 +1090,7 @@
 	}
 
 	// Move vehicle.
-	GetNewVehiclePos(v, &gp);
+	GetNewAircraftPos(v, &gp, tilesMoved);
 	v->tile = gp.new_tile;
 
 	// If vehicle is in the air, use tile coordinate 0.
@@ -1027,6 +1141,20 @@
 			v->cur_speed -= 4;
 	}
 
+	curz = z;
+	if(v->queue_item != NULL)
+	{
+		curz = GetAircraftFlyingAltitude(v);
+	}
+
+	if(curz < z)
+	{
+		z--;
+	} else if(curz > z)
+	{
+		z++;
+	}
+
 	SetAircraftPosition(v, gp.x, gp.y, z);
 	return false;
 }
@@ -1039,7 +1167,7 @@
 {
 	uint32 r;
 	Station *st;
-	int z;
+	uint32 z;
 
 	v->u.air.crashed_counter++;
 
@@ -1274,7 +1402,16 @@
 	if (v->current_order.type == OT_GOTO_DEPOT)
 		return;
 
+	//Maybe check what happens if we go Terminal => Hangar => Terminal
 	st = GetStation(v->u.air.targetairport);
+//	if (v->cargo_type != CT_MAIL) st->this_month_vehicles[5]++;
+	if ((v->subtype == 0) || (v->subtype == 2))
+	{
+		st->vehicles[STS_VEH_AIRCRAFT].this_month++;
+		if (st->months_counted == 0) st->months_counted = 1;
+	}
+	InvalidateWindow(WC_STATION_STATS, st->index);
+	
 	v->last_station_visited = v->u.air.targetairport;
 
 	/* Check if station was ever visited before */
@@ -1552,8 +1689,15 @@
 	byte landingtype;
 	AirportFTA *current;
 	uint16 tcur_speed, tsubspeed;
+	// For all those budding software engineers out there:
+	// An invariant that changes :P.
+	bool can_land;
+	
+	can_land = false;
 
+	// Get the target airport
 	st = GetStation(v->u.air.targetairport);
+
 	// flying device is accepted at this station
 	// small airport --> no helicopters (AIRCRAFT_ONLY)
 	// all other airports --> all types of flying devices (ALL)
@@ -1567,14 +1711,59 @@
 		// it is possible to choose from multiple landing runways, so loop until a free one is found
 		landingtype = (v->subtype != 0) ? LANDING : HELILANDING;
 		current = Airport->layout[v->u.air.pos].next_in_chain;
+
+
+		// Check to see if we're going to land at an airport.
+
+		// Fisrt, check queue - if we are on top, or if it's empty,
+		// we can land.
+
+		// Just in case the code in AircraftController code misses,
+		// We check before the aircraft lands.
+
+		// If it's already in the queue, don't re-add it
+		// Otherwise, add it to queue - but don't add helicopters!
+		// otherwise, helicopters will be part of the queue and can't land separately!
+		if(!(v->queue_item != NULL) && (_patches.aircraft_queueing == true && v->subtype != 0)) {
+			// Add to queue
+			assert(st->airport_queue->push(st->airport_queue, v));
+		}
+
+		// save speed before, since if AirportHasBlock is false, it resets them to 0
+		// we don't want that for plane in air
+		// hack for speed thingie
+		tcur_speed = v->cur_speed;
+		tsubspeed = v->subspeed;
+
+		// If we're on top, go in
+		if(st->airport_queue->getTop(st->airport_queue) == v && (_patches.aircraft_queueing == true && v->subtype != 0)) {
+			if (!AirportHasBlock(v, current, Airport)) {			
+				can_land = true;
+				st->airport_queue->pop(st->airport_queue);
+			} else {
+				can_land = false;
+			}
+		}
+
+		if(_patches.aircraft_queueing == false || v->subtype == 0) {
+			if (!AirportHasBlock(v, current, Airport)) {			
+				can_land = true;
+			} else {
+				can_land = false;
+			}
+		}
+
+		// Always do helicopters, regardless.
+//		if(landingtype == HELILANDING) {
+//			if (!AirportHasBlock(v, current, Airport)) {			
+//				can_land = true;
+//			}
+//		}
+
 		while (current != NULL) {
 			if (current->heading == landingtype) {
-				// save speed before, since if AirportHasBlock is false, it resets them to 0
-				// we don't want that for plane in air
-				// hack for speed thingie
-				tcur_speed = v->cur_speed;
-				tsubspeed = v->subspeed;
-				if (!AirportHasBlock(v, current, Airport)) {
+
+				if(can_land == true) {
 					v->u.air.state = landingtype; // LANDING / HELILANDING
 					// it's a bit dirty, but I need to set position to next position, otherwise
 					// if there are multiple runways, plane won't know which one it took (because
Index: npf.c
===================================================================
--- npf.c	(revision 2456)
+++ npf.c	(working copy)
@@ -11,6 +11,18 @@
 
 AyStar _npf_aystar;
 
+/*
+const byte _track_exitdir_to_trackdir[6][4] = {
+	{0,    0xff, 8,    0xff},
+	{0xff, 1,    0xff, 9},
+	{2,    0xff, 0xff, 10},
+	{0xff, 3,    11,   0xf},
+	{0xff, 0xff, 4,    12},
+	{13,   5,    0xff, 0xff}
+};
+
+*/
+
 /* The cost of each trackdir. A diagonal piece is the full NPF_TILE_LENGTH,
  * the shorter piece is sqrt(2)/2*NPF_TILE_LENGTH =~ 0.7071
  */
@@ -21,6 +33,8 @@
 	NPF_TILE_LENGTH, NPF_TILE_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH
 };
 
+bool IsEndOfLine(TileIndex tile, byte trackdir);
+
 uint NTPHash(uint key1, uint key2)
 {
 	/* This function uses the old hash, which is fixed on 10 bits (1024 buckets) */
@@ -84,6 +98,71 @@
 	return TILE_XY(tx,ty);
 };
 
+void NPFReservePBSPath(AyStar *as)
+{
+	NPFFoundTargetData* ftd = (NPFFoundTargetData*)as->user_path;
+	bool eolstuff = false;
+
+	if (ftd->best_trackdir == 0xFF)
+		return;
+
+	if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_EXIT) && IsEndOfLine(ftd->node.tile, ftd->node.direction) && !NPFGetFlag(&ftd->node, NPF_FLAG_SEEN_SIGNAL)) {
+		eolstuff = true;
+		NPFSetFlag(&ftd->node, NPF_FLAG_PBS_EXIT, true);
+		if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_TARGET_SEEN))
+			NPFSetFlag(&ftd->node, NPF_FLAG_PBS_RED, true);
+	}
+
+	if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_CHOICE)) {
+		NPFSetFlag(&ftd->node, NPF_FLAG_PBS_RED, false);
+	}
+
+	if (NPFGetFlag(&ftd->node, NPF_FLAG_PBS_EXIT) &&
+		  !NPFGetFlag(&ftd->node, NPF_FLAG_PBS_BLOCKED) &&
+		  (  ((as->user_data[NPF_PBS_MODE] & PBS_MODE_MASK) != PBS_MODE_GREEN) ||
+			   (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_RED))
+		  ) ) {
+		PathNode parent;
+		PathNode *curr = &parent;
+		PathNode *prev = NULL;
+		TileIndex start = INVALID_TILE;
+		byte trackdir = 0;
+
+		parent.node = ftd->node;
+		parent.parent = &ftd->path;
+
+		do {
+			if (!NPFGetFlag(&curr->node, NPF_FLAG_PBS_EXIT) || eolstuff) {
+				if ((PBSTileUnavail(curr->node.tile) & (1 << curr->node.direction))
+				&& !(PBSTileReserved(curr->node.tile) & (1 << (curr->node.direction & 7)))
+				&& (start != INVALID_TILE)) {
+					PBSClearPath(start, trackdir);
+					NPFSetFlag(&ftd->node, NPF_FLAG_PBS_BLOCKED, true);
+					DEBUG(pbs, 1) ("PBS: Self-crossing path!!!");
+					return;
+				};
+
+				PBSReserveTrack(curr->node.tile, (curr->node.direction & 7) );
+
+				if (prev != NULL && start == INVALID_TILE) {
+					PBSReserveTrack(prev->node.tile, (prev->node.direction & 7) );
+					start = prev->node.tile;
+					trackdir = ReverseTrackdir(prev->node.direction);
+				}
+			}
+
+			//if (IsTileType(parent->node.tile, MP_TUNNELBRIDGE) && (_map5[parent->node.tile] & 0xF0)==0 && (_map5[parent->node.tile] & 3) == _trackdir_to\_exitdir[parent->node.direction])
+//			if ((curr->parent != NULL) && IsTileType(curr->node.tile, MP_TUNNELBRIDGE) && (_map5[curr->node.tile] & 0xF0)==0)
+//						curr = curr->parent;
+
+			prev = curr;
+			curr = curr->parent;
+		} while (curr != NULL);
+	}
+
+}
+
+
 /* Calcs the heuristic to the target station or tile. For train stations, it
  * takes into account the direction of approach.
  */
@@ -105,15 +184,26 @@
 		/* Ships and trains can also go diagonal, so the minimum distance is shorter */
 		dist = DistanceTrack(from, to) * NPF_TILE_LENGTH;
 
-	if (dist < ftd->best_bird_dist) {
+	DEBUG(npf, 4)("Calculating H for: (%d, %d). Result: %d", TileX(current->tile), TileY(current->tile), dist);
+
+	if ((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE)
+	&&  (!NPFGetFlag(current , NPF_FLAG_SEEN_SIGNAL))
+	&&  (!IsEndOfLine(current->tile, current->direction)))
+		return dist;
+
+	if ((dist < ftd->best_bird_dist) ||
+		((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE) && !NPFGetFlag(current, NPF_FLAG_PBS_RED) && NPFGetFlag(&ftd->node, NPF_FLAG_PBS_RED))
+) {
 		ftd->best_bird_dist = dist;
 		ftd->best_trackdir = current->user_data[NPF_TRACKDIR_CHOICE];
+		ftd->path = parent->path;
+		ftd->node = *current;
+		//debug("new low tile: %x", ftd->node.tile);
 	}
-	DEBUG(npf, 4)("Calculating H for: (%d, %d). Result: %d", TileX(current->tile), TileY(current->tile), dist);
+
 	return dist;
 }
 
-
 /* Fills AyStarNode.user_data[NPF_TRACKDIRCHOICE] with the chosen direction to
  * get here, either getting it from the current choice or from the parent's
  * choice */
@@ -225,7 +315,7 @@
 
 /* Determine the cost of this node, for road tracks */
 int32 NPFRoadPathCost(AyStar* as, AyStarNode* current, OpenListNode* parent) {
-	TileIndex tile = current->tile;
+	TileIndex tile = current->tile, tile2;
 	int32 cost = 0;
 
 	/* Determine base length */
@@ -236,9 +326,31 @@
 				break;
 			}
 			/* Fall through if above if is false, it is a bridge
-			 * then. We treat that as ordinary rail */
+			 * then. We treat that as ordinary road */
 		case MP_STREET:
 			cost = NPF_TILE_LENGTH;
+			/* Increase the cost for level crossings */
+			if ((_map5[tile] & 0xF0) == 0x10)
+				cost += _patches.npf_crossing_penalty;
+				
+ 			/* Drivers prefer to go past trees and water, rather
+ 			 * than houses and industries (not a proven fact)
+ 			 * so this is what this lot of code does :D */
+ 			
+ 			// tile right
+ 			tile2 = TILE_MASK(tile + TileOffsByDir((current->direction + 1) & 3));
+ 			if (GetTileType(tile2) == MP_HOUSE || GetTileType(tile2) == MP_INDUSTRY)
+ 				cost += 100;
+ 			if (GetTileType(tile2) == MP_WATER || GetTileType(tile2) ==  MP_TREES)
+ 				cost -= 50;
+ 				
+ 			// tile left
+ 			tile2 = TILE_MASK(tile + TileOffsByDir((current->direction - 1) & 3));	
+ 			if (GetTileType(tile2) == MP_HOUSE || GetTileType(tile2) == MP_INDUSTRY)
+ 				cost += 100;
+ 			if (GetTileType(tile2) == MP_WATER || GetTileType(tile2) ==  MP_TREES)
+ 				cost -= 50;
+
 			break;
 		default:
 			break;
@@ -298,6 +410,11 @@
 	}
 
 	/* Determine extra costs */
+	
+	/* Check for reserved tracks (PBS) */
+	if (((as->user_data[NPF_PBS_MODE]&PBS_MODE_MASK) != PBS_MODE_NONE) && !(NPFGetFlag(current, NPF_FLAG_PBS_EXIT)) && !(NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) && (PBSTileUnavail(tile) & (1<<trackdir))) {
+		NPFSetFlag(current, NPF_FLAG_PBS_BLOCKED, true);
+	};
 
 	/* Check for signals */
 	if (IsTileType(tile, MP_RAILWAY) && HasSignalOnTrackdir(tile, trackdir)) {
@@ -315,6 +432,9 @@
 					cost += _patches.npf_rail_firstred_exit_penalty;
 				else
 					cost += _patches.npf_rail_firstred_penalty;
+
+				if (!(NPFGetFlag(current, NPF_FLAG_PBS_EXIT)) && !(NPFGetFlag(current, NPF_FLAG_PBS_RED)) && (NPFGetFlag(current, NPF_FLAG_PBS_CHOICE)))
+					NPFSetFlag(current, NPF_FLAG_PBS_RED, true);
 			}
 			/* Record the state of this signal */
 			NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, true);
@@ -322,9 +442,16 @@
 			/* Record the state of this signal */
 			NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, false);
 		}
+		
+		if (!NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL) && NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) {
+			cost += 1000;
+		}
+		if ((PBSIsPbsSignal(tile, trackdir)) && !NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL)) {
+			NPFSetFlag(current, NPF_FLAG_PBS_EXIT, true);
+		}
 		NPFSetFlag(current, NPF_FLAG_SEEN_SIGNAL, true);
 	}
-
+	
 	/* Penalise the tile if it is a target tile and the last signal was
 	 * red */
 	/* HACK: We create a new_node here so we can call EndNodeCheck. Ugly as hell
@@ -342,12 +469,25 @@
 	//TODO, with realistic acceleration, also the amount of straight track between
 	//      curves should be taken into account, as this affects the speed limit.
 
-	/* Check for reverse in depot */
-	if (IsTileDepotType(tile, TRANSPORT_RAIL) && !as->EndNodeCheck(as, &new_node)==AYSTAR_FOUND_END_NODE)
+
+	/* Check for depots */
+		if (IsTileDepotType(tile, TRANSPORT_RAIL)) {
 		/* Penalise any depot tile that is not the last tile in the path. This
 		 * _should_ penalise every occurence of reversing in a depot (and only
 		 * that) */
-		cost += _patches.npf_rail_depot_reverse_penalty;
+		if (!as->EndNodeCheck(as, &new_node)==AYSTAR_FOUND_END_NODE) 
+			cost += _patches.npf_rail_depot_reverse_penalty;
+		/* PBS stuff */
+		if (!NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL)) {
+			if (NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) {
+				cost += 1000;
+			}
+			if (PBSIsPbsSegment(tile, TrackdirToExitdir(ReverseTrackdir(trackdir))*2+1)) { // TODO: fix hack?
+				NPFSetFlag(current, NPF_FLAG_PBS_EXIT, true);
+			}
+		}
+		NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, false);
+	}
 
 	/* Check for occupied track */
 	//TODO
@@ -379,8 +519,12 @@
 	 * is correct */
 	if (
 		(fstd->station_index == -1 && tile == fstd->dest_coords) || /* We've found the tile, or */
-		(IsTileType(tile, MP_STATION) && _map2[tile] == fstd->station_index) /* the station */
+		(IsTileType(tile, MP_STATION) && _map2[tile] == fstd->station_index) || /* the station */
+		(NPFGetFlag(node, NPF_FLAG_PBS_TARGET_SEEN))
 	) {
+		NPFSetFlag(&current->path.node, NPF_FLAG_PBS_TARGET_SEEN, true);
+		if ((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE) && !NPFGetFlag(node, NPF_FLAG_SEEN_SIGNAL) && !IsEndOfLine(node->tile, node->direction))
+			return AYSTAR_DONE;
 		return AYSTAR_FOUND_END_NODE;
 	} else {
 		return AYSTAR_DONE;
@@ -397,8 +541,54 @@
 	ftd->best_path_dist = current->g;
 	ftd->best_bird_dist = 0;
 	ftd->node = current->path.node;
+	ftd->path = current->path;
 }
 
+bool IsEndOfLine(TileIndex tile, byte trackdir)
+{
+	byte exitdir = TrackdirToExitdir(trackdir);
+	TileIndex dst_tile;
+	uint32 ts;
+
+	// tunnel entrance?
+	if (IsTileType(tile, MP_TUNNELBRIDGE) && (_map5[tile] & 0xF0)==0 && (_map5[tile] & 3) == exitdir)
+		return false;
+
+	// depot
+	if (IsTileDepotType(tile, TRANSPORT_RAIL))
+		return false;
+
+	/* Calculate next tile */
+	dst_tile = tile + TileOffsByDir(exitdir);
+	// determine the track status on the next tile.
+	ts = GetTileTrackStatus(dst_tile, TRANSPORT_RAIL) & TrackdirReachesTrackdirs(trackdir);
+
+	if ( (uint16)ts == 0) 
+		return true;
+
+	{
+		byte src_type = GetTileRailType(tile, trackdir);
+		byte dst_type = GetTileRailType(dst_tile, TrackdirToExitdir(trackdir));
+		if (src_type != dst_type) {
+			return true;
+		}
+		if (GetTileOwner(tile) != GetTileOwner(dst_tile))
+			return true;
+
+		if (IsTileDepotType(dst_tile, TRANSPORT_RAIL) && (TrackdirToExitdir(trackdir) != ReverseDiagdir(GetDepotDirection(dst_tile, TRANSPORT_RAIL))))
+			return true;
+
+		/* Check for oneway signal against us */
+		if (IsTileType(dst_tile, MP_RAILWAY) && GetRailTileType(dst_tile) == RAIL_TYPE_SIGNALS) {
+			if (HasSignalOnTrackdir(dst_tile, ReverseTrackdir(FindFirstBit2x64(ts))) && !HasSignalOnTrackdir(dst_tile, FindFirstBit2x64(ts)))
+				// if one way signal not pointing towards us, stop going in this direction.
+				return true;
+		}
+
+		return false;
+	}
+};
+
 /* Will just follow the results of GetTileTrackStatus concerning where we can
  * go and where not. Uses AyStar.user_data[NPF_TYPE] as the transport type and
  * an argument to GetTileTrackStatus. Will skip tunnels, meaning that the
@@ -418,6 +608,8 @@
 	aystar->num_neighbours = 0;
 	DEBUG(npf, 4)("Expanding: (%d, %d, %d) [%d]", TileX(src_tile), TileY(src_tile), src_trackdir, src_tile);
 
+	aystar->EndNodeCheck(aystar, current);
+
 	/* Find dest tile */
 	if (IsTileType(src_tile, MP_TUNNELBRIDGE) && (_map5[src_tile] & 0xF0)==0 && (DiagDirection)(_map5[src_tile] & 3) == src_exitdir) {
 		/* This is a tunnel. We know this tunnel is our type,
@@ -507,7 +699,15 @@
 	/* Select only trackdirs we can reach from our current trackdir */
 	trackdirbits &= TrackdirReachesTrackdirs(src_trackdir);
 	if (_patches.forbid_90_deg && (type == TRANSPORT_RAIL || type == TRANSPORT_WATER)) /* Filter out trackdirs that would make 90 deg turns for trains */
-		trackdirbits &= ~TrackdirCrossesTrackdirs(src_trackdir);
+
+	trackdirbits &= ~TrackdirCrossesTrackdirs(src_trackdir);
+
+	if (KillFirstBit2x64(trackdirbits) != 0)
+		NPFSetFlag(&current->path.node, NPF_FLAG_PBS_CHOICE, true);
+
+	if (!(NPFGetFlag(&current->path.node, NPF_FLAG_PBS_EXIT)) && ((aystar->user_data[NPF_PBS_MODE]&PBS_MODE_MASK) == PBS_MODE_ANY))
+		trackdirbits &= ~PBSTileUnavail(dst_tile);
+
 	DEBUG(npf,6)("After filtering: (%d, %d), possible trackdirs: %#x", TileX(dst_tile), TileY(dst_tile), trackdirbits);
 
 	i = 0;
@@ -548,7 +748,7 @@
  * multiple targets that are spread around, we should perform a breadth first
  * search by specifiying CalcZero as our heuristic.
  */
-NPFFoundTargetData NPFRouteInternal(AyStarNode* start1, AyStarNode* start2, NPFFindStationOrTileData* target, AyStar_EndNodeCheck target_proc, AyStar_CalculateH heuristic_proc, TransportType type, Owner owner, uint reverse_penalty) {
+NPFFoundTargetData NPFRouteInternal(AyStarNode* start1, AyStarNode* start2, NPFFindStationOrTileData* target, AyStar_EndNodeCheck target_proc, AyStar_CalculateH heuristic_proc, TransportType type, Owner owner, uint reverse_penalty, byte pbs_mode) {
 	int r;
 	NPFFoundTargetData result;
 
@@ -566,6 +766,11 @@
 	else
 		assert(0);
 
+	if (pbs_mode != PBS_MODE_NONE)
+		_npf_aystar.BeforeExit = NPFReservePBSPath;
+	else
+		_npf_aystar.BeforeExit = NULL;
+
 	/* Initialize Start Node(s) */
 	start1->user_data[NPF_TRACKDIR_CHOICE] = INVALID_TRACKDIR;
 	start1->user_data[NPF_NODE_FLAGS] = 0;
@@ -589,6 +794,7 @@
 	/* Initialize user_data */
 	_npf_aystar.user_data[NPF_TYPE] = type;
 	_npf_aystar.user_data[NPF_OWNER] = owner;
+	_npf_aystar.user_data[NPF_PBS_MODE] = pbs_mode;
 
 	/* GO! */
 	r = AyStarMain_Main(&_npf_aystar);
@@ -606,7 +812,7 @@
 	return result;
 }
 
-NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner) {
+NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode) {
 	AyStarNode start1;
 	AyStarNode start2;
 
@@ -619,11 +825,25 @@
 	start2.direction = trackdir2;
 	start2.user_data[NPF_TRACKDIR_CHOICE] = INVALID_TRACKDIR;
 
-	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), target, NPFFindStationOrTile, NPFCalcStationOrTileHeuristic, type, owner, 0);
+	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), target, NPFFindStationOrTile, NPFCalcStationOrTileHeuristic, type, owner, 0, pbs_mode);
 }
 
-NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner) {
-	return NPFRouteToStationOrTileTwoWay(tile, trackdir, INVALID_TILE, 0, target, type, owner);
+/*<<<<<<< .mine
+NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, byte trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode) {
+	AyStarNode start;
+
+	assert(tile != 0);
+
+	start.tile = tile;
+	start.direction = trackdir;
+	/ * We set this in case the target is also the start tile, we will just
+	 * return a not found then * /
+	start.user_data[NPF_TRACKDIR_CHOICE] = 0xff;
+
+	return NPFRouteToStationOrTileTwoWay(tile, trackdir, INVALID_TILE, 0, target, type, owner, pbs_mode);
+-------*/
+NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode) {
+	return NPFRouteToStationOrTileTwoWay(tile, trackdir, INVALID_TILE, 0, target, type, owner, pbs_mode);
 }
 
 NPFFoundTargetData NPFRouteToDepotBreadthFirstTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, TransportType type, Owner owner, uint reverse_penalty) {
@@ -641,7 +861,7 @@
 
 	/* perform a breadth first search. Target is NULL,
 	 * since we are just looking for any depot...*/
-	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), NULL, NPFFindDepot, NPFCalcZero, type, owner, reverse_penalty);
+	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), NULL, NPFFindDepot, NPFCalcZero, type, owner, reverse_penalty, PBS_MODE_NONE);
 }
 
 NPFFoundTargetData NPFRouteToDepotBreadthFirst(TileIndex tile, Trackdir trackdir, TransportType type, Owner owner) {
@@ -692,6 +912,8 @@
 	else
 		assert(0);
 
+	_npf_aystar.BeforeExit = NULL;
+
 	/* Initialize target */
 	target.station_index = -1; /* We will initialize dest_coords inside the loop below */
 	_npf_aystar.user_target = &target;
@@ -699,6 +921,7 @@
 	/* Initialize user_data */
 	_npf_aystar.user_data[NPF_TYPE] = type;
 	_npf_aystar.user_data[NPF_OWNER] = owner;
+	_npf_aystar.user_data[NPF_PBS_MODE] = PBS_MODE_NONE;
 
 	/* Initialize Start Node */
 	start.tile = tile;
Index: vehicle_gui.c
===================================================================
--- vehicle_gui.c	(revision 2456)
+++ vehicle_gui.c	(working copy)
@@ -10,6 +10,8 @@
 #include "gui.h"
 #include "command.h"
 #include "gfx.h"
+#include "station.h"
+#include "waypoint.h"
 
 VehicleSortListingTypeFunctions * const _vehicle_sorter[] = {
 	&VehicleUnsortedSorter,
@@ -1061,3 +1063,90 @@
 {
 	memset(&_sorting, 0, sizeof(_sorting));
 }
+
+void BuildVehicleListMasked(vehiclelist_d *vl, DisplayListOptions *listopt, int owner)
+{
+	int subtype = (HASBIT(listopt->veh_type_mask, 1 << VEH_Aircraft)) ? 2 : TS_Front_Engine;
+	int n = 0;
+	int i;
+	uint32 cmask;
+
+	if (!(vl->flags & VL_REBUILD)) return;
+
+	/* Create array for sorting */
+	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
+	if (_vehicle_sort == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+
+	DEBUG(misc, 1) ("Building vehicle list for player %d station at %d...",
+		owner, listopt->xy);
+	
+	if (listopt->xy < MapSize()) {
+		const Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->veh_type_mask, v->type) && v->subtype <= subtype)
+			{
+				const Vehicle *u = v;
+				cmask = HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], v->cargo_type);
+				while (u->next != NULL) {
+					cmask |= HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], u->cargo_type);
+					u = u->next;
+				}
+				if (listopt->cargo_mask & cmask) {
+					const Order *order;
+
+					FOR_VEHICLE_ORDERS(v, order) {
+						switch (order->type)
+						{
+							case OT_GOTO_STATION:
+								if (GetStation(order->station)->xy == listopt->xy) {
+									_vehicle_sort[n].index = v->index;
+									_vehicle_sort[n].owner = v->owner;
+									++n;
+									break;
+								} break;
+							case OT_GOTO_WAYPOINT:
+								if (GetWaypoint(order->station)->xy == listopt->xy) {
+									_vehicle_sort[n].index = v->index;
+									_vehicle_sort[n].owner = v->owner;
+									++n;
+									break;
+								} break;
+							default: break;
+						}
+					}
+				}
+			}
+		}
+	} else {
+		Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->veh_type_mask, v->type) && v->subtype <= subtype && v->owner == owner)
+			{
+				Vehicle *u = v;
+				cmask = HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], v->cargo_type);
+				u = v; // search all cargotypes of consist
+				while (u->next != NULL) {
+					cmask |= HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], u->cargo_type);
+					u = u->next;
+				}
+				if (listopt->cargo_mask & cmask) {
+					_vehicle_sort[n].index = v->index;
+					_vehicle_sort[n].owner = v->owner;
+					++n;
+				}
+			}
+		}
+	}
+
+	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
+	if (n!=0 && vl->sort_list == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+	vl->list_length = n;
+
+	for (i = 0; i < n; ++i)
+		vl->sort_list[i] = _vehicle_sort[i];
+
+	vl->flags &= ~VL_REBUILD;
+	vl->flags |= VL_RESORT;
+}
Index: pbs.c
===================================================================
--- pbs.c	(revision 0)
+++ pbs.c	(revision 0)
@@ -0,0 +1,239 @@
+#include "stdafx.h"
+#include "openttd.h"
+#include "pbs.h"
+#include "functions.h"
+#include "debug.h"
+#include "map.h"
+#include "tile.h"
+#include "npf.h"
+#include "pathfind.h"
+#include "depot.h"
+
+/** @file pbs.c Path-Based-Signalling implementation file
+ *  @see pbs.h */
+
+/* reserved track encoding:
+ normal railway tracks:
+   map3lo bits 4..6 = railbit of reserved track + 1, if this is zero it means nothing is reserved on this tile
+   map3lo bit  7    = if this is set, then the opposite rail (rb^1) is also reserved
+ waypoints/stations:
+   map3lo bit 6 set = track is reserved
+ tunnels/bridges:
+   map3hi bit 0 set = track with railbit 0 is reserved
+   map3hi bit 1 set = track with railbit 1 is reserved
+ level crossings:
+   map5 bit 3 set = the rail track is reserved
+*/
+
+/**
+ * maps an encoded reserved track (from map3lo bits 4..7)
+ * to the tracks that are reserved.
+ * 0xFF are invalid entries and should never be accessed.
+ */
+static const byte encrt_to_reserved[16] = {
+	0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0xFF,
+	0xFF, 0xFF, 0xFF, 0x0C, 0x0C, 0x30, 0x30, 0xFF
+};
+
+/**
+ * maps an encoded reserved track (from map3lo bits 4..7)
+ * to the track(dir)s that are unavailable due to reservations.
+ * 0xFFFF are invalid entries and should never be accessed.
+ */
+static const int16 encrt_to_unavail[16] = {
+	0x0000, 0x3F3F, 0x3F3F, 0x3737, 0x3B3B, 0x1F1F, 0x2F2F, 0xFFFF,
+	0xFFFF, 0xFFFF, 0xFFFF, 0x3F3F, 0x3F3F, 0x3F3F, 0x3F3F, 0xFFFF
+};
+
+void PBSReserveTrack(TileIndex tile, byte track) {
+	assert(IsValidTile(tile));
+	assert(track <= 5);
+	switch (GetTileType(tile)) {
+		case MP_RAILWAY:
+			if ((_map5[tile] & ~1) == 0xC4) {
+				// waypoint
+				SETBIT(_map3_lo[tile], 6);
+			} else {
+				// normal rail track
+				byte encrt = (_map3_hi[tile] & 0xF0) >> 4;
+
+				if (encrt == 0)
+					encrt = track + 1;
+				else if (encrt == (track^1) + 1)
+					encrt |= 8;
+
+				_map3_hi[tile] &= ~0xF0;
+				_map3_hi[tile] |= encrt << 4;
+			}
+			break;
+		case MP_TUNNELBRIDGE:
+			_map3_hi[tile] |= (1 << track) & 3;
+			break;
+		case MP_STATION:
+			SETBIT(_map3_lo[tile], 6);
+			break;
+		case MP_STREET:
+			// make sure it is a railroad crossing
+			if (!IsLevelCrossing(tile)) return;
+			SETBIT(_map5[tile], 0);
+			break;
+		default:
+			return;
+	};
+#ifdef PBS_SHOW_RESERVED
+	MarkTileDirtyByTile(tile);
+#endif
+}
+
+byte PBSTileReserved(TileIndex tile) {
+	assert(IsValidTile(tile));
+	switch (GetTileType(tile)) {
+		case MP_RAILWAY:
+			if ((_map5[tile] & ~1) == 0xC4) {
+				// waypoint
+				return HASBIT(_map3_lo[tile], 6) ? 3 : 0;
+			} else {
+				// normal track
+				byte res = encrt_to_reserved[(_map3_hi[tile] & 0xF0) >> 4];
+				assert(res != 0xFF);
+				return res;
+			};
+		case MP_TUNNELBRIDGE:
+			return (_map3_hi[tile] & 3);
+		case MP_STATION:
+			return HASBIT(_map3_lo[tile], 6) ? 3 : 0;
+		case MP_STREET:
+			// make sure its a railroad crossing
+			if (!IsLevelCrossing(tile)) return 0;
+			// check if its reserved
+			if (!HASBIT(_map5[tile], 0)) return 0;
+			// return the track for the correct direction
+			return HASBIT(_map5[tile], 3) ? 1 : 2;
+		default:
+			return 0;
+	};
+};
+
+uint16 PBSTileUnavail(TileIndex tile) {
+	assert(IsValidTile(tile));
+	switch (GetTileType(tile)) {
+		case MP_RAILWAY:
+			if ((_map5[tile] & ~1) == 0xC4) {
+				// waypoint
+				return HASBIT(_map3_lo[tile], 6) ? 0x3F3F : 0;
+			} else {
+				// normal track
+				uint16 res = encrt_to_unavail[(_map3_hi[tile] & 0xF0) >> 4];
+				assert(res != 0xFFFF);
+				return res;
+			};
+		case MP_TUNNELBRIDGE:
+			return (_map3_hi[tile] & 3) | ((_map3_hi[tile] & 3) << 8);
+		case MP_STATION:
+			return HASBIT(_map3_lo[tile], 6) ? 0x3F3F : 0;
+		case MP_STREET:
+			// make sure its a railroad crossing
+			if (!IsLevelCrossing(tile)) return 0;
+			// check if its reserved
+			return (HASBIT(_map5[tile], 0)) ? 0x3F3F : 0;
+		default:
+			return 0;
+	};
+};
+
+void PBSClearTrack(TileIndex tile, byte track) {
+	assert(IsValidTile(tile));
+	assert(track <= 5);
+	switch (GetTileType(tile)) {
+		case MP_RAILWAY:
+			if ((_map5[tile] & ~1) == 0xC4) {
+				// waypoint
+				CLRBIT(_map3_lo[tile], 6);
+			} else {
+				// normal rail track
+				byte encrt = (_map3_hi[tile] & 0xF0) >> 4;
+
+				if (encrt == track + 1)
+					encrt = 0;
+				else if (encrt == track + 1 + 8)
+					encrt = (track^1) + 1;
+				else if (encrt == (track^1) + 1 + 8)
+					encrt &= 7;
+
+				_map3_hi[tile] &= ~0xF0;
+				_map3_hi[tile] |= encrt << 4;
+			}
+			break;
+		case MP_TUNNELBRIDGE:
+			_map3_hi[tile] &= ~((1 << track) & 3);
+			break;
+		case MP_STATION:
+			CLRBIT(_map3_lo[tile], 6);
+			break;
+		case MP_STREET:
+			// make sure it is a railroad crossing
+			if (!IsLevelCrossing(tile)) return;
+			CLRBIT(_map5[tile], 0);
+			break;
+		default:
+			return;
+	};
+#ifdef PBS_SHOW_RESERVED
+	MarkTileDirtyByTile(tile);
+#endif
+};
+
+void PBSClearPath(TileIndex tile, byte trackdir) {
+	uint16 res;
+	FindLengthOfTunnelResult flotr;
+	assert(IsValidTile(tile));
+	assert((trackdir & ~8) <= 5);
+	do {
+		PBSClearTrack(tile, trackdir & 7);
+
+		if (IsTileType(tile, MP_TUNNELBRIDGE) && (_map5[tile] & 0xF0)==0 && (unsigned)(_map5[tile] & 3) == TrackdirToExitdir(trackdir)) {
+			// this is a tunnel
+			flotr = FindLengthOfTunnel(tile, TrackdirToExitdir(trackdir));
+
+			tile = flotr.tile;
+		} else {
+			byte exitdir = TrackdirToExitdir(trackdir);
+			if (IsTileDepotType(tile, TRANSPORT_RAIL) && (exitdir != GetDepotDirection(tile, TRANSPORT_RAIL)))
+				return;
+			tile = AddTileIndexDiffCWrap(tile, TileIndexDiffCByDir(exitdir));
+			if (IsTileDepotType(tile, TRANSPORT_RAIL) && (exitdir != ReverseDiagdir(GetDepotDirection(tile, TRANSPORT_RAIL))))
+				return;
+		};
+
+		res = PBSTileReserved(tile);
+		res |= res << 8;
+		res &= TrackdirReachesTrackdirs(trackdir);
+		trackdir = FindFirstBit2x64(res);
+
+	} while (res != 0);
+};
+
+bool PBSIsPbsSignal(TileIndex tile, byte trackdir)
+{
+	assert(IsValidTile(tile));
+	assert((trackdir & ~8) <= 5);
+
+	if (!_patches.new_pathfinding_all)
+		return false;
+
+	if (!IsTileType(tile, MP_RAILWAY))
+		return false;
+
+	if (GetRailTileType(tile) != RAIL_TYPE_SIGNALS)
+		return false;
+
+	if (!(_map3_lo[tile] & _signal_along_trackdir[trackdir]))
+		return false;
+
+	//if ((_map3_hi[tile] & 3) == 3)
+	if ((_map3_hi[tile] & 8) == 8)
+		return true;
+	else
+		return false;
+};
+
Index: debug.c
===================================================================
--- debug.c	(revision 2456)
+++ debug.c	(working copy)
@@ -14,6 +14,7 @@
 int _debug_net_level;
 int _debug_spritecache_level;
 int _debug_oldloader_level;
+int _debug_pbs_level;
 int _debug_npf_level;
 
 
@@ -44,6 +45,7 @@
 	DEBUG_LEVEL(net),
 	DEBUG_LEVEL(spritecache),
 	DEBUG_LEVEL(oldloader),
+	DEBUG_LEVEL(pbs),
 	DEBUG_LEVEL(npf)
 	};
 #undef DEBUG_LEVEL
Index: rail.c
===================================================================
--- rail.c	(revision 2456)
+++ rail.c	(working copy)
@@ -75,6 +75,15 @@
 	{TRACKDIR_RIGHT_N,  TRACKDIR_RIGHT_S,  INVALID_TRACKDIR,  INVALID_TRACKDIR}
 };
 
+const Trackdir _track_enterdir_to_trackdir[6][4] = { // TODO: replace magic with enums
+	{0,    0xff, 8,    0xff},
+	{0xff, 1,    0xff, 9},
+	{0xff, 2,    10,   0xff},
+	{3,    0xff, 0xff, 11},
+	{12,   4,    0xff, 0xff},
+	{0xff, 0xff, 5,    13}
+};
+
 const Trackdir _track_direction_to_trackdir[][DIR_END] = {
 	{INVALID_TRACKDIR, TRACKDIR_DIAG1_NE, INVALID_TRACKDIR, INVALID_TRACKDIR,  INVALID_TRACKDIR, TRACKDIR_DIAG1_SW, INVALID_TRACKDIR, INVALID_TRACKDIR},
 	{INVALID_TRACKDIR, INVALID_TRACKDIR,  INVALID_TRACKDIR, TRACKDIR_DIAG2_SE, INVALID_TRACKDIR, INVALID_TRACKDIR,  INVALID_TRACKDIR, TRACKDIR_DIAG2_NW},
Index: npf.h
===================================================================
--- npf.h	(revision 2456)
+++ npf.h	(working copy)
@@ -4,6 +4,7 @@
 #include "openttd.h"
 #include "aystar.h"
 #include "vehicle.h"
+#include "pbs.h"
 #include "tile.h"
 #include "rail.h"
 
@@ -35,16 +36,23 @@
 enum { /* Indices into AyStar.userdata[] */
 	NPF_TYPE = 0, /* Contains a TransportTypes value */
 	NPF_OWNER, /* Contains an Owner value */
+	NPF_PBS_MODE, /* Contains the pbs mode, see pbs.h */
 };
 
 enum { /* Indices into AyStarNode.userdata[] */
 	NPF_TRACKDIR_CHOICE = 0, /* The trackdir chosen to get here */
 	NPF_NODE_FLAGS,
 };
+
 typedef enum { /* Flags for AyStarNode.userdata[NPF_NODE_FLAGS]. Use NPFGetBit() and NPFGetBit() to use them. */
 	NPF_FLAG_SEEN_SIGNAL, /* Used to mark that a signal was seen on the way, for rail only */
 	NPF_FLAG_REVERSE, /* Used to mark that this node was reached from the second start node, if applicable */
 	NPF_FLAG_LAST_SIGNAL_RED, /* Used to mark that the last signal on this path was red */
+	NPF_FLAG_PBS_EXIT, /* Used to mark tracks inside a pbs block, for rail only, for the end node, this is set when the path found goes through a pbs block */
+	NPF_FLAG_PBS_BLOCKED, /* Used to mark that this path crosses another pbs path */
+	NPF_FLAG_PBS_RED, /* Used to mark that this path goes through a red exit-pbs signal */
+	NPF_FLAG_PBS_CHOICE, /*  */
+	NPF_FLAG_PBS_TARGET_SEEN, /*  */
 } NPFNodeFlag;
 
 typedef struct NPFFoundTargetData { /* Meant to be stored in AyStar.userpath */
@@ -52,6 +60,7 @@
 	uint best_path_dist; /* The shortest path. Is (uint)-1 if no path is found */
 	Trackdir best_trackdir; /* The trackdir that leads to the shortest path/closest birds dist */
 	AyStarNode node; /* The node within the target the search led us to */
+	PathNode path;
 } NPFFoundTargetData;
 
 /* These functions below are _not_ re-entrant, in favor of speed! */
@@ -59,12 +68,14 @@
 /* Will search from the given tile and direction, for a route to the given
  * station for the given transport type. See the declaration of
  * NPFFoundTargetData above for the meaning of the result. */
-NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner);
+NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode);
+
 /* Will search as above, but with two start nodes, the second being the
  * reverse. Look at the NPF_FLAG_REVERSE flag in the result node to see which
  * direction was taken (NPFGetBit(result.node, NPF_FLAG_REVERSE)) */
-NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner);
 
+NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode);
+
 /* Will search a route to the closest depot. */
 
 /* Search using breadth first. Good for little track choice and inaccurate
Index: vehicle_gui.h
===================================================================
--- vehicle_gui.h	(revision 2456)
+++ vehicle_gui.h	(working copy)
@@ -5,6 +5,12 @@
 
 struct vehiclelist_d;
 
+typedef struct DisplayListOptions {
+	uint32 cargo_mask;
+	uint32 veh_type_mask;
+	TileIndex xy;
+} DisplayListOptions;
+
 void DrawVehicleProfitButton(Vehicle *v, int x, int y);
 CargoID DrawVehicleRefitWindow(const Vehicle *v, int sel);
 void InitializeVehiclesGuiList(void);
@@ -15,6 +21,7 @@
 
 void BuildVehicleList(struct vehiclelist_d *vl, int type, int owner, int station);
 void SortVehicleList(struct vehiclelist_d *vl);
+void BuildVehicleListMasked(struct vehiclelist_d *vl, struct DisplayListOptions *listopt, int owner);
 
 int CDECL GeneralOwnerSorter(const void *a, const void *b);
 VARDEF uint32	_internal_name_sorter_id;	// internal StringID for default vehicle-names
Index: network.c
===================================================================
--- network.c	(revision 2456)
+++ network.c	(working copy)
@@ -547,10 +547,19 @@
 
 	if (_network_server) {
 		// We just lost one client :(
-		if (cs->status > STATUS_INACTIVE)
+		_network_clients_connected--;
+		if (cs->status > STATUS_INACTIVE) {
 			_network_game_info.clients_on--;
-		_network_clients_connected--;
 
+			if (cs->status == STATUS_ACTIVE && _network_game_info.clients_on == 0 &&
+					_network_pause_on_no_clients &&	_network_dedicated) {
+				// Pause game as now no active clients connected
+				DoCommandP(0, 1, 0, NULL, CMD_PAUSE);
+			
+				NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game paused (no clients)", NETWORK_SERVER_INDEX);
+			}
+		}
+
 		while ((cs + 1) != DEREF_CLIENT(MAX_CLIENTS) && (cs + 1)->socket != INVALID_SOCKET) {
 			*cs = *(cs + 1);
 			*ci = *(ci + 1);
@@ -979,6 +988,14 @@
 	/* Try to register us to the master server */
 	_network_last_advertise_date = 0;
 	NetworkUDPAdvertise();
+
+	// Possible not the correct place for this
+	if (_network_dedicated && _network_pause_on_no_clients) {
+		// Pause server as there are no clients connected yet
+		DoCommandP(0, 1, 0, NULL, CMD_PAUSE);
+		
+		NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game paused (no clients)", NETWORK_SERVER_INDEX);
+	}
 	return true;
 }
 
Index: pbs.h
===================================================================
--- pbs.h	(revision 0)
+++ pbs.h	(revision 0)
@@ -0,0 +1,92 @@
+#ifndef PBS_H
+#define PBS_H
+
+/** @file pbs.h Path-Based-Signalling header file
+ *  @see pbs.c */
+
+#include "vehicle.h"
+#include "tile.h"
+#include "map.h"
+#include "rail.h"
+
+/// With this enabled, reserved tracks will be shown darkened
+#define PBS_SHOW_RESERVED
+
+/**
+ * constants used for pbs_mode argument of npf-functions
+ */
+enum pbs_modes {
+	PBS_MODE_NONE = 0,		// no pbs
+	PBS_MODE_GREEN = 1,		// look for green exit signal from pbs block
+	PBS_MODE_ANY = 2,			// look for any exit signal from block
+
+	PBS_MODE_MASK = 0x0F,
+
+	//PBS_MODE_FLAG_SAVE = 1 << 8,
+};
+
+/**
+ * constants used for v->u.rail.pbs_status
+ */
+enum PBSStatus {
+	PBS_STAT_NONE = 0,
+	PBS_STAT_HAS_PATH = 1,
+	PBS_STAT_NEED_PATH = 2,
+};
+
+
+void PBSReserveTrack(TileIndex tile, byte track);
+/**<
+ * Marks a track as reserved.
+ * @param tile The tile of the track.
+ * @param track The track to reserve, valid values 0-5.
+ */
+
+byte PBSTileReserved(TileIndex tile);
+/**<
+ * Check which tracks are reserved on a tile.
+ * @param tile The tile which you want to check.
+ * @return The tracks reserved on that tile, each of the bits 0-5 is set when the corresponding track is reserved.
+ */
+
+uint16 PBSTileUnavail(TileIndex tile);
+/**<
+ * Check which trackdirs are unavailable due to reserved tracks on a tile.
+ * @param tile The tile which you want to check.
+ * @return The tracks reserved on that tile, each of the bits 0-5,8-13 is set when the corresponding trackdir is unavailable.
+ */
+
+void PBSClearTrack(TileIndex tile, byte track);
+/**<
+ * Unreserves a track.
+ * @param tile The tile of the track.
+ * @param track The track to unreserve, valid values 0-5.
+ */
+
+void PBSClearPath(TileIndex tile, byte trackdir);
+/**<
+ * Follows a planned(reserved) path, and unreserves the tracks.
+ * @param tile The tile on which the path starts
+ * @param trackdir The trackdirection in which the path starts
+ */
+
+bool PBSIsPbsSignal(TileIndex tile, byte trackdir);
+/**<
+ * Checks if there are pbs signals on a track.
+ * @param tile The tile you want to check
+ * @param trackdir The trackdir you want to check
+ * @return True when there are pbs signals on that tile
+ */
+
+bool PBSIsPbsSegment(uint tile, byte direction);
+/**<
+ * Checks if all signals encountered by going in a certain direction from a tile are pbs signals,
+ * used to check if a depot is inside a pbs block.
+ * @param tile The start tile (depot tile)
+ * @param direction The direction to go in
+ * @return True when only pbs signals are encountered
+ * TODO: Ditch the direction argument, this function is only used for depots, and then this can be extracted from the tile
+ * TODO: This function is a bit hackish atm, at least move it to pbs.c or something
+ */
+
+#endif
Index: debug.h
===================================================================
--- debug.h	(revision 2456)
+++ debug.h	(working copy)
@@ -14,6 +14,7 @@
 	extern int _debug_net_level;
 	extern int _debug_spritecache_level;
 	extern int _debug_oldloader_level;
+	extern int _debug_pbs_level;
 	extern int _debug_npf_level;
 #endif
 
Index: rail.h
===================================================================
--- rail.h	(revision 2456)
+++ rail.h	(working copy)
@@ -317,6 +317,15 @@
 }
 
 /**
+ * Maps a track and an (4-way) dir to the trackdir that represents the track
+ * with the exit in the given direction.
+ */
+static inline Trackdir TrackEnterdirToTrackdir(Track track, DiagDirection diagdir) {
+	extern const Trackdir _track_enterdir_to_trackdir[TRACK_END][DIAGDIR_END];
+	return _track_enterdir_to_trackdir[track][diagdir];
+}
+
+/**
  * Maps a track and a full (8-way) direction to the trackdir that represents
  * the track running in the given direction.
  */
Index: network.h
===================================================================
--- network.h	(revision 2456)
+++ network.h	(working copy)
@@ -163,6 +163,7 @@
 
 VARDEF uint16 _network_max_join_time;             //! Time a client can max take to join
 VARDEF bool _network_pause_on_join;               //! Pause the game when a client tries to join (more chance of succeeding join)
+VARDEF bool _network_pause_on_no_clients; ///< Pause the game if there are no clients connected
 
 VARDEF uint16 _redirect_console_to_client;
 
Index: airport_movement.h
===================================================================
--- airport_movement.h	(revision 2456)
+++ airport_movement.h	(working copy)
@@ -108,10 +108,10 @@
 	{  3, 40,AMED_NOSPDCLAMP | AMED_BRAKE,0},			// 12 Just landed, brake until end of runway
 	{  7, 40,0,0},																// 13 Just landed, turn around and taxi 1 square
 	{ 53, 40,0,0},																// 14 Taxi from runway to crossing
-	{-31,193,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 15 Fly around waiting for a landing spot (north-east)
-	{  1,  1,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 16 Fly around waiting for a landing spot (north-west)
-	{257,  1,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 17 Fly around waiting for a landing spot (south-west)
-	{273, 49,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 18 Fly around waiting for a landing spot (south)
+	{145,-58,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 15 Fly around waiting for a landing spot (north-east)
+	{260,-58,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 16 Fly around waiting for a landing spot (north-west)
+	{291, 17,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 17 Fly around waiting for a landing spot (south-west)
+	{177, 40,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 18 Fly around waiting for a landing spot (south)
 	{ 44, 37,AMED_HELI_RAISE,0},									// 19 Helicopter takeoff
 	{ 44, 40,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 20 In position above landing spot helicopter
 	{ 44, 40,AMED_HELI_LOWER,0}										// 21 Helicopter landing
@@ -137,10 +137,10 @@
 	{  3, 85,AMED_NOSPDCLAMP | AMED_BRAKE,0},			// 15 Just landed, brake until end of runway
 	{ 20, 87,0,0},																// 16 Just landed, turn around and taxi 1 square
 	{ 36, 71,0,0},																// 17 Taxi from runway to crossing
-	{-31,193,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 18 Fly around waiting for a landing spot (north-east)
-	{  1,  1,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 19 Fly around waiting for a landing spot (north-west)
-	{257,  1,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 20 Fly around waiting for a landing spot (south-west)
-	{273, 49,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 21 Fly around waiting for a landing spot (south)
+	{145,-13,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 19 Fly around waiting for a landing spot (north-east)
+	{260,-13,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 20 Fly around waiting for a landing spot (north-west)
+	{291, 62,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 21 Fly around waiting for a landing spot (south-west)
+	{177, 85,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 22 Fly around waiting for a landing spot (south)
 	{ 44, 63,AMED_HELI_RAISE,0},									// 22 Helicopter takeoff
 	{ 28, 74,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 23 In position above landing spot helicopter
 	{ 28, 74,AMED_HELI_LOWER,0}										// 24 Helicopter landing
@@ -167,10 +167,10 @@
 	{ 21, 85,0,0},																// 16 Just landed, turn around and taxi 1 square
 	{ 21, 69,0,0},																// 17 On Runway-out taxiing to In-Way
 	{ 21, 54,AMED_EXACTPOS,5},										// 18 Taxi from runway to crossing
-	{-31,193,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 19 Fly around waiting for a landing spot (north-east)
-	{  1,  1,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 20 Fly around waiting for a landing spot (north-west)
-	{257,  1,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 21 Fly around waiting for a landing spot (south-west)
-	{273, 49,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 22 Fly around waiting for a landing spot (south)
+	{145,-13,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 19 Fly around waiting for a landing spot (north-east)
+	{260,-13,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 20 Fly around waiting for a landing spot (north-west)
+	{291, 62,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 21 Fly around waiting for a landing spot (south-west)
+	{177, 85,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 22 Fly around waiting for a landing spot (south)
 	{ 44, 58,0,0},																// 23 Helicopter takeoff spot on ground (to clear airport sooner)
 	{ 44, 63,AMED_HELI_RAISE,0},									// 24 Helicopter takeoff
 	{ 15, 54,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 25 Get in position above landing spot helicopter
@@ -216,10 +216,10 @@
 	{  3,104,AMED_NOSPDCLAMP | AMED_BRAKE,0},			// 34 Just landed, brake until end of runway
 	{ 12,104,0,0},																// 35 Just landed, turn around and taxi 1 square
 	{  7, 84,0,0},																// 36 Taxi from runway to crossing
-	{-31,209,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 37 Fly around waiting for a landing spot (north-east)
-	{  1,  6,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 38 Fly around waiting for a landing spot (north-west)
-	{273,  6,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 39 Fly around waiting for a landing spot (south-west)
-	{305, 81,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 40 Fly around waiting for a landing spot (south)
+	{193,  6,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 37 Fly around waiting for a landing spot (north-east)
+	{388,  6,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 38 Fly around waiting for a landing spot (north-west)
+	{419, 81,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 39 Fly around waiting for a landing spot (south-west)
+	{305,104,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 40 Fly around waiting for a landing spot (south)
 	// Helicopter
 	{128, 80,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 41 Bufferspace before helipad
 	{128, 80,AMED_NOSPDCLAMP | AMED_SLOWTURN,0},	// 42 Bufferspace before helipad
Index: misc_gui.c
===================================================================
--- misc_gui.c	(revision 2456)
+++ misc_gui.c	(working copy)
@@ -1690,14 +1690,15 @@
 	{CE_BOOL, 0, STR_CHEAT_SETUP_PROD,			&_cheats.setup_prod.value,			&_cheats.setup_prod.been_used,			NULL,											0, 0, 0},
 	{CE_UINT8, 0, STR_CHEAT_SWITCH_CLIMATE, &_opt.landscape, 								&_cheats.switch_climate.been_used,	&ClickChangeClimateCheat,-1, 4, 1},
 	{CE_UINT8, 0, STR_CHEAT_CHANGE_DATE,		&_cur_year,											&_cheats.change_date.been_used,			&ClickChangeDateCheat,	 -1, 1, 1},
+	{CE_BOOL, 0, STR_CHEAT_RESET_STATION,			&_cheats.reset_station.value,			&_cheats.reset_station.been_used,			NULL,											0, 0, 0},
 };
 
 
 static const Widget _cheat_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   399,     0,    13, STR_CHEATS,	STR_018C_WINDOW_TITLE_DRAG_THIS},
-{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_NULL},
-{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_CHEATS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_CHEATS_TIP},
 {   WIDGETS_END},
 };
 
@@ -1832,7 +1833,7 @@
 	}
 }
 static const WindowDesc _cheats_desc = {
-	240, 22, 400, 160,
+	240, 22, 400, 174,
 	WC_CHEATS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
 	_cheat_widgets,
Index: lang/american.txt
===================================================================
--- lang/american.txt	(revision 2456)
+++ lang/american.txt	(working copy)
@@ -1092,6 +1092,9 @@
 STR_CONFIG_PATCHES_QUERY_CAPT                                   :{WHITE}Change setting value
 STR_CONFIG_PATCHES_SERVICE_INTERVAL_INCOMPATIBLE                :{WHITE}Some or all of the default service interval(s) below are incompatible with chosen setting! 5-90% and 30-800 days are valid
 
+STR_CONFIG_PATCHES_AIRQUEUE										:{LTBLUE}Queue aircraft at airports{ORANGE}
+STR_CONFIG_PATCHES_AIR_COEFF									:{LTBLUE}Aircraft speedup (1=TTD default, 8=realistic):{ORANGE} {STRING}
+
 STR_TEMPERATE_LANDSCAPE                                         :temperate landscape
 STR_SUB_ARCTIC_LANDSCAPE                                        :sub-arctic landscape
 STR_SUB_TROPICAL_LANDSCAPE                                      :sub-tropical landscape
Index: lang/english.txt
===================================================================
--- lang/english.txt	(revision 2456)
+++ lang/english.txt	(working copy)
@@ -787,13 +787,18 @@
 STR_02DE_MAP_OF_WORLD                                           :Map of world
 STR_EXTRA_VIEW_PORT                                             :Extra viewport
 STR_SIGN_LIST                                                   :Sign list
+
 STR_02DF_TOWN_DIRECTORY                                         :Town directory
 STR_TOWN_POPULATION                                             :{BLACK}World population: {COMMA32}
 STR_EXTRA_VIEW_PORT_TITLE                                       :{WHITE}Viewport {COMMA16}
-STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN                                :{BLACK}Copy to viewport
-STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN_TT                             :{BLACK}Copy the location of the global view to this viewport
-STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW                                :{BLACK}Paste from viewport
-STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW_TT                             :{BLACK}Paste the location of this viewport to the global view
+STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN                                :{BLACK}Go to location
+STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN_TT                             :{BLACK}Paste the location of this viewport into the global view
+STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW                                :{BLACK}Set location
+STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW_TT                             :{BLACK}Copy the location of the global view into this viewport
+ 
+STR_ZOOM_IN_SMALLMAP                             :{BLACK}Zoom in the small map
+STR_ZOOM_OUT_SMALLMAP                             :{BLACK}Zoom out the small map
+STR_RECENTRE_SMALLMAP                             :{BLACK}Recentre the location of the small map
 
 STR_02E0_CURRENCY_UNITS                                         :{BLACK}Currency units
 STR_02E1                                                        :{BLACK}{SKIP}{STRING}
@@ -1079,6 +1084,7 @@
 STR_CONFIG_PATCHES_TOOLBAR_POS_RIGHT                            :Right
 STR_CONFIG_PATCHES_SNAP_RADIUS                                  :{LTBLUE}Window snap radius: {ORANGE}{STRING} px
 STR_CONFIG_PATCHES_SNAP_RADIUS_DISABLED                         :{LTBLUE}Window snap radius: {ORANGE}disabled
+STR_CONFIG_PATCHES_SET_MIDDLE_KEY_BIND                         :{LTBLUE}Set middle mouse button key binding
 
 STR_CONFIG_PATCHES_GUI                                          :{BLACK}Interface
 STR_CONFIG_PATCHES_CONSTRUCTION                                 :{BLACK}Construction
@@ -1094,6 +1100,9 @@
 STR_CONFIG_PATCHES_QUERY_CAPT                                   :{WHITE}Change setting value
 STR_CONFIG_PATCHES_SERVICE_INTERVAL_INCOMPATIBLE                :{WHITE}Some or all of the default service interval(s) below are incompatible with the chosen setting! 5-90% and 30-800 days are valid
 
+STR_CONFIG_PATCHES_AIRQUEUE										:{LTBLUE}Queue aircraft at airports{ORANGE}
+STR_CONFIG_PATCHES_AIR_COEFF									:{LTBLUE}Aircraft speedup (1=TTD default, 8=realistic):{ORANGE} {STRING}
+
 STR_TEMPERATE_LANDSCAPE                                         :Temperate landscape
 STR_SUB_ARCTIC_LANDSCAPE                                        :Sub-arctic landscape
 STR_SUB_TROPICAL_LANDSCAPE                                      :Sub-tropical landscape
@@ -1111,6 +1120,7 @@
 STR_CHEAT_SWITCH_CLIMATE                                        :{LTBLUE}Switch climate: {ORANGE} {STRING}
 STR_CHEAT_CHANGE_DATE                                           :{LTBLUE}Change date: {ORANGE} {DATE_SHORT}
 STR_CHEAT_SETUP_PROD                                            :{LTBLUE}Enable modifying production values: {ORANGE}{STRING}
+STR_CHEAT_RESET_STATION                                         :{LTBLUE}Enable Resetting of Stations: {ORANGE}{STRING}
 
 STR_HEADING_FOR_WAYPOINT                                        :{LTBLUE}Heading for {WAYPOINT}
 STR_HEADING_FOR_WAYPOINT_VEL                                    :{LTBLUE}Heading for {WAYPOINT}, {VELOCITY}
@@ -1745,6 +1755,7 @@
 STR_400E_SELECT_NEW_GAME_TYPE                                   :{WHITE}Select New Game Type
 STR_400F_SELECT_SCENARIO_GREEN_PRE                              :{BLACK}Select scenario (green), pre-set game (blue), or random new game
 STR_4010_GENERATE_RANDOM_NEW_GAME                               :Generate random new game
+STR_4011_GRFS_COULD_NOT_LOAD                                    :{WHITE}Some GRFs could not be found, please see the program output for more information
 
 ##id 0x4800
 STR_4800_IN_THE_WAY                                             :{WHITE}{STRING} in the way
@@ -2740,6 +2751,46 @@
 STR_BUILD_DATE                                                  :{BLACK}Built: {LTBLUE}{DATE_LONG}
 STR_MULTIPLAYER_PAUSED                                          :{WHITE}Game is paused.{}Command cannot be executed
 
+STR_RESET_STATION                                               :{BLACK}Reset Station
+STR_STATION_STATS                                               :{BLACK}Statistics
+STR_STATION_GOODS_IN                                            :{BLACK}In
+STR_STATION_GOODS_OUT                                           :{BLACK}Out
+STR_STATION_GOODS_TRANSFER                                      :{BLACK}Transit
+STR_VEHICLES                                                    :{BLACK}Vehicles
+STR_SCHEDULED                                                   :{BLACK}Scheduled
+STR_VEHICLES_MONTH                                              :{BLACK}Last Month
+STR_VEHICLES_CURRENT                                            :{BLACK}Current Month
+STR_TRAINS                                                      :{BLACK}Trains
+STR_RVS                                                         :{BLACK}Road Vehicles
+STR_BUSSES                                                      :{BLACK}Buses
+STR_TRUCKS                                                      :{BLACK}Trucks
+STR_SHIPS                                                       :{BLACK}Ships
+STR_AIRCRAFT                                                    :{BLACK}Aircraft
+STR_NUMBER                                                      :{YELLOW}{COMMA32}
+STR_STATION_MONTHS                                              :{BLACK}Cargo amount [This Month (Last Month) ]
+STR_CNUMBERS                                                    :{WHITE}{COMMA32} {TINYFONT}{BLACK}({YELLOW}{COMMA32}{BLACK})
+STR_VEHICLES_MONTHS_AVERAGE                                     :{BLACK}Average / Min / Max
+STR_MONTHS_COUNTED_NUM                                          :{BLACK}Months Counted: {GOLD}{COMMA32}
+STR_MONTHS_TINY                                                 :{TINYFONT}{BLACK}Months
+STR_STATION_MONTHS_AVERAGE                                      :{BLACK}Cargo amount [Average (Min/Max) per Month]
+STR_TOGGLE_MINMAX                                               :{BLACK}Toggle  -This/Last Month-   or   -Average/Min/Max-   Stats
+STR_RESET_STATISTICS                                            :{BLACK}Reset Statistics
+STR_AVERAGENUMBERS                                              :{SILVER}{COMMA32} {BLACK}{TINYFONT}({ORANGE}{COMMA32}{BLACK}/{LTBLUE}{COMMA32}{BLACK})
+STR_BLACK_SLASH                                                 :{BLACK}/
+STR_TINY_GOLD_NUMBER                                            :{TINYFONT}{GOLD}{COMMA32}
+STR_SILVER_NUMBER                                               :{SILVER}{COMMA32}
+STR_ORANGE_NUMBER                                               :{ORANGE}{COMMA32}
+STR_LTBLUE_NUMBER                                               :{LTBLUE}{COMMA32}
+STR_WHITE_NUMBER                                                :{WHITE}{COMMA32}
+STR_STS_NOT_SCHEDULED                                           :{BLACK}Not Scheduled
+STR_AVERAGE                                                     :{BLACK}Average
+STR_MINIMUM                                                     :{BLACK}Minimum
+STR_MAXIMUM                                                     :{BLACK}Maximum
+STR_STS_VEHICLES_LAST_YEAR                                      :{BLACK}Last Year
+STR_STS_VEHICLES_THIS_YEAR                                      :{BLACK}This Year
+STR_STS_YEARS_COUNTED_NUM                                       :{BLACK}Years Counted: {GOLD}{COMMA32}
+STR_STS_TOGGLE_MONTH_YEAR                                       :{BLACK}Toggle  -Monthly-   or   -Yearly-   Stats
+
 STR_PERFORMANCE_DETAIL                                          :{WHITE}Detailed performance rating
 STR_PERFORMANCE_DETAIL_KEY                                      :{BLACK}Detail
 STR_PERFORMANCE_DETAIL_AMOUNT_CURRENCY                          :{BLACK}({CURRCOMPACT}/{CURRCOMPACT})
Index: variables.h
===================================================================
--- variables.h	(revision 2456)
+++ variables.h	(working copy)
@@ -193,6 +193,9 @@
 	byte drag_signals_density; // many signals density
 	bool ainew_active;  // Is the new AI active?
 
+	bool aircraft_queueing; // Aircraft queueing patch
+	uint aircraft_speed_coeff; // Coefficient of aircraft speed, based on Benben's patch
+
 	/*
 	 * New Path Finding
 	 */
@@ -216,13 +219,23 @@
 	uint32 npf_buoy_penalty; /* The penalty for going over (through) a buoy */
 	uint32 npf_water_curve_penalty; /* The penalty for curves */
 	uint32 npf_road_curve_penalty; /* The penalty for curves */
-
+	uint32 npf_crossing_penalty; /* The penalty for railway crossings */
+	
 	bool population_in_label; // Show the population of a town in his label?
+	
+	uint32 middle_key_bind; // key code for middle mouse button binding
+	bool set_middle_key_bind; // the key code of the next key press will be recorded for the middle mouse button binding (not saved)
 } Patches;
 
-VARDEF Patches _patches;
+VARDEF Patches _patches; /** Main place where patches are set */
 
+/** When a game is loaded that has patches build in, the main ones will be
+* overwritten, so they are copied here, and then copied back when the user
+* ends the game.
+*/
+VARDEF Patches _set_patches;
 
+
 typedef struct Cheat {
 	bool been_used;	// has this cheat been used before?
 	byte value;			// active?
@@ -243,6 +256,7 @@
 	Cheat switch_climate;
 	Cheat change_date;				//changes date ingame
 	Cheat setup_prod;				//setup raw-material production in game
+	Cheat reset_station;		// allow resetting of Stations
 } Cheats;
 
 VARDEF Cheats _cheats;
@@ -342,6 +356,9 @@
 
 VARDEF bool _cache_sprites;
 
+VARDEF bool _show_average_stats; // show Average Stats for Station-Stats?
+VARDEF bool _show_yearly_stats; // show Yearly Stats for Waypoints?
+
 // debug features
 VARDEF char _savedump_path[64];
 VARDEF uint _savedump_first, _savedump_freq, _savedump_last;
Index: macros.h
===================================================================
--- macros.h	(revision 2456)
+++ macros.h	(working copy)
@@ -140,6 +140,7 @@
 static inline void swap_byte(byte *a, byte *b) { byte t = *a; *a = *b; *b = t; }
 static inline void swap_uint16(uint16 *a, uint16 *b) { uint16 t = *a; *a = *b; *b = t; }
 static inline void swap_int16(int16 *a, int16 *b) { int16 t = *a; *a = *b; *b = t; }
+static inline void swap_uint32(uint32 *a, uint32 *b) { uint32 t = *a; *a = *b; *b = t; }
 static inline void swap_int32(int32 *a, int32 *b) { int32 t = *a; *a = *b; *b = t; }
 static inline void swap_tile(TileIndex *a, TileIndex *b) { TileIndex t = *a; *a = *b; *b = t; }
 
Index: gui.h
===================================================================
--- gui.h	(revision 2456)
+++ gui.h	(working copy)
@@ -46,7 +46,7 @@
 /* road_gui.c */
 void ShowBuildRoadToolbar(void);
 void ShowBuildRoadScenToolbar(void);
-void ShowPlayerRoadVehicles(int player, int station);
+void ShowPlayerRoadVehicles(int player, int station, uint32 cargomask);
 
 /* dock_gui.c */
 void ShowBuildDocksToolbar(void);
@@ -137,7 +137,8 @@
 	ZOOM_NONE = 2, // hack, used to update the button status
 };
 
-bool DoZoomInOutWindow(int how, Window * w);
+bool DoZoomInOutWindow(byte how, Window * w);
+void DirtyZoomButtons(Window *w, const ViewPort *vp, int widget);
 void ShowBuildIndustryWindow(void);
 void ShowQueryString(StringID str, StringID caption, uint maxlen, uint maxwidth, WindowClass window_class, WindowNumber window_number);
 void ShowMusicWindow(void);
Index: aystar.c
===================================================================
--- aystar.c	(revision 2456)
+++ aystar.c	(working copy)
@@ -230,6 +230,10 @@
 	else if (r == AYSTAR_LIMIT_REACHED)
 		printf("[AyStar] Exceeded search_nodes, no path found\n");
 #endif
+
+	if (aystar->BeforeExit != NULL)
+		aystar->BeforeExit(aystar);
+
 	if (r != AYSTAR_STILL_BUSY)
 		/* We're done, clean up */
 		aystar->clear(aystar);
Index: tunnelbridge_cmd.c
===================================================================
--- tunnelbridge_cmd.c	(revision 2456)
+++ tunnelbridge_cmd.c	(working copy)
@@ -10,6 +10,8 @@
 #include "player.h"
 #include "town.h"
 #include "sound.h"
+#include "pbs.h"
+#include "debug.h"
 
 extern void DrawCanalWater(uint tile);
 
@@ -772,6 +774,7 @@
 		byte m5;
 		uint c = tile;
 		uint16 new_data;
+		byte pbs;
 
 		//checks if the owner is town then decrease town rating by RATING_TUNNEL_BRIDGE_DOWN_STEP until
 		// you have a "Poor" (0) town rating
@@ -780,6 +783,7 @@
 
 		do {
 			m5 = _map5[c];
+			pbs = PBSTileReserved(c);
 
 			if (m5 & 0x40) {
 				if (m5 & 0x20) {
@@ -793,6 +797,9 @@
 				SetTileType(c, new_data >> 12);
 				_map5[c] = (byte)new_data;
 				_map2[c] = 0;
+				_map3_hi[c] &= 0x0F;
+				if (direction ? HASBIT(pbs,0) : HASBIT(pbs,1))
+					PBSReserveTrack(c, direction ? 0 : 1);
 
 				MarkTileDirtyByTile(c);
 
@@ -1145,7 +1152,19 @@
 			}
 		}
 	}
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(0x3ED | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(0x3EE | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(0x3EF | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(0x3F0 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(0x3F2 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 | PALETTE_CRASH);
 }
+#endif
+}
 
 static uint GetSlopeZ_TunnelBridge(TileInfo *ti) {
 	uint z = ti->z;
@@ -1428,6 +1447,8 @@
 					return 0;
 				}
 				if (fc == _tunnel_fractcoord_2[dir]) {
+					if (v->next == NULL)
+						PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 					v->tile = tile;
 					v->u.rail.track = 0x40;
 					v->vehstatus |= VS_HIDDEN;
Index: aystar.h
===================================================================
--- aystar.h	(revision 2456)
+++ aystar.h	(working copy)
@@ -96,6 +96,11 @@
  */
 typedef void AyStar_FoundEndNode(AyStar *aystar, OpenListNode *current);
 
+/*
+ * Is called when aystar ends it pathfinding, but before cleanup.
+ */
+typedef void AyStar_BeforeExit(AyStar *aystar);
+
 // For internal use, see aystar.c
 typedef void AyStar_AddStartNode(AyStar *aystar, AyStarNode* start_node, uint g);
 typedef int AyStar_Main(AyStar *aystar);
@@ -115,6 +120,7 @@
 	AyStar_GetNeighbours* GetNeighbours;
 	AyStar_EndNodeCheck* EndNodeCheck;
 	AyStar_FoundEndNode* FoundEndNode;
+	AyStar_BeforeExit* BeforeExit;
 
 	/* These are completely untouched by AyStar, they can be accesed by
 	 * the application specific routines to input and output data.
Index: roadveh_cmd.c
===================================================================
--- roadveh_cmd.c	(revision 2456)
+++ roadveh_cmd.c	(working copy)
@@ -808,6 +808,14 @@
 
 static void RoadVehArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_ROAD].this_month++;
+    if (st->months_counted == 0) st->months_counted = 1;
+	if (v->cargo_type == CT_PASSENGERS)
+		st->vehicles[STS_VEH_BUS].this_month++;
+	else
+		st->vehicles[STS_VEH_TRUCK].this_month++;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	if (v->engine_type < 123) {
 		/* Check if station was ever visited before */
 		if (!(st->had_vehicle_of_type & HVOT_BUS)) {
@@ -1104,7 +1112,7 @@
 		trackdir = DiagdirToDiagTrackdir(enterdir);
 		//debug("Finding path. Enterdir: %d, Trackdir: %d", enterdir, trackdir);
 
-		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_ROAD, v->owner);
+		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_ROAD, v->owner, PBS_MODE_NONE);
 		if (ftd.best_trackdir == 0xff) {
 			/* We are already at our target. Just do something */
 			//TODO: maybe display error?
@@ -1181,7 +1189,7 @@
   fstd.dest_coords = tile;
   fstd.station_index = -1;	// indicates that the destination is a tile, not a station
 
-  return NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_ROAD, v->owner).best_path_dist;
+  return NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_ROAD, v->owner, PBS_MODE_NONE).best_path_dist;
 }
 
 typedef struct RoadDriveEntry {
Index: openttd.c
===================================================================
--- openttd.c	(revision 2456)
+++ openttd.c	(working copy)
@@ -34,6 +34,7 @@
 #include "signs.h"
 #include "depot.h"
 #include "waypoint.h"
+#include "newgrf.h"
 
 #include <stdarg.h>
 
@@ -500,6 +501,7 @@
 	bool network = false;
 	char *network_conn = NULL;
 	char *language = NULL;
+	Patches *_set_patches_ptr = NULL;
 	const char *optformat;
 	char musicdriver[16], sounddriver[16], videodriver[16];
 	int resolution[2] = {0,0};
@@ -610,6 +612,9 @@
 	if (resolution[0]) { _cur_resolution[0] = resolution[0]; _cur_resolution[1] = resolution[1]; }
 	if (startdate != (uint)-1) _patches.starting_date = startdate;
 
+	_set_patches_ptr = &_set_patches;
+	memcpy(_set_patches_ptr, &_patches, sizeof(Patches));
+	
 	if (_dedicated_forks && !dedicated)
 		_dedicated_forks = false;
 
@@ -856,7 +861,15 @@
 
 void SwitchMode(int new_mode)
 {
+	Patches *_patches_ptr = NULL;
+	
 	_in_state_game_loop = true;
+	
+	if (_game_mode != GM_MENU)
+	{
+		_patches_ptr = &_patches;
+		memcpy(_patches_ptr, &_set_patches, sizeof(Patches));
+	}
 
 #ifdef ENABLE_NETWORK
 	// If we are saving something, the network stays in his current state
@@ -910,6 +923,8 @@
 			LoadIntroGame();
 			ShowErrorMessage(_error_message, STR_4009_GAME_LOAD_FAILED, 0, 0);
 		} else {
+			if (!CheckLoadedGRFs(false))
+				ShowErrorMessage(_error_message, STR_NULL, 0, 0);
 			_local_player = 0;
 			DoCommandP(0, 0, 0, NULL, CMD_PAUSE); // decrease pause counter (was increased from opening load dialog)
 #ifdef ENABLE_NETWORK
@@ -1305,6 +1320,8 @@
 	// convert road side to my format.
 	if (_opt.road_side) _opt.road_side = 1;
 
+	CheckLoadedGRFs(true);
+	
 	// Load the sprites
 	GfxLoadSprites();
 
Index: openttd.h
===================================================================
--- openttd.h	(revision 2456)
+++ openttd.h	(working copy)
@@ -265,7 +265,7 @@
 
 	NUM_CARGO = 12,
 
-	CT_INVALID = 0xFF
+	CT_INVALID = 0xFF,
 };
 
 typedef uint AcceptedCargo[NUM_CARGO];
@@ -441,6 +441,8 @@
 	WC_HIGHSCORE = 0x4D,
 	WC_ENDSCREEN = 0x4E,
 	WC_SIGN_LIST = 0x4F,
+	WC_STATION_STATS = 0x50,
+	WC_WAYPOINT_STATS = 0x51,
 };
 
 
@@ -527,6 +529,7 @@
 #define INVALID_UINT_TILE (uint)0xFFFFFFFF
 #define INVALID_STRING_ID 0xFFFF
 
+
 enum {
 	MAX_SCREEN_WIDTH = 2048,
 	MAX_SCREEN_HEIGHT = 1200,
Index: station_gui.c
===================================================================
--- station_gui.c	(revision 2456)
+++ station_gui.c	(working copy)
@@ -10,6 +10,7 @@
 #include "player.h"
 #include "town.h"
 #include "command.h"
+#include "engine.h"
 
 static void StationsWndShowStationRating(int x, int y, int type, uint acceptance, int rating)
 {
@@ -286,9 +287,31 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    64,   248,   210,   221, 0x0,					STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_expanded_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,					STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,					STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,					STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,   197, 0x0,					STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   198,   209, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   198,   209, STR_3033_ACCEPTS,	STR_3056_SHOW_LIST_OF_ACCEPTED_CARGO},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   198,   209, STR_0130_RENAME,		STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,   198,   209, STR_TRAIN, STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   248,   210,   221, STR_RESET_STATION, 0x0},
+{   WIDGETS_END},
+};
+
 static const Widget _station_view_widgets[] = {
 {    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -304,9 +327,31 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    64,   248,   110,   121, 0x0,					STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,					STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,					STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,    97, 0x0,					STR_NULL},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,					STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,    98,   109, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,    98,   109, STR_3032_RATINGS,	STR_3054_SHOW_STATION_RATINGS},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,    98,   109, STR_0130_RENAME,		STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,    98,   109, STR_TRAIN, STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   248,   110,   121, STR_RESET_STATION, 0x0},
+{   WIDGETS_END},
+};
+
 static void DrawStationViewWindow(Window *w)
 {
 	Station *st;
@@ -331,7 +376,10 @@
 	}
 	SetVScrollCount(w, num);
 
-	w->disabled_state = st->owner == _local_player ? 0 : (1 << 9);
+	if (_cheats.reset_station.value)
+        w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 14) | (1 << 15);
+	else
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 14);
 
 	if (!(st->facilities & FACIL_TRAIN)) SETBIT(w->disabled_state,  10);
 	if (!(st->facilities & FACIL_TRUCK_STOP) &&
@@ -454,12 +502,19 @@
 			SetWindowDirty(w);
 
 			/* toggle height/widget set */
-			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)) {
-				AssignWidgetToWindow(w, _station_view_widgets);
-				w->height = 110;
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_widgets);
+				w->height = 122;
 			} else {
-				AssignWidgetToWindow(w, _station_view_expanded_widgets);
-				w->height = 210;
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+				w->height = 222;
 			}
 
 			SetWindowDirty(w);
@@ -480,7 +535,7 @@
 
 		case 11: { /* Show a list of scheduled road-vehicles to this station */
 			const Station *st = GetStation(w->window_number);
-			ShowPlayerRoadVehicles(st->owner, w->window_number);
+			ShowPlayerRoadVehicles(st->owner, w->window_number, CARGO_MASK_ALL);
 			break;
 		}
 
@@ -499,7 +554,37 @@
 			ShowPlayerShips(owner, w->window_number);
 			break;
 		}
+
+		case 14: {
+			ShowStationStatsWindow(w->window_number);
+			break;
 		}
+		case 15: {
+			if (_cheats.reset_station.value) {
+				Station *st = GetStation(w->window_number);
+				GoodsEntry *ge;
+
+				for(ge = st->goods; ge != endof(st->goods); ge++) {
+					ge->last_speed = 0;
+					ge->waiting_acceptance = 0;
+					ge->days_since_pickup = 0;
+					ge->enroute_from = 0xFFFF;
+					ge->rating = 175;
+					ge->last_speed = 0;
+					ge->last_age = 0xFF;
+					ge->feeder_profit = 0;
+				}
+				InitializeStationStats(st);
+				st->had_vehicle_of_type = 0;
+				st->time_since_load = 255;
+				st->time_since_unload = 255;
+				st->last_vehicle = INVALID_VEHICLE;
+
+				SetWindowDirty(w);
+			}
+			break;
+ 		}
+		}
 		break;
 
 	case WE_ON_EDIT_TEXT: {
@@ -520,6 +605,7 @@
 		DeleteWindowById(WC_ROADVEH_LIST, wno);
 		DeleteWindowById(WC_SHIPS_LIST, wno);
 		DeleteWindowById(WC_AIRCRAFT_LIST, wno);
+		DeleteWindowById(WC_STATION_STATS, w->window_number);
 		break;
 	}
 	}
@@ -527,19 +613,30 @@
 
 
 static const WindowDesc _station_view_desc = {
-	-1, -1, 249, 110,
+	-1, -1, 249, 122,
 	WC_STATION_VIEW,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
 	_station_view_widgets,
 	StationViewWndProc
 };
 
+static const WindowDesc _station_view_cheat_desc = {
+	-1, -1, 249, 122,
+	WC_STATION_VIEW,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_view_cheat_widgets,
+	StationViewWndProc
+};
+
 void ShowStationViewWindow(int station)
 {
 	Window *w;
 	byte color;
 
-	w = AllocateWindowDescFront(&_station_view_desc, station);
+	if (_cheats.reset_station.value)
+		w = AllocateWindowDescFront(&_station_view_cheat_desc, station);
+	else
+		w = AllocateWindowDescFront(&_station_view_desc, station);
 	if (w) {
 		color = GetStation(w->window_number)->owner;
 		if (color != 0x10)
@@ -547,3 +644,244 @@
 		w->vscroll.cap = 5;
 	}
 }
+
+void StationStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _station_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   398,     0,    13, STR_300A_0, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   399,   410,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    91,   410,    14,    25, STR_TOGGLE_MINMAX, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,    90,    26,    37, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    38,    49, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    50,    61, STR_RVS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    62,    73, STR_BUSSES, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    74,    85, STR_TRUCKS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    85,    97, STR_SHIPS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    98,   109, STR_AIRCRAFT, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    91,   410,    26,   109, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,   110,   135, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   398,   136,   191, 0x0,0x0},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   399,   410,   136,   191, 0x0, STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WIDGETS_END},
+};
+
+WindowDesc _station_view_stats = {
+	-1, -1, 411, 192,
+	WC_STATION_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_stats_widgets,
+	StationStatsWndProc
+};
+
+void DrawStationStatWindow(Window *w, Station *st)
+{
+	int i, y, numcargo=0, pos;
+	GoodsEntry *ge;
+	
+	// count number of goods at station (months_counted will be 0 if good not delivered/picked up)
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		if (ge->months_counted != 0) numcargo++;
+	}
+	SetVScrollCount(w, numcargo);
+		
+	//Get the Station name
+	SetDParam(0, st->index);
+	
+	//and the little carrier type images
+	SetDParam(1, st->facilities);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawStringCentered(45, 28, STR_VEHICLES, 0);
+
+	//Part 1:       Find the number of carriers on the station
+	y = 27;
+	if (_show_average_stats) {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(275, y, STR_VEHICLES_MONTHS_AVERAGE, 0);
+		SetDParam(0, max(st->months_counted - 1,0));
+		DrawStringRightAligned(405, y, STR_MONTHS_COUNTED_NUM, 0);
+	} else {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(295, y, STR_VEHICLES_MONTH, 0);
+		DrawStringRightAligned(395, y, STR_VEHICLES_CURRENT, 0);	
+	}
+
+	y = 38;
+	for (i = 0; i < STS_VEH_TYPES; i++) {
+		if (w->custom[i] != 0) {
+			SetDParam(0, w->custom[i]);
+			DrawStringRightAligned(150, y+i*12, STR_NUMBER, 0);
+			CLRBIT(w->disabled_state, i+7);
+		} else {
+			SETBIT(w->disabled_state, i+7);
+		}
+		if (_show_average_stats) {
+			if (st->vehicles[i].average != 0 || st->vehicles[i].month_max !=0) {
+				SetDParam(0, st->vehicles[i].average / STS_MULTIPLIER);
+				DrawStringRightAligned(235, y+i*12, STR_SILVER_NUMBER, 0);
+				DrawStringRightAligned(245, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_min);
+				DrawStringRightAligned(290, y+i*12, STR_ORANGE_NUMBER, 0);
+				DrawStringRightAligned(300, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_max);
+				DrawStringRightAligned(350, y+i*12, STR_LTBLUE_NUMBER, 0);
+			}
+		} else {
+			if (st->vehicles[i].last_month != 0) {
+				SetDParam(0, st->vehicles[i].last_month);
+				DrawStringRightAligned(295, y+i*12, STR_NUMBER, 0);
+			}
+			if (st->vehicles[i].this_month) {
+				SetDParam(0, st->vehicles[i].this_month);
+				DrawStringRightAligned(395, y+i*12, STR_WHITE_NUMBER, 0);
+			}
+		}
+	}
+	
+	y = 124;
+	if (_show_average_stats) {
+		DrawString(5, y-10, STR_STATION_MONTHS_AVERAGE, 0);
+		DrawStringRightAligned(100, y+2, STR_MONTHS_TINY, 0);
+	} else {
+        DrawString(5, y-10, STR_STATION_MONTHS, 0);
+	}
+	DrawStringRightAligned(200, y, STR_STATION_GOODS_IN, 0);
+	DrawStringRightAligned(305, y, STR_STATION_GOODS_OUT, 0);
+	DrawStringRightAligned(395, y, STR_STATION_GOODS_TRANSFER, 0);
+	
+	y += 5;
+	pos = w->vscroll.pos;
+	for (i = 0; i < NUM_CARGO; i++) {
+		ge = &st->goods[i];
+		if (ge->months_counted != 0 && ((--pos < 0) && (pos >= -4)) )
+		{
+			StationStats *sts = ge->cargo_amount;
+			//Print the cargo name
+			y += 12;
+			SetDParam(0, _cargoc.names_p[i]);
+			DrawString(3, y, STR_02BD, 0);
+			if (_show_average_stats) {
+				SetDParam(0, ge->months_counted - 1);
+				DrawStringRightAligned(100, y, STR_TINY_GOLD_NUMBER, 0);
+				if (sts[STS_AMOUNT_IN].average != 0 || sts[STS_AMOUNT_IN].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].average / STS_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_IN].month_min);
+					SetDParam(2, sts[STS_AMOUNT_IN].month_max);
+					DrawStringRightAligned(200, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].average != 0 || sts[STS_AMOUNT_OUT].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].average / STS_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_OUT].month_min);
+					SetDParam(2, sts[STS_AMOUNT_OUT].month_max);
+					DrawStringRightAligned(305, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].average != 0 || sts[STS_AMOUNT_TRANSFER].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].average / STS_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].month_min);
+					SetDParam(2, sts[STS_AMOUNT_TRANSFER].month_max);
+					DrawStringRightAligned(395, y, STR_AVERAGENUMBERS, 0);
+				}
+			} else {
+				if (sts[STS_AMOUNT_IN].this_month != 0 || sts[STS_AMOUNT_IN].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].this_month);
+					SetDParam(1, sts[STS_AMOUNT_IN].last_month);
+					DrawStringRightAligned(200, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].this_month != 0 || sts[STS_AMOUNT_OUT].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].this_month);
+					SetDParam(1, sts[STS_AMOUNT_OUT].last_month);
+					DrawStringRightAligned(305, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].this_month != 0 || sts[STS_AMOUNT_TRANSFER].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].this_month);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].last_month);
+					DrawStringRightAligned(395, y, STR_CNUMBERS, 0);
+				}
+			}
+		}
+	}
+}
+
+void StationStatsWndProc(Window *w, WindowEvent *e)
+{
+	Station *st = GetStation(w->window_number);
+	switch(e->event)
+	{
+	case WE_TICK: {
+//		static int counter = 0;
+//		if (++counter % 40) return;
+		int i;
+		
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+		InvalidateWindow(WC_STATION_STATS, w->window_number);
+		break;
+	}
+	case WE_PAINT: {
+		DrawStationStatWindow(w, st);
+		break;
+		}
+	case WE_CLICK: {
+		switch (e->click.widget)
+		{
+			case 4:			// Reset Statistics
+				if (st->owner == _current_player) {
+					InitializeStationStats(st);
+					InvalidateWindow(WC_STATION_STATS, w->window_number);
+				}
+				break;
+			case 5:			// Toggle Average and This Month
+				_show_average_stats ^= 1;
+				InvalidateWindow(WC_STATION_STATS, w->window_number);
+				break;
+			case 7:			//Trains
+				ShowPlayerTrains(st->owner, st->index);
+				break;
+			case 8: 		//Road Vehicles
+				ShowPlayerRoadVehicles(st->owner, st->index, CARGO_MASK_ALL);
+				break;
+			case 9:			// Buses
+				ShowPlayerRoadVehicles(st->owner, st->index, 1 << GC_PASSENGERS);
+				break;
+			case 10:		// Trucks
+				ShowPlayerRoadVehicles(st->owner, st->index, CARGO_MASK_ALL &~(1 << GC_PASSENGERS));
+				break;
+			case 11: 		//Ships
+				ShowPlayerShips(st->owner, st->index);
+				break;
+			case 12: 		//Aircraft
+				ShowPlayerAircraft(st->owner, st->index);
+				break;
+		}
+	} break;
+	case WE_DESTROY: {
+//		DeleteWindowById(WC_TRAINS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_ROADVEH_LIST, st->owner + ( (st->index + 1) << 8) + 64 + 128);
+//		DeleteWindowById(WC_SHIPS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_AIRCRAFT_LIST, st->owner + ( (st->index + 1) << 8));
+	} break;
+	}
+}
+
+void ShowStationStatsWindow(int station)
+{
+	Window *w;
+	byte color;
+
+	Station *st = GetStation(station);
+		
+	w = AllocateWindowDescFront(&_station_view_stats, st->index);
+	if (w) {
+		int i;
+		color = st->owner;
+		if (color != 0x10)
+			w->caption_color = color;
+		w->vscroll.cap = 4;
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+	}
+}
Index: network_data.h
===================================================================
--- network_data.h	(revision 2456)
+++ network_data.h	(working copy)
@@ -56,7 +56,6 @@
 typedef enum {
 	MAP_PACKET_START,
 	MAP_PACKET_NORMAL,
-	MAP_PACKET_PATCH,
 	MAP_PACKET_END,
 } MapPacket;
 
Index: ai_pathfinder.c
===================================================================
--- ai_pathfinder.c	(revision 2456)
+++ ai_pathfinder.c	(working copy)
@@ -96,6 +96,8 @@
 	result->EndNodeCheck = AyStar_AiPathFinder_EndNodeCheck;
 	result->FoundEndNode = AyStar_AiPathFinder_FoundEndNode;
 	result->GetNeighbours = AyStar_AiPathFinder_GetNeighbours;
+	
+	result->BeforeExit = NULL;
 
 	result->free = AyStar_AiPathFinder_Free;
 
Index: saveload.c
===================================================================
--- saveload.c	(revision 2456)
+++ saveload.c	(working copy)
@@ -23,8 +23,8 @@
 #include "saveload.h"
 
 enum {
-	SAVEGAME_MAJOR_VERSION = 14,
-	SAVEGAME_MINOR_VERSION = 0,
+	SAVEGAME_MAJOR_VERSION = 15,
+	SAVEGAME_MINOR_VERSION = 0x1,
 
 	SAVEGAME_LOADABLE_VERSION = (SAVEGAME_MAJOR_VERSION << 8) + SAVEGAME_MINOR_VERSION
 };
@@ -102,38 +102,38 @@
 /** Wrapper for SlWriteByteInternal */
 void SlWriteByte(byte b) {SlWriteByteInternal(b);}
 
-static inline int SlReadUint16(void)
+int SlReadUint16(void)
 {
 	int x = SlReadByte() << 8;
 	return x | SlReadByte();
 }
 
-static inline uint32 SlReadUint32(void)
+uint32 SlReadUint32(void)
 {
 	uint32 x = SlReadUint16() << 16;
 	return x | SlReadUint16();
 }
 
-static inline uint64 SlReadUint64(void)
+uint64 SlReadUint64(void)
 {
 	uint32 x = SlReadUint32();
 	uint32 y = SlReadUint32();
 	return (uint64)x << 32 | y;
 }
 
-static inline void SlWriteUint16(VarType v)
+void SlWriteUint16(VarType v)
 {
 	SlWriteByte((byte)(v >> 8));
 	SlWriteByte((byte)v);
 }
 
-static inline void SlWriteUint32(uint32 v)
+void SlWriteUint32(uint32 v)
 {
 	SlWriteUint16((uint16)(v >> 16));
 	SlWriteUint16((uint16)v);
 }
 
-static inline void SlWriteUint64(uint64 x)
+void SlWriteUint64(uint64 x)
 {
 	SlWriteUint32((uint32)(x >> 32));
 	SlWriteUint32((uint32)x);
@@ -311,6 +311,7 @@
 	if (_sl.save) { /* SAVE values */
 		/* Read a value from the struct. These ARE endian safe. */
 		switch ((conv >> 4) & 0xF) {
+                case SLE_VAR_B    >> 4: x = *(bool*)ptr; break;
 		case SLE_VAR_I8   >> 4: x = *(int8*)ptr; break;
 		case SLE_VAR_U8   >> 4: x = *(byte*)ptr; break;
 		case SLE_VAR_I16  >> 4: x = *(int16*)ptr; break;
@@ -325,6 +326,7 @@
 
 		// Write the value to the file and check if its value is in the desired range
 		switch (conv & 0xF) {
+		case SLE_FILE_B:     assert( x == 1 || x == 0);         SlWriteByte(x);break;
 		case SLE_FILE_I8: assert(x >= -128 && x <= 127);     SlWriteByte(x);break;
 		case SLE_FILE_U8:	assert(x >= 0 && x <= 255);        SlWriteByte(x);break;
 		case SLE_FILE_I16:assert(x >= -32768 && x <= 32767); SlWriteUint16(x);break;
@@ -338,6 +340,7 @@
 
 		// Read a value from the file
 		switch (conv & 0xF) {
+		case SLE_FILE_B:   x = (bool)SlReadByte(); break;
 		case SLE_FILE_I8:  x = (int8)SlReadByte(); break;
 		case SLE_FILE_U8:  x = (byte)SlReadByte(); break;
 		case SLE_FILE_I16: x = (int16)SlReadUint16(); break;
@@ -352,6 +355,7 @@
 
 		/* Write The value to the struct. These ARE endian safe. */
 		switch ((conv >> 4) & 0xF) {
+		case SLE_VAR_B    >> 4: *(bool*)ptr = x; break;
 		case SLE_VAR_I8   >> 4:  *(int8*)ptr = x; break;
 		case SLE_VAR_U8   >> 4:  *(byte*)ptr = x; break;
 		case SLE_VAR_I16  >> 4: *(int16*)ptr = x; break;
@@ -1267,7 +1271,7 @@
 {
 	uint32 hdr[2];
 	const SaveLoadFormat *fmt;
-  uint version;
+	uint version;
 
 	/* An instance of saving is already active, so wait until it is done */
 	if (_ts.saveinprogress) {
Index: aircraft_gui.c
===================================================================
--- aircraft_gui.c	(revision 2456)
+++ aircraft_gui.c	(working copy)
@@ -534,24 +534,26 @@
 			switch (v->current_order.type) {
 			case OT_GOTO_STATION: {
 				SetDParam(0, v->current_order.station);
-				SetDParam(1, v->cur_speed * 8);
+				SetDParam(1, v->cur_speed * 8 / _patches.aircraft_speed_coeff);
 				str = STR_HEADING_FOR_STATION + _patches.vehicle_speed;
 			} break;
 
 			case OT_GOTO_DEPOT: {
 				SetDParam(0, v->current_order.station);
-				SetDParam(1, v->cur_speed * 8);
+				SetDParam(1, v->cur_speed * 8 / _patches.aircraft_speed_coeff);
 				str = STR_HEADING_FOR_HANGAR + _patches.vehicle_speed;
 			} break;
 
 			case OT_LOADING:
+				SetDParam(0, v->current_order.station);
+				SetDParam(1, v->cur_speed * 8 / _patches.aircraft_speed_coeff);
 				str = STR_882F_LOADING_UNLOADING;
 				break;
 
 			default:
 				if (v->num_orders == 0) {
 					str = STR_NO_ORDERS + _patches.vehicle_speed;
-					SetDParam(0, v->cur_speed * 8);
+					SetDParam(0, v->cur_speed * 8 / _patches.aircraft_speed_coeff);
 				} else
 					str = STR_EMPTY;
 				break;
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 2456)
+++ train_cmd.c	(working copy)
@@ -1,3 +1,4 @@
+
 #include "stdafx.h"
 #include "openttd.h"
 #include "debug.h"
@@ -16,6 +17,7 @@
 #include "player.h"
 #include "sound.h"
 #include "depot.h"
+#include "debug.h"
 #include "waypoint.h"
 #include "vehicle_gui.h"
 
@@ -312,7 +314,10 @@
 		}
 	} else {
 		//"kickoff" acceleration
-		force = resistance * 10;
+		//  1 => train slowly start moving
+		// 10 => train quickly start moving
+		int kickoff_acceleration = 10;
+		force = ((mass * 4) * kickoff_acceleration) + resistance;
 	}
 
 	if (force <= 0) force = 10000;
@@ -1231,7 +1236,7 @@
 		swap_int32(&a->x_pos, &b->x_pos);
 		swap_int32(&a->y_pos, &b->y_pos);
 		swap_tile(&a->tile, &b->tile);
-		swap_byte(&a->z_pos, &b->z_pos);
+		swap_uint32(&a->z_pos, &b->z_pos);
 
 		SwapTrainFlags(&a->u.rail.flags, &b->u.rail.flags);
 
@@ -1319,14 +1324,94 @@
 	}
 }
 
+TileIndex GetVehicleTileOutOfTunnel(const Vehicle *v, bool reverse)
+{
+	TileIndex tile;
+	byte direction = (!reverse) ? v->direction >> 1 : ReverseDiagdir(v->direction >> 1);
+	TileIndexDiff delta = TileOffsByDir(direction);
+
+	if (v->u.rail.track != 0x40)
+		return v->tile;
+
+	for (tile = v->tile;; tile += delta) {
+		if (IsTileType(tile, MP_TUNNELBRIDGE) &&
+				(_map5[tile] & 0xF3) != (direction) &&
+				GetTileZ(tile) == v->z_pos)
+ 			break;
+ 	}
+ 	return tile;
+
+};
+
 static void ReverseTrainDirection(Vehicle *v)
 {
 	int l = 0, r = -1;
 	Vehicle *u;
+	TileIndex tile;
+	byte trackdir;
 
+	u = GetLastVehicleInChain(v);
+	tile = GetVehicleTileOutOfTunnel(u, false);
+	trackdir = ReverseTrackdir(GetVehicleTrackdir(u));
+
+	if (PBSTileReserved(tile) & (1 << (trackdir&7))) {
+		NPFFindStationOrTileData fstd;
+		NPFFoundTargetData ftd;
+		
+		NPFFillWithOrderData(&fstd, v);
+
+		tile = GetVehicleTileOutOfTunnel(u, true);
+
+		DEBUG(pbs, 2) ("pbs: (%i) choose reverse (RV), tile:%x, trackdir:%i",v->unitnumber,  u->tile, trackdir);
+		ftd = NPFRouteToStationOrTile(tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+	
+		if (ftd.best_trackdir == 0xFF) {
+			DEBUG(pbs, 0) ("pbs: (%i) no nodes encountered (RV)", v->unitnumber);
+			CLRBIT(v->u.rail.flags, VRF_REVERSING);
+			return;
+		}
+
+    // we found a way out of the pbs block
+		if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED)) {
+				CLRBIT(v->u.rail.flags, VRF_REVERSING);
+				return;
+			}
+		}/* else {
+			CLRBIT(v->u.rail.flags, VRF_REVERSING);
+			return;
+		};*/
+	}/* else if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH) {
+		CLRBIT(v->u.rail.flags, VRF_REVERSING);
+		return;
+	}*/
+
+	tile = GetVehicleTileOutOfTunnel(v, false);
+	trackdir = GetVehicleTrackdir(v);
+
+	if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH) {
+		byte trackdir = GetVehicleTrackdir(v);
+		TileIndex tile = AddTileIndexDiffCWrap(v->tile, TileIndexDiffCByDir(TrackdirToExitdir(trackdir)));
+		uint32 ts;
+		assert(tile != INVALID_TILE);
+		ts = GetTileTrackStatus(tile, TRANSPORT_RAIL);
+		ts &= TrackdirReachesTrackdirs(trackdir);
+		assert(ts != 0 && KillFirstBit2x64(ts) == 0);
+		trackdir = FindFirstBit2x64(ts); 
+		PBSClearPath(tile, trackdir);
+//		if (PBSTileReserved(v->tile) & v->u.rail.track)
+//			PBSReserveTrack(tile, trackdir & 7);
+		v->u.rail.pbs_status = PBS_STAT_NONE;
+	} else if (PBSTileReserved(tile) & (1 << (trackdir&7))) {
+		PBSClearPath(tile, trackdir);
+		if (v->u.rail.track != 0x40)
+			PBSReserveTrack(tile, trackdir & 7);
+	};
+
 	if (IsTileDepotType(v->tile, TRANSPORT_RAIL))
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
 
+
 	/* Check if we were approaching a rail/road-crossing */
 	{
 		TileIndex tile = v->tile;
@@ -1770,13 +1855,37 @@
 		}
 
 		v->load_unload_time_rem = 0;
+		
+		if (PBSIsPbsSegment(v->tile, v->direction)) {
+			byte trackdir = GetVehicleTrackdir(v);
+					//_track_direction_to_trackdir[FIND_FIRST_BIT(v->u.rail.track)][v->direction];
+			NPFFindStationOrTileData fstd;
+			NPFFoundTargetData ftd;
+			
+			if (PBSTileUnavail(v->tile) & (1 << trackdir))
+				return true;
 
+			NPFFillWithOrderData(&fstd, v);
+
+			DEBUG(pbs, 2) ("pbs: (%i) choose depot (DP), tile:%x, trackdir:%i",v->unitnumber,  v->tile, trackdir);
+			ftd = NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+
+			// we found a way out of the pbs block
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+				if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+					return true;
+				else
+					goto green;
+			}
+		}
+			
+		
 		if (UpdateSignalsOnSegment(v->tile, v->direction)) {
 			InvalidateWindowClasses(WC_TRAINS_LIST);
 			return true;
 		}
 	}
-
+green:
 	VehicleServiceInDepot(v);
 	InvalidateWindowClasses(WC_TRAINS_LIST);
 	TrainPlayLeaveStationSound(v);
@@ -1926,14 +2035,33 @@
 		NPFFindStationOrTileData fstd;
 		NPFFoundTargetData ftd;
 		Trackdir trackdir;
+		uint16 pbs_tracks;
 
 		NPFFillWithOrderData(&fstd, v);
 		/* The enterdir for the new tile, is the exitdir for the old tile */
 		trackdir = GetVehicleTrackdir(v);
 		assert(trackdir != 0xff);
 
-		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner);
+		pbs_tracks = PBSTileReserved(tile);
+		pbs_tracks |= pbs_tracks << 8;
+		pbs_tracks &= TrackdirReachesTrackdirs(trackdir);
+		if (pbs_tracks || (v->u.rail.pbs_status == PBS_STAT_NEED_PATH)) {
+			DEBUG(pbs, 2) ("pbs: (%i) choosefromblock, tile_org:%x tile_dst:%x  trackdir:%i  pbs_tracks:%i",v->unitnumber, tile,tile - TileOffsByDir(enterdir), trackdir, pbs_tracks);
 
+			// clear the currently planned path
+			if (v->u.rail.pbs_status != PBS_STAT_NEED_PATH) PBSClearPath(tile, FindFirstBit2x64(pbs_tracks));
+
+			// try to find a route to a green exit signal
+			ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+
+			// if no route found, find one to any exit signal
+/*			if (ftd.best_bird_dist != 0 || ftd.best_trackdir == 0xff) {
+				ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+				DEBUG(pbs, 1) ("pbs: (%i) no green sig found, PBS_MODE_ANY result:%i%i", v->index, ftd.best_bird_dist, ftd.best_trackdir);
+		}*/
+		} else
+			ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_NONE);
+
 		if (ftd.best_trackdir == 0xff) {
 			/* We are already at our target. Just do something */
 			//TODO: maybe display error?
@@ -2070,7 +2198,7 @@
 		assert(trackdir != 0xff);
 		assert(trackdir_rev != 0xff);
 
-		ftd = NPFRouteToStationOrTileTwoWay(v->tile, trackdir, last->tile, trackdir_rev, &fstd, TRANSPORT_RAIL, v->owner);
+		ftd = NPFRouteToStationOrTileTwoWay(v->tile, trackdir, last->tile, trackdir_rev, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_NONE);
 		if (ftd.best_bird_dist != 0) {
 			/* We didn't find anything, just keep on going straight ahead */
 			reverse_best = false;
@@ -2153,7 +2281,7 @@
 	// check if we've reached the waypoint?
 	if (v->current_order.type == OT_GOTO_WAYPOINT && v->tile == v->dest_tile) {
 		v->cur_order_index++;
-	}
+	}	
 
 	// check if we've reached a non-stop station while TTDPatch nonstop is enabled..
 	if (_patches.new_nonstop && v->current_order.flags & OF_NON_STOP &&
@@ -2322,6 +2450,9 @@
 			v->index,
 			0);
 	}
+	if (v->subtype == TS_Front_Engine) st->vehicles[STS_VEH_TRAIN].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
 
 	// Did we reach the final destination?
 	if (v->current_order.type == OT_GOTO_STATION &&
@@ -2599,6 +2730,8 @@
 			(v->u.rail.track & 0x40 && (v->direction & 2) != (realcoll->direction & 2)))
 		return;
 
+	//DEBUG(pbs,0) ("collision, %i-%i", v->index, coll->index);
+	//assert(0);
 	//two drivers + passangers killed in train v
 	num = 2 + CountPassengersInTrain(v);
 	if (!(coll->vehstatus & VS_CRASHED))
@@ -2666,7 +2799,7 @@
 				} else {
 					/* is not inside depot */
 
-					if (!TrainCheckIfLineEnds(v))
+					if ((prev == NULL) && (!TrainCheckIfLineEnds(v)))
 						return;
 
 					r = VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);
@@ -2721,11 +2854,63 @@
 				}
 
 				if (prev == NULL) {
+					byte trackdir;
 					/* Currently the locomotive is active. Determine which one of the
 					 * available tracks to choose */
 					chosen_track = 1 << ChooseTrainTrack(v, gp.new_tile, enterdir, bits);
 					assert(chosen_track & tracks);
 
+					trackdir = TrackEnterdirToTrackdir(FIND_FIRST_BIT(chosen_track), enterdir);
+					assert(trackdir != 0xff);
+//					DEBUG(misc,0) ("chosen track (%i)  tile:%x  track:%i", v->unitnumber, gp.new_tile, chosen_track);
+					//assert(gp.new_tile < MapSize());
+					if (PBSIsPbsSignal(gp.new_tile,trackdir)) {
+						// encountered a pbs signal, and possible a pbs block
+						DEBUG(pbs, 3) ("pbs: (%i) arrive AT signal, tile:%x  pbs_stat:%i",v->unitnumber, gp.new_tile, v->u.rail.pbs_status);
+
+						if (v->u.rail.pbs_status == PBS_STAT_NONE) {
+							// we havent planned a path already, so try to find one now
+							NPFFindStationOrTileData fstd;
+							NPFFoundTargetData ftd;
+
+							NPFFillWithOrderData(&fstd, v);
+
+							if (v->unitnumber == 12) {
+								v->unitnumber--;
+								v->unitnumber++;
+							}
+
+
+							DEBUG(pbs, 2) ("pbs: (%i) choose signal (TC), tile:%x, trackdir:%i",v->unitnumber,  gp.new_tile, trackdir);
+							ftd = NPFRouteToStationOrTile(gp.new_tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+							//DEBUG(pbs, 2) ("pbs: (%i) choose signal (TC) done", v->unitnumber);
+
+							
+							if (v->u.rail.force_proceed != 0)
+								goto green_light;
+
+							if (ftd.best_trackdir == 0xFF)
+								goto red_light;
+							
+							// we found a way out of the pbs block
+							if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+								if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+									goto red_light;
+								else {
+									goto green_light;
+								}
+								
+							};
+
+						} else {
+							// we have already planned a path through this pbs block
+							// on entering the block, we reset our status
+							v->u.rail.pbs_status = PBS_STAT_NONE;
+							goto green_light;
+						};
+						DEBUG(pbs, 3) ("pbs: (%i) no green light found, or was no pbs-block",v->unitnumber);
+					};
+
 					/* Check if it's a red signal and that force proceed is not clicked. */
 					if ( (tracks>>16)&chosen_track && v->u.rail.force_proceed == 0) goto red_light;
 				} else {
@@ -2734,6 +2919,9 @@
 					/* The wagon is active, simply follow the prev vehicle. */
 					chosen_track = (byte)(_matching_tracks[GetDirectionToVehicle(prev, gp.x, gp.y)] & bits);
 				}
+green_light:
+				if (v->next == NULL)
+					PBSClearTrack(gp.old_tile, FIND_FIRST_BIT(v->u.rail.track));
 
 				/* make sure chosen track is a valid track */
 				assert(chosen_track==1 || chosen_track==2 || chosen_track==4 || chosen_track==8 || chosen_track==16 || chosen_track==32);
@@ -2761,13 +2949,25 @@
 					assert(v->u.rail.track);
 				}
 
-				if (v->subtype == TS_Front_Engine)
- 				TrainMovedChangeSignals(gp.new_tile, enterdir);
+ 				if (v->subtype == TS_Front_Engine) {
+  					TrainMovedChangeSignals(gp.new_tile, enterdir);
+ 					if (v->current_order.type == OT_GOTO_WAYPOINT && v->tile == v->dest_tile) {
+ 						Waypoint *wp = GetWaypointByTile(v->tile);
+ 						if (wp->months_counted == 0) wp->months_counted = 1;
+ 						wp->vehicles[STS_WP_ORDER].this_month++;
+ 						wp->vehicles[STS_WP_ORDER_YEAR].this_month++;
+ 					} else if (IsRailWaypoint(_map5[v->tile])) {
+ 						Waypoint *wp = GetWaypointByTile(v->tile);
+ 						if (wp->months_counted == 0) wp->months_counted = 1;
+ 						wp->vehicles[STS_WP_PATHFIND].this_month++;
+ 						wp->vehicles[STS_WP_PATHFIND_YEAR].this_month++;
+ 					}
+ 				}
 
 				/* Signals can only change when the first
 				 * (above) or the last vehicle moves. */
 				if (v->next == NULL)
- 				TrainMovedChangeSignals(gp.old_tile, (enterdir) ^ 2);
+				TrainMovedChangeSignals(gp.old_tile, (enterdir) ^ 2);
 
 				if (prev == NULL) {
 					AffectSpeedByDirChange(v, chosen_dir);
@@ -2882,6 +3082,16 @@
 	EndVehicleMove(v);
 	DeleteVehicle(v);
 
+	// clear up reserved pbs tracks
+	/*
+	if (PBSTileReserved(v->tile) & v->u.rail.track) {
+		if (v->tile != u->tile) {
+			PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
+		} else if (v == u) {
+		};
+	}
+	*/
+	
 	if (!(v->u.rail.track & 0xC0))
 		SetSignalsOnBothDir(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 
@@ -3009,6 +3219,7 @@
 	uint x,y;
 	int t;
 	uint32 ts;
+	byte trackdir;
 
 	if ((uint)(t=v->breakdown_ctr) > 1) {
 		v->vehstatus |= VS_TRAIN_SLOWING;
@@ -3047,6 +3258,11 @@
 	// determine the track status on the next tile.
 	ts = GetTileTrackStatus(tile, TRANSPORT_RAIL) & _reachable_tracks[t];
 
+	if (ts & 0x3F3F)
+		trackdir = FindFirstBit2x64(ts & 0x3F3F);
+	else
+		trackdir = 0xFF;
+
 	/* Calc position within the current tile ?? */
 	x = v->x_pos & 0xF;
 	y = v->y_pos & 0xF;
@@ -3099,6 +3315,40 @@
 		return false;
 	}
 
+	if  (v->u.rail.pbs_status == PBS_STAT_HAS_PATH)
+		return true;
+
+	if ((trackdir != 0xFF) && (PBSIsPbsSignal(tile,trackdir)) && !(IsTileType(v->tile, MP_STATION) && (v->current_order.station == _map2[v->tile]))) {
+		NPFFindStationOrTileData fstd;
+		NPFFoundTargetData ftd;
+
+		NPFFillWithOrderData(&fstd, v);
+
+		if (v->unitnumber == 55) {
+			trackdir--;
+			trackdir++;
+		}
+
+		DEBUG(pbs, 2) ("pbs: (%i) choose signal (CEOL), tile:%x  trackdir:%i", v->unitnumber, tile, trackdir);
+		ftd = NPFRouteToStationOrTile(tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+		DEBUG(pbs, 2) ("pbs: (%i) choose signal (CEOL) done", v->unitnumber);
+
+//		if ((ftd.best_bird_dist == 0) && NPFGetFlag(&ftd.node, NPF_FLAG_PBS_TRACK) && !NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED) && !NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED)) {
+//			v->u.rail.pbs_status = PBS_STAT_HAS_PATH;
+//			return true;
+//		};
+
+		if (ftd.best_trackdir != 0xFF && NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+			{;}
+			else {
+				v->u.rail.pbs_status = PBS_STAT_HAS_PATH;
+				return true;
+			}
+		};
+							
+	};
+
 	// slow down
 	v->vehstatus |= VS_TRAIN_SLOWING;
 	t = _breakdown_speeds[x & 0xF];
@@ -3186,6 +3436,9 @@
 	v->tick_counter++;
 
 	if (v->subtype == TS_Front_Engine) {
+//		if (v->unitnumber != 86) {
+//			v->vehstatus= VS_STOPPED;
+//		};
 		TrainLocoHandler(v, false);
 
 		// make sure vehicle wasn't deleted.
@@ -3259,6 +3512,12 @@
 	Depot *depot;
 	TrainFindDepotData tfdd;
 
+	if (PBSTileReserved(v->tile) & v->u.rail.track)
+		return;
+
+	if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH)
+		return;
+
 	if (_patches.servint_trains == 0)
 		return;
 
Index: saveload.h
===================================================================
--- saveload.h	(revision 2456)
+++ saveload.h	(working copy)
@@ -110,6 +110,8 @@
 	SLE_FILE_U64 = 7,
 
 	SLE_FILE_STRINGID = 8,
+	
+	SLE_FILE_B = 9,
 //	SLE_FILE_IVAR = 8,
 //	SLE_FILE_UVAR = 9,
 
@@ -124,6 +126,8 @@
 
 	SLE_VAR_NULL = 8 << 4, // useful to write zeros in savegame.
 
+	SLE_VAR_B = 9 << 4, // boolean value, currently just wrote as bytes
+	
 	SLE_VAR_INT  = SLE_VAR_I32,
 	SLE_VAR_UINT = SLE_VAR_U32,
 
@@ -137,6 +141,8 @@
 	SLE_UINT64 = SLE_FILE_U64 | SLE_VAR_U64,
 
 	SLE_STRINGID = SLE_FILE_STRINGID | SLE_VAR_U16,
+	
+	SLE_BOOL = SLE_FILE_B | SLE_VAR_B,
 } VarType;
 
 enum SaveLoadTypes {
@@ -191,10 +197,19 @@
 void SlArray(void *array, uint length, VarType conv);
 void SlObject(void *object, const SaveLoad *desc);
 void SlAutolength(AutolengthProc *proc, void *arg);
+
 uint SlGetFieldLength(void);
 int SlReadByte(void);
+int SlReadUint16(void);
+uint32 SlReadUint32(void);
+uint64 SlReadUint64(void);
+
 void SlSetLength(size_t length);
 void SlWriteByte(byte b);
+void SlWriteUint16(VarType v);
+void SlWriteUint32(uint32 v);
+void SlWriteUint64(uint64 v);
+ 
 void SlGlobList(const SaveLoadGlobVarList *desc);
 
 #endif /* SAVELOAD_H */
Index: table/sprites.h
===================================================================
--- table/sprites.h	(revision 2456)
+++ table/sprites.h	(working copy)
@@ -42,7 +42,7 @@
 	SPR_ASCII_SPACE_BIG   = 450,
 
 	/* Extra graphic spritenumbers */
-	SPR_CANALS_BASE		= 5126,
+	SPR_CANALS_BASE		= 5382,
 	SPR_SLOPES_BASE		= SPR_CANALS_BASE + 70,
 	SPR_AUTORAIL_BASE		= SPR_SLOPES_BASE + 78,
 	SPR_OPENTTD_BASE	= SPR_AUTORAIL_BASE + 55, // can be lowered once autorail.grf is finalized
Index: table/files.h
===================================================================
--- table/files.h	(revision 2456)
+++ table/files.h	(working copy)
@@ -26,7 +26,7 @@
 		{ "TRG1.GRF", {0x93,0x11,0x67,0x62,0x80,0xe5,0xb1,0x40,0x77,0xa8,0xee,0x41,0xc1,0xb4,0x21,0x92} },     //    0 - 4792 inclusive
 		{ "TRGI.GRF", {0xda,0x6a,0x6c,0x9d,0xcc,0x45,0x1e,0xec,0x88,0xd7,0x92,0x11,0x43,0x7b,0x76,0xa8} },     // 4793 - 4889 inclusive
 		{ "dosdummy.grf", {0x07,0x01,0xe6,0xc4,0x07,0x6a,0x5b,0xc3,0xf4,0x9f,0x01,0xad,0x21,0x6c,0xa0,0xc2} }, // 4890 - 4895 inclusive
-		{ "signalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5125 inclusive
+		{ "nsignalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5381 inclusive
 		{ NULL, { 0 } }
 	},
 	{	{ "TRGC.GRF", {0xed,0x44,0x66,0x37,0xe0,0x34,0x10,0x4c,0x55,0x59,0xb3,0x2c,0x18,0xaf,0xe7,0x8d} },
@@ -39,7 +39,7 @@
 	{
 		{ "TRG1R.GRF", {0xb0,0x4c,0xe5,0x93,0xd8,0xc5,0x01,0x6e,0x07,0x47,0x3a,0x74,0x3d,0x7d,0x33,0x58} },    //    0 - 4792 inclusive
 		{ "TRGIR.GRF", {0x0c,0x24,0x84,0xff,0x6b,0xe4,0x9f,0xc6,0x3a,0x83,0xbe,0x6a,0xb5,0xc3,0x8f,0x32} },    // 4793 - 4895 inclusive
-		{ "signalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5125 inclusive
+		{ "nsignalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5381 inclusive
 		{ NULL, { 0 } },
 		{ NULL, { 0 } }
 	},
Index: road_cmd.c
===================================================================
--- road_cmd.c	(revision 2456)
+++ road_cmd.c	(working copy)
@@ -1,5 +1,6 @@
 #include "stdafx.h"
 #include "openttd.h"
+#include "table/sprites.h"
 #include "table/strings.h"
 #include "map.h"
 #include "tile.h"
@@ -11,6 +12,7 @@
 #include "gfx.h"
 #include "sound.h"
 #include "depot.h"
+#include "pbs.h"
 
 /* When true, GetTrackStatus for roads will treat roads under reconstruction
  * as normal roads instead of impassable. This is used when detecting whether
@@ -246,6 +248,7 @@
 
 			cost = _price.remove_road * 2;
 			if (flags & DC_EXEC) {
+				byte pbs_track = PBSTileReserved(tile);
 				ChangeTownRating(t, -road_remove_cost[(byte)edge_road], RATING_ROAD_MINIMUM);
 
 				ModifyTile(tile,
@@ -254,6 +257,8 @@
 					_map3_hi[tile] & 0xF, /* map3_lo */
 					c											/* map5 */
 				);
+				if (pbs_track != 0)
+					PBSReserveTrack(tile, FIND_FIRST_BIT(pbs_track));
 			}
 			return cost;
 		} else
@@ -354,6 +359,7 @@
 	int32 cost;
 	byte pieces = (byte)p1, existing = 0;
 	TileIndex tile;
+	
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
@@ -396,6 +402,7 @@
 			goto do_clear;
 
 		if (flags & DC_EXEC) {
+			byte pbs_track = PBSTileReserved(tile);
 			ModifyTile(tile,
 				MP_SETTYPE(MP_STREET) |
 				MP_MAP2 | MP_MAP3LO | MP_MAP3HI | MP_MAP5,
@@ -404,6 +411,8 @@
 				_map3_lo[tile] & 0xF, /* map3_hi */
 				m5 /* map5 */
 			);
+			if (pbs_track != 0)
+				PBSReserveTrack(tile, FIND_FIRST_BIT(pbs_track));
 		}
 		return _price.build_road * 2;
 	} else if (ti.type == MP_TUNNELBRIDGE) {
@@ -826,6 +835,20 @@
 		}
 
 		DrawGroundSprite(image + (_map3_hi[ti->tile] & 0xF) * 12);
+
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(0x3ED | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(0x3EE | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(0x3EF | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(0x3F0 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(0x3F2 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 | PALETTE_CRASH);
+}
+#endif
+
 	} else {
 		uint32 ormod;
 		int player;
Index: smallmap_gui.c
===================================================================
--- smallmap_gui.c	(revision 2456)
+++ smallmap_gui.c	(working copy)
@@ -13,7 +13,19 @@
 #include "vehicle.h"
 #include "town.h"
 #include "sound.h"
+#include "variables.h"
+#include "debug.h"
 
+static int _smallmap_type;
+static bool _smallmap_show_towns = true;
+static int smallmap_zoom;
+
+void SmallMapRecentre(void);
+
+#define MK(a,b) a, b
+#define MKEND() 0xFFFF
+#define MS(a,b) (a | 0x100), b
+
 static const Widget _smallmap_widgets[] = {
 {   WWT_TEXTBTN,   RESIZE_NONE,    13,     0,    10,     0,    13, STR_00C5,                STR_018B_CLOSE_WINDOW},
 {   WWT_CAPTION,  RESIZE_RIGHT,    13,    11,   433,     0,    13, STR_00B0_MAP,            STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -26,21 +38,16 @@
 {    WWT_IMGBTN,   RESIZE_LRTB,    13,   380,   401,   280,   301, SPR_IMG_SHOW_ROUTES,     STR_0194_SHOW_TRANSPORT_ROUTES_ON},
 {    WWT_IMGBTN,   RESIZE_LRTB,    13,   402,   423,   280,   301, SPR_IMG_PLANTTREES,      STR_0195_SHOW_VEGETATION_ON_MAP},
 {    WWT_IMGBTN,   RESIZE_LRTB,    13,   424,   445,   280,   301, SPR_IMG_COMPANY_GENERAL, STR_0196_SHOW_LAND_OWNERS_ON_MAP},
-{    WWT_IMGBTN,   RESIZE_LRTB,    13,   358,   379,   258,   279, 0x0,                     STR_NULL},
+{     WWT_PANEL,   RESIZE_LRTB,    13,   358,   379,   258,   279, 683,				STR_RECENTRE_SMALLMAP},
 {    WWT_IMGBTN,   RESIZE_LRTB,    13,   358,   379,   280,   301, SPR_IMG_TOWN,            STR_0197_TOGGLE_TOWN_NAMES_ON_OFF},
-{    WWT_IMGBTN,    RESIZE_RTB,    13,     0,   357,   258,   301, 0x0,                     STR_NULL},
+{     WWT_PANEL,   RESIZE_LRTB,    13,   336,   357,   258,   279, 0x2DF,					STR_ZOOM_IN_SMALLMAP},
+{     WWT_PANEL,   RESIZE_LRTB,    13,   336,   357,   280,   301, 0x2E0,					STR_ZOOM_OUT_SMALLMAP},
+{     WWT_IMGBTN,    RESIZE_RTB,    13,     0,   335,   258,   301, 0x0,					STR_NULL},
 {     WWT_PANEL,    RESIZE_RTB,    13,     0,   433,   302,   313, 0x0,                     STR_NULL},
 { WWT_RESIZEBOX,   RESIZE_LRTB,    13,   434,   445,   302,   313, 0x0,                     STR_RESIZE_BUTTON},
 {  WIDGETS_END},
 };
 
-static int _smallmap_type;
-static bool _smallmap_show_towns = true;
-
-#define MK(a,b) a, b
-#define MKEND() 0xFFFF
-#define MS(a,b) (a | 0x100), b
-
 /* Legend text giving the colours to look for on the minimap */
 static const uint16 _legend_land_contours[] = {
 	MK(0x5A,STR_00F0_100M),
@@ -330,10 +337,10 @@
 
 	do {
 		// check if the tile (xc,yc) is within the map range
-		if (xc < MapMaxX() && yc < MapMaxY()) {
+		if (xc * smallmap_zoom < MapMaxX() && yc * smallmap_zoom < MapMaxY()) {
 			// check if the dst pointer points to a pixel inside the screen buffer
 			if (dst > _screen.dst_ptr && dst < dst_ptr_end)
-				WRITE_PIXELS_OR(dst, proc(TILE_XY(xc, yc)) & mask );
+				WRITE_PIXELS_OR(dst, proc(TILE_XY(xc * smallmap_zoom, yc * smallmap_zoom)) & mask );
 		}
 	// switch to next tile in the column
 	} while (xc++, yc++, dst += pitch, --reps != 0);
@@ -701,8 +708,8 @@
 					(v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) == 0) {
 				// Remap into flat coordinates.
 				Point pt = RemapCoords(
-					(v->x_pos - WP(w,smallmap_d).scroll_x) / 16,
-					(v->y_pos - WP(w,smallmap_d).scroll_y) / 16,
+					((v->x_pos / smallmap_zoom) - WP(w,smallmap_d).scroll_x) / 16,
+					((v->y_pos / smallmap_zoom)  - WP(w,smallmap_d).scroll_y) / 16,
 					0);
 				x = pt.x;
 				y = pt.y;
@@ -749,8 +756,8 @@
 			if (t->xy != 0) {
 				// Remap the town coordinate
 				Point pt = RemapCoords(
-					(int)(TileX(t->xy) * 16 - WP(w, smallmap_d).scroll_x) / 16,
-					(int)(TileY(t->xy) * 16 - WP(w, smallmap_d).scroll_y) / 16,
+					(int)((TileX(t->xy) / smallmap_zoom) * 16 - WP(w, smallmap_d).scroll_x) / 16,
+					(int)((TileY(t->xy) / smallmap_zoom) * 16 - WP(w, smallmap_d).scroll_y) / 16,
 					0);
 				x = pt.x - WP(w,smallmap_d).subscroll + 3 - (t->sign.width_2 >> 1);
 				y = pt.y;
@@ -777,10 +784,10 @@
 
 		pt = RemapCoords(WP(w, smallmap_d).scroll_x, WP(w, smallmap_d).scroll_y, 0);
 
-		x = vp->virtual_left - pt.x;
-		y = vp->virtual_top - pt.y;
-		x2 = (x + vp->virtual_width) / 16;
-		y2 = (y + vp->virtual_height) / 16;
+		x = (vp->virtual_left / smallmap_zoom) - pt.x;
+		y = (vp->virtual_top / smallmap_zoom) - pt.y;
+		x2 = (x + (vp->virtual_width / smallmap_zoom)) / 16;
+		y2 = (y + (vp->virtual_height / smallmap_zoom)) / 16;
 		x /= 16;
 		y /= 16;
 
@@ -799,6 +806,10 @@
 static void SmallMapWindowProc(Window *w, WindowEvent *e)
 {
 	switch (e->event) {
+	case WE_CREATE: { /* Disable zoom in button */
+		w->disabled_state = (1 << 13);
+		smallmap_zoom = 1;
+	} break;
 	case WE_PAINT: {
 		const uint16 *tbl;
 		int x,y,y_org;
@@ -846,8 +857,8 @@
 			w2 = FindWindowById(WC_MAIN_WINDOW, 0);
 
 			pt = RemapCoords(WP(w,smallmap_d).scroll_x, WP(w,smallmap_d).scroll_y, 0);
-			WP(w2,vp_d).scrollpos_x = pt.x + ((_cursor.pos.x - w->left + 2) << 4) - (w2->viewport->virtual_width >> 1);
-			WP(w2,vp_d).scrollpos_y = pt.y + ((_cursor.pos.y - w->top - 16) << 4) - (w2->viewport->virtual_height >> 1);
+			WP(w2,vp_d).scrollpos_x = (pt.x * smallmap_zoom) + (((_cursor.pos.x - w->left + 2) << 4) * smallmap_zoom)  - ((w2->viewport->virtual_width >> 1) /  smallmap_zoom);
+			WP(w2,vp_d).scrollpos_y = (pt.y * smallmap_zoom) + (((_cursor.pos.y - w->top - 16) << 4) * smallmap_zoom) - ((w2->viewport->virtual_height >> 1)  / smallmap_zoom);
 		} break;
 
 		case 5: /* Show land contours */
@@ -864,12 +875,33 @@
 			SndPlayFx(SND_15_BEEP);
 			break;
 
+		case 11: /* centre location */
+			SmallMapRecentre();
+			SetWindowDirty(w);
+			SndPlayFx(SND_15_BEEP);
+			break;
 		case 12: /* toggle town names */
 			w->click_state ^= (1 << 12);
 			_smallmap_show_towns = (w->click_state >> 12) & 1;
 			SetWindowDirty(w);
 			SndPlayFx(SND_15_BEEP);
 			break;
+		case 13: /* zoom in */
+			if (smallmap_zoom > 1)
+				smallmap_zoom--;
+			
+			SmallMapRecentre();
+			SetWindowDirty(w);
+			SndPlayFx(SND_15_BEEP);
+			break;
+		case 14: /* zoom out */
+			if (smallmap_zoom < 8)
+				smallmap_zoom++;
+			
+			SmallMapRecentre();
+			SetWindowDirty(w);
+			SndPlayFx(SND_15_BEEP);
+			break;
 		}
 		break;
 
@@ -882,15 +914,67 @@
 			_cursor.delta.y = 0;
 		}
 		break;
+	case WE_MCLICK:
+		SmallMapRecentre();
+		SetWindowDirty(w);
+		break;
 
 	case WE_MOUSELOOP:
 		/* update the window every now and then */
 		if ((++w->vscroll.pos & 0x1F) == 0)
 			SetWindowDirty(w);
 		break;
+
+	case WE_SCROLL: {
+		/* handle mouse wheel zooming */
+		int oldzoom = smallmap_zoom;
+
+		DEBUG(misc,0)("Got: %d", e->scroll.scroll);
+		
+		if ((smallmap_zoom + e->scroll.amount) > 0 && e->scroll.scroll == ZOOM_IN)
+			smallmap_zoom += e->scroll.amount;
+			
+		if ((smallmap_zoom + e->scroll.amount) < 9 && e->scroll.scroll == ZOOM_OUT)
+			smallmap_zoom += e->scroll.amount;
+	
+		if (oldzoom != smallmap_zoom)
+		{
+			SmallMapRecentre();
+			SetWindowDirty(w);
+		}
+
+		} break;
 	}
 }
 
+void SmallMapRecentre(void)
+{
+	int x,y;
+	Window *w;
+	ViewPort *vp;
+	
+	/* recentre the map */
+	w = FindWindowById(WC_SMALLMAP, 0);
+	vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
+
+	x =  ((((vp->virtual_width / smallmap_zoom) - (220*32)) / 2) + vp->virtual_left) / (4  * smallmap_zoom);
+	y = (((((vp->virtual_height  / smallmap_zoom) - (120*32)) / 2) + vp->virtual_top) / (2 * smallmap_zoom)) - 32;
+
+	WP(w,smallmap_d).scroll_x = (y-x) & ~0xF;
+	WP(w,smallmap_d).scroll_y = (x+y) & ~0xF;
+	WP(w,smallmap_d).subscroll = 0;
+
+	/* handle disabled states of buttons */
+	CLRBIT(w->disabled_state, 13);
+	CLRBIT(w->disabled_state, 14);
+
+	if (smallmap_zoom <= 1) {
+		SETBIT(w->disabled_state, 13);
+	}if (smallmap_zoom >= 8) {
+		SETBIT(w->disabled_state, 14);
+	}
+}	
+
 static const WindowDesc _smallmap_desc = {
 	-1,-1, 446, 314,
 	WC_SMALLMAP,0,
@@ -913,8 +997,8 @@
 
 		vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 
-		x =  (((vp->virtual_width - (220*32)) / 2) + vp->virtual_left) / 4;
-		y = ((((vp->virtual_height- (120*32)) / 2) + vp->virtual_top ) / 2) - 32;
+		x =  ((((vp->virtual_width / smallmap_zoom) - (220*32)) / 2) + vp->virtual_left) / (4  * smallmap_zoom);
+		y = (((((vp->virtual_height  / smallmap_zoom) - (120*32)) / 2) + vp->virtual_top) / (2 * smallmap_zoom)) - 32;
 		WP(w,smallmap_d).scroll_x = (y-x) & ~0xF;
 		WP(w,smallmap_d).scroll_y = (x+y) & ~0xF;
 		WP(w,smallmap_d).subscroll = 0;
@@ -930,8 +1014,8 @@
 {          WWT_6,     RESIZE_RB,    14,     2,   297,    16,   231, 0x0,				STR_NULL},
 {      WWT_PANEL,     RESIZE_TB,    14,     0,    21,   234,   255, 0x2DF,			STR_017F_ZOOM_THE_VIEW_IN},
 {      WWT_PANEL,     RESIZE_TB,    14,    22,    43,   234,   255, 0x2E0,			STR_0180_ZOOM_THE_VIEW_OUT},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,    44,   171,   234,   255, STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW,STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW_TT},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   172,   298,   234,   255, STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN,STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN_TT},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,    44,   171,   234,   255, STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN,STR_EXTRA_VIEW_MOVE_VIEW_TO_MAIN_TT},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   172,   298,   234,   255, STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW,STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW_TT},
 {      WWT_PANEL,    RESIZE_RTB,    14,   299,   299,   234,   255, 0x0,				STR_NULL},
 {      WWT_PANEL,    RESIZE_RTB,    14,     0,   287,   256,   267, 0x0,				STR_NULL},
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   288,   299,   256,   267, 0x0,				STR_RESIZE_BUTTON},
@@ -980,6 +1064,10 @@
 		}
 	} break;
 
+	case WE_SCROLL:
+		DirtyZoomButtons(w, w->viewport, 5);
+		break;
+
 	case WE_RESIZE:
 		w->viewport->width  += e->sizing.diff.x;
 		w->viewport->height += e->sizing.diff.y;
@@ -993,7 +1081,7 @@
 static const WindowDesc _extra_view_port_desc = {
 	-1,-1, 300, 268,
 	WC_EXTRA_VIEW_PORT,0,
-	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE | WDF_ZOOMABLE,
 	_extra_view_port_widgets,
 	ExtraViewPortWndProc
 };
@@ -1015,6 +1103,7 @@
 		v = FindWindowById(WC_MAIN_WINDOW, 0);
 		// New viewport start ats (zero,zero)
 		AssignWindowViewport(w, 3, 17, 294, 214, 0 , 0);
+		w->viewport->zoom_max = 2; // max zoom of 2
 
 		// center on same place as main window (zoom is maximum, no adjustment needed)
 		x = WP(v, vp_d).scrollpos_x;
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 2456)
+++ rail_cmd.c	(working copy)
@@ -16,7 +16,9 @@
 #include "station.h"
 #include "sprite.h"
 #include "depot.h"
+#include "pbs.h"
 #include "waypoint.h"
+#include "npf.h"
 #include "rail.h"
 
 extern uint16 _custom_sprites_base;
@@ -759,9 +761,22 @@
 			} else {
 				if (pre_signal) {
 					// cycle between normal -> pre -> exit -> combo -> ...
-					byte type = (GetSignalType(tile, track) + 1) & 0x03;
-					_map3_hi[tile] &= ~0x03;
-					_map3_hi[tile] |= type;
+//<<<<<<< .mine
+					// TODO: fix up this hacky mess :-p
+					byte type = (_map3_hi[tile] & 0x03) + ((_map3_hi[tile] & 0x08) >> 1);
+					DEBUG(pbs, 0) ("change signals, type:%i", type);
+					++type;
+					if (type == 5)
+						type = 0;
+					_map3_hi[tile] &= ~0x0B;
+					_map3_hi[tile] |= type & 0x03;
+					type <<= 1;
+					_map3_hi[tile] |= type & 0x08;
+//-------
+//					byte type = (GetSignalType(tile, track) + 1) & 0x03;
+//					_map3_hi[tile] &= ~0x03;
+//					_map3_hi[tile] |= type;
+//>>>>>>> .r2456
 				} else {
 					// cycle between two-way -> one-way -> one-way -> ...
 					/* TODO: Rewrite switch into something more general */
@@ -1116,7 +1131,7 @@
 #include "table/track_land.h"
 
 // used for presignals
-static const SpriteID _signal_base_sprites[16] = {
+static const SpriteID _signal_base_sprites[32] = {
 	0x4FB,
 	0x1323,
 	0x1333,
@@ -1128,16 +1143,41 @@
 	0x1373,
 	0x1383,
 
+	// pbs
+	0x1393,
+	0x13A3,  // not used (yet?)
+	0x13B3,  // not used (yet?)
+	0x13C3,  // not used (yet?)
+
+	// pbs + sema
+	0x13D3,
+	0x13E3,  // not used (yet?)
+	0x13F3,  // not used (yet?)
+	0x1403,  // not used (yet?)
+
+
 	// mirrored versions
 	0x4FB,
 	0x1323,
 	0x1333,
 	0x1343,
 
-	0x13C6,
-	0x13D6,
-	0x13E6,
-	0x13F6,
+	0x1446,
+	0x1456,
+	0x1466,
+	0x1476,
+
+	// pbs
+	0x1393,
+	0x13A3,  // not used (yet?)
+	0x13B3,  // not used (yet?)
+	0x13C3,  // not used (yet?)
+
+	// pbs + sema
+	0x14C6,
+	0x14D6,  // not used (yet?)
+	0x14E6,  // not used (yet?)
+	0x14F6,  // not used (yet?)
 };
 
 // used to determine the side of the road for the signal
@@ -1155,7 +1195,7 @@
 	uint v = _signal_position[(image_and_pos & 0xF) + (otherside ? 12 : 0)];
 	uint x = ti->x | (v&0xF);
 	uint y = ti->y | (v>>4);
-	uint sprite = _signal_base_sprites[(_map3_hi[ti->tile] & 7) + (otherside ? 8 : 0)] + (image_and_pos>>4) + ((condition != 0) ? 1 : 0);
+	uint sprite = _signal_base_sprites[(_map3_hi[ti->tile] & 15) + (otherside ? 16 : 0)] + (image_and_pos>>4) + ((condition != 0) ? 1 : 0);
 	AddSortableSpriteToDraw(sprite, x, y, 1, 1, 10, GetSlopeZ(x,y));
 }
 
@@ -1366,6 +1406,19 @@
 			if (m5 & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 + tracktype_offs);
 		}
 
+#ifdef PBS_SHOW_RESERVED
+		{
+			byte pbs = PBSTileReserved(ti->tile);
+			assert(pbs != 0xFF);
+			if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite((0x3ED + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite((0x3EE + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_UPPER) DrawGroundSprite((0x3EF + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_LOWER) DrawGroundSprite((0x3F0 + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite((0x3F2 + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite((0x3F1 + tracktype_offs) | PALETTE_CRASH);
+		}
+#endif
+
 		if (_display_opt & DO_FULL_DETAIL) {
 			_detailed_track_proc[_map2[ti->tile] & RAIL_MAP2LO_GROUND_MASK](ti);
 		}
@@ -1475,6 +1528,19 @@
 
 		DrawGroundSprite(image);
 
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite((0x3ED + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite((0x3EE + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite((0x3EF + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite((0x3F0 + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite((0x3F2 + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite((0x3F1 + tracktype_offs) | PALETTE_CRASH);
+}
+#endif
+
 		while ((image=drss->image) != 0) {
 			DrawSpecialBuilding(image, type < 4 ? tracktype_offs : 0, ti,
 			                    drss->subcoord_x, drss->subcoord_y, 0,
@@ -1519,6 +1585,7 @@
 	int cur_stack;
 	bool stop;
 	bool has_presignal;
+	bool has_pbssignal;
 
 	// presignal info
 	int presignal_exits;
@@ -1528,6 +1595,10 @@
 	byte bit[NUM_SSD_ENTRY];
 	TileIndex tile[NUM_SSD_ENTRY];
 
+	int pbs_cur;
+	// these are used to keep track of the signals that change.
+	TileIndex pbs_tile[NUM_SSD_ENTRY];
+
 	// these are used to keep track of the stack that modifies presignals recursively
 	TileIndex next_tile[NUM_SSD_STACK];
 	byte next_dir[NUM_SSD_STACK];
@@ -1545,12 +1616,19 @@
 					ssd->tile[ssd->cur] = tile; // remember the tile index
 					ssd->bit[ssd->cur] = track; // and the controlling bit number
 					ssd->cur++;
+//					DEBUG(pbs, 0) ("sigstuff tile:%x  track:%i",tile,track);
+					ssd->has_pbssignal |= PBSIsPbsSignal(tile, ReverseTrackdir(track));
 				}
 
 				// remember if this block has a presignal.
 				ssd->has_presignal |= (_map3_hi[tile]&1);
 			}
 
+			if ((_map3_lo[tile] & _signals_table_both[track]) != 0) {
+				ssd->pbs_tile[ssd->pbs_cur] = tile; // remember the tile index
+				ssd->pbs_cur++;
+			}
+
 			// is this an exit signal that points out from the segment?
 			if ((_map3_hi[tile]&2) && _map3_lo[tile]&_signals_table_other[track]) {
 				ssd->presignal_exits++;
@@ -1565,6 +1643,26 @@
 	return false;
 }
 
+static bool SetSignalsEnumProcPBS(uint tile, SetSignalsData *ssd, int track, uint length, byte *state)
+{
+	// the tile has signals?
+	if (IsTileType(tile, MP_RAILWAY)) {
+		if (GetRailTileType(tile) == RAIL_TYPE_SIGNALS) {
+			if ((_map3_lo[tile] & _signals_table_both[track]) != 0) {
+
+				if (ssd->cur != NUM_SSD_ENTRY) {
+					ssd->tile[ssd->cur] = tile; // remember the tile index
+					ssd->bit[ssd->cur] = track & 7; // and the controlling bit number
+					ssd->cur++;
+				}
+				return true;
+			}
+		} else if (IsTileDepotType(tile, TRANSPORT_RAIL))
+			return true; // don't look further if the tile is a depot
+	}
+	return false;
+}
+
 /* Struct to parse data from VehicleFromPos to SignalVehicleCheckProc */
 typedef struct SignalVehicleCheckStruct {
 	TileIndex tile;
@@ -1692,6 +1790,15 @@
 	//   there is at least one green exit signal OR
 	//   there are no exit signals in the segment
 
+	if (false && !(ssd->stop) && (ssd->has_pbssignal))
+	for(i=0; i!=ssd->pbs_cur; i++) {
+		TileIndex tile = ssd->pbs_tile[i];
+		_map3_hi[tile] &= ~0x0B;
+		_map3_hi[tile] |= 0x08;
+		MarkTileDirtyByTile(tile);
+	}
+
+
 	// then mark the signals in the segment accordingly
 	for(i=0; i!=ssd->cur; i++) {
 		uint tile = ssd->tile[i];
@@ -1752,8 +1859,9 @@
 
 	for(;;) {
 		// go through one segment and update all signals pointing into that segment.
-		ssd.cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
+		ssd.cur = ssd.pbs_cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
 		ssd.has_presignal = false;
+		ssd.has_pbssignal = false;
 
 		FollowTrack(tile, 0xC000 | TRANSPORT_RAIL, direction, (TPFEnumProc*)SetSignalsEnumProc, SetSignalsAfterProc, &ssd);
 		ChangeSignalStates(&ssd);
@@ -1773,6 +1881,30 @@
 	return (bool)result;
 }
 
+bool PBSIsPbsSegment(uint tile, byte direction)
+{
+	SetSignalsData ssd;
+	bool result = false;
+	int i;
+
+	ssd.cur_stack = 0;
+	direction>>=1;
+
+	ssd.cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
+	ssd.has_presignal = false;
+
+	FollowTrack(tile, 0xC000 | TRANSPORT_RAIL, direction, (TPFEnumProc*)SetSignalsEnumProcPBS, SetSignalsAfterProc, &ssd);
+	for(i=0; i!=ssd.cur; i++) {
+		uint tile = ssd.tile[i];
+		byte bit = ssd.bit[i];
+		if (!PBSIsPbsSignal(tile, bit) && !PBSIsPbsSignal(tile, bit | 8))
+			return false;
+		result = true;
+	};
+	
+	return result;
+}
+
 void SetSignalsOnBothDir(uint tile, byte track)
 {
 	static const byte _search_dir_1[6] = {1, 3, 1, 3, 5, 3};
@@ -1976,8 +2108,7 @@
 	if (IsTileDepotType(tile, TRANSPORT_RAIL))
 		ShowTrainDepotWindow(tile);
 	else if (IsRailWaypoint(_map5[tile]))
-		ShowRenameWaypointWindow(GetWaypointByTile(tile));
-
+		ShowWaypointStatsWindow(GetWaypointByTile(tile));
 }
 
 static void GetTileDesc_Track(TileIndex tile, TileDesc *td)
@@ -2061,6 +2192,8 @@
 	} else if (_fractcoords_enter[dir] == fract_coord) {
 		if (_enter_directions[dir] == v->direction) {
 			/* enter the depot */
+			if (v->next == NULL)
+				PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 			v->u.rail.track = 0x80,
 			v->vehstatus |= VS_HIDDEN; /* hide it */
 			v->direction ^= 4;
Index: vehicle.c
===================================================================
--- vehicle.c	(revision 2456)
+++ vehicle.c	(working copy)
@@ -200,6 +200,8 @@
 	memset(v, 0, sizeof(Vehicle));
 	v->index = index;
 
+	v->queue_item = NULL;
+
 	assert(v->orders == NULL);
 
 	v->left_coord = INVALID_COORD;
@@ -216,6 +218,9 @@
 	    the other, it can be InteractiveRandomRange() without any problem
 	*/
 	v->random_bits = InteractiveRandomRange(256);
+
+	v->queue_item = NULL;
+
 	return v;
 }
 
@@ -1916,8 +1921,9 @@
 	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,flags), SLE_UINT8, 2, 255),
 	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,days_since_order_progr), SLE_UINT16, 2, 255),
 
-	// reserve extra space in savegame here. (currently 13 bytes)
-	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 13, 2, 255),
+	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,pbs_status), SLE_UINT8, 2, 255),
+	// reserve extra space in savegame here. (currently 12 bytes)
+	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 12, 2, 255),
 
 	SLE_END()
 };
Index: viewport.c
===================================================================
--- viewport.c	(revision 2456)
+++ viewport.c	(working copy)
@@ -35,7 +35,7 @@
 	struct TileSpriteToDraw *next;
 	int32 x;
 	int32 y;
-	byte z;
+	uint32 z;
 } TileSpriteToDraw;
 
 typedef struct ChildScreenSpriteToDraw {
@@ -57,8 +57,8 @@
 	int32 tile_bottom;
 	ChildScreenSpriteToDraw *child;
 	byte unk16;
-	byte tile_z;
-	byte tile_z_bottom;
+	uint32 tile_z;
+	uint32 tile_z_bottom;
 } ParentSpriteToDraw;
 
 typedef struct ViewportDrawer {
@@ -86,7 +86,7 @@
 static TileInfo *_cur_ti;
 
 
-Point MapXYZToViewport(ViewPort *vp, uint x, uint y, uint z)
+Point MapXYZToViewport(ViewPort *vp, uint x, uint y, uint32 z)
 {
 	Point p = RemapCoords(x, y, z);
 	p.x -= (vp->virtual_width>>1);
@@ -273,7 +273,7 @@
 
 static Point TranslateXYToTileCoord(ViewPort *vp, int x, int y)
 {
-	int z;
+	uint32 z;
 	Point pt;
 	int a,b;
 
@@ -394,7 +394,7 @@
 	_offset_ground_sprites = true;
 }
 
-static void AddCombinedSprite(uint32 image, int x, int y, byte z)
+static void AddCombinedSprite(uint32 image, int x, int y, int z)
 {
 	ViewportDrawer *vd = _cur_vd;
 	int t;
@@ -414,7 +414,7 @@
 }
 
 
-void AddSortableSpriteToDraw(uint32 image, int x, int y, int w, int h, byte dz, byte z)
+void AddSortableSpriteToDraw(uint32 image, int x, int y, int w, int h, uint32 dz, uint32 z)
 {
 	ViewportDrawer *vd = _cur_vd;
 	ParentSpriteToDraw *ps;
@@ -1439,7 +1439,7 @@
 
 void MarkTileDirty(int x, int y)
 {
-	int z = 0;
+	uint32 z = 0;
 	Point pt;
 	if (IS_INT_INSIDE(x, 0, MapSizeX() * 16) &&
 			IS_INT_INSIDE(y, 0, MapSizeY() * 16))
Index: vehicle.h
===================================================================
--- vehicle.h	(revision 2456)
+++ vehicle.h	(working copy)
@@ -68,6 +68,8 @@
 	byte railtype;
 
 	byte flags;
+
+	byte pbs_status;
 } VehicleRail;
 
 enum {
@@ -87,6 +89,8 @@
   byte previous_pos;
 	uint16 targetairport;
 	byte state;
+	uint16 desired_speed;	// Speed aircraft desires to maintain, used to
+							// decrease traffic to busy airports.
 } VehicleAir;
 
 typedef struct VehicleRoad {
@@ -141,7 +145,7 @@
 
 struct Vehicle {
 	byte type;	// type, ie roadven,train,ship,aircraft,special
-	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)(Filled with values from EffectVehicles or TrainSubTypes)
+	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)
 
 	VehicleID index;	// NOSAVE: Index in vehicle array
 
@@ -158,7 +162,7 @@
 
 	int32 x_pos;			// coordinates
 	int32 y_pos;
-	byte z_pos;
+	uint32 z_pos;		// Was byte, changed for aircraft queueing
 	byte direction;		// facing
 
 	byte spritenum; // currently displayed sprite index
@@ -181,8 +185,8 @@
 	uint16 max_speed;	// maximum speed
 	uint16 cur_speed;	// current speed
 	byte subspeed;		// fractional speed
-	byte acceleration; // used by train & aircraft
-	byte progress;
+	uint16 acceleration; // used by train & aircraft
+	uint16 progress;
 
 	byte vehstatus;		// Status
 	uint16 last_station_visited;
@@ -234,6 +238,9 @@
 	int32 profit_last_year;
 	uint32 value;
 
+	// Current position in a vehicle queue - can only belong to one queue at a time
+	VQueueItem* queue_item;
+
 	union {
 		VehicleRail rail;
 		VehicleAir air;
Index: viewport.h
===================================================================
--- viewport.h	(revision 2456)
+++ viewport.h	(working copy)
@@ -8,11 +8,11 @@
 	int virtual_left, virtual_top;			// virtual coordinates
 	int virtual_width, virtual_height;	// these are just width << zoom, height << zoom
 
-	byte zoom;
+	byte zoom, zoom_max;                // the current and maximum zoom level
 };
 
 /* viewport.c */
-Point MapXYZToViewport(ViewPort *vp, uint x, uint y, uint z);
+Point MapXYZToViewport(ViewPort *vp, uint x, uint y, uint32 z);
 void AssignWindowViewport(Window *w, int x, int y,
 	int width, int height, uint32 follow_flags, byte zoom);
 void SetViewportPosition(Window *w, int x, int y);
@@ -26,7 +26,7 @@
 
 void DrawGroundSprite(uint32 image);
 void DrawGroundSpriteAt(uint32 image, int32 x, int32 y, byte z);
-void AddSortableSpriteToDraw(uint32 image, int x, int y, int w, int h, byte dz, byte z);
+void AddSortableSpriteToDraw(uint32 image, int x, int y, int w, int h, uint32 dz, uint32 z);
 void *AddStringToDraw(int x, int y, StringID string, uint32 params_1, uint32 params_2, uint32 params_3);
 void AddChildSpriteScreen(uint32 image, int x, int y);
 
Index: misc.c
===================================================================
--- misc.c	(revision 2456)
+++ misc.c	(working copy)
@@ -14,7 +14,14 @@
 #include "network_server.h"
 #include "engine.h"
 #include "vehicle_gui.h"
+#include "newgrf.h"
+#include "md5.h"
+#include "fileio.h"
+#include <ctype.h>
+#include "gui.h"
 
+#include "debug.h"
+
 extern void StartupEconomy(void);
 extern void InitNewsItemStructs(void);
 
@@ -547,6 +554,7 @@
 void TownsMonthlyLoop(void);
 void IndustryMonthlyLoop(void);
 void StationMonthlyLoop(void);
+void WaypointMonthlyLoop(void);
 
 void PlayersYearlyLoop(void);
 void TrainsYearlyLoop(void);
@@ -655,6 +663,7 @@
 		TownsMonthlyLoop();
 		IndustryMonthlyLoop();
 		StationMonthlyLoop();
+		WaypointMonthlyLoop();
 #ifdef ENABLE_NETWORK
 		if (_network_server)
 			NetworkServerMonthlyLoop();
@@ -788,7 +797,300 @@
 	SlObject(&_opt, _game_opt_desc);
 }
 
+static const SaveLoad _game_patch_desc[] = {
+	// Denotes running total of space usage
+	SLE_VAR(Patches,	build_on_slopes,	SLE_BOOL), // 1
+	SLE_VAR(Patches,	mammoth_trains,	SLE_BOOL), // 2 
+	SLE_VAR(Patches,	join_stations,	SLE_BOOL), // 3
+	SLE_VAR(Patches,	station_spread,	SLE_UINT8), // 4
+	SLE_VAR(Patches,	full_load_any,	SLE_BOOL), // 5
+	SLE_VAR(Patches,	modified_catchment,	SLE_BOOL), // 6
+	SLE_VAR(Patches,	inflation,	SLE_BOOL), // 7
+	SLE_VAR(Patches,	selectgoods,	SLE_BOOL), // 8
+	SLE_VAR(Patches,	longbridges,	SLE_BOOL), // 9
+	SLE_VAR(Patches,	gotodepot,	SLE_BOOL), // 10
+	SLE_VAR(Patches,	build_rawmaterial_ind,	SLE_BOOL), // 11
+	SLE_VAR(Patches,	multiple_industry_per_town,	SLE_BOOL), // 12
+	SLE_VAR(Patches,	same_industry_close,	SLE_BOOL), // 13
+	SLE_VAR(Patches,	signal_side,	SLE_BOOL), // 14
+	SLE_VAR(Patches,	new_nonstop,	SLE_BOOL), // 15
+	SLE_VAR(Patches,	roadveh_queue,	SLE_BOOL), // 16
+	SLE_VAR(Patches,	snow_line_height,	SLE_UINT8), // 17
+	SLE_VAR(Patches,	bribe,	SLE_BOOL), // 18
+	SLE_VAR(Patches,	new_depot_finding,	SLE_BOOL), // 19
+	SLE_VAR(Patches,	nonuniform_stations,	SLE_BOOL), // 20
+	SLE_VAR(Patches,	always_small_airport,	SLE_BOOL), // 21
+	SLE_VAR(Patches,	realistic_acceleration,	SLE_BOOL), // 22
+	SLE_VAR(Patches,	forbid_90_deg,	SLE_BOOL), // 23
+	SLE_VAR(Patches,	improved_load,	SLE_BOOL), // 24
+	SLE_VAR(Patches,	max_trains,	SLE_UINT16), // 26
+	SLE_VAR(Patches,	max_roadveh,	SLE_UINT16), // 28
+	SLE_VAR(Patches,	max_aircraft,	SLE_UINT16), // 30
+	SLE_VAR(Patches,	max_ships,	SLE_UINT16), // 32
+	SLE_VAR(Patches,	servint_ispercent,	SLE_BOOL), // 33
+	SLE_VAR(Patches,	servint_trains,	SLE_UINT16), // 35
+	SLE_VAR(Patches,	servint_roadveh,	SLE_UINT16), // 37
+	SLE_VAR(Patches,	servint_ships,	SLE_UINT16), // 39
+	SLE_VAR(Patches,	servint_aircraft,	SLE_UINT16), // 41
+	SLE_VAR(Patches,	no_servicing_if_no_breakdowns,	SLE_BOOL), // 42
+	SLE_VAR(Patches,	new_pathfinding,	SLE_BOOL), // 43
+	SLE_VAR(Patches,	pf_maxlength,	SLE_UINT16), // 45
+	SLE_VAR(Patches,	pf_maxdepth,	SLE_UINT32), // 49
+	SLE_VAR(Patches,	ai_disable_veh_train,	SLE_BOOL), // 50
+	SLE_VAR(Patches,	ai_disable_veh_roadveh,	SLE_BOOL), // 51
+	SLE_VAR(Patches,	ai_disable_veh_aircraft,	SLE_BOOL), // 52
+	SLE_VAR(Patches,	ai_disable_veh_ship,	SLE_BOOL), // 53
+	SLE_VAR(Patches,	starting_date,	SLE_UINT32), // 57
+	SLE_VAR(Patches,	ending_date,	SLE_UINT32), // 61
+	SLE_VAR(Patches,	colored_news_date,	SLE_UINT32), // 65
+	SLE_VAR(Patches,	extra_dynamite,	SLE_BOOL), // 66
+	SLE_VAR(Patches,	never_expire_vehicles,	SLE_BOOL), // 67
+	SLE_VAR(Patches,	extend_vehicle_life,	SLE_UINT8), // 68
+	SLE_VAR(Patches,	auto_euro,	SLE_BOOL), // 69
+	SLE_VAR(Patches,	serviceathelipad,	SLE_BOOL), // 70
+	SLE_VAR(Patches,	smooth_economy,	SLE_BOOL), // 71
+	SLE_VAR(Patches,	allow_shares,	SLE_BOOL), // 72
+	SLE_VAR(Patches,	dist_local_authority,	SLE_UINT8), // 73
+	SLE_VAR(Patches,	wait_oneway_signal,	SLE_UINT8), // 74
+	SLE_VAR(Patches,	wait_twoway_signal,	SLE_UINT8), // 75
+	SLE_VAR(Patches,	ainew_active,	SLE_BOOL), // 76
+	SLE_VAR(Patches,	map_x,	SLE_UINT32), // 80
+	SLE_VAR(Patches,	map_y,	SLE_UINT32),  // 84
+	SLE_VAR(Patches,	new_pathfinding_all,	SLE_BOOL), // 85
+	SLE_VAR(Patches,	npf_max_search_nodes,	SLE_UINT32), // 89
+	SLE_VAR(Patches,	npf_rail_firstred_penalty,	SLE_UINT32), // 93
+	SLE_VAR(Patches,	npf_rail_firstred_exit_penalty,	SLE_UINT32), // 97
+	SLE_VAR(Patches,	npf_rail_lastred_penalty,	SLE_UINT32), // 101
+	SLE_VAR(Patches,	npf_rail_station_penalty,	SLE_UINT32), // 105
+	SLE_VAR(Patches,	npf_rail_slope_penalty,	SLE_UINT32), // 109
+	SLE_VAR(Patches,	npf_rail_curve_penalty,	SLE_UINT32), // 113
+	SLE_VAR(Patches,	npf_rail_depot_reverse_penalty,	SLE_UINT32), // 117
+	SLE_VAR(Patches,	npf_buoy_penalty,	SLE_UINT32), // 121
+	SLE_VAR(Patches,	npf_water_curve_penalty,	SLE_UINT32), // 125
+	SLE_VAR(Patches,	npf_road_curve_penalty,	SLE_UINT32), // 129
+	SLE_VAR(Patches,	npf_crossing_penalty,	SLE_UINT32), // 133
+	SLE_END()
+};
 
+/** 
+* Save/Load game patches.
+* @note The value of the SlSetLength function needs to be the size of the above
+*	array. Boolean values are currently saved as bytes, so they take up one
+*	 byte of space!
+*/
+static void SaveLoad_PATS(void)
+{
+	Patches *_set_patches_ptr;
+
+	if (_sl.save)
+	{
+		/* Create a copy of the original patch settings so that they
+		* are not overwritten */
+		_set_patches_ptr = &_set_patches;
+		memcpy(_set_patches_ptr, &_patches, sizeof(Patches));
+		SlSetLength(133);
+	}
+	
+	SlObject(&_patches, _game_patch_desc); 
+}
+
+/** 
+* Calculate the MD5 sum of file. Returns true if successful, false if not.
+*
+* @param file Name (and path) of a file in the data/ folder.
+* @param digest The resulting MD5 sum will be placed here.
+*
+* @note For some reason the MD5 sums that are calculated don't just contain the
+*	MD5 sum (seems to be a bug in md5_finish of md5.c), but a load of other 
+*	crap. As such whenever you manipulate whatever is calculated, make sure
+*	you only use the first 16 bytes!
+*/
+static bool MD5(char* file, md5_byte_t* digest)
+{	
+	FILE *f = 0;
+	char buf[MAX_PATH];
+
+	md5_state_t filemd5state;
+	int len = 0;
+	md5_byte_t buffer[1024];
+
+	// open file
+	sprintf(buf, "%s%s", _path.data_dir, file);
+	f = fopen(buf, "rb");
+
+#if !defined(WIN32)
+	if (f == NULL) {
+		char *s = 0;
+	// make lower case and check again
+		for (s = buf + strlen(_path.data_dir) - 1; *s != '\0'; s++)
+			*s = tolower(*s);
+		f = fopen(buf, "rb");
+	}
+#endif
+
+	if (f != NULL) {
+		md5_init(&filemd5state);
+		while ((len = fread(buffer, 1, 1024, f)) != 0)
+			//assert(strlen(digest) < 17);
+			md5_append(&filemd5state, buffer, len);
+		if (ferror(f))
+			DEBUG(misc,0)("Error Reading from %s \n", buf);
+		fclose(f);
+		
+		md5_finish(&filemd5state, digest);
+		
+		return true;
+	}
+	
+	return false;
+	
+}
+
+/**
+* Saves details of any New GRFs loaded. Details which are saved are: filename,
+* grfid, and md5 sum.
+*
+* @note	Run in debug level 6 to see output (-d 6).
+*/	
+static void Save_GRFS(void)
+{	
+	GRFFile *c = _first_grffile; /**< Loaded GRFs. */
+	int i = 0, y; /**< Integers used for iterations. */
+	uint32 grfid; /**< Temporary storage of grfid. */
+	char filename[32]; /**< Temporary storage of filename. */
+	char *fptr; /**< Pointer to filename. */
+	md5_byte_t md5[16]; /**< Temporary storage of md5 sum. */
+	
+	fptr = filename;
+	
+	c = _first_grffile;
+	
+	/*
+	* Count the number of grfs loaded, should be no more than 32, so
+	* assert if more.
+	*/
+	while(c != NULL)
+	{
+		i++;
+		c = c->next;
+	}
+	
+	assert(i < 32);
+	
+	SlSetLength((32 + 16 + 4)*i);
+	
+	DEBUG(misc,6)("Save_GRFS: %d records / %d bytes", i, (4+32+16)*i);
+	
+	i=0;
+	/*
+	* Loop through each grf saving details of it. Strings are just saved as
+	* seperate bytes, so maybe a function to save strings could be added?
+	*/
+	for (c = _first_grffile; c != NULL; c = c->next)
+	{	
+		strcpy(fptr,c->filename);
+		grfid = c->grfid;
+		
+		for (y=0; y<32; y++)
+			SlWriteByte(filename[y]);
+					
+		MD5(c->filename, md5);
+						
+		for (y=0; y<16; y++)
+			SlWriteByte(md5[y]);	
+				
+		SlWriteUint32(grfid);
+		
+		DEBUG(misc,6)("Save_GRFS: %d) %s %08lx %s", i++, filename, grfid, md5);
+	}
+}
+
+/**
+* Loads details of saved New GRFs, and checks if they are loaded. Also compares
+* details (grfid and md5 sum) of grfs to make sure the same ones are loaded and
+* warns the user if not.
+*
+* @todo Popup an error window to the user, rather than using the console if
+*	there are any problems.
+*
+* @note Rather than using the DEBUG function to show problems, the grfmsg
+*	function should probably be used. This is local to the newgrf.c file
+*	only, so the checking stuff should be split off or that will need to be
+*	changed.
+*
+* @note	Run in debug level 6 to see output (-d 6).
+*/
+static void Load_GRFS(void)
+{
+	GRFFile *c = _first_grffile; /**< Loaded GRFs. */
+	int x = 0, y = 0, t; /**< Integers for iterations. */
+	int size; /**< Size of field, returned from SlGetFieldLength. */
+	/** Used to count how many bytes of MD5 sums match. */
+	int matching_bytes = 0;
+	char filename[32][32]; /**< Array to hold file names in save. */
+	char *fptr; /**< Pointer to records in the above array. */
+	/** Holds MD5 sums loaded and MD5 sum calculated; why it is 33. */
+	md5_byte_t md5[33][16];
+	
+	/*
+	* Get the field size, and calculate size of each record.
+	*/
+	size = SlGetFieldLength();
+	_grfs_in_save_num = size / (4 + 16 + 32);
+	
+	DEBUG(misc,6)("Load_GRFS: %d records / %d bytes", _grfs_in_save_num, size);
+	
+	/*
+	* Load details from the save.
+	*/
+	while(x < _grfs_in_save_num)
+	{
+		fptr = filename[x];
+		for (y=0; y<32; y++)
+			filename[x][y] = (char) SlReadByte();
+		for (y=0; y<16; y++)
+			md5[x][y] = (char) SlReadByte();
+				
+		_grfs_in_save[x].filename = fptr;
+		_grfs_in_save[x].grfid = SlReadUint32();
+		
+		DEBUG(misc,6)("Load_GRFS: %d) %s %08x %s", x, _grfs_in_save[x].filename, _grfs_in_save[x].grfid, md5);
+		x++;
+	}
+	
+	/*
+	* Start checking to see if any loaded GRFs match, ones in the save.
+	* If so the 0x0001 bit is set. Next the grfids are compared, and then
+	* MD5 sums are compared.
+	*/
+	x = 0;
+	while (c != NULL)
+	{
+	MD5(c->filename, md5[32]);
+	
+		for(y=0; y < _grfs_in_save_num; y++)
+		{	
+			if (*_grfs_in_save[y].filename == *c->filename)
+			{	
+				_grfs_in_save[y].flags |= 0x0001;
+				if (_grfs_in_save[y].grfid != c->grfid)
+					DEBUG(misc,0)("GRF ID different!\n  %s\n  %08x", _grfs_in_save[y].filename, _grfs_in_save[y].grfid);
+					
+					matching_bytes = 0;
+					for (t = 0; t < 16; t++)
+						if (md5[32][t] == md5[x][t])
+							matching_bytes++;
+					
+				if (!(matching_bytes == 16))
+					DEBUG(misc,0)("MD5 sum different! %d bytes different!\n  %s\n  %08x\n M: %d", (16-matching_bytes), _grfs_in_save[y].filename, _grfs_in_save[y].grfid);
+			}
+				
+		}
+	x++;
+	c = c->next;
+	}
+}
+
 static const SaveLoadGlobVarList _date_desc[] = {
 	{&_date, 										SLE_UINT16, 0, 255},
 	{&_date_fract, 							SLE_UINT16, 0, 255},
@@ -944,5 +1246,7 @@
 	{ 'DATE', SaveLoad_DATE, SaveLoad_DATE, CH_RIFF},
 	{ 'VIEW', SaveLoad_VIEW, SaveLoad_VIEW, CH_RIFF},
 	{ 'OPTS', SaveLoad_OPTS, SaveLoad_OPTS, CH_RIFF},
-	{ 'CHTS', Save_CHTS, Load_CHTS, CH_RIFF | CH_LAST}
+	{ 'PATS', SaveLoad_PATS, SaveLoad_PATS, CH_RIFF},
+	{ 'GRFS', Save_GRFS, Load_GRFS, CH_RIFF},
+	{ 'CHTS', Save_CHTS, Load_CHTS, CH_RIFF | CH_LAST},
 };
Index: win32.c
===================================================================
--- win32.c	(revision 2456)
+++ win32.c	(working copy)
@@ -258,6 +258,17 @@
 		_right_button_down = false;
 		return 0;
 
+	case WM_MBUTTONDOWN:
+		ReleaseCapture();
+		_middle_button_down = true;
+		return 0;
+		
+	case WM_MBUTTONUP:
+		ReleaseCapture();
+		_middle_button_down = false;
+		_middle_button_clicked = false;
+		return 0;
+
 	case WM_MOUSEMOVE: {
 		int x = (int16)LOWORD(lParam);
 		int y = (int16)HIWORD(lParam);
Index: economy.c
===================================================================
--- economy.c	(revision 2456)
+++ economy.c	(working copy)
@@ -1362,6 +1362,9 @@
 				unloading_time += v->cargo_count; /* TTDBUG: bug in original TTD */
 				profit += DeliverGoods(v->cargo_count, v->cargo_type, v->cargo_source, last_visited, v->cargo_days);
 				result |= 1;
+				ge->cargo_amount[STS_AMOUNT_IN].this_month += v->cargo_count;
+                if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 				v->cargo_count = 0;
 			} else if (u->current_order.flags & ( OF_UNLOAD | OF_TRANSFER) ) {
 				/* unload goods and let it wait at the station */
@@ -1375,6 +1378,9 @@
 
 				v_profit_total += v_profit;
 
+				ge->cargo_amount[STS_AMOUNT_TRANSFER].this_month += v->cargo_count;
+                if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 
 				unloading_time += v->cargo_count;
 				if ((t=ge->waiting_acceptance & 0xFFF) == 0) {
@@ -1443,6 +1449,11 @@
 			ge->waiting_acceptance -= cap;
 			v->profit_this_year -= feeder_profit_share;
 			ge->feeder_profit -= feeder_profit_share;
+
+			ge->cargo_amount[STS_AMOUNT_OUT].this_month += cap;
+			if (ge->months_counted == 0) ge->months_counted = 1;
+			InvalidateWindow(WC_STATION_STATS, st->index);
+
 			unloading_time += cap;
 			st->time_since_load = 0;
 
@@ -1456,6 +1467,9 @@
 
 
 	v = u;
+	
+	if (v_profit_total > 0)
+		ShowFeederIncomeAnimation(v->x_pos, v->y_pos, v->z_pos, v_profit_total);
 
 	if (v_profit_total > 0)
 		ShowFeederIncomeAnimation(v->x_pos, v->y_pos, v->z_pos, v_profit_total);
Index: sdl.c
===================================================================
--- sdl.c	(revision 2456)
+++ sdl.c	(working copy)
@@ -479,6 +479,9 @@
 				_right_button_down = true;
 				_right_button_clicked = true;
 				break;
+			case SDL_BUTTON_MIDDLE:
+				_middle_button_down = true;
+				break;
 			case SDL_BUTTON_WHEELUP:
 				_cursor.wheel--;
 				break;
@@ -500,6 +503,9 @@
 			_left_button_clicked = false;
 		} else if (ev.button.button == SDL_BUTTON_RIGHT) {
 			_right_button_down = false;
+		} else if (ev.button.button == SDL_BUTTON_MIDDLE) {
+			_middle_button_down = false;
+			_middle_button_clicked = false;
 		}
 		break;
 
Index: ship_cmd.c
===================================================================
--- ship_cmd.c	(revision 2456)
+++ ship_cmd.c	(working copy)
@@ -451,6 +451,10 @@
 
 static void ShipArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_SHIP].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	/* Check if station was ever visited before */
 	if (!(st->had_vehicle_of_type & HVOT_SHIP)) {
 		uint32 flags;
@@ -574,7 +578,7 @@
 
 		NPFFillWithOrderData(&fstd, v);
 
-		ftd = NPFRouteToStationOrTile(src_tile, trackdir, &fstd, TRANSPORT_WATER, v->owner);
+		ftd = NPFRouteToStationOrTile(src_tile, trackdir, &fstd, TRANSPORT_WATER, v->owner, PBS_MODE_NONE);
 
 		if (ftd.best_trackdir != 0xff)
 			/* If ftd.best_bird_dist is 0, we found our target and ftd.best_trackdir contains
Index: main_gui.c
===================================================================
--- main_gui.c	(revision 2456)
+++ main_gui.c	(working copy)
@@ -314,7 +314,7 @@
 
 static void MenuClickShowRoad(int index)
 {
-	ShowPlayerRoadVehicles(index, -1);
+	ShowPlayerRoadVehicles(index, -1, CARGO_MASK_ALL);
 }
 
 static void MenuClickShowShips(int index)
@@ -853,71 +853,6 @@
 	PopupMainPlayerToolbMenu(w, 376, 16, dis);
 }
 
-/* Zooms a viewport in a window in or out */
-/* No button handling or what so ever */
-bool DoZoomInOutWindow(int how, Window *w)
-{
-	ViewPort *vp;
-	int button;
-
-	switch(_game_mode) {
-	case GM_EDITOR: button = 9; break;
-	case GM_NORMAL: button = 17; break;
-	default: return false;
-	}
-
-	assert(w);
-	vp = w->viewport;
-
-	if (how == ZOOM_IN) {
-		if (vp->zoom == 0) return false;
-		vp->zoom--;
-		vp->virtual_width >>= 1;
-		vp->virtual_height >>= 1;
-
-		WP(w,vp_d).scrollpos_x += vp->virtual_width >> 1;
-		WP(w,vp_d).scrollpos_y += vp->virtual_height >> 1;
-
-		SetWindowDirty(w);
-	} else if (how == ZOOM_OUT) {
-		if (vp->zoom == 2) return false;
-		vp->zoom++;
-
-		WP(w,vp_d).scrollpos_x -= vp->virtual_width >> 1;
-		WP(w,vp_d).scrollpos_y -= vp->virtual_height >> 1;
-
-		vp->virtual_width <<= 1;
-		vp->virtual_height <<= 1;
-
-		SetWindowDirty(w);
-	}
-
-	// routine to disable/enable the zoom buttons. Didn't know where to place these otherwise
-	{
-		Window *wt = NULL;
-		switch (w->window_class) {
-		case WC_MAIN_WINDOW:
-			wt = FindWindowById(WC_MAIN_TOOLBAR, 0);
-			break;
-		case WC_EXTRA_VIEW_PORT:
-			wt = FindWindowById(WC_EXTRA_VIEW_PORT, w->window_number);
-			button = 5;
-			break;
-		}
-
-		assert(wt);
-
-		// update the toolbar button too
-		CLRBIT(wt->disabled_state, button);
-		CLRBIT(wt->disabled_state, button + 1);
-		if (vp->zoom == 0) SETBIT(wt->disabled_state, button);
-		else if (vp->zoom == 2) SETBIT(wt->disabled_state, button + 1);
-		SetWindowDirty(wt);
-	}
-
-	return true;
-}
-
 static void MaxZoomIn(void)
 {
 	while (DoZoomInOutWindow(ZOOM_IN, FindWindowById(WC_MAIN_WINDOW, 0) ) ) {}
@@ -1055,18 +990,15 @@
 
 void ZoomInOrOutToCursorWindow(bool in, Window *w)
 {
-	ViewPort * vp;
-	Point pt;
+	assert(w != NULL && w->viewport != NULL);
 
-	assert(w != 0);
-
-	vp = w->viewport;
-
 	if (_game_mode != GM_MENU) {
-		if ((in && vp->zoom == 0) || (!in && vp->zoom == 2))
-			return;
+		const ViewPort *vp = w->viewport;
+		Point pt;
 
-		pt = GetTileZoomCenterWindow(in,w);
+		if ((in && vp->zoom == 0) || (!in && vp->zoom == vp->zoom_max)) return;
+
+		pt = GetTileZoomCenterWindow(in, w);
 		if (pt.x != -1) {
 			ScrollWindowTo(pt.x, pt.y, w);
 
@@ -1075,6 +1007,65 @@
 	}
 }
 
+/** Zooms a viewport in a window in or out and calls the appropiate
+ * windows event for any special handling (buttons, etc.)
+ * @param how ZOOM_IN (zooming in), ZOOM_OUT (zooming out) or ZOOM_NONE to just update buttons
+ * @param *w the window whose viewport the zoom is acted upon
+ * @return true on a successful zoom, and false if a zoom was not possible
+ */
+bool DoZoomInOutWindow(byte how, Window *w)
+{
+	ViewPort *vp;
+	WindowEvent e;
+
+	if (_game_mode == GM_MENU || w->viewport == NULL) return false;
+
+	vp = w->viewport;
+
+	if (how == ZOOM_IN) {
+		if (vp->zoom == 0) return false;
+		vp->zoom--;
+		vp->virtual_width >>= 1;
+		vp->virtual_height >>= 1;
+
+		WP(w,vp_d).scrollpos_x += vp->virtual_width >> 1;
+		WP(w,vp_d).scrollpos_y += vp->virtual_height >> 1;
+	} else if (how == ZOOM_OUT) {
+		if (vp->zoom == vp->zoom_max) return false;
+		vp->zoom++;
+
+		WP(w,vp_d).scrollpos_x -= vp->virtual_width >> 1;
+		WP(w,vp_d).scrollpos_y -= vp->virtual_height >> 1;
+
+		vp->virtual_width <<= 1;
+		vp->virtual_height <<= 1;
+	}
+
+	SetWindowDirty(w);
+
+	e.event = WE_SCROLL;
+	e.scroll.scroll = how;
+	w->wndproc(w, &e);
+
+	return true;
+}
+
+/** Update the button status of the window that is being zoomed if it
+ * has any buttons. Zoom-in is always button X and Zoom-out X + 1
+ * @param *w the window that contains the buttons
+ * @param *vp the viewport that the zoom buttons are bound to
+ * @param widget the widget id of the zoom-in button
+ */
+void DirtyZoomButtons(Window *w, const ViewPort *vp, int widget)
+{
+	CLRBIT(w->disabled_state, widget);
+	CLRBIT(w->disabled_state, widget + 1);
+
+	if (vp->zoom == 0) SETBIT(w->disabled_state, widget);
+	if (vp->zoom == vp->zoom_max) SETBIT(w->disabled_state, widget + 1);
+	SetWindowDirty(w);
+}
+
 static void ResetLandscape(void)
 {
 	_random_seeds[0][0] = InteractiveRandom();
@@ -1898,7 +1889,7 @@
 		case WKC_F11: ShowCompanyLeagueTable(); break;
 		case WKC_F12: ShowBuildIndustryWindow(); break;
 		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, -1); break;
-		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, -1); break;
+		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, -1, CARGO_MASK_ALL); break;
 		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, -1); break;
 		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, -1); break;
 		case WKC_SHIFT | WKC_F5: ToolbarZoomInClick(w); break;
@@ -2296,14 +2287,13 @@
 
 extern void UpdateAllStationVirtCoord(void);
 
-static void MainWindowWndProc(Window *w, WindowEvent *e) {
-	int off_x;
-
-	switch(e->event) {
+static void MainWindowWndProc(Window *w, WindowEvent *e)
+{
+	switch (e->event) {
 	case WE_PAINT:
 		DrawWindowViewport(w);
 		if (_game_mode == GM_MENU) {
-			off_x = _screen.width / 2;
+			int off_x = _screen.width / 2;
 
 			DrawSprite(SPR_OTTD_O, off_x - 120, 50);
 			DrawSprite(SPR_OTTD_P, off_x -  86, 50);
@@ -2334,6 +2324,10 @@
 		}
 		break;
 
+	case WE_SCROLL: 
+		DirtyZoomButtons(FindWindowById(WC_MAIN_TOOLBAR, 0), w->viewport, (_game_mode == GM_EDITOR) ? 9 : 17);
+		break;
+
 	case WE_KEYPRESS:
 		if (e->keypress.keycode == WKC_BACKQUOTE) {
 			IConsoleSwitch();
@@ -2417,38 +2411,35 @@
 	width = _screen.width;
 	height = _screen.height;
 
+	w = AllocateWindow(0, 0, width, height, MainWindowWndProc, WC_MAIN_WINDOW, NULL);
+	// set the default view to position 32,32 when starting a new game
+	AssignWindowViewport(w, 0, 0, width, height, TILE_XY(32, 32), 0);
+	w->desc_flags = WDF_ZOOMABLE;
+	w->viewport->zoom_max = 2; // zoom out to a maximum value of 2
+
 	// XXX: these are not done
-	switch(_game_mode) {
-	case GM_MENU:
-		w = AllocateWindow(0, 0, width, height, MainWindowWndProc, WC_MAIN_WINDOW, NULL);
-		AssignWindowViewport(w, 0, 0, width, height, TILE_XY(32, 32), 0);
-//		w = AllocateWindowDesc(&_toolb_intro_desc);
-//		w->flags4 &= ~WF_WHITE_BORDER_MASK;
-		ShowSelectGameWindow();
-		break;
-	case GM_NORMAL:
-		w = AllocateWindow(0, 0, width, height, MainWindowWndProc, WC_MAIN_WINDOW, NULL);
-		AssignWindowViewport(w, 0, 0, width, height, TILE_XY(32, 32), 0);
+	switch (_game_mode) {
+		case GM_MENU:
+			ShowSelectGameWindow();
+			break;
+		case GM_NORMAL:
+			ShowVitalWindows();
 
-		ShowVitalWindows();
+			/* Bring joining GUI to front till the client is really joined */
+			if (_networking && !_network_server)
+				ShowJoinStatusWindowAfterJoin();
 
-		/* Bring joining GUI to front till the client is really joined */
-		if (_networking && !_network_server)
-			ShowJoinStatusWindowAfterJoin();
+			break;
+		case GM_EDITOR:
+			ScrollWindowTo(0, 0, w);
 
-		break;
-	case GM_EDITOR:
-		w = AllocateWindow(0, 0, width, height, MainWindowWndProc, WC_MAIN_WINDOW, NULL);
-		AssignWindowViewport(w, 0, 0, width, height, 0, 0);
+			w = AllocateWindowDesc(&_toolb_scen_desc);
+			w->disabled_state = 1 << 9;
+			CLRBITS(w->flags4, WF_WHITE_BORDER_MASK);
 
-		w = AllocateWindowDesc(&_toolb_scen_desc);
-		w->disabled_state = 1 << 9;
-		CLRBITS(w->flags4, WF_WHITE_BORDER_MASK);
-
-		PositionMainToolbar(w); // already WC_MAIN_TOOLBAR passed (&_toolb_scen_desc)
-		break;
-	default:
-		NOT_REACHED();
+			PositionMainToolbar(w); // already WC_MAIN_TOOLBAR passed (&_toolb_scen_desc)
+			break;
+		default: NOT_REACHED();
 	}
 }
 
Index: Makefile
===================================================================
--- Makefile	(revision 2456)
+++ Makefile	(working copy)
@@ -641,9 +641,11 @@
 C_SOURCES += news_gui.c
 C_SOURCES += npf.c
 C_SOURCES += oldloader.c
+C_SOURCES += openttd.c
 C_SOURCES += order_cmd.c
 C_SOURCES += order_gui.c
 C_SOURCES += pathfind.c
+C_SOURCES += pbs.c
 C_SOURCES += player_gui.c
 C_SOURCES += players.c
 C_SOURCES += pool.c
@@ -680,7 +682,6 @@
 C_SOURCES += train_cmd.c
 C_SOURCES += train_gui.c
 C_SOURCES += tree_cmd.c
-C_SOURCES += openttd.c
 C_SOURCES += tunnelbridge_cmd.c
 C_SOURCES += unmovable_cmd.c
 C_SOURCES += vehicle.c
Index: roadveh_gui.c
===================================================================
--- roadveh_gui.c	(revision 2456)
+++ roadveh_gui.c	(working copy)
@@ -815,7 +815,8 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Road, owner, station);
+//		BuildVehicleList(vl, VEH_Road, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -997,7 +998,7 @@
 };
 
 
-void ShowPlayerRoadVehicles(int player, int station)
+void ShowPlayerRoadVehicles(int player, int station, uint32 cargomask)
 {
 	Window *w;
 
@@ -1007,6 +1008,10 @@
 		w = AllocateWindowDescFront(&_other_player_roadveh_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = cargomask;
+		w->listopt.veh_type_mask = 1 << VEH_Road;
+		w->listopt.xy = GetStation(station)->xy;
+
 		w->caption_color = player;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: order_cmd.c
===================================================================
--- order_cmd.c	(revision 2456)
+++ order_cmd.c	(working copy)
@@ -348,6 +348,25 @@
 			/* Increase amount of orders */
 			u->num_orders++;
 
+			// count vehicles scheduled for station
+			if (new_order.type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(new_order.station)->veh_scheduled++;
+			} else {
+				Station *st = GetStation(new_order.station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]++;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]++;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]++;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]++;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]++;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]++;
+						break;
+				}
+			}
+
 			/* If the orderlist was empty, assign it */
 			if (u->orders == NULL) u->orders = v->orders;
 
@@ -429,14 +448,45 @@
 			GetVehicleOrder(v, sel_ord - 1)->next = order->next;
 		}
 
-		/* Give the item free */
-		order->type = OT_NOTHING;
-		order->next = NULL;
+ 		if (v->type == VEH_Aircraft) {
+ 			/* Take out of airport queue
+ 			 */
+ 			if(v->queue_item != NULL)
+ 			{
+ 				v->queue_item->queue->del(v->queue_item->queue, v);
+ 			}
+ 		}
 
 		u = GetFirstVehicleFromSharedList(v);
 		while (u != NULL) {
+			if (order->type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(order->station)->veh_scheduled--;
+			} else {
+				Station *st = GetStation(order->station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]--;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]--;
+						break;
+				}
+			}
 			u->num_orders--;
 
+ 			if (u->type == VEH_Aircraft) {
+ 				/* Take out of airport queue
+ 				*/
+ 				if(u->queue_item != NULL)
+ 				{
+ 					v->queue_item->queue->del(v->queue_item->queue, v);
+ 				}
+ 			}
+
 			if (sel_ord < u->cur_order_index)
 				u->cur_order_index--;
 
@@ -459,6 +509,10 @@
 			u = u->next_shared;
 		}
 
+		/* Give the item free */
+		order->type = OT_NOTHING;
+		order->next = NULL;
+
 		RebuildVehicleLists();
 	}
 
@@ -499,7 +553,15 @@
 	}
 
 	/* We have an aircraft/ship, they have a mini-schedule, so update them all */
-	if (v->type == VEH_Aircraft) InvalidateWindowClasses(WC_AIRCRAFT_LIST);
+	if (v->type == VEH_Aircraft) {
+		InvalidateWindowClasses(WC_AIRCRAFT_LIST);
+		/* Take out of airport queue
+		 */
+		if(v->queue_item != NULL)
+		{
+			v->queue_item->queue->del(v->queue_item->queue, v);
+		}
+	}
 	if (v->type == VEH_Ship) InvalidateWindowClasses(WC_SHIPS_LIST);
 
 	return 0;
@@ -959,6 +1021,15 @@
 				order->type = OT_DUMMY;
 				order->flags = 0;
 
+				if (v->type == VEH_Aircraft) {
+					/* Take out of airport queue
+					 */
+					if(v->queue_item != NULL)
+					{
+						v->queue_item->queue->del(v->queue_item->queue, v);
+					}
+				}
+
 				need_invalidate = true;
 			}
 		}
@@ -1031,8 +1102,35 @@
 	v->orders = NULL;
 	v->num_orders = 0;
 
+	if (v->type == VEH_Aircraft) {
+		/* Take out of airport queue
+		 */
+		if(v->queue_item != NULL)
+		{
+			v->queue_item->queue->del(v->queue_item->queue, v);
+		}
+	}
+
 	order = NULL;
 	while (cur != NULL) {
+		// decrease vehicles scheduled for station
+		if (cur->type == OT_GOTO_WAYPOINT) {
+			GetWaypoint(cur->station)->veh_scheduled--;
+		} else {
+			Station *st = GetStation(cur->station);
+			switch (v->type)
+			{
+				case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+				case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+				case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+				case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+					if (v->cargo_type == CT_PASSENGERS)
+						st->veh_scheduled[STS_VEH_BUS]--;
+					else
+						st->veh_scheduled[STS_VEH_TRUCK]--;
+					break;
+			}
+		}
 		if (order != NULL) {
 			order->type = OT_NOTHING;
 			order->next = NULL;
Index: settings.c
===================================================================
--- settings.c	(revision 2456)
+++ settings.c	(working copy)
@@ -763,6 +763,7 @@
 	{"frame_freq",			SDT_UINT8 | SDT_NOSAVE,	(void*)0,			&_network_frame_freq,		NULL},
 	{"max_join_time",		SDT_UINT16,	(void*)500,	&_network_max_join_time,	NULL},
 	{"pause_on_join",		SDT_BOOL, (void*)false, &_network_pause_on_join, NULL},
+	{"pause_on_no_clients", SDT_BOOL, (void*)false, &_network_pause_on_no_clients, NULL},
 	{"server_bind_ip",	SDT_STRINGBUF | (lengthof(_network_server_bind_ip_host) << 16),	"0.0.0.0",	&_network_server_bind_ip_host,	NULL},
 	{"server_port",			SDT_UINT,	(void*)NETWORK_DEFAULT_PORT,	&_network_server_port,	NULL},
 	{"server_advertise",SDT_BOOL, (void*)false, &_network_advertise, NULL},
@@ -838,6 +839,8 @@
 	{"autorenew_money",			SDT_INT32,	(void*)100000,&_patches.autorenew_money,			NULL},
 
 	{"population_in_label",	SDT_BOOL,		(void*)true,	&_patches.population_in_label,	NULL},
+	
+	{"middle_key_bind",	SDT_UINT32,		(void*)0,	&_patches.middle_key_bind,	NULL},
 
 	{NULL,									0,					NULL,					NULL,																						NULL}
 };
@@ -920,6 +923,9 @@
 
 	{"ainew_active",				SDT_BOOL,		(void*)false, &_patches.ainew_active,					NULL},
 
+	{"aircraft_queueing",		SDT_BOOL,		(void*)false,	&_patches.aircraft_queueing,			NULL},
+	{"plane_speed_coeff",		SDT_UINT16,		(void*)8,	&_patches.aircraft_speed_coeff,			NULL},
+
 	{"map_x", SDT_UINT32, (void*)8, &_patches.map_x, NULL},
 	{"map_y", SDT_UINT32, (void*)8, &_patches.map_y, NULL},
 
@@ -977,7 +983,8 @@
 	{"npf_water_curve_penalty",     SDT_UINT32, (void*)(NPF_TILE_LENGTH / 4),   &_patches.npf_water_curve_penalty,      NULL},
 	/* This is the penalty for road, same as for rail. */
 	{"npf_road_curve_penalty",      SDT_UINT32, (void*)(1),                     &_patches.npf_road_curve_penalty,       NULL},
-
+	/* Road penalty for railway crossings */
+	{"npf_crossing_penalty",        SDT_UINT32, (void*)601,                     &_patches.npf_crossing_penalty,         NULL},
 	{NULL,                          0,          NULL,                           NULL,                                   NULL}
 };
 
Index: waypoint.c
===================================================================
--- waypoint.c	(revision 2456)
+++ waypoint.c	(working copy)
@@ -13,6 +13,7 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 #include "table/track_land.h"
+#include "gui.h"
 
 enum {
 	/* Max waypoints: 64000 (8 * 8000) */
@@ -201,6 +202,7 @@
 		wp->deleted = 0;
 		wp->xy = tile;
 		wp->build_date = _date;
+		InitializeWaypointStats(wp);
 
 		if (wp->town_index == STR_NULL)
 			MakeDefaultWaypointName(wp);
@@ -440,18 +442,33 @@
 	SLE_CONDVAR(Waypoint, build_date, SLE_UINT16, 3, 255),
 	SLE_CONDVAR(Waypoint, stat_id, SLE_UINT8, 3, 255),
 
+//	SLE_CONDVAR(Waypoint,months_counted,	SLE_UINT16, 15, 255),
+
 	SLE_END()
 };
 
+static const SaveLoad _stats_desc[] = {
+	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,average,	SLE_UINT32, 15, 255),
+	SLE_END()
+};
+
 static void Save_WAYP(void)
 {
 	Waypoint *wp;
+//	int i;
 
 	FOR_ALL_WAYPOINTS(wp) {
 		if (wp->xy != 0) {
 			SlSetArrayIndex(wp->index);
 			SlObject(wp, _waypoint_desc);
 		}
+//		for (i = 0; i < STS_VEH_TYPES; i++) 
+//			SlObject(&wp->vehicles[i], _stats_desc);
+
 	}
 }
 
@@ -467,9 +484,222 @@
 
 		wp = GetWaypoint(index);
 		SlObject(wp, _waypoint_desc);
+		InitializeWaypointStats(wp);
 	}
 }
 
 const ChunkHandler _waypoint_chunk_handlers[] = {
 	{ 'CHKP', Save_WAYP, Load_WAYP, CH_ARRAY | CH_LAST},
 };
+
+void WaypointMonthlyLoop(void)
+{
+	Waypoint *wp;
+	StationStats *sts;
+	int i;
+
+ 	FOR_ALL_WAYPOINTS(wp) {
+		// if we have stats for this station the number of counted months is >0
+		if (wp->months_counted > 0)
+		{
+			// update vehicle-counts and min/max
+			for (i = 0; i < STS_WP_TYPES / 2; i++) {
+				sts = &wp->vehicles[i];
+				if (sts->month_max == 0) sts->month_min = sts->this_month;
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, wp->months_counted - 1);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			if (wp->months_counted == (wp->months_counted /12) * 12)
+			{ // do this once a year to have yearly stats
+				for (i = STS_WP_TYPES / 2; i < STS_WP_TYPES; i++) {
+					sts = &wp->vehicles[i];
+					if (sts->month_max == 0) sts->month_min = sts->this_month;
+					sts->month_min = min(sts->month_min, sts->this_month);
+					sts->month_max = max(sts->month_max, sts->this_month);
+					sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, (wp->months_counted / 12) - 1);
+					sts->last_month = sts->this_month;
+					sts->this_month = 0;
+				}
+			}
+			wp->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, wp->index);
+	}
+}
+
+void SearchVehiclesForWaypoint(Waypoint *wp)
+{
+	Vehicle *v;
+	Order* ord;
+	
+	ord = NULL;
+	if (wp->xy == 0) return;
+	wp->veh_scheduled = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+	
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (v->owner == GetTileOwner(wp->xy)) &&
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) )       //Trains (first engine, that contains the orders)
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == wp->index && ord->type == OT_GOTO_WAYPOINT) {
+					wp->veh_scheduled++;
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	} 
+}
+
+void InitializeWaypointStats(Waypoint *wp)
+{
+	StationStats *sts;
+
+	wp->months_counted = 0;
+	for (sts = wp->vehicles; sts != endof(wp->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = 65535;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForWaypoint(wp);
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _waypoint_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   288,     0,    13, STR_WAYPOINT_VIEWPORT, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   289,   300,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   150,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   151,   300,    14,    25, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   300,    26,    37, STR_STS_TOGGLE_MONTH_YEAR, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   300,    38,   140, 0x0, 0x0},
+{      WIDGETS_END},
+};
+
+WindowDesc _waypoint_view_stats = {
+	-1, -1, 301, 141,
+	WC_WAYPOINT_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_waypoint_stats_widgets,
+	WaypointStatsWndProc
+};
+
+void DrawWaypointStatWindow(Window *w, Waypoint *wp)
+{
+	int i, j, x, y;
+	
+	//Get the Station name
+	SetDParam(0, wp->index);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	x = 10;
+	y = 40;
+	DrawString(x, y,	STR_SCHEDULED, 0);
+	if (_show_yearly_stats) {
+		DrawString(x, y + 20,	STR_STS_VEHICLES_LAST_YEAR, 0);
+		DrawString(x, y + 32,	STR_STS_VEHICLES_THIS_YEAR, 0);
+		SetDParam(0, max((wp->months_counted - 1) / 12 ,0));
+		DrawString(x, y + 90,	STR_STS_YEARS_COUNTED_NUM, 0);
+	} else {
+		DrawString(x, y + 20,	STR_VEHICLES_MONTH, 0);
+		DrawString(x, y + 32,	STR_VEHICLES_CURRENT, 0);
+		SetDParam(0, max(wp->months_counted - 1,0));
+		DrawString(x, y + 90,	STR_MONTHS_COUNTED_NUM, 0);
+	}
+	DrawString(x, y + 50,	STR_AVERAGE, 0);
+	DrawString(x, y + 62,	STR_MINIMUM, 0);
+	DrawString(x, y + 74,	STR_MAXIMUM, 0);
+
+	x = 170;
+	SetDParam(0, wp->veh_scheduled);
+	DrawStringRightAligned(x, y, STR_NUMBER, 0);
+	DrawStringRightAligned(290, y, STR_STS_NOT_SCHEDULED, 0);
+	if (wp->veh_scheduled != 0) {
+		CLRBIT(w->disabled_state, 5);
+	} else {
+		SETBIT(w->disabled_state, 5);
+	}
+
+	j = _show_yearly_stats ? 2 : 0;
+	for (i = 0; i < STS_WP_TYPES / 2; i++)
+	{
+		SetDParam(0, wp->vehicles[i+j].last_month);
+		DrawStringRightAligned(x + i * 120, y + 20, STR_NUMBER, 0);
+		SetDParam(0, wp->vehicles[i+j].this_month);
+		DrawStringRightAligned(x + i * 120, y + 32, STR_WHITE_NUMBER, 0);
+
+		if (wp->months_counted > (_show_yearly_stats ? 12 : 1)) {
+			SetDParam(0, wp->vehicles[i+j].average / STS_MULTIPLIER);
+			DrawStringRightAligned(x + i * 120, y + 50, STR_SILVER_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_min);
+			DrawStringRightAligned(x + i * 120, y + 62, STR_ORANGE_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_max);
+			DrawStringRightAligned(x + i * 120, y + 74, STR_LTBLUE_NUMBER, 0);
+		}
+	}
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e)
+{
+	Waypoint *wp = GetWaypoint(w->window_number);
+	switch(e->event)
+	{
+		case WE_TICK: {
+//			static int counter = 0;
+//			if (++counter % 40) return;
+//			SearchVehiclesForWaypoint(wp, &w->custom[0]);
+			w->custom[0] = wp->veh_scheduled;
+			InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+			break;
+		}
+		case WE_PAINT: {
+			DrawWaypointStatWindow(w, wp);
+			break;
+			}
+		case WE_CLICK: {
+			switch (e->click.widget)
+			{
+				case 4:			// Reset Statistics
+					if (GetTileOwner(wp->xy) == _current_player) {
+						InitializeWaypointStats(wp);
+						InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+					}
+					break;
+				case 5:			//Trains
+					ShowWaypointTrains(_current_player, wp->index, CARGO_MASK_ALL);
+					break;
+				case 6:
+				_show_yearly_stats ^= 1;
+				InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+				break;
+			}
+		} break;
+		case WE_DESTROY: {
+			DeleteWindowById(WC_TRAINS_LIST, GetTileOwner(wp->xy) + ( (wp->index + 1) << 8));
+		} break;
+	}
+}
+
+void ShowWaypointStatsWindow(Waypoint *wp)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_waypoint_view_stats, wp->index);
+	if (w) {
+		color = GetTileOwner(wp->xy);
+		if (color != 0x10)
+			w->caption_color = color;
+	}
+}
Index: waypoint.h
===================================================================
--- waypoint.h	(revision 2456)
+++ waypoint.h	(working copy)
@@ -2,6 +2,7 @@
 #define WAYPOINT_H
 
 #include "pool.h"
+#include "station.h"
 
 struct Waypoint {
 	TileIndex xy;
@@ -11,12 +12,20 @@
 	byte town_cn;          // The Nth waypoint for this town (consecutive number)
 	StringID string;       // If this is zero, town + town_cn is used for naming
 
+	StationStats vehicles[STS_WP_TYPES];
+	uint16 veh_scheduled;
+	uint16 months_counted;
+
 	ViewportSign sign;
 	uint16 build_date;
 	byte stat_id;
 	byte deleted;          // this is a delete counter. when it reaches 0, the waypoint struct is deleted.
 };
 
+void InitializeWaypointStats(Waypoint *wp);
+void ShowWaypointStatsWindow(Waypoint *wp);
+void ShowWaypointTrains(int player, int waypoint, uint32 cargomask);
+
 enum {
 	RAIL_TYPE_WAYPOINT = 0xC4,
 	RAIL_WAYPOINT_TRACK_MASK = 1,
Index: train_gui.c
===================================================================
--- train_gui.c	(revision 2456)
+++ train_gui.c	(working copy)
@@ -15,6 +15,7 @@
 #include "engine.h"
 #include "vehicle_gui.h"
 #include "depot.h"
+#include "waypoint.h"
 
 int _traininfo_vehicle_pitch = 0;
 
@@ -1294,7 +1295,8 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Train, owner, station);
+//		BuildVehicleList(vl, VEH_Train, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1490,6 +1492,10 @@
 		w = AllocateWindowDescFront(&_other_player_trains_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.veh_type_mask = 1 << VEH_Train;
+		w->listopt.xy = GetStation(station)->xy;
+
 		w->caption_color = player;
 		w->hscroll.cap = 10;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
@@ -1499,3 +1505,27 @@
 		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
 	}
 }
+
+void ShowWaypointTrains(int player, int waypoint, uint32 cargomask)
+{
+	Window *w;
+
+	if (player == _local_player) {
+		w = AllocateWindowDescFront(&_player_trains_desc, (waypoint << 16) | player);
+	} else {
+		w = AllocateWindowDescFront(&_other_player_trains_desc, (waypoint << 16) | player);
+	}
+	if (w) {
+		w->listopt.cargo_mask = cargomask;
+		w->listopt.veh_type_mask = 1 << VEH_Train;
+		w->listopt.xy = GetWaypoint(waypoint)->xy;
+
+		w->caption_color = player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 7; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_SMALL;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
+	}
+}
Index: station.h
===================================================================
--- station.h	(revision 2456)
+++ station.h	(working copy)
@@ -6,6 +6,34 @@
 #include "tile.h"
 #include "vehicle.h"
 
+enum {
+	STS_AMOUNT_IN = 0,
+    STS_AMOUNT_OUT = 1,
+	STS_AMOUNT_TRANSFER = 2,
+	STS_VEH_TRAIN = 0,
+	STS_VEH_ROAD = 1,
+	STS_VEH_BUS = 2,
+	STS_VEH_TRUCK = 3,
+	STS_VEH_SHIP = 4,
+	STS_VEH_AIRCRAFT = 5,
+	STS_MULTIPLIER = 10000, // controls how much digits behind comma are stored for average
+	STS_VEH_TYPES = 6,
+	STS_AMNT_TYPES = 3,
+	STS_WP_TYPES = 4,
+	STS_WP_ORDER = 0, // reached WP by order
+	STS_WP_PATHFIND = 1, // reached WP by normal pathfinding
+	STS_WP_ORDER_YEAR = 2, // yearly stats by order
+	STS_WP_PATHFIND_YEAR =3 , // yearly stats by pathfinding
+};
+
+typedef struct StationStats {
+	uint16 this_month;
+	uint16 last_month;
+	uint16 month_min;
+	uint16 month_max;
+	uint32 average;
+} StationStats;
+
 typedef struct GoodsEntry {
 	uint16 waiting_acceptance;
 	byte days_since_pickup;
@@ -14,6 +42,9 @@
 	byte enroute_time;
 	byte last_speed;
 	byte last_age;
+
+	StationStats cargo_amount[STS_AMNT_TYPES];
+	uint16 months_counted;
 	int32 feeder_profit;
 } GoodsEntry;
 
@@ -74,10 +105,15 @@
 	//uint16 airport_flags;
 	uint32 airport_flags;
 	StationID index;
+	VehicleQueue *airport_queue;			// airport queue
 
 	VehicleID last_vehicle;
 	GoodsEntry goods[NUM_CARGO];
 
+	StationStats vehicles[STS_VEH_TYPES];
+	uint16 veh_scheduled[STS_VEH_TYPES];
+	uint16 months_counted;
+
 	/* Stuff that is no longer used, but needed for conversion */
 	TileIndex bus_tile_obsolete;
 	TileIndex lorry_tile_obsolete;
@@ -122,6 +158,11 @@
 
 void ModifyStationRatingAround(TileIndex tile, byte owner, int amount, uint radius);
 
+void SearchVehiclesForStation(Station *st);
+void ShowStationStatsWindow(int station);
+void InitializeStationStats(Station *st);
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted);
+
 TileIndex GetStationTileForVehicle(const Vehicle *v, const Station *st);
 
 void ShowStationViewWindow(int station);
Index: network_client.c
===================================================================
--- network_client.c	(revision 2456)
+++ network_client.c	(working copy)
@@ -14,8 +14,9 @@
 #include "window.h"
 #include "settings.h"
 #include "console.h"
+#include "gui.h"
+#include "newgrf.h"
 
-
 // This file handles all the client-commands
 
 
@@ -26,8 +27,6 @@
 
 static uint32 last_ack_frame;
 
-void NetworkRecvPatchSettings(NetworkClientState *cs, Packet *p);
-
 // **********
 // Sending functions
 //   DEF_CLIENT_SEND_COMMAND has no parameters
@@ -481,10 +480,6 @@
 		InvalidateWindow(WC_NETWORK_STATUS_WINDOW, 0);
 	}
 
-	if (maptype == MAP_PACKET_PATCH) {
-		NetworkRecvPatchSettings(MY_CLIENT, p);
-	}
-
 	// Check if this was the last packet
 	if (maptype == MAP_PACKET_END) {
 		// We also get, very nice, the player_seeds in this packet
@@ -509,6 +504,9 @@
 
 		_opt_ptr = &_opt; // during a network game you are always in-game
 
+		if (!CheckLoadedGRFs(false))
+			ShowErrorMessage(_error_message, STR_NULL, 0, 0);
+
 		// Say we received the map and loaded it correctly!
 		SEND_COMMAND(PACKET_CLIENT_MAP_OK)();
 
@@ -796,37 +794,6 @@
 // If this fails, check the array above with network_data.h
 assert_compile(lengthof(_network_client_packet) == PACKET_END);
 
-extern const SettingDesc patch_settings[];
-
-// This is a TEMPORARY solution to get the patch-settings
-//  to the client. When the patch-settings are saved in the savegame
-//  this should be removed!!
-void NetworkRecvPatchSettings(NetworkClientState *cs, Packet *p)
-{
-	const SettingDesc *item;
-
-	item = patch_settings;
-
-	while (item->name != NULL) {
-		switch (item->flags) {
-			case SDT_BOOL:
-			case SDT_INT8:
-			case SDT_UINT8:
-				*(uint8 *)(item->ptr) = NetworkRecv_uint8(cs, p);
-				break;
-			case SDT_INT16:
-			case SDT_UINT16:
-				*(uint16 *)(item->ptr) = NetworkRecv_uint16(cs, p);
-				break;
-			case SDT_INT32:
-			case SDT_UINT32:
-				*(uint32 *)(item->ptr) = NetworkRecv_uint32(cs, p);
-				break;
-		}
-		item++;
-	}
-}
-
 // Is called after a client is connected to the server
 void NetworkClient_Connected(void)
 {
Index: tile.h
===================================================================
--- tile.h	(revision 2456)
+++ tile.h	(working copy)
@@ -74,9 +74,12 @@
 	return TileHeight(tile) * 8;
 }
 
-static inline TileType GetTileType(TileIndex tile)
+static TileType GetTileType(TileIndex tile)
 {
 	assert(tile < MapSize());
+	//if (!(tile < MapSize())) {
+//		return 0;
+//	}
 	return GB(_map_type_and_height[tile], 4, 4);
 }
 
Index: settings_gui.c
===================================================================
--- settings_gui.c	(revision 2456)
+++ settings_gui.c	(working copy)
@@ -656,6 +656,8 @@
 	{PE_UINT8,	PF_0ISDIS | PF_PLAYERBASED, STR_CONFIG_PATCHES_SNAP_RADIUS, "window_snap_radius", &_patches.window_snap_radius,     1, 32,  1, NULL},
 	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_INVISIBLE_TREES,	"invisible_trees", &_patches.invisible_trees,					0,  1,  1, &InvisibleTreesActive},
 	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_POPULATION_IN_LABEL, "population_in_label", &_patches.population_in_label, 0, 1, 1, &PopulationInLabelActive},
+	
+	{PE_BOOL,		PF_PLAYERBASED, STR_CONFIG_PATCHES_SET_MIDDLE_KEY_BIND, "set_middle_key_binding", &_patches.set_middle_key_bind, 0, 1, 1, NULL},	
 
 	{PE_INT32, 0, STR_CONFIG_PATCHES_MAP_X, "map_x", &_patches.map_x, 6, 11, 1, NULL},
 	{PE_INT32, 0, STR_CONFIG_PATCHES_MAP_Y, "map_y", &_patches.map_y, 6, 11, 1, NULL},
@@ -702,6 +704,7 @@
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_AIRCRAFT, "servint_aircraft", &_patches.servint_aircraft, 5,800,  5, &InValidateDetailsWindow},
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_SHIPS,		"servint_ships",    &_patches.servint_ships,		5,800,  5, &InValidateDetailsWindow},
 	{PE_BOOL,   0,         STR_CONFIG_PATCHES_NOSERVICE,        "no_servicing_if_no_breakdowns", &_patches.no_servicing_if_no_breakdowns, 0, 0, 0, NULL},
+	{PE_UINT16,   0,         STR_CONFIG_PATCHES_AIR_COEFF,        "aircraft_speed_coeff", &_patches.aircraft_speed_coeff, 1, 8, 1, NULL},
 };
 
 static const PatchEntry _patches_stations[] = {
@@ -714,6 +717,7 @@
 	{PE_UINT8,	0, STR_CONFIG_PATCHES_STATION_SPREAD,		"station_spread", &_patches.station_spread,						4, 64,  1, &InvalidateStationBuildWindow},
 	{PE_BOOL,		0, STR_CONFIG_PATCHES_SERVICEATHELIPAD, "service_at_helipad", &_patches.serviceathelipad,					0,  0,  0, NULL},
 	{PE_BOOL, 0, STR_CONFIG_PATCHES_CATCHMENT, "modified_catchment", &_patches.modified_catchment, 0, 0, 0, NULL},
+	{PE_BOOL, 0, STR_CONFIG_PATCHES_AIRQUEUE, "aircraft_queueing", &_patches.aircraft_queueing, 0, 0, 0, NULL},
 
 };
 
@@ -1123,7 +1127,7 @@
 {   WWT_CLOSEBOX,   RESIZE_NONE,    10,     0,    10,     0,    13, STR_00C5,												STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    10,    11,   369,     0,    13, STR_CONFIG_PATCHES_CAPTION,			STR_018C_WINDOW_TITLE_DRAG_THIS},
 {      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    14,    41, 0x0,															STR_NULL},
-{      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    42,   320, 0x0,															STR_NULL},
+{      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    42,   336, 0x0,															STR_NULL},
 
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    10,    96,    16,    27, STR_CONFIG_PATCHES_GUI,					STR_NULL},
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    97,   183,    16,    27, STR_CONFIG_PATCHES_CONSTRUCTION,	STR_NULL},
@@ -1135,7 +1139,7 @@
 };
 
 static const WindowDesc _patches_selection_desc = {
-	WDP_CENTER, WDP_CENTER, 370, 321,
+	WDP_CENTER, WDP_CENTER, 370, 337,
 	WC_GAME_OPTIONS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET,
 	_patches_selection_widgets,
Index: console_cmds.c
===================================================================
--- console_cmds.c	(revision 2456)
+++ console_cmds.c	(working copy)
@@ -1356,6 +1356,9 @@
 	IConsoleVarRegister("pause_on_join",         &_network_pause_on_join, ICONSOLE_VAR_BOOLEAN, "Set if the server should pause gameplay while a client is joining. This might help slow users");
 	IConsoleVarHookAdd("pause_on_join",          ICONSOLE_HOOK_ACCESS, ConHookServerOnly);
 
+	IConsoleVarRegister("pause_on_no_clients",   &_network_pause_on_no_clients, ICONSOLE_VAR_BOOLEAN, "Set if the server should pause gameplay when there are no clients connected.");
+	IConsoleVarHookAdd("pause_on_no_clients",    ICONSOLE_HOOK_ACCESS, ConHookServerOnly);
+
 	IConsoleVarRegister("autoclean_companies",   &_network_autoclean_companies, ICONSOLE_VAR_BOOLEAN, "Automatically shut down inactive companies to free them up for other players. Customize with 'autoclean_(un)protected'");
 	IConsoleVarHookAdd("autoclean_companies",    ICONSOLE_HOOK_ACCESS, ConHookServerOnly);
 
Index: network_server.c
===================================================================
--- network_server.c	(revision 2456)
+++ network_server.c	(working copy)
@@ -20,7 +20,6 @@
 
 void NetworkHandleCommandQueue(NetworkClientState *cs);
 void NetworkPopulateCompanyInfo(void);
-void NetworkSendPatchSettings(NetworkClientState *cs);
 
 extern const char _openttd_revision[];
 
@@ -326,9 +325,6 @@
 				int i;
 				Packet *p;
 
-				// XXX - Delete this when patch-settings are saved in-game
-				NetworkSendPatchSettings(cs);
-
 				p = NetworkSend_Init(PACKET_SERVER_MAP);
 				NetworkSend_uint8(p, MAP_PACKET_END);
 				// Send the player_seeds in this packet
@@ -753,8 +749,9 @@
 			}
 		}
 
-		if (_network_pause_on_join) {
+		if (_network_pause_on_join && !(_network_pause_on_no_clients && _network_dedicated && _network_game_info.clients_on == 1)) {
 			/* Now pause the game till the client is in sync */
+			/* If pause on no clients is enabled and this is the first client, then it will already be paused */
 			DoCommandP(0, 1, 0, NULL, CMD_PAUSE);
 
 			NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game paused (incoming client)", NETWORK_SERVER_INDEX);
@@ -960,7 +957,7 @@
 		/* Now he is! Unpause the game */
 		cs->status = STATUS_ACTIVE;
 
-		if (_network_pause_on_join) {
+		if (_network_pause_on_join || (_network_pause_on_no_clients && _network_dedicated && _network_game_info.clients_on == 1)) {
 			DoCommandP(0, 0, 0, NULL, CMD_PAUSE);
 			NetworkServer_HandleChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0, "Game unpaused", NETWORK_SERVER_INDEX);
 		}
@@ -1188,43 +1185,6 @@
 // If this fails, check the array above with network_data.h
 assert_compile(lengthof(_network_server_packet) == PACKET_END);
 
-
-extern const SettingDesc patch_settings[];
-
-// This is a TEMPORARY solution to get the patch-settings
-//  to the client. When the patch-settings are saved in the savegame
-//  this should be removed!!
-void NetworkSendPatchSettings(NetworkClientState *cs)
-{
-	const SettingDesc *item;
-	Packet *p = NetworkSend_Init(PACKET_SERVER_MAP);
-	NetworkSend_uint8(p, MAP_PACKET_PATCH);
-	// Now send all the patch-settings in a pretty order..
-
-	item = patch_settings;
-
-	while (item->name != NULL) {
-		switch (item->flags) {
-			case SDT_BOOL:
-			case SDT_INT8:
-			case SDT_UINT8:
-				NetworkSend_uint8(p, *(uint8 *)item->ptr);
-				break;
-			case SDT_INT16:
-			case SDT_UINT16:
-				NetworkSend_uint16(p, *(uint16 *)item->ptr);
-				break;
-			case SDT_INT32:
-			case SDT_UINT32:
-				NetworkSend_uint32(p, *(uint32 *)item->ptr);
-				break;
-		}
-		item++;
-	}
-
-	NetworkSend_Packet(p, cs);
-}
-
 // This update the company_info-stuff
 void NetworkPopulateCompanyInfo(void)
 {
Index: window.c
===================================================================
--- window.c	(revision 2456)
+++ window.c	(working copy)
@@ -1,11 +1,13 @@
 #include "stdafx.h"
 #include "openttd.h"
+#include "table/sprites.h"
 #include "debug.h"
 #include "map.h"
 #include "window.h"
 #include "gfx.h"
 #include "viewport.h"
 #include "console.h"
+#include "gui.h"
 
 // delta between mouse cursor and upper left corner of dragged window
 static Point _drag_delta;
@@ -104,6 +106,8 @@
 	const Widget *wi1 = &w->widget[widget];
 	const Widget *wi2 = &w->widget[widget + 1];
 	Scrollbar *sb;
+	WindowEvent e;
+	byte how;
 
 	/* The listbox can only scroll if scrolling was done on the scrollbar itself,
 	 * or on the listbox (and the next item is (must be) the scrollbar)
@@ -120,9 +124,32 @@
 			}
 		}
 	}
+
+	if (wheel < 0) {
+		how = ZOOM_IN;
+	} else if (wheel > 0) {
+		how = ZOOM_OUT;
+	} else {
+		how = ZOOM_NONE;
+	}
+	
+	DEBUG(misc,0)("%d %d I%d O%d U%d", how, wheel, ZOOM_IN, ZOOM_OUT, ZOOM_NONE);
+
+	e.event = WE_SCROLL;
+	e.scroll.scroll = how;
+	e.scroll.amount = wheel;
+	w->wndproc(w, &e);
 }
 
+void DispatchMiddleClickEvent(Window *w, int x, int y) {
+	WindowEvent e;
 
+	e.event = WE_MCLICK;
+	e.click.pt.x = x;
+	e.click.pt.y = y;
+	w->wndproc(w, &e);
+}
+
 void DrawOverlappedWindowForAll(int left, int top, int right, int bottom)
 {
 	Window *w;
@@ -1312,6 +1339,8 @@
 	* to thein this main toolbar. */
 	bool query_open = false;
 
+	DEBUG(misc,0)("Got key: %d", key);
+
 	// Setup event
 	we.keypress.event = WE_KEYPRESS;
 	we.keypress.ascii = key & 0xFF;
@@ -1376,7 +1405,6 @@
 	x = _cursor.pos.x;
 	y = _cursor.pos.y;
 
-
 	if (click == 0 && mousewheel == 0) {
 		if (_patches.autoscroll && _game_mode != GM_MENU) {
 			w = FindWindowFromPt(x, y);
@@ -1403,22 +1431,18 @@
 	w = MaybeBringWindowToFront(w);
 	vp = IsPtInWindowViewport(w, x, y);
 	if (vp != NULL) {
-		if (_game_mode == GM_MENU)
-			return;
+		if (_game_mode == GM_MENU) return;
 
-		// only allow zooming in-out in main window, or in viewports
-		if ( mousewheel && !(w->flags4 & WF_DISABLE_VP_SCROLL) &&
-			   (w->window_class == WC_MAIN_WINDOW || w->window_class == WC_EXTRA_VIEW_PORT) ) {
-			ZoomInOrOutToCursorWindow(mousewheel < 0,w);
-		}
+		// only allow zooming in-out zoomable windows (with viewports)
+		if ( mousewheel && !(w->flags4 & WF_DISABLE_VP_SCROLL) && (w->desc_flags & WDF_ZOOMABLE))
+			ZoomInOrOutToCursorWindow(mousewheel < 0, w);
 
 		if (click == 1) {
 			DEBUG(misc, 2) ("cursor: 0x%X (%d)", _cursor.sprite, _cursor.sprite);
 			if (_thd.place_mode != 0 &&
 					// query button and place sign button work in pause mode
-					!(_cursor.sprite == 0x2CF || _cursor.sprite == 0x2D2) &&
-					_pause != 0 &&
-					!_cheats.build_in_pause.value)
+					!(_cursor.sprite == SPR_CURSOR_QUERY || _cursor.sprite == SPR_CURSOR_SIGN) &&
+					_pause != 0 && !_cheats.build_in_pause.value)
 						return;
 
 			if (_thd.place_mode == 0) {
@@ -1431,6 +1455,8 @@
 				_scrolling_viewport = true;
 				_cursor.fix_at = true;
 			}
+		} else if (click == 3) {
+			HandleKeypress(_patches.middle_key_bind);
 		}
 	} else {
 		if (mousewheel)
@@ -1440,6 +1466,8 @@
 			DispatchLeftClickEvent(w, x - w->left, y - w->top);
 		else if (click == 2)
 			DispatchRightClickEvent(w, x - w->left, y - w->top);
+		else if (click == 3 && !mousewheel) // Prevent accidental scrolling and clicking
+			DispatchMiddleClickEvent(w, x - w->left, y - w->top);
 	}
 }
 
@@ -1451,7 +1479,11 @@
 	_current_player = _local_player;
 
 	// Handle pressed keys
-	if (_pressed_key) {
+	if (_patches.set_middle_key_bind && _pressed_key) {
+		_patches.middle_key_bind = _pressed_key;
+		_patches.set_middle_key_bind = 0;
+		_pressed_key = false;
+	} else if (_pressed_key) {
 		uint32 key = _pressed_key; _pressed_key = 0;
 		HandleKeypress(key);
 	}
@@ -1464,6 +1496,9 @@
 	} else if (_right_button_clicked) {
 		_right_button_clicked = false;
 		click = 2;
+	} else if (_middle_button_down && !_middle_button_clicked) {
+		_middle_button_clicked = true;
+		click = 3;
 	}
 
 	mousewheel = 0;
Index: window.h
===================================================================
--- window.h	(revision 2456)
+++ window.h	(working copy)
@@ -5,6 +5,10 @@
 
 typedef union WindowEvent WindowEvent;
 
+enum {
+	CARGO_MASK_ALL = 0xFFFFFFFF,
+};
+
 //typedef void WindowProc(Window *w, int event, int wparam, long lparam);
 
 typedef void WindowProc(Window *w, WindowEvent *e);
@@ -136,6 +140,12 @@
 		uint wparam; // additional message-specific information
 		uint lparam; // additional message-specific information
 	} message;
+
+	struct {
+		byte event;
+		byte scroll; // scrolled up our down with the mouse, or ZOOM_NONE to just update status
+		int amount;
+	} scroll;
 };
 
 enum WindowKeyCodes {
@@ -226,13 +236,14 @@
 } WindowDesc;
 
 enum {
-	WDF_STD_TOOLTIPS   = 1, /* use standard routine when displaying tooltips */
-	WDF_DEF_WIDGET     = 2,	/* default widget control for some widgets in the on click event */
-	WDF_STD_BTN        = 4,	/* default handling for close and drag widgets (widget no 0 and 1) */
-	WDF_RESTORE_DPARAM = 8, /* when drawing widgets, restore the dparam so all widgets recieve the same set of them */
-	WDF_UNCLICK_BUTTONS=16, /* Unclick buttons when the window event times out */
-	WDF_STICKY_BUTTON  =32, /* Set window to sticky mode; they are not closed unless closed with 'X' (widget 2) */
-	WDF_RESIZABLE      =64, /* A window can be resized */
+	WDF_STD_TOOLTIPS   =   1, /* use standard routine when displaying tooltips */
+	WDF_DEF_WIDGET     =   2,	/* default widget control for some widgets in the on click event */
+	WDF_STD_BTN        =   4,	/* default handling for close and drag widgets (widget no 0 and 1) */
+	WDF_RESTORE_DPARAM =   8, /* when drawing widgets, restore the dparam so all widgets recieve the same set of them */
+	WDF_UNCLICK_BUTTONS=  16, /* Unclick buttons when the window event times out */
+	WDF_STICKY_BUTTON  =  32, /* Set window to sticky mode; they are not closed unless closed with 'X' (widget 2) */
+	WDF_RESIZABLE      =  64, /* A window can be resized */
+	WDF_ZOOMABLE       = 128, /* The window (viewport) can be zoomed in/out with the mousewheel */
 };
 
 /* can be used as x or y coordinates to cause a specific placement */
@@ -307,6 +318,8 @@
 
 	Message message;
 	byte custom[WINDOW_CUSTOM_SIZE];
+	
+	DisplayListOptions listopt; // Options for displaying vehicle-lists
 };
 
 typedef struct {
@@ -482,7 +495,9 @@
 	WE_MOUSEOVER = 20,
 	WE_ON_EDIT_TEXT_CANCEL = 21,
 	WE_RESIZE = 22,
-	WE_MESSAGE = 23
+	WE_MESSAGE = 23,
+	WE_SCROLL = 24,
+	WE_MCLICK = 25
 };
 
 
@@ -638,6 +653,9 @@
 VARDEF bool _right_button_down;
 VARDEF bool _right_button_clicked;
 
+VARDEF bool _middle_button_down;
+VARDEF bool _middle_button_clicked;
+
 VARDEF int _alloc_wnd_parent_num;
 
 VARDEF int _scrollbar_start_pos;
Index: queue.c
===================================================================
--- queue.c	(revision 2456)
+++ queue.c	(working copy)
@@ -1,6 +1,7 @@
 #include "stdafx.h"
 #include "openttd.h"
 #include "queue.h"
+#include "vehicle.h"
 
 static void Stack_Clear(Queue* q, bool free_values)
 {
@@ -114,6 +115,18 @@
 	return result;
 }
 
+static void* Fifo_GetTop(Queue* q)
+{
+	void* result;
+	if (q->data.fifo.head == q->data.fifo.tail)
+		return NULL;
+	result = q->data.fifo.elements[q->data.fifo.tail];
+
+	// Only getting top, do not take off
+	//q->data.fifo.tail = (q->data.fifo.tail + 1) % q->data.fifo.max_size;
+	return result;
+}
+
 static bool Fifo_Delete(Queue* q, void* item, int priority)
 {
 	return false;
@@ -131,6 +144,7 @@
 	q->data.fifo.tail = 0;
 	q->data.fifo.elements = malloc(max_size * sizeof(void*));
 	q->freeq = false;
+	q->getTop = Fifo_GetTop;
 	return q;
 }
 
@@ -717,3 +731,232 @@
 uint Hash_Size(Hash* h) {
     return h->size;
 }
+
+// Returns success
+bool VPush(VehicleQueue *q, Vehicle *v)
+{
+	VQueueItem* newItem;
+
+	// Do not push NULLs
+	assert(v != NULL);
+
+	if(q->size == 0x7FFFFFFF)
+		return false;
+
+	newItem = malloc(sizeof(VQueueItem));
+
+	if(newItem == NULL)
+		return false;
+
+	if(q->size == 0)
+	{
+		assert(q->top == NULL);
+		assert(q->bottom == NULL);
+		newItem->data = v;
+		newItem->position = 1;
+		newItem->queue = q;
+		newItem->above = NULL;
+		newItem->below = NULL;
+		q->bottom = newItem;
+		q->top = newItem;
+		v->queue_item = newItem;
+		q->size = 1;
+		return true;
+	}
+
+	q->bottom->below = newItem;
+	newItem->above = q->bottom;
+	newItem->below = NULL;
+	newItem->data = v;
+	newItem->position = q->bottom->position + 1;
+	newItem->queue = q;
+	v->queue_item = newItem;
+	q->bottom = newItem;
+	q->size++;
+	return true;
+}
+
+// Returns vehicle popped
+Vehicle* VPop(VehicleQueue *q)
+{
+	Vehicle* v;
+	VQueueItem* oldItem;
+	if(q->size == 0)
+		return NULL;
+
+	oldItem = q->top;
+
+	assert(oldItem != NULL);
+
+	q->top = oldItem->below;
+	if(q->top != NULL)
+	{
+		q->top->above = NULL;
+	}
+
+	// Had one item, now empty
+	if(q->size == 1)
+	{
+		q->bottom = NULL;
+		q->top = NULL;
+		q->size = 0;
+		q->offset = 0;
+		q->dirty = false;
+		v = oldItem->data;
+		v->queue_item = NULL;
+		free(oldItem);
+		return v;
+	}
+
+	// Top was above bottom - now top *IS* bottom
+	if(q->size == 2)
+	{
+		q->bottom->above = NULL;
+	}
+
+	v = oldItem->data;
+
+	v->queue_item = NULL;
+
+	free(oldItem);
+
+	q->offset++;
+	q->size--;
+
+	if(q->offset > 0x7FFFFFFF)
+	{
+		q->dirty = true;
+		q->clean(q);
+	}
+	return v;
+}
+
+Vehicle* VGetTop(VehicleQueue *q)
+{
+	if(q->size != 0)
+		return q->top->data;
+	else
+		return NULL;
+}
+
+void VClean(VehicleQueue *q)
+{
+	bool done;
+	uint32 currentSize;
+	VQueueItem* currItem;
+	done = false;
+
+	if(q->top == NULL)
+	{
+		assert(q->bottom == NULL);
+		assert(q->size == 0);
+		return;
+	}
+
+	currItem = q->top;
+	q->offset = 0;
+
+	currentSize = 1;
+	while(done == false)
+	{
+		currItem->position = currentSize;
+		currItem = currItem->below;
+		if(currItem == NULL)
+		{
+			done = true;
+			assert(q->size == currentSize);
+		}
+		currentSize++;
+	}
+
+	// Congrats! We now have a clean queue!
+	q->dirty = false;
+	return;
+}
+
+void VClear(VehicleQueue *q)
+{
+	while(q->pop(q) != NULL)
+	{
+		// What? Expecting something? The clearing is done
+		// in the while statement above - I don't need anything here!
+	}
+	return;
+}
+
+// This is one of the special functions - allows item to take itself off
+// the queue no matter where in the queue it is!
+void VDelete(VehicleQueue *q, Vehicle *v)
+{
+	VQueueItem* current;
+	VQueueItem* above;
+	VQueueItem* below;
+
+	current = v->queue_item;
+	if(current == NULL)
+		return;
+
+	if(current == q->top)
+	{
+		q->top = current->below;
+	}
+
+	if(current == q->bottom)
+	{
+		q->bottom = current->above;
+	}
+
+	above = current->above;
+	below = current->below;
+
+	if(above != NULL)
+		above->below = below;
+	
+	if(below != NULL)
+		below->above = above;
+
+	v->queue_item = NULL;
+
+	free(current);
+
+	q->size--;
+	q->dirty = true;
+}
+
+uint32 VGetPos(VehicleQueue *q, Vehicle *v)
+{
+	if(q->dirty)
+	{
+		q->clean(q);
+	}
+
+	return v->queue_item->position - q->offset;
+}
+
+//bool VQueue_InitProc(VehicleQueue* q)
+//{
+
+
+
+VehicleQueue* new_VQueue(void)
+{
+	VehicleQueue* q = malloc(sizeof(VehicleQueue));
+
+	q->push = VPush;
+	q->pop = VPop;
+	q->getTop = VGetTop;
+	q->clean = VClean;
+	q->clear = VClear;
+	q->del = VDelete;
+	q->getPos = VGetPos;
+
+	q->size = 0;
+	q->offset = 0;
+	q->top = NULL;
+	q->bottom = NULL;
+	q->dirty = false;
+	
+	//init_stack(q, max_size);
+	//q->freeq = true;
+	return q;
+}
Index: newgrf.c
===================================================================
--- newgrf.c	(revision 2456)
+++ newgrf.c	(working copy)
@@ -10,6 +10,7 @@
 #include "station.h"
 #include "sprite.h"
 #include "newgrf.h"
+#include "table/strings.h"
 
 /* TTDPatch extended GRF format codec
  * (c) Petr Baudis 2004 (GPL'd)
@@ -2242,3 +2243,46 @@
 	free(buf);
 #undef NUM_ACTIONS
 }
+
+/**
+* Gives a warning about any GRFs that are in the save, but have not been
+* matched to loaded GRFs.
+*
+* @todo Improve error notification. It would be best to popup a list of GRFs
+*	on the screen, but at the moment there isn't a dynamic error box, so it
+*	ends up messing up everything because the box is too small.
+*/
+bool CheckLoadedGRFs(bool show_console_errors)
+{
+	int y = 0, p = 0; /**< Iteration integers. */
+	/** Buffer for output (1024, just in case a noob tries to load a
+	* cazillion GRFs) */
+	char buf[1024]; 
+	
+	/** There is probably a better way of doing this */
+	sprintf(buf," "); 
+	
+	for(y=0; y<_grfs_in_save_num; y++)
+	{
+		if(!(_grfs_in_save[y].flags & 0x0001))
+		{	
+			if (show_console_errors)	
+				sprintf(buf,"%s\n\t\t%s - %08x", buf, _grfs_in_save[y].filename, _grfs_in_save[y].grfid);
+			p++;
+		}
+	}
+	
+	if (p > 0)
+	{
+		if(show_console_errors)
+		{
+			DEBUG(misc,0)("\n\tWARNING: The following GRFs could not be loaded:\n\t\tFilename - GRF ID%s\n", buf);
+		} else {
+			_error_message = STR_4011_GRFS_COULD_NOT_LOAD;
+		}
+		
+		return false;
+	} else {
+		return true;
+	}
+}
Index: queue.h
===================================================================
--- queue.h	(revision 2456)
+++ queue.h	(working copy)
@@ -14,6 +14,9 @@
 typedef void Queue_ClearProc(Queue* q, bool free_values);
 typedef void Queue_FreeProc(Queue* q, bool free_values);
 
+// Get top without popping
+typedef void* Queue_GetTopProc(Queue* q);
+
 typedef struct InsSortNode InsSortNode;
 struct InsSortNode {
 	void* item;
@@ -55,6 +58,11 @@
 	 * items are free()'d too.
 	 */
 	Queue_FreeProc* free;
+	/* Obtains the top of the queue, allowing the user to look at the 
+	 * queue without destroying it.
+	 * WARNING: ONLY IMPLEMENTED IN FIFO SO FAR!
+	 */
+	Queue_GetTopProc* getTop;
 
 	union {
 		struct {
@@ -202,4 +210,77 @@
  */
 uint Hash_Size(Hash* h);
 
+/* 
+ * NOT part of normal Queue structures defined above!
+ * This is a special queue designed to have special behaviors
+ * for the aircraft queueing algorithm, which has special requirements ;).
+ * Note that this is NOT a priority queue!
+ */
+typedef struct VehicleQueue VehicleQueue;
+
+// O(1), always
+typedef bool VQueue_PushProc(VehicleQueue* q, Vehicle* item);
+// O(1), unless offset is > 2147483647 - then O(n) -- increments offset
+typedef Vehicle* VQueue_PopProc(VehicleQueue* q);
+// O(1)
+typedef Vehicle* VQueue_GetTopProc(VehicleQueue* q);
+// O(n) -- Rebuilds the "position"s, resets the offset, asserts the size.
+typedef void VQueue_CleanProc(VehicleQueue* q);
+// O(n)
+typedef void VQueue_ClearProc(VehicleQueue* q);
+// O(1) -- sets dirty bit
+typedef void VQueue_DeleteProc(VehicleQueue* q, Vehicle* item);
+// O(1) if not dirty, otherwise O(n) -- Gets current position in queue.
+typedef uint32 VQueue_GetPosProc(VehicleQueue* q, Vehicle* item);
+// O(1)
+typedef bool VQueue_InitProc(VehicleQueue* q);
+
+//typedef void VQueue_FreeProc(Queue* q, bool free_values);
+
+/*
+ * WARNING: Do NOT directly manipulate data inside this queue!
+ * Queue is *very* sensitive and will toss assertions if it detects
+ * improper values!
+ */
+typedef struct VQueueItem VQueueItem;
+struct VQueueItem
+{
+	Vehicle *data;
+	// Position in queue
+	uint32 position;
+	VQueueItem *below;
+	VQueueItem *above;
+
+	// Queue item belongs to (so we can have reverse lookups)
+	VehicleQueue *queue;
+};
+
+struct VehicleQueue
+{
+	// Ahh, yes! Classic C functional programming!
+	// Should really be converted to C++, though . . .
+	VQueue_PushProc*	push;
+	VQueue_PopProc*		pop;
+	VQueue_GetTopProc*	getTop;
+	VQueue_CleanProc*	clean;
+	VQueue_ClearProc*	clear;
+	VQueue_DeleteProc*	del;
+	VQueue_GetPosProc*	getPos;
+	//VQueue_InitProc*	init;
+
+	VQueueItem* top;
+	VQueueItem* bottom;
+
+	// Dirty means "position" in VQueueItems is incorrect
+	// and needs to be rebuilt.
+    bool dirty;	
+	uint32 size;
+
+	// Offset for "position" in queue - allows for O(1) pushes & pops
+	uint32 offset;
+};
+
+VehicleQueue* new_VQueue(void);
+
+
 #endif /* QUEUE_H */
Index: newgrf.h
===================================================================
--- newgrf.h	(revision 2456)
+++ newgrf.h	(working copy)
@@ -37,8 +37,12 @@
 extern int _grffile_count;
 extern GRFFile *_first_grffile;
 
+GRFFile _grfs_in_save[32]; // GRFs in game save
+int _grfs_in_save_num; // Num of GRFs in game save
+
 void InitNewGRFFile(const char *filename, int sprite_offset);
 void DecodeSpecialSprite(const char *filename, int num, int spriteid, int stage);
+bool CheckLoadedGRFs(bool show_console_errors);
 
 
 #endif /* NEWGRF_H */
