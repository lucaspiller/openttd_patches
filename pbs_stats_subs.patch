Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 2447)
+++ station_cmd.c	(working copy)
@@ -18,8 +18,10 @@
 #include "player.h"
 #include "airport.h"
 #include "sprite.h"
+#include "network.h"
 #include "npf.h"
 #include "depot.h"
+#include "pbs.h"
 
 enum {
 	/* Max stations: 64000 (64 * 1000) */
@@ -423,7 +425,7 @@
 	Station* st;
 
 	FOR_ALL_STATIONS(st) {
-		if (st->xy != 0 && (owner == OWNER_SPECTATOR || st->owner == owner)) {
+		if (st->xy != 0 && (owner == OWNER_SPECTATOR || IsSisterCompany(st->owner, owner) || _patches.shared_stations)) {
 			uint cur_dist = DistanceManhattan(tile, st->xy);
 
 			if (cur_dist < threshold) {
@@ -460,6 +462,7 @@
 		ge->last_age = 0xFF;
 		ge->feeder_profit = 0;
 	}
+	InitializeStationStats(st);
 
 	_global_station_sort_dirty = true; // build a new station
 }
@@ -535,10 +538,10 @@
 
 	// expand the region by rad tiles on each side
 	// while making sure that we remain inside the board.
-	x2 = min(x + w + rad, MapSizeX());
+	x2 = min((uint)(x + w + rad), MapSizeX());
 	x1 = max(x - rad, 0);
 
-	y2 = min(y + h + rad, MapSizeY());
+	y2 = min((uint)(y + h + rad), MapSizeY());
 	y1 = max(y - rad, 0);
 
 	assert(x1 < x2);
@@ -584,8 +587,8 @@
 
 	// expand the region by rad tiles on each side
 	// while making sure that we remain inside the board.
-	x2 = min(x + w + rad, MapSizeX());
-	y2 = min(y + h + rad, MapSizeY());
+	x2 = min((uint)(x + w + rad), MapSizeX());
+	y2 = min((uint)(y + h + rad), MapSizeY());
 	x1 = max(x - rad, 0);
 	y1 = max(y - rad, 0);
 
@@ -939,6 +942,7 @@
 	int plat_len, numtracks;
 	int direction;
 	uint finalvalues[3];
+	bool extending = false;
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
@@ -987,15 +991,18 @@
 
 	if (st != NULL) {
 		// Reuse an existing station.
-		if (st->owner != OWNER_NONE && st->owner != _current_player)
+		if (st->owner != OWNER_NONE && !IsSisterCompany(st->owner,_current_player))
 			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
 
 		if (st->train_tile != 0) {
 			// check if we want to expanding an already existing station?
 			if ((!_patches.ainew_active && _is_ai_player) || !_patches.join_stations)
 				return_cmd_error(STR_3005_TOO_CLOSE_TO_ANOTHER_RAILROAD);
+
 			if (!CanExpandRailroadStation(st, finalvalues, direction))
 				return CMD_ERROR;
+			else
+				extending = true;
 		}
 
 		//XXX can't we pack this in the "else" part of the if above?
@@ -1033,7 +1040,8 @@
 		st->train_tile = finalvalues[0];
 		if (!st->facilities) st->xy = finalvalues[0];
 		st->facilities |= FACIL_TRAIN;
-		st->owner = _current_player;
+		if(!_patches.subsidiaries || (_patches.subsidiaries && st->facilities == FACIL_TRAIN && !extending))
+			st->owner = _current_player;
 
 		st->trainst_w = finalvalues[1];
 		st->trainst_h = finalvalues[2];
@@ -1133,7 +1141,7 @@
 	// make sure the specified tile belongs to the current player, and that it is a railroad station.
 	if (!IsTileType(tile, MP_STATION) || _map5[tile] >= 8 || !_patches.nonuniform_stations) return CMD_ERROR;
 	st = GetStation(_map2[tile]);
-	if (_current_player != OWNER_WATER && (!CheckOwnership(st->owner) || !EnsureNoVehicle(tile))) return CMD_ERROR;
+	if (_current_player != OWNER_WATER && (!(CheckOwnership(st->owner) && DEREF_PLAYER(st->owner)->is_active) || !EnsureNoVehicle(tile))) return CMD_ERROR;
 
 	// if we reached here, it means we can actually delete it. do that.
 	if (flags & DC_EXEC) {
@@ -1349,7 +1357,7 @@
 		return DoCommandByTile(tile, 0, 0, DC_EXEC, CMD_REMOVE_FROM_RAILROAD_STATION);
 
 	/* Current player owns the station? */
-	if (_current_player != OWNER_WATER && !CheckOwnership(st->owner))
+	if (_current_player != OWNER_WATER && !CheckOwnership(st->owner) && DEREF_PLAYER(st->owner)->is_active)
 		return CMD_ERROR;
 
 	/* determine width and height of platforms */
@@ -1479,7 +1487,7 @@
 		return_cmd_error( (type) ? STR_3008B_TOO_MANY_TRUCK_STOPS : STR_3008A_TOO_MANY_BUS_STOPS);
 
 	if (st != NULL) {
-		if (st->owner != OWNER_NONE && st->owner != _current_player)
+		if (st->owner != OWNER_NONE && !IsSisterCompany(st->owner, _current_player))
 			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
 
 		if (!CheckStationSpreadOut(st, tile, 1, 1))
@@ -1519,9 +1527,10 @@
 		InitializeRoadStop(road_stop, prev, tile, st->index);
 		(*currstop)->type = type;
 		if (!st->facilities) st->xy = tile;
+		if(!_patches.subsidiaries || (_patches.subsidiaries && !st->facilities)){
+			st->owner = _current_player;
+		}
 		st->facilities |= (type) ? FACIL_TRUCK_STOP : FACIL_BUS_STOP;
-		st->owner = _current_player;
-
 		st->build_date = _date;
 
 		ModifyTile(tile,
@@ -1547,7 +1556,7 @@
 	RoadStop *cur_stop;
 	bool is_truck = _map5[tile] < 0x47;
 
-	if (_current_player != OWNER_WATER && !CheckOwnership(st->owner))
+	if (_current_player != OWNER_WATER && !CheckOwnership(st->owner) && DEREF_PLAYER(st->owner)->is_active)
 		return CMD_ERROR;
 
 	if (is_truck) {	//truck stop
@@ -1711,7 +1720,7 @@
 	}
 
 	if (st != NULL) {
-		if (st->owner != OWNER_NONE && st->owner != _current_player)
+		if (st->owner != OWNER_NONE && !IsSisterCompany(st->owner,_current_player))
 			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
 
 		if (!CheckStationSpreadOut(st, tile, 1, 1))
@@ -1745,8 +1754,9 @@
 
 	if (flags & DC_EXEC) {
 		const AirportFTAClass *afc = GetAirport(p1);
-
-		st->owner = _current_player;
+		if(!st->facilities){
+			st->owner = _current_player;
+		}
 		if (_current_player == _local_player && afc->nof_depots != 0) {
       _last_built_aircraft_depot_tile = tile + ToTileIndexDiff(afc->airport_depots[0]);
     }
@@ -1791,7 +1801,7 @@
 	int w,h;
 	int32 cost;
 
-	if (_current_player != OWNER_WATER && !CheckOwnership(st->owner))
+	if (_current_player != OWNER_WATER && !CheckOwnership(st->owner) && DEREF_PLAYER(st->owner)->is_active)
 		return CMD_ERROR;
 
 	tile = st->airport_tile;
@@ -2003,7 +2013,7 @@
 	}
 
 	if (st != NULL) {
-		if (st->owner != OWNER_NONE && st->owner != _current_player)
+		if (st->owner != OWNER_NONE && !IsSisterCompany(st->owner, _current_player))
 			return_cmd_error(STR_3009_TOO_CLOSE_TO_ANOTHER_STATION);
 
 		if (!CheckStationSpreadOut(st, tile, 1, 1)) return CMD_ERROR;
@@ -2032,7 +2042,8 @@
 		st->dock_tile = tile;
 		if (!st->facilities) st->xy = tile;
 		st->facilities |= FACIL_DOCK;
-		st->owner = _current_player;
+		if(!_patches.subsidiaries || (_patches.subsidiaries && st->facilities == FACIL_DOCK))
+			st->owner = _current_player;
 
 		st->build_date = _date;
 
@@ -2061,7 +2072,7 @@
 {
 	uint tile1, tile2;
 
-	if (!CheckOwnership(st->owner))
+	if (!CheckOwnership(st->owner) && DEREF_PLAYER(st->owner)->is_active)
 		return CMD_ERROR;
 
 	tile1 = st->dock_tile;
@@ -2155,6 +2166,18 @@
 		} else {
 			AddChildSpriteScreen(image, dtss->delta_x, dtss->delta_y);
 		}
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & RAIL_BIT_DIAG1) DrawGroundSprite((0x3ED) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_DIAG2) DrawGroundSprite((0x3EE) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_UPPER) DrawGroundSprite((0x3EF) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LOWER) DrawGroundSprite((0x3F0) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LEFT)  DrawGroundSprite((0x3F2) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_RIGHT) DrawGroundSprite((0x3F1) | PALETTE_CRASH);
+}
+#endif
 	}
 }
 
@@ -2609,8 +2632,55 @@
 
 }
 
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted)
+{
+	if (times_counted == 0)
+		return lastamount;
+	average = (uint32)((uint64)(((uint64)average * (uint64)times_counted + (uint64)lastamount) / ((uint64)times_counted + 1)));
+	return average;
+}
+
 void StationMonthlyLoop(void)
 {
+	Station *st;
+	StationStats *sts;
+	GoodsEntry *ge;
+
+ 	FOR_ALL_STATIONS(st) {
+		// if we have stats for this station the number of counted months is >0
+		if (st->months_counted > 0)
+		{
+			for (ge = st->goods; ge != endof(st->goods); ge++) {
+				// if we have stats for this good, the number of months counted is >0
+				if (ge->months_counted > 0) 
+				{
+					// set current months stats to 0 after storing value for last month
+					// do this for all stats (currently In/Out/Transfer)
+					// also determine new min/max-values
+					for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+						if (sts->month_max == 0) sts->month_min = sts->this_month;
+						sts->month_min = min(sts->month_min, sts->this_month);
+						sts->month_max = max(sts->month_max, sts->this_month);
+						sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, ge->months_counted - 1);
+						sts->last_month = sts->this_month;
+						sts->this_month = 0;
+					}
+					ge->months_counted++; // one more month counted
+				}
+			}
+			// update vehicle-counts and min/max
+			for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+				if (sts->month_max == 0) sts->month_min = sts->this_month;
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, st->months_counted - 1);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			st->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, st->index);
+	}
 }
 
 
@@ -2642,6 +2712,7 @@
 	st->goods[type].enroute_time = 0;
 	st->goods[type].enroute_from = st->index;
 	InvalidateWindow(WC_STATION_VIEW, st->index);
+	InvalidateWindow(WC_STATION_STATS, st->index);
 }
 
 /** Rename a station
@@ -2834,7 +2905,7 @@
 			_map2[tile] = st->index;
 
 			st->owner = OWNER_NONE;
-      st->airport_flags = 0;
+			st->airport_flags = 0;
 			st->airport_type = AT_OILRIG;
 			st->xy = tile;
 			st->bus_stops = NULL;
@@ -3030,12 +3101,25 @@
 	SLE_CONDREF(Station,bus_stops,					REF_ROADSTOPS, 6, 255),
 	SLE_CONDREF(Station,truck_stops,				REF_ROADSTOPS, 6, 255),
 
+	// station stats data is stored here since savegame format 14
+	SLE_CONDVAR(Station,months_counted,	SLE_UINT16, 14, 255),
+
 	// reserve extra space in savegame here. (currently 28 bytes)
 	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 32, 2, 255),
 
 	SLE_END()
 };
 
+// station stats data since savegame format 15
+static const SaveLoad _stats_desc[] = {
+	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,average,	SLE_UINT32, 15, 255),
+	SLE_END()
+};
+
 static const SaveLoad _goods_desc[] = {
 	SLE_VAR(GoodsEntry,waiting_acceptance,SLE_UINT16),
 	SLE_VAR(GoodsEntry,days_since_pickup,	SLE_UINT8),
@@ -3047,22 +3131,29 @@
 	SLE_VAR(GoodsEntry,last_age,					SLE_UINT8),
 	SLE_CONDVAR(GoodsEntry,feeder_profit,			SLE_INT32, 14, 255),
 
+	// station stats data is stored here since savegame format 15
+//	SLE_CONDVAR(GoodsEntry,months_counted,	SLE_UINT16, 15, 255),
+
 	SLE_END()
 };
 
 
 static void SaveLoad_STNS(Station *st)
 {
-	int i;
+	int i; //, j;
 
 	SlObject(st, _station_desc);
 	for (i = 0; i != NUM_CARGO; i++) {
 		SlObject(&st->goods[i], _goods_desc);
+//		for (j = 0; j < STS_AMNT_TYPES; j++)
+//			SlObject(&st->goods[i].cargo_amount[j], _stats_desc);
 
 		/* In older versions, enroute_from had 0xFF as INVALID_STATION, is now 0xFFFF */
 		if (_sl.full_version < 0x700 && st->goods[i].enroute_from == 0xFF)
 			st->goods[i].enroute_from = 0xFFFF;
 	}
+//	for (i = 0; i < STS_VEH_TYPES; i++) 
+//		SlObject(&st->vehicles[i], _stats_desc);
 }
 
 static void Save_STNS(void)
@@ -3088,6 +3179,7 @@
 
 		st = GetStation(index);
 		SaveLoad_STNS(st);
+		InitializeStationStats(st);
 
 		// this means it's an oldstyle savegame without support for nonuniform stations
 		if (st->train_tile && st->trainst_h == 0) {
@@ -3154,3 +3246,83 @@
 	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY | CH_LAST},
 };
 
+void SearchVehiclesForStation(Station *st)
+{
+	Vehicle *v;
+	int i;
+	Order* ord;
+	
+	ord = NULL;
+	if (st->xy == 0) return;
+	for(i = 0; i < STS_VEH_TYPES; i++) st->veh_scheduled[i] = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+	
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ||       //Trains (first engine, that contains the orders)
+			( (v->type == VEH_Road) && (v->subtype == 0) ) ||       //Road vehicles (subtype should always be 0 anyway)
+			( (v->type == VEH_Ship) && (v->subtype == 0) ) ||       //Ships, subtype should be 0 anyway)
+			( (v->type == VEH_Aircraft) && (
+				(v->subtype == 0) ||                            //Choppers
+				(v->subtype == 2) ) ) ) &&                               //Fixed-wing stuff
+			(v->owner == st->owner) ) 
+//			(v->owner == _local_player) ) 
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == st->index && ord->type == OT_GOTO_STATION) {
+					switch (v->type) {
+						case VEH_Train:
+							st->veh_scheduled[STS_VEH_TRAIN]++;
+							break;
+						case VEH_Road:
+							st->veh_scheduled[STS_VEH_ROAD]++;
+                            if (v->cargo_type == CT_PASSENGERS)
+								st->veh_scheduled[STS_VEH_BUS]++;
+							else
+								st->veh_scheduled[STS_VEH_TRUCK]++;
+							break;
+						case VEH_Ship:
+							st->veh_scheduled[STS_VEH_SHIP]++;
+							break;
+						case VEH_Aircraft:
+							st->veh_scheduled[STS_VEH_AIRCRAFT]++;
+							break;
+						default:
+							NOT_REACHED();
+					}
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	}
+}
+
+
+void InitializeStationStats(Station *st)
+{
+	StationStats *sts;
+	GoodsEntry *ge;
+
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->months_counted = 0;
+		for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+			sts->average = 0;
+			sts->last_month = 0;
+			sts->month_max = 0;
+			sts->month_min = 65535;
+			sts->this_month = 0;
+		}
+	}
+	st->months_counted = 0;
+	for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = 65535;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForStation(st);
+}
Index: functions.h
===================================================================
--- functions.h	(revision 2447)
+++ functions.h	(working copy)
@@ -72,6 +72,7 @@
 void SubtractMoneyFromPlayerFract(byte player, int32 cost);
 bool CheckOwnership(byte owner);
 bool CheckTileOwnership(uint tile);
+bool CheckSubsidiaryTileOwnership(uint tile);
 StringID GetPlayerNameString(byte player, byte index);
 
 /* standard */
Index: aircraft_cmd.c
===================================================================
--- aircraft_cmd.c	(revision 2447)
+++ aircraft_cmd.c	(working copy)
@@ -14,6 +14,7 @@
 #include "sound.h"
 #include "player.h"
 #include "airport.h"
+#include "economy.h"
 #include "vehicle_gui.h"
 
 static bool AirportMove(Vehicle *v, const AirportFTAClass *Airport);
@@ -178,7 +179,7 @@
 	// Workaround: TODO: make AI players try to build planes in a hangar instead of just an airport tile.
 	if (!IsAircraftHangarTile(tile) && IS_HUMAN_PLAYER(_current_player)) return CMD_ERROR;
 
-	if (!IsTileOwner(tile, _current_player) && IS_HUMAN_PLAYER(_current_player)) return CMD_ERROR;
+	if (!IsSisterCompany(GetTileOwner(tile),_current_player) && IS_HUMAN_PLAYER(_current_player)) return CMD_ERROR;
 
 	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 
@@ -1274,7 +1275,16 @@
 	if (v->current_order.type == OT_GOTO_DEPOT)
 		return;
 
+	//Maybe check what happens if we go Terminal => Hangar => Terminal
 	st = GetStation(v->u.air.targetairport);
+//	if (v->cargo_type != CT_MAIL) st->this_month_vehicles[5]++;
+	if ((v->subtype == 0) || (v->subtype == 2))
+	{
+		st->vehicles[STS_VEH_AIRCRAFT].this_month++;
+		if (st->months_counted == 0) st->months_counted = 1;
+	}
+	InvalidateWindow(WC_STATION_STATS, st->index);
+	
 	v->last_station_visited = v->u.air.targetairport;
 
 	/* Check if station was ever visited before */
@@ -1560,7 +1570,8 @@
 	// heliport/oilrig, etc --> no airplanes (HELICOPTERS_ONLY)
 	// runway busy or not allowed to use this airstation, circle
 	if (! (v->subtype == Airport->acc_planes ||
-			st->airport_tile == 0 || (st->owner != OWNER_NONE && st->owner != v->owner) )) {
+			st->airport_tile == 0 || (st->owner != OWNER_NONE &&
+			!(IsSisterCompany(st->owner, v->owner) || _patches.shared_stations)))) {
 
 		// {32,FLYING,NOTHING_block,37}, {32,LANDING,N,33}, {32,HELILANDING,N,41},
 		// if it is an airplane, look for LANDING, for helicopter HELILANDING
Index: npf.c
===================================================================
--- npf.c	(revision 2447)
+++ npf.c	(working copy)
@@ -8,6 +8,7 @@
 #include "station.h"
 #include "tile.h"
 #include "depot.h"
+#include "economy.h"
 
 AyStar _train_find_station;
 AyStar _train_find_depot;
@@ -73,6 +74,15 @@
 	{13,   5,    0xff, 0xff}
 };
 
+const byte _track_enterdir_to_trackdir[6][4] = {
+	{0,    0xff, 8,    0xff},
+	{0xff, 1,    0xff, 9},
+	{0xff, 2,    10,   0xff},
+	{3,    0xff, 0xff, 11},
+	{12,   4,    0xff, 0xff},
+	{0xff, 0xff, 5,    13}
+};
+
 const byte _track_direction_to_trackdir[6][8] = {
 	{0xff, 0,    0xff, 0xff, 0xff, 8,    0xff, 0xff},
 	{0xff, 0xff, 0xff, 1,    0xff, 0xff, 0xff, 9},
@@ -105,6 +115,8 @@
 	NPF_TILE_LENGTH, NPF_TILE_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH
 };
 
+bool IsEndOfLine(TileIndex tile, byte trackdir);
+
 uint NTPHash(uint key1, uint key2)
 {
 	/* This function uses the old hash, which is fixed on 10 bits (1024 buckets) */
@@ -159,6 +171,71 @@
 	return TILE_XY(tx,ty);
 };
 
+void NPFReservePBSPath(AyStar *as)
+{
+	NPFFoundTargetData* ftd = (NPFFoundTargetData*)as->user_path;
+	bool eolstuff = false;
+
+	if (ftd->best_trackdir == 0xFF)
+		return;
+
+	if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_EXIT) && IsEndOfLine(ftd->node.tile, ftd->node.direction) && !NPFGetFlag(&ftd->node, NPF_FLAG_SEEN_SIGNAL)) {
+		eolstuff = true;
+		NPFSetFlag(&ftd->node, NPF_FLAG_PBS_EXIT, true);
+		if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_TARGET_SEEN))
+			NPFSetFlag(&ftd->node, NPF_FLAG_PBS_RED, true);
+	}
+
+	if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_CHOICE)) {
+		NPFSetFlag(&ftd->node, NPF_FLAG_PBS_RED, false);
+	}
+
+	if (NPFGetFlag(&ftd->node, NPF_FLAG_PBS_EXIT) &&
+		  !NPFGetFlag(&ftd->node, NPF_FLAG_PBS_BLOCKED) &&
+		  (  ((as->user_data[NPF_PBS_MODE] & PBS_MODE_MASK) != PBS_MODE_GREEN) ||
+			   (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_RED))
+		  ) ) {
+		PathNode parent;
+		PathNode *curr = &parent;
+		PathNode *prev = NULL;
+		TileIndex start = INVALID_TILE;
+		byte trackdir = 0;
+
+		parent.node = ftd->node;
+		parent.parent = &ftd->path;
+
+		do {
+			if (!NPFGetFlag(&curr->node, NPF_FLAG_PBS_EXIT) || eolstuff) {
+				if ((PBSTileUnavail(curr->node.tile) & (1 << curr->node.direction))
+				&& !(PBSTileReserved(curr->node.tile) & (1 << (curr->node.direction & 7)))
+				&& (start != INVALID_TILE)) {
+					PBSClearPath(start, trackdir);
+					NPFSetFlag(&ftd->node, NPF_FLAG_PBS_BLOCKED, true);
+					DEBUG(pbs, 1) ("PBS: Self-crossing path!!!");
+					return;
+				};
+
+				PBSReserveTrack(curr->node.tile, (curr->node.direction & 7) );
+
+				if (prev != NULL && start == INVALID_TILE) {
+					PBSReserveTrack(prev->node.tile, (prev->node.direction & 7) );
+					start = prev->node.tile;
+					trackdir = _reverse_trackdir[prev->node.direction];
+				}
+			}
+
+			//if (IsTileType(parent->node.tile, MP_TUNNELBRIDGE) && (_map5[parent->node.tile] & 0xF0)==0 && (_map5[parent->node.tile] & 3) == _trackdir_to\_exitdir[parent->node.direction])
+//			if ((curr->parent != NULL) && IsTileType(curr->node.tile, MP_TUNNELBRIDGE) && (_map5[curr->node.tile] & 0xF0)==0)
+//						curr = curr->parent;
+
+			prev = curr;
+			curr = curr->parent;
+		} while (curr != NULL);
+	}
+
+}
+
+
 /* Calcs the heuristic to the target station or tile. For train stations, it
  * takes into account the direction of approach.
  */
@@ -180,15 +257,26 @@
 		/* Ships and trains can also go diagonal, so the minimum distance is shorter */
 		dist = DistanceTrack(from, to) * NPF_TILE_LENGTH;
 
-	if (dist < ftd->best_bird_dist) {
+	DEBUG(npf, 4)("Calculating H for: (%d, %d). Result: %d", TileX(current->tile), TileY(current->tile), dist);
+
+	if ((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE)
+	&&  (!NPFGetFlag(current , NPF_FLAG_SEEN_SIGNAL))
+	&&  (!IsEndOfLine(current->tile, current->direction)))
+		return dist;
+
+	if ((dist < ftd->best_bird_dist) ||
+		((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE) && !NPFGetFlag(current, NPF_FLAG_PBS_RED) && NPFGetFlag(&ftd->node, NPF_FLAG_PBS_RED))
+) {
 		ftd->best_bird_dist = dist;
 		ftd->best_trackdir = current->user_data[NPF_TRACKDIR_CHOICE];
+		ftd->path = parent->path;
+		ftd->node = *current;
+		//debug("new low tile: %x", ftd->node.tile);
 	}
-	DEBUG(npf, 4)("Calculating H for: (%d, %d). Result: %d", TileX(current->tile), TileY(current->tile), dist);
+
 	return dist;
 }
 
-
 /* Fills AyStarNode.user_data[NPF_TRACKDIRCHOICE] with the chosen direction to
  * get here, either getting it from the current choice or from the parent's
  * choice */
@@ -228,20 +316,25 @@
 	}
 }
 
+const byte _slope_dir_to_offs[4][2] = {
+	{ 0,  8},
+	{ 8, 15},
+	{15,  8},
+	{ 8,  0}	
+};
+
 uint NPFSlopeCost(AyStarNode* current) {
-	TileIndex next = current->tile + TileOffsByDir(_trackdir_to_exitdir[current->direction]);
+	byte exitdir = _trackdir_to_exitdir[current->direction];
+	byte enterdir = _trackdir_to_exitdir[_reverse_trackdir[current->direction]];
 	int x,y;
 	int8 z1,z2;
 
 	x = TileX(current->tile) * 16;
 	y = TileY(current->tile) * 16;
-	z1 = GetSlopeZ(x+8, y+8);
+	z1 = GetSlopeZ(x+_slope_dir_to_offs[enterdir][0], y+_slope_dir_to_offs[enterdir][1]);
+	z2 = GetSlopeZ(x+_slope_dir_to_offs[exitdir][0], y+_slope_dir_to_offs[exitdir][1]);
 
-	x = TileX(next) * 16;
-	y = TileY(next) * 16;
-	z2 = GetSlopeZ(x+8, y+8);
-
-	if ((z2 - z1) > 1) {
+	if ((z2 - z1) > 0) {
 		/* Slope up */
 		return _patches.npf_rail_slope_penalty;
 	}
@@ -371,6 +464,11 @@
 	}
 
 	/* Determine extra costs */
+	
+	/* Check for reserved tracks (PBS) */
+	if (((as->user_data[NPF_PBS_MODE]&PBS_MODE_MASK) != PBS_MODE_NONE) && !(NPFGetFlag(current, NPF_FLAG_PBS_EXIT)) && !(NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) && (PBSTileUnavail(tile) & (1<<trackdir))) {
+		NPFSetFlag(current, NPF_FLAG_PBS_BLOCKED, true);
+	};
 
 	/* Check for signals */
 	if (IsTileType(tile, MP_RAILWAY) && (_map5[tile] & 0xC0) == 0x40 && (_map3_lo[tile] & _signal_along_trackdir[trackdir]) != 0) {
@@ -387,6 +485,9 @@
 					cost += _patches.npf_rail_firstred_exit_penalty;
 				else
 					cost += _patches.npf_rail_firstred_penalty;
+
+				if (!(NPFGetFlag(current, NPF_FLAG_PBS_EXIT)) && !(NPFGetFlag(current, NPF_FLAG_PBS_RED)) && (NPFGetFlag(current, NPF_FLAG_PBS_CHOICE)))
+					NPFSetFlag(current, NPF_FLAG_PBS_RED, true);
 			}
 			/* Record the state of this signal */
 			NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, true);
@@ -394,9 +495,16 @@
 			/* Record the state of this signal */
 			NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, false);
 		}
+		
+		if (!NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL) && NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) {
+			cost += 1000;
+		}
+		if ((PBSIsPbsSignal(tile, trackdir)) && !NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL)) {
+			NPFSetFlag(current, NPF_FLAG_PBS_EXIT, true);
+		}
 		NPFSetFlag(current, NPF_FLAG_SEEN_SIGNAL, true);
 	}
-
+	
 	/* Penalise the tile if it is a target tile and the last signal was
 	 * red */
 	new_node.path.node = *current;
@@ -412,12 +520,25 @@
 	//TODO, with realistic acceleration, also the amount of straight track between
 	//      curves should be taken into account, as this affects the speed limit.
 
-	/* Check for reverse in depot */
-	if (IsTileDepotType(tile, TRANSPORT_RAIL) && !as->EndNodeCheck(as, &new_node)==AYSTAR_FOUND_END_NODE)
+
+	/* Check for depots */
+		if (IsTileDepotType(tile, TRANSPORT_RAIL)) {
 		/* Penalise any depot tile that is not the last tile in the path. This
 		 * _should_ penalise every occurence of reversing in a depot (and only
 		 * that) */
-		cost += _patches.npf_rail_depot_reverse_penalty;
+		if (!as->EndNodeCheck(as, &new_node)==AYSTAR_FOUND_END_NODE) 
+			cost += _patches.npf_rail_depot_reverse_penalty;
+		/* PBS stuff */
+		if (!NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL)) {
+			if (NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) {
+				cost += 1000;
+			}
+			if (PBSIsPbsSegment(tile, _trackdir_to_exitdir[_reverse_trackdir[trackdir]]*2+1)) {
+				NPFSetFlag(current, NPF_FLAG_PBS_EXIT, true);
+			}
+		}
+		NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, false);
+	}
 
 	/* Check for occupied track */
 	//TODO
@@ -449,8 +570,12 @@
 	 * is correct */
 	if (
 		(fstd->station_index == -1 && tile == fstd->dest_coords) || /* We've found the tile, or */
-		(IsTileType(tile, MP_STATION) && _map2[tile] == fstd->station_index) /* the station */
+		(IsTileType(tile, MP_STATION) && _map2[tile] == fstd->station_index) || /* the station */
+		(NPFGetFlag(node, NPF_FLAG_PBS_TARGET_SEEN))
 	) {
+		NPFSetFlag(&current->path.node, NPF_FLAG_PBS_TARGET_SEEN, true);
+		if ((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE) && !NPFGetFlag(node, NPF_FLAG_SEEN_SIGNAL) && !IsEndOfLine(node->tile, node->direction))
+			return AYSTAR_DONE;
 		return AYSTAR_FOUND_END_NODE;
 	} else {
 		return AYSTAR_DONE;
@@ -467,6 +592,7 @@
 	ftd->best_path_dist = current->g;
 	ftd->best_bird_dist = 0;
 	ftd->node = current->path.node;
+	ftd->path = current->path;
 }
 
 /**
@@ -511,6 +637,54 @@
 	return type;
 }
 
+bool IsEndOfLine(TileIndex tile, byte trackdir)
+{
+	byte exitdir = _trackdir_to_exitdir[trackdir];
+	TileIndex dst_tile;
+	uint32 ts;
+
+	// tunnel entrance?
+	if (IsTileType(tile, MP_TUNNELBRIDGE) && (_map5[tile] & 0xF0)==0 && (_map5[tile] & 3) == exitdir)
+		return false;
+
+	// depot
+	if (IsTileDepotType(tile, TRANSPORT_RAIL))
+		return false;
+
+	/* Calculate next tile */
+	dst_tile = tile + TileOffsByDir(exitdir);
+	// determine the track status on the next tile.
+	ts = GetTileTrackStatus(dst_tile, TRANSPORT_RAIL) & _trackdir_reaches_trackdirs[trackdir];
+
+	if ( (uint16)ts == 0) 
+		return true;
+
+	{
+		byte src_type = GetTileRailType(tile, trackdir);
+		byte dst_type = GetTileRailType(dst_tile, _trackdir_to_exitdir[trackdir]);
+		if (src_type != dst_type) {
+			return true;
+		}
+		if (GetTileOwner(tile) != GetTileOwner(dst_tile))
+			return true;
+
+		if (IsTileDepotType(dst_tile, TRANSPORT_RAIL) && (_trackdir_to_exitdir[trackdir] != _reverse_dir[GetDepotDirection(dst_tile, TRANSPORT_RAIL)]))
+			return true;
+
+		if (IsTileType(dst_tile, MP_RAILWAY) && (_map5[dst_tile]&0xC0) == 0x40 ) {
+			// the tile has a signal
+			byte signal_present = _map3_lo[dst_tile];
+			if (!(signal_present & _signal_along_trackdir[FindFirstBit2x64(ts)])) {
+				// if one way signal not pointing towards us, stop going in this direction.
+				if (signal_present & _signal_against_trackdir[FindFirstBit2x64(ts)])
+					return true;
+			}
+		}
+
+		return false;
+	}
+};
+
 /* Will just follow the results of GetTileTrackStatus concerning where we can
  * go and where not. Uses AyStar.user_data[NPF_TYPE] as the transport type and
  * an argument to GetTileTrackStatus. Will skip tunnels, meaning that the
@@ -530,6 +704,8 @@
 	aystar->num_neighbours = 0;
 	DEBUG(npf, 4)("Expanding: (%d, %d, %d) [%d]", TileX(src_tile), TileY(src_tile), src_trackdir, src_tile);
 
+	aystar->EndNodeCheck(aystar, current);
+
 	/* Find dest tile */
 	if (IsTileType(src_tile, MP_TUNNELBRIDGE) && (_map5[src_tile] & 0xF0)==0 && (_map5[src_tile] & 3) == src_exitdir) {
 		/* This is a tunnel. We know this tunnel is our type,
@@ -594,7 +770,7 @@
 		|| IsTileDepotType(dst_tile, TRANSPORT_WATER) /* Water depot tile */
 	) /* TODO: Crossings, tunnels and bridges are "public" now */
 		/* The above cases are "private" tiles, we need to check the owner */
-		if (!IsTileOwner(dst_tile, aystar->user_data[NPF_OWNER]))
+		if (!_patches.shared_tracks && !IsSisterCompany(GetTileOwner(dst_tile), aystar->user_data[NPF_OWNER]))
 			return;
 
 	/* Determine available tracks */
@@ -620,6 +796,13 @@
 	trackdirs &= _trackdir_reaches_trackdirs[src_trackdir];
 	if (_patches.forbid_90_deg && (type == TRANSPORT_RAIL || type == TRANSPORT_WATER)) /* Filter out trackdirs that would make 90 deg turns for trains */
 		trackdirs &= ~_trackdir_crosses_trackdirs[src_trackdir];
+
+	if (KillFirstBit2x64(trackdirs) != 0)
+		NPFSetFlag(&current->path.node, NPF_FLAG_PBS_CHOICE, true);
+
+	if (!(NPFGetFlag(&current->path.node, NPF_FLAG_PBS_EXIT)) && ((aystar->user_data[NPF_PBS_MODE]&PBS_MODE_MASK) == PBS_MODE_ANY))
+		trackdirs &= ~PBSTileUnavail(dst_tile);
+
 	DEBUG(npf,6)("After filtering: (%d, %d), possible trackdirs: %#x", TileX(dst_tile), TileY(dst_tile), trackdirs);
 
 	/* Enumerate possible track */
@@ -630,7 +813,7 @@
 		DEBUG(npf, 5)("Expanded into trackdir: %d, remaining trackdirs: %#x", dst_trackdir, trackdirs);
 
 		/* Check for oneway signal against us */
-		if (IsTileType(dst_tile, MP_RAILWAY) && (_map5[dst_tile]&0xC0) == 0x40) {
+		if (IsTileType(dst_tile, MP_RAILWAY) && (_map5[dst_tile]&0xC0) == 0x40 ) {
 			// the tile has a signal
 			byte signal_present = _map3_lo[dst_tile];
 			if (!(signal_present & _signal_along_trackdir[dst_trackdir])) {
@@ -663,7 +846,7 @@
  * multiple targets that are spread around, we should perform a breadth first
  * search by specifiying CalcZero as our heuristic.
  */
-NPFFoundTargetData NPFRouteInternal(AyStarNode* start1, AyStarNode* start2, NPFFindStationOrTileData* target, AyStar_EndNodeCheck target_proc, AyStar_CalculateH heuristic_proc, TransportType type, Owner owner, uint reverse_penalty) {
+NPFFoundTargetData NPFRouteInternal(AyStarNode* start1, AyStarNode* start2, NPFFindStationOrTileData* target, AyStar_EndNodeCheck target_proc, AyStar_CalculateH heuristic_proc, TransportType type, Owner owner, uint reverse_penalty, byte pbs_mode) {
 	int r;
 	NPFFoundTargetData result;
 
@@ -681,6 +864,11 @@
 	else
 		assert(0);
 
+	if (pbs_mode != PBS_MODE_NONE)
+		_npf_aystar.BeforeExit = NPFReservePBSPath;
+	else
+		_npf_aystar.BeforeExit = NULL;
+
 	/* Initialize Start Node(s) */
 	start1->user_data[NPF_TRACKDIR_CHOICE] = 0xff;
 	start1->user_data[NPF_NODE_FLAGS] = 0;
@@ -704,6 +892,7 @@
 	/* Initialize user_data */
 	_npf_aystar.user_data[NPF_TYPE] = type;
 	_npf_aystar.user_data[NPF_OWNER] = owner;
+	_npf_aystar.user_data[NPF_PBS_MODE] = pbs_mode;
 
 	/* GO! */
 	r = AyStarMain_Main(&_npf_aystar);
@@ -721,7 +910,7 @@
 	return result;
 }
 
-NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, byte trackdir1, TileIndex tile2, byte trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner) {
+NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, byte trackdir1, TileIndex tile2, byte trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode) {
 	AyStarNode start1;
 	AyStarNode start2;
 
@@ -734,11 +923,21 @@
 	start2.direction = trackdir2;
 	start2.user_data[NPF_TRACKDIR_CHOICE] = 0xff;
 
-	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), target, NPFFindStationOrTile, NPFCalcStationOrTileHeuristic, type, owner, 0);
+	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), target, NPFFindStationOrTile, NPFCalcStationOrTileHeuristic, type, owner, 0, pbs_mode);
 }
 
-NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, byte trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner) {
-	return NPFRouteToStationOrTileTwoWay(tile, trackdir, INVALID_TILE, 0, target, type, owner);
+NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, byte trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode) {
+	AyStarNode start;
+
+	assert(tile != 0);
+
+	start.tile = tile;
+	start.direction = trackdir;
+	/* We set this in case the target is also the start tile, we will just
+	 * return a not found then */
+	start.user_data[NPF_TRACKDIR_CHOICE] = 0xff;
+
+	return NPFRouteToStationOrTileTwoWay(tile, trackdir, INVALID_TILE, 0, target, type, owner, pbs_mode);
 }
 
 NPFFoundTargetData NPFRouteToDepotBreadthFirstTwoWay(TileIndex tile1, byte trackdir1, TileIndex tile2, byte trackdir2, TransportType type, Owner owner, uint reverse_penalty) {
@@ -756,7 +955,7 @@
 
 	/* perform a breadth first search. Target is NULL,
 	 * since we are just looking for any depot...*/
-	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), NULL, NPFFindDepot, NPFCalcZero, type, owner, reverse_penalty);
+	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), NULL, NPFFindDepot, NPFCalcZero, type, owner, reverse_penalty, PBS_MODE_NONE);
 }
 
 NPFFoundTargetData NPFRouteToDepotBreadthFirst(TileIndex tile, byte trackdir, TransportType type, Owner owner) {
@@ -786,7 +985,7 @@
 	FOR_ALL_DEPOTS(depot) {
 		/* Check if this is really a valid depot, it is of the needed type and
 		 * owner */
-		if (IsValidDepot(depot) && IsTileDepotType(depot->xy, type) && IsTileOwner(depot->xy, owner))
+		if (IsValidDepot(depot) && IsTileDepotType(depot->xy, type) && (_patches.shared_tracks || IsSisterCompany(GetTileOwner(depot->xy),owner)))
 			/* If so, let's add it to the queue, sorted by distance */
 			depots.push(&depots, depot, DistanceManhattan(tile, depot->xy));
 	}
@@ -807,6 +1006,8 @@
 	else
 		assert(0);
 
+	_npf_aystar.BeforeExit = NULL;
+
 	/* Initialize target */
 	target.station_index = -1; /* We will initialize dest_coords inside the loop below */
 	_npf_aystar.user_target = &target;
@@ -814,6 +1015,7 @@
 	/* Initialize user_data */
 	_npf_aystar.user_data[NPF_TYPE] = type;
 	_npf_aystar.user_data[NPF_OWNER] = owner;
+	_npf_aystar.user_data[NPF_PBS_MODE] = PBS_MODE_NONE;
 
 	/* Initialize Start Node */
 	start.tile = tile;
Index: vehicle_gui.c
===================================================================
--- vehicle_gui.c	(revision 2447)
+++ vehicle_gui.c	(working copy)
@@ -10,6 +10,8 @@
 #include "gui.h"
 #include "command.h"
 #include "gfx.h"
+#include "station.h"
+#include "waypoint.h"
 
 VehicleSortListingTypeFunctions * const _vehicle_sorter[] = {
 	&VehicleUnsortedSorter,
@@ -1061,3 +1063,90 @@
 {
 	memset(&_sorting, 0, sizeof(_sorting));
 }
+
+void BuildVehicleListMasked(vehiclelist_d *vl, DisplayListOptions *listopt, int owner)
+{
+	int subtype = (HASBIT(listopt->veh_type_mask, 1 << VEH_Aircraft)) ? 2 : TS_Front_Engine;
+	int n = 0;
+	int i;
+	uint32 cmask;
+
+	if (!(vl->flags & VL_REBUILD)) return;
+
+	/* Create array for sorting */
+	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
+	if (_vehicle_sort == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+
+	DEBUG(misc, 1) ("Building vehicle list for player %d station at %d...",
+		owner, listopt->xy);
+	
+	if (listopt->xy < MapSize()) {
+		const Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->veh_type_mask, v->type) && v->subtype <= subtype)
+			{
+				const Vehicle *u = v;
+				cmask = HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], v->cargo_type);
+				while (u->next != NULL) {
+					cmask |= HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], u->cargo_type);
+					u = u->next;
+				}
+				if (listopt->cargo_mask & cmask) {
+					const Order *order;
+
+					FOR_VEHICLE_ORDERS(v, order) {
+						switch (order->type)
+						{
+							case OT_GOTO_STATION:
+								if (GetStation(order->station)->xy == listopt->xy) {
+									_vehicle_sort[n].index = v->index;
+									_vehicle_sort[n].owner = v->owner;
+									++n;
+									break;
+								} break;
+							case OT_GOTO_WAYPOINT:
+								if (GetWaypoint(order->station)->xy == listopt->xy) {
+									_vehicle_sort[n].index = v->index;
+									_vehicle_sort[n].owner = v->owner;
+									++n;
+									break;
+								} break;
+							default: break;
+						}
+					}
+				}
+			}
+		}
+	} else {
+		Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->veh_type_mask, v->type) && v->subtype <= subtype && v->owner == owner)
+			{
+				Vehicle *u = v;
+				cmask = HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], v->cargo_type);
+				u = v; // search all cargotypes of consist
+				while (u->next != NULL) {
+					cmask |= HASBIT(_landscape_global_cargo_mask[_opt_ptr->landscape], u->cargo_type);
+					u = u->next;
+				}
+				if (listopt->cargo_mask & cmask) {
+					_vehicle_sort[n].index = v->index;
+					_vehicle_sort[n].owner = v->owner;
+					++n;
+				}
+			}
+		}
+	}
+
+	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
+	if (n!=0 && vl->sort_list == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+	vl->list_length = n;
+
+	for (i = 0; i < n; ++i)
+		vl->sort_list[i] = _vehicle_sort[i];
+
+	vl->flags &= ~VL_REBUILD;
+	vl->flags |= VL_RESORT;
+}
Index: debug.c
===================================================================
--- debug.c	(revision 2447)
+++ debug.c	(working copy)
@@ -14,6 +14,7 @@
 int _debug_net_level;
 int _debug_spritecache_level;
 int _debug_oldloader_level;
+int _debug_pbs_level;
 int _debug_npf_level;
 
 
@@ -44,6 +45,7 @@
 	DEBUG_LEVEL(net),
 	DEBUG_LEVEL(spritecache),
 	DEBUG_LEVEL(oldloader),
+	DEBUG_LEVEL(pbs),
 	DEBUG_LEVEL(npf)
 	};
 #undef DEBUG_LEVEL
Index: npf.h
===================================================================
--- npf.h	(revision 2447)
+++ npf.h	(working copy)
@@ -6,6 +6,7 @@
 #include "openttd.h"
 #include "aystar.h"
 #include "vehicle.h"
+#include "pbs.h"
 
 //mowing grass
 enum {
@@ -35,16 +36,23 @@
 enum { /* Indices into AyStar.userdata[] */
 	NPF_TYPE = 0, /* Contains a TransportTypes value */
 	NPF_OWNER, /* Contains an Owner value */
+	NPF_PBS_MODE, /* Contains the pbs mode, see pbs.h */
 };
 
 enum { /* Indices into AyStarNode.userdata[] */
 	NPF_TRACKDIR_CHOICE = 0, /* The trackdir chosen to get here */
 	NPF_NODE_FLAGS,
 };
+
 typedef enum { /* Flags for AyStarNode.userdata[NPF_NODE_FLAGS]. Use NPFGetBit() and NPFGetBit() to use them. */
 	NPF_FLAG_SEEN_SIGNAL, /* Used to mark that a signal was seen on the way, for rail only */
 	NPF_FLAG_REVERSE, /* Used to mark that this node was reached from the second start node, if applicable */
 	NPF_FLAG_LAST_SIGNAL_RED, /* Used to mark that the last signal on this path was red */
+	NPF_FLAG_PBS_EXIT, /* Used to mark tracks inside a pbs block, for rail only, for the end node, this is set when the path found goes through a pbs block */
+	NPF_FLAG_PBS_BLOCKED, /* Used to mark that this path crosses another pbs path */
+	NPF_FLAG_PBS_RED, /* Used to mark that this path goes through a red exit-pbs signal */
+	NPF_FLAG_PBS_CHOICE, /*  */
+	NPF_FLAG_PBS_TARGET_SEEN, /*  */
 } NPFNodeFlag;
 
 typedef struct NPFFoundTargetData { /* Meant to be stored in AyStar.userpath */
@@ -52,6 +60,7 @@
 	uint best_path_dist; /* The shortest path. Is (uint)-1 if no path is found */
 	byte best_trackdir; /* The trackdir that leads to the shortest path/closest birds dist */
 	AyStarNode node; /* The node within the target the search led us to */
+	PathNode path;
 } NPFFoundTargetData;
 
 /* These functions below are _not_ re-entrant, in favor of speed! */
@@ -59,11 +68,11 @@
 /* Will search from the given tile and direction, for a route to the given
  * station for the given transport type. See the declaration of
  * NPFFoundTargetData above for the meaning of the result. */
-NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, byte trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner);
+NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, byte trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode);
 /* Will search as above, but with two start nodes, the second being the
  * reverse. Look at the NPF_FLAG_REVERSE flag in the result node to see which
  * direction was taken (NPFGetBit(result.node, NPF_FLAG_REVERSE)) */
-NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, byte trackdir1, TileIndex tile2, byte trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner);
+NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, byte trackdir1, TileIndex tile2, byte trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode);
 
 /* Will search a route to the closest depot. */
 
@@ -158,6 +167,12 @@
 const byte _track_exitdir_to_trackdir[6][4];
 
 /**
+ * Maps a track and an (4-way) dir to the trackdir that represents the track
+ * with the entry in the given direction.
+ */
+const byte _track_enterdir_to_trackdir[6][4];
+
+/**
  * Maps a track and a full (8-way) direction to the trackdir that represents
  * the track running in the given direction.
  */
Index: vehicle_gui.h
===================================================================
--- vehicle_gui.h	(revision 2447)
+++ vehicle_gui.h	(working copy)
@@ -15,6 +15,7 @@
 
 void BuildVehicleList(struct vehiclelist_d *vl, int type, int owner, int station);
 void SortVehicleList(struct vehiclelist_d *vl);
+void BuildVehicleListMasked(struct vehiclelist_d *vl, struct DisplayListOptions *listopt, int owner);
 
 int CDECL GeneralOwnerSorter(const void *a, const void *b);
 VARDEF uint32	_internal_name_sorter_id;	// internal StringID for default vehicle-names
Index: debug.h
===================================================================
--- debug.h	(revision 2447)
+++ debug.h	(working copy)
@@ -14,6 +14,7 @@
 	extern int _debug_net_level;
 	extern int _debug_spritecache_level;
 	extern int _debug_oldloader_level;
+	extern int _debug_pbs_level;
 	extern int _debug_npf_level;
 #endif
 
Index: misc_gui.c
===================================================================
--- misc_gui.c	(revision 2447)
+++ misc_gui.c	(working copy)
@@ -1690,14 +1690,15 @@
 	{CE_BOOL, 0, STR_CHEAT_SETUP_PROD,			&_cheats.setup_prod.value,			&_cheats.setup_prod.been_used,			NULL,											0, 0, 0},
 	{CE_UINT8, 0, STR_CHEAT_SWITCH_CLIMATE, &_opt.landscape, 								&_cheats.switch_climate.been_used,	&ClickChangeClimateCheat,-1, 4, 1},
 	{CE_UINT8, 0, STR_CHEAT_CHANGE_DATE,		&_cur_year,											&_cheats.change_date.been_used,			&ClickChangeDateCheat,	 -1, 1, 1},
+	{CE_BOOL, 0, STR_CHEAT_RESET_STATION,			&_cheats.reset_station.value,			&_cheats.reset_station.been_used,			NULL,											0, 0, 0},
 };
 
 
 static const Widget _cheat_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   399,     0,    13, STR_CHEATS,	STR_018C_WINDOW_TITLE_DRAG_THIS},
-{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_NULL},
-{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_CHEATS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_CHEATS_TIP},
 {   WIDGETS_END},
 };
 
@@ -1832,7 +1833,7 @@
 	}
 }
 static const WindowDesc _cheats_desc = {
-	240, 22, 400, 160,
+	240, 22, 400, 174,
 	WC_CHEATS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
 	_cheat_widgets,
Index: lang/french.txt
===================================================================
--- lang/french.txt	(revision 2447)
+++ lang/french.txt	(working copy)
@@ -2801,6 +2801,73 @@
 STR_SHORT_DATE                                                  :{WHITE}{DATE_TINY}
 STR_SIGN_LIST_CAPTION                                           :{WHITE}Liste des panneaux - {COMMA16} panneaux
 
+############ subsidiaries strings
+STR_SUBSIDIARIES                                                :{BLACK}Filiales
+STR_SUBSIDIARIES_MANAGEMENT                                     :{BLACK}gérer vos filiales
+STR_YOUR_SUBSIDIARIES                                           :{WHITE}Vos filiales
+STR_SUBSIDIARIES_ADMINISTRATE                                   :{BLACK}Administrer
+STR_SUBSIDIARIES_SEND_MONEY                                     :{BLACK}Envoyer Argent
+STR_SUBSIDIARIES_REQUEST_MONEY                                  :{BLACK}Recevoir Argent
+STR_SUBSIDIARIES_MERGER                                         :{BLACK}Fusionner
+STR_SUBSIDIARIES_ADMINISTRATE_E                                 :{BLACK}Administrer (Jouer avec) la filiale sélectionée
+STR_SUBSIDIARIES_SEND_MONEY_E                                   :{BLACK}Envoyer de l'argnet à la filiale, la banque prélève 6% de frais sur la transaction 
+STR_SUBSIDIARIES_REQUEST_MONEY_E                                :{BLACK}Recevoir de l'argent de la filiale, la banque prélève 6% de frais sur la transaction 
+STR_SUBSIDIARIES_MERGER_E                                       :{BLACK}Effectue une fusion complète en la filiale sélectionée et votre compagnie
+STR_SUBSIDIARY_OF                                               :{WHITE}(Filiale de {STRING})
+STR_SUBSIDIARY_CREATE                                           :{BLACK}Créer
+STR_SUBSIDIARY_CREATE_E                                         :{BLACK}Crée une nouvelle filiale
+STR_SUBSIDIARY_ADD_CASH                                         :{BLACK}ajouter {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_ADD_CASH_E                                       :{BLACK}Augmente le montant transféré
+STR_SUBSIDIARY_SUB_CASH                                         :{BLACK}Soustraire {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_SUB_CASH_E                                       :{BLACK}Diminue le montant transféré
+STR_SUBSIDIARY_SEND_TO                                          :{WHITE}Envoyer argent à {STRING}
+STR_SUBSIDIARY_REQUEST_FROM                                     :{WHITE}Recevoir argent de {STRING}
+STR_SUBSIDIARY_SEND_AMOUNT                                      :{WHITE}Montant à envoyer:
+STR_SUBSIDIARY_REQUEST_AMOUNT                                   :{WHITE}Montant prélevé:
+STR_SUBSIDIARY_AMOUNT_SEND                                      :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_GET                                       :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_TARGET                                    :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_GET_ERROR                                        :{WHITE}Impossible de recevoir ce montant...
+STR_SUBSIDIARY_SEND_ERROR                                       :{WHITE}Impossible d'envoyer ce montant...
+STR_SUBSIDIARY_PLAYER_ERROR                                     :{WHITE}Impossible de créer la filiale...
+STR_SUBSIDIARY_ASK_MERGER                                       :{YELLOW}Voulez vous fusionner {STRING} avec {STRING}?
+STR_SUBSIDIARY_ASK_MERGER_TITLE                                 :{WHITE}Fusionner
+STR_SUBSIDIARY_TARGET_HAS                                       :{WHITE}Equilibre bancaire de la filiale:
+STR_SUBSIDIARY_TOGGLE                                           :{BLACK}Toggle this subsidiary
+STR_SUBSIDIARY_CASH_REQUEST                                     :{WHITE}Prélèvement demandé
+STR_SUBSIDIARY_CASH_REQUESTED                                   :{WHITE}{STRING} demande {CURRENCY64}. Voulez vous lui envoyer ce montant?
+STR_SUBSIDIARY_CASH_REQUEST_DENIED                              :{WHITE}Votre prélèvement est refusé
+STR_SUBSIDIARY_CASH_REQUEST_GRANTED                             :{WHITE}Votre prélèvement est accepté
+STR_SUBSIDIARY_SELL_SHARE_TITLE                                 :{WHITE}Requete
+STR_SUBSIDIARY_SELL_SHARE                                       :{WHITE}{STRING} veut acheter 25% de vos actions acceptez vous de lui vendre ?
+STR_SUBSIDIARY_SELL_SHARE_GRANTED                               :{WHITE}Votre offre est acceptée
+STR_SUBSIDIARY_SELL_SHARE_DENIED                                :{WHITE}Votre offre est refusée
+STR_TOO_MANY_PLAYERS                                            :{WHITE}Trop de joueurs
+
+STR_CONFIG_PATCHES_SUBSIDIARIES                                 :{LTBLUE}Active la gestion des filiales: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_ST_TAX                                :{LTBLUE}Taxe sur les véhicules s'arrêtant dans une station de vos filiales: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_SUB_CONFIG        :{LTBLUE}Taxe de base pour l'utilisation des voies de vos filiales: {ORANGE}{STRING} per tile
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_CONFIG            :{LTBLUE}Autorise le partage des voies pour tout le monde: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_OTHER_CONFIG      :{LTBLUE}Taxe de base pour l'utilisation des voies partagées: {ORANGE}{STRING} per tile
+STR_CONFIG_PATCHES_SUBS_ALLOW_REMOVE                            :{LTBLUE}Autorise les filiales à supprimer les routes/voies de tout le groupe: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_COOP                                         :{BLACK}Coopération
+STR_CONFIG_PATCHES_SHARED_STATIONS                              :{LTBLUE}Autorise le partage des stations pour tous: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_STATIONS_SUBS_CARGOTAX                :{LTBLUE}Base tax for subsidiaries cargo pickup: {ORANGE}{STRING} per unit
+STR_CONFIG_PATCHES_SHARED_STATIONS_OTHERS_CARGOTAX              :{LTBLUE}Base tax for cargo pickup: {ORANGE}{STRING} per unit
+STR_CONFIG_PATCHES_SHARED_ST_TAX_OTHERS                         :{LTBLUE}Taxe sur les véhicules s'arretant dans la station d'une autre companie: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_YEARS_OF_PROTECTION                          :{LTBLUE}Protection des actions pendant:{ORANGE}{STRING} année(s)
+
+STR_703A_TRAIN_SUB                                              :{WHITE}{COMMA16} train sur {COMMA16} ({COMMA16}%)
+STR_703B_TRAINS_SUB                                             :{WHITE}{COMMA16} trains sur {COMMA16} ({COMMA16}%)
+STR_703C_ROAD_VEHICLE_SUB                                       :{WHITE}{COMMA16} véhicule routier sur {COMMA16} ({COMMA16}%)
+STR_703D_ROAD_VEHICLES_SUB                                      :{WHITE}{COMMA16} véhicules routiers sur {COMMA16} ({COMMA16}%)
+STR_703E_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} aéroplane sur {COMMA16} ({COMMA16}%)
+STR_703F_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} aéroplanes sur {COMMA16} ({COMMA16}%)
+STR_7040_SHIP_SUB                                               :{WHITE}{COMMA16} navire sur {COMMA16} ({COMMA16}%)
+STR_7041_SHIPS_SUB                                              :{WHITE}{COMMA16} navires sur {COMMA16} ({COMMA16}%)
+############ end of subsidiaries strings
+
+
 ############ Lists rail types
 
 STR_RAIL_VEHICLES                                               :Véhicules sur rail
Index: lang/german.txt
===================================================================
--- lang/german.txt	(revision 2447)
+++ lang/german.txt	(working copy)
@@ -2799,10 +2799,75 @@
 STR_REPLACE_HELP_RAILTYPE                                       :{BLACK}Wähle einen Schienentyp für den Loks ersetzt werden sollen
 STR_REPLACE_HELP_REPLACE_INFO_TAB                               :{BLACK}Hier wird angezeigt, gegen welches Fahrzeug das auf der linken Seite gewählte ersetzt wird
 STR_REPLACE_HELP                                                :{BLACK}Dieses Feature ermöglicht es, einen Fahrzeugtyp auszuwählen und ihn durch einen anderen ersetzen zu lassen. Dies geschieht automatisch, wenn das Fahrzeug regulär das Depot besucht.
-
 STR_SHORT_DATE                                                  :{WHITE}{DATE_TINY}
 STR_SIGN_LIST_CAPTION                                           :{WHITE}Schilderliste - {COMMA16} Schild(er)
 
+############ Subsidiaries strings
+STR_SUBSIDIARIES                                                :{BLACK}Tochterfirmen
+STR_SUBSIDIARIES_MANAGEMENT                                     :{BLACK}verwalte Deine Tochterfirmen
+STR_YOUR_SUBSIDIARIES                                           :{WHITE}Deine Tochterfirmen
+STR_SUBSIDIARIES_ADMINISTRATE			                :{BLACK}Verwalten
+STR_SUBSIDIARIES_SEND_MONEY			                :{BLACK}Überweise Geld
+STR_SUBSIDIARIES_REQUEST_MONEY			                :{BLACK}Fordere Geld
+STR_SUBSIDIARIES_MERGER			                        :{BLACK}Fusionieren
+STR_SUBSIDIARIES_ADMINISTRATE_E			                :{BLACK}Verwalte (spielen als) die ausgewählte Firma
+STR_SUBSIDIARIES_SEND_MONEY_E			                :{BLACK}Überweise Geld an die ausgewählte Firma, die Bank kassiert 6 % Überweisungsgebühr
+STR_SUBSIDIARIES_REQUEST_MONEY_E			        :{BLACK} Überweise Geld von der ausgewählten Firma, die Bank kassiert 6 % Überweisungsgebühr
+STR_SUBSIDIARIES_MERGER_E			                :{BLACK}Vollziehe eine Fusion mit der ausgewählten Tochterfirma
+STR_SUBSIDIARY_OF			                        :{WHITE}(Tochterfirma von {STRING})
+STR_SUBSIDIARY_CREATE			                        :{BLACK}Erstellen
+STR_SUBSIDIARY_CREATE_E			                        :{BLACK}Erstelle eine neue Tochterfirma
+STR_SUBSIDIARY_ADD_CASH			                        :{BLACK}Hinzufügen {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_ADD_CASH_E			                :{BLACK}Erhöhe den zu überweisenden Betrag
+STR_SUBSIDIARY_SUB_CASH			                        :{BLACK}Abziehen {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_SUB_CASH_E			                :{BLACK}Vermindere den zu überweisenden Betrag
+STR_SUBSIDIARY_SEND_TO                                          :{WHITE}Sende Geld an {STRING}
+STR_SUBSIDIARY_REQUEST_FROM                                     :{WHITE}Fordere Geld an von {STRING}
+STR_SUBSIDIARY_SEND_AMOUNT                                      :{WHITE}Betrag zum Überweisen:
+STR_SUBSIDIARY_REQUEST_AMOUNT                                   :{WHITE}Betrag der an Dich überwiesen wird:
+STR_SUBSIDIARY_AMOUNT_SEND                                      :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_GET                                       :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_TARGET                                    :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_GET_ERROR                                        :{WHITE}Unmöglich diesen Betrag abzufordern...
+STR_SUBSIDIARY_SEND_ERROR                                       :{WHITE}Unmöglich diesen Betrag zu überweisen...
+STR_SUBSIDIARY_PLAYER_ERROR                                     :{WHITE}Kann keine Tochterfirma eröffnen...
+STR_SUBSIDIARY_ASK_MERGER                                       :{YELLOW}Bist Du sicher daß {STRING} fusionieren soll mit {STRING}?
+STR_SUBSIDIARY_ASK_MERGER_TITLE                                 :{WHITE}Fusion ausführen
+STR_SUBSIDIARY_TARGET_HAS                                       :{WHITE}Derzeitiges Bankguthaben der ausgewählten Tochterfirma:
+STR_SUBSIDIARY_TOGGLE                                           :{BLACK}Erpresse diese Tochterfirma
+STR_SUBSIDIARY_CASH_REQUEST                                     :{WHITE}Ankommende Geldforderung
+STR_SUBSIDIARY_CASH_REQUESTED                                   :{WHITE}{STRING} Angefordert {CURRENCY64}. Aktzeptieren Sie die Überweisung?
+STR_SUBSIDIARY_CASH_REQUEST_DENIED                              :{WHITE}Überweisung wurde abgelehnt
+STR_SUBSIDIARY_CASH_REQUEST_GRANTED                             :{WHITE}Überweisung wurde angenommen
+STR_SUBSIDIARY_SELL_SHARE_TITLE                                 :{WHITE}Anfrage
+STR_SUBSIDIARY_SELL_SHARE                                       :{WHITE}{STRING} möchte 25% Ihrer Aktien kaufen. Wollen Sie die Aktien verkaufen?
+STR_SUBSIDIARY_SELL_SHARE_GRANTED                               :{WHITE}Angebot angemommen
+STR_SUBSIDIARY_SELL_SHARE_DENIED                                :{WHITE}Angebot abgelehnt
+STR_TOO_MANY_PLAYERS                                            :{WHITE}Zu viele Spieler
+
+STR_CONFIG_PATCHES_SUBSIDIARIES                                 :{LTBLUE}Ermögliche Tochterfirmen: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_ST_TAX                                :{LTBLUE}Gebühr für das Benutzen der Stationen: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_SUB_CONFIG        :{LTBLUE}Gebühr für das Nutzen der Schienen: {ORANGE}{STRING} per tile
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_CONFIG            :{LTBLUE}Erlaube die Schienennutzung für jeden: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_OTHER_CONFIG      :{LTBLUE}Gebühr für FREMDE Stations-Nutzung: {ORANGE}{STRING} per tile
+STR_CONFIG_PATCHES_SUBS_ALLOW_REMOVE                            :{LTBLUE}Tochterfrinem dürfen Schienen/Strassen entfernen: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_COOP                                         :{BLACK}Cooperation
+STR_CONFIG_PATCHES_SHARED_STATIONS                              :{LTBLUE}Erlaube die Nutzung der Bahnhöfe durch alle: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_STATIONS_SUBS_CARGOTAX                :{LTBLUE}Gebühr für das Aufnehmen von Gütern(Töchter): {ORANGE}{STRING} per unit
+STR_CONFIG_PATCHES_SHARED_STATIONS_OTHERS_CARGOTAX              :{LTBLUE}Gebühr für das Aufnehmen von Gütern(Fremde): {ORANGE}{STRING} per unit
+STR_CONFIG_PATCHES_SHARED_ST_TAX_OTHERS                         :{LTBLUE}Gebühr für das Halten in fremden Stationen: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_YEARS_OF_PROTECTION                          :{LTBLUE}Jahre Aktienschutz:{ORANGE}{STRING} Jahr(e)
+
+STR_703A_TRAIN_SUB                                              :{WHITE}{COMMA16} Zug von {COMMA16} ({COMMA16}%)
+STR_703B_TRAINS_SUB                                             :{WHITE}{COMMA16} Züge von {COMMA16} ({COMMA16}%)
+STR_703C_ROAD_VEHICLE_SUB                                       :{WHITE}{COMMA16} Strassenfahrzeug von {COMMA16} ({COMMA16}%)
+STR_703D_ROAD_VEHICLES_SUB                                      :{WHITE}{COMMA16} Strassenfahrzeuge von {COMMA16} ({COMMA16}%)
+STR_703E_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} Flugzeug von {COMMA16} ({COMMA16}%)
+STR_703F_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} Flugzeuge von {COMMA16} ({COMMA16}%)
+STR_7040_SHIP_SUB                                               :{WHITE}{COMMA16} Schiff von {COMMA16} ({COMMA16}%)
+STR_7041_SHIPS_SUB                                              :{WHITE}{COMMA16} Schiffe von {COMMA16} ({COMMA16}%)
+################### end of subs strings
+
 ############ Lists rail types
 
 STR_RAIL_VEHICLES                                               :Eisenbahn
Index: lang/hungarian.txt
===================================================================
--- lang/hungarian.txt	(revision 2447)
+++ lang/hungarian.txt	(working copy)
@@ -2803,6 +2803,72 @@
 STR_SHORT_DATE                                                  :{WHITE}{DATE_TINY}
 STR_SIGN_LIST_CAPTION                                           :{WHITE}Feliratok listája ({COMMA16} db)
 
+############ Subsidiairies strings
+STR_SUBSIDIARIES                                                :{BLACK}Leányvállalatok
+STR_SUBSIDIARIES_MANAGEMENT                                     :{BLACK}Leányvállalataid irányítása
+STR_YOUR_SUBSIDIARIES                                           :{WHITE}Leányvállalataid
+STR_SUBSIDIARIES_ADMINISTRATE                                   :{BLACK}Irányít
+STR_SUBSIDIARIES_SEND_MONEY                                     :{BLACK}Pénz küldése
+STR_SUBSIDIARIES_REQUEST_MONEY                                  :{BLACK}Pénz fogadása
+STR_SUBSIDIARIES_MERGER                                         :{BLACK}Egyesítés
+STR_SUBSIDIARIES_ADMINISTRATE_E                                 :{BLACK}A kiválasztott leányvállalat irányítása
+STR_SUBSIDIARIES_SEND_MONEY_E                                   :{BLACK}Pénz küldése a kiválasztott leányvállalatnak, a bank 6% kezelési költséget számol fel.
+STR_SUBSIDIARIES_REQUEST_MONEY_E                                :{BLACK}Pénz fogadása a kiválasztott leányvállalattól, a bank 6% kezelési költséget számol fel.
+STR_SUBSIDIARIES_MERGER_E                                       :{BLACK}A jelenlegi és a kiválasztott leányvállalatok egyesítése
+STR_SUBSIDIARY_OF                                               :{WHITE}({STRING} leányvállalata)
+STR_SUBSIDIARY_CREATE                                           :{BLACK}Alapít
+STR_SUBSIDIARY_CREATE_E                                         :{BLACK}Új leányvállalatot alapít a semmibõl
+STR_SUBSIDIARY_ADD_CASH                                         :{BLACK}{SKIP}{SKIP}{SKIP}{CURRENCY64} hozzáadása
+STR_SUBSIDIARY_ADD_CASH_E                                       :{BLACK}Az átviteli összeg emelése
+STR_SUBSIDIARY_SUB_CASH                                         :{BLACK}{SKIP}{SKIP}{SKIP}{CURRENCY64} elvítele
+STR_SUBSIDIARY_SUB_CASH_E                                       :{BLACK}Az átviteli összeg csökkentése
+STR_SUBSIDIARY_SEND_TO                                          :{WHITE}Pénz küldése {STRING} cégnek
+STR_SUBSIDIARY_REQUEST_FROM                                     :{WHITE}Pénz kérése {STRING} cégtõl
+STR_SUBSIDIARY_SEND_AMOUNT                                      :{WHITE}Az elküldendõ összeg:
+STR_SUBSIDIARY_REQUEST_AMOUNT                                   :{WHITE}A kért összeg:
+STR_SUBSIDIARY_AMOUNT_SEND                                      :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_GET                                       :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_TARGET                                    :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_GET_ERROR                                        :{WHITE}Lehetetlen ennyit kapni...
+STR_SUBSIDIARY_SEND_ERROR                                       :{WHITE}Lehetetlen ennyit küldeni...
+STR_SUBSIDIARY_PLAYER_ERROR                                     :{WHITE}Nem lehet leányvállalatot alapítani...
+STR_SUBSIDIARY_ASK_MERGER                                       :{YELLOW}Biztos hogy {STRING} egyesüljön {STRING} cégbe?
+STR_SUBSIDIARY_ASK_MERGER_TITLE                                 :{WHITE}Egyesítés
+STR_SUBSIDIARY_TARGET_HAS                                       :{WHITE}A leányvállalat jelenlegi banki tartozása:
+STR_SUBSIDIARY_TOGGLE                                           :{BLACK}Átkapcsol erre a leányvállalatra
+STR_SUBSIDIARY_CASH_REQUEST                                     :{WHITE}Bejövõ összeg kérelem
+STR_SUBSIDIARY_CASH_REQUESTED                                   :{WHITE}{STRING} {CURRENCY64} összeget kér. Elküldöd neki?
+STR_SUBSIDIARY_CASH_REQUEST_DENIED                              :{WHITE}A pénzkérésed elutasították
+STR_SUBSIDIARY_CASH_REQUEST_GRANTED                             :{WHITE}A pénzkérésed elfogadták
+STR_SUBSIDIARY_SELL_SHARE_TITLE                                 :{WHITE}Kérés
+STR_SUBSIDIARY_SELL_SHARE                                       :{WHITE}{STRING} akar 25%-ot vásárolni a részvényeidbõl. Beleegyezel?
+STR_SUBSIDIARY_SELL_SHARE_GRANTED                               :{WHITE}A kérésed elutasították
+STR_SUBSIDIARY_SELL_SHARE_DENIED                                :{WHITE}A kérésed elfogadták
+STR_TOO_MANY_PLAYERS                                            :{WHITE}Túl sok játékos
+
+STR_CONFIG_PATCHES_SUBSIDIARIES                                 :{LTBLUE}Leányvállalatok engedélyezése: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_ST_TAX                                :{LTBLUE}Adó mértéke a leányvállalatok megállójában megálláskor: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_SUB_CONFIG        :{LTBLUE}Adó mértéke a leányvállalatok sín használatákor: {ORANGE}{STRING} négyzetenként
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_CONFIG            :{LTBLUE}Mindenki használhatja a síneket: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_OTHER_CONFIG      :{LTBLUE}Adó mértéke a megosztott sín használatákor: {ORANGE}{STRING} négyzetenként
+STR_CONFIG_PATCHES_SUBS_ALLOW_REMOVE                            :{LTBLUE}A leányvállalatok törölhetik-e egymás útjait és sínjeit: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_COOP                                         :{BLACK}Együttmûködés
+STR_CONFIG_PATCHES_SHARED_STATIONS			                        :{LTBLUE}Mindenki használhatja az állomásokat: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_STATIONS_SUBS_CARGOTAX			          :{LTBLUE}Adó mértéke a leányvállalatok rakományaihoz: {ORANGE}{STRING} egységenként
+STR_CONFIG_PATCHES_SHARED_STATIONS_OTHERS_CARGOTAX			        :{LTBLUE}Adó mértéke a megosztott rakományokhoz: {ORANGE}{STRING} egységenként
+STR_CONFIG_PATCHES_SHARED_ST_TAX_OTHERS                         :{LTBLUE}Adó mértéke a megosztott állomáson megálláskor: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_YEARS_OF_PROTECTION                          :{LTBLUE}Megosztások elleni védelem: {ORANGE}{STRING} évig
+
+STR_703A_TRAIN_SUB                                              :{WHITE}{COMMA16} vonat a {COMMA16} darabból ({COMMA16}%)
+STR_703B_TRAINS_SUB                                             :{WHITE}{COMMA16} vonat a {COMMA16} darabból ({COMMA16}%)
+STR_703C_ROAD_VEHICLE_SUB                                       :{WHITE}{COMMA16} közúti jármû a {COMMA16} darabból ({COMMA16}%)
+STR_703D_ROAD_VEHICLES_SUB                                      :{WHITE}{COMMA16} közûti jármû a {COMMA16} darabból ({COMMA16}%)
+STR_703E_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} repülõgép a {COMMA16} darabból({COMMA16}%)
+STR_703F_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} repülõgép a {COMMA16} darabból({COMMA16}%)
+STR_7040_SHIP_SUB                                               :{WHITE}{COMMA16} hajó a {COMMA16} darabból ({COMMA16}%)
+STR_7041_SHIPS_SUB                                              :{WHITE}{COMMA16} hajó a {COMMA16} darabból ({COMMA16}%)
+############ End of Subsidiairies strings
+
 ############ Lists rail types
 
 STR_RAIL_VEHICLES                                               :Normál Vasutak
Index: lang/english.txt
===================================================================
--- lang/english.txt	(revision 2447)
+++ lang/english.txt	(working copy)
@@ -1111,6 +1111,7 @@
 STR_CHEAT_SWITCH_CLIMATE                                        :{LTBLUE}Switch climate: {ORANGE} {STRING}
 STR_CHEAT_CHANGE_DATE                                           :{LTBLUE}Change date: {ORANGE} {DATE_SHORT}
 STR_CHEAT_SETUP_PROD                                            :{LTBLUE}Enable modifying production values: {ORANGE}{STRING}
+STR_CHEAT_RESET_STATION                                         :{LTBLUE}Enable Resetting of Stations: {ORANGE}{STRING}
 
 STR_HEADING_FOR_WAYPOINT                                        :{LTBLUE}Heading for {WAYPOINT}
 STR_HEADING_FOR_WAYPOINT_VEL                                    :{LTBLUE}Heading for {WAYPOINT}, {VELOCITY}
@@ -2740,6 +2741,46 @@
 STR_BUILD_DATE                                                  :{BLACK}Built: {LTBLUE}{DATE_LONG}
 STR_MULTIPLAYER_PAUSED                                          :{WHITE}Game is paused.{}Command cannot be executed
 
+STR_RESET_STATION                                               :{BLACK}Reset Station
+STR_STATION_STATS                                               :{BLACK}Statistics
+STR_STATION_GOODS_IN                                            :{BLACK}In
+STR_STATION_GOODS_OUT                                           :{BLACK}Out
+STR_STATION_GOODS_TRANSFER                                      :{BLACK}Transit
+STR_VEHICLES                                                    :{BLACK}Vehicles
+STR_SCHEDULED                                                   :{BLACK}Scheduled
+STR_VEHICLES_MONTH                                              :{BLACK}Last Month
+STR_VEHICLES_CURRENT                                            :{BLACK}Current Month
+STR_TRAINS                                                      :{BLACK}Trains
+STR_RVS                                                         :{BLACK}Road Vehicles
+STR_BUSSES                                                      :{BLACK}Buses
+STR_TRUCKS                                                      :{BLACK}Trucks
+STR_SHIPS                                                       :{BLACK}Ships
+STR_AIRCRAFT                                                    :{BLACK}Aircraft
+STR_NUMBER                                                      :{YELLOW}{COMMA32}
+STR_STATION_MONTHS                                              :{BLACK}Cargo amount [This Month (Last Month) ]
+STR_CNUMBERS                                                    :{WHITE}{COMMA32} {TINYFONT}{BLACK}({YELLOW}{COMMA32}{BLACK})
+STR_VEHICLES_MONTHS_AVERAGE                                     :{BLACK}Average / Min / Max
+STR_MONTHS_COUNTED_NUM                                          :{BLACK}Months Counted: {GOLD}{COMMA32}
+STR_MONTHS_TINY                                                 :{TINYFONT}{BLACK}Months
+STR_STATION_MONTHS_AVERAGE                                      :{BLACK}Cargo amount [Average (Min/Max) per Month]
+STR_TOGGLE_MINMAX                                               :{BLACK}Toggle  -This/Last Month-   or   -Average/Min/Max-   Stats
+STR_RESET_STATISTICS                                            :{BLACK}Reset Statistics
+STR_AVERAGENUMBERS                                              :{SILVER}{COMMA32} {BLACK}{TINYFONT}({ORANGE}{COMMA32}{BLACK}/{LTBLUE}{COMMA32}{BLACK})
+STR_BLACK_SLASH                                                 :{BLACK}/
+STR_TINY_GOLD_NUMBER                                            :{TINYFONT}{GOLD}{COMMA32}
+STR_SILVER_NUMBER                                               :{SILVER}{COMMA32}
+STR_ORANGE_NUMBER                                               :{ORANGE}{COMMA32}
+STR_LTBLUE_NUMBER                                               :{LTBLUE}{COMMA32}
+STR_WHITE_NUMBER                                                :{WHITE}{COMMA32}
+STR_STS_NOT_SCHEDULED                                           :{BLACK}Not Scheduled
+STR_AVERAGE                                                     :{BLACK}Average
+STR_MINIMUM                                                     :{BLACK}Minimum
+STR_MAXIMUM                                                     :{BLACK}Maximum
+STR_STS_VEHICLES_LAST_YEAR                                      :{BLACK}Last Year
+STR_STS_VEHICLES_THIS_YEAR                                      :{BLACK}This Year
+STR_STS_YEARS_COUNTED_NUM                                       :{BLACK}Years Counted: {GOLD}{COMMA32}
+STR_STS_TOGGLE_MONTH_YEAR                                       :{BLACK}Toggle  -Monthly-   or   -Yearly-   Stats
+
 STR_PERFORMANCE_DETAIL                                          :{WHITE}Detailed performance rating
 STR_PERFORMANCE_DETAIL_KEY                                      :{BLACK}Detail
 STR_PERFORMANCE_DETAIL_AMOUNT_CURRENCY                          :{BLACK}({CURRCOMPACT}/{CURRCOMPACT})
@@ -2819,6 +2860,72 @@
 STR_SHORT_DATE                                                  :{WHITE}{DATE_TINY}
 STR_SIGN_LIST_CAPTION                                           :{WHITE}Sign List - {COMMA16} Signs
 
+############ subsidiaries strings
+STR_SUBSIDIARIES						                                    :{BLACK}Subsidiaries
+STR_SUBSIDIARIES_MANAGEMENT				                              :{BLACK}Manage your subsidiaries
+STR_YOUR_SUBSIDIARIES                                           :{WHITE}Your Subsidiaries
+STR_SUBSIDIARIES_ADMINISTRATE                                   :{BLACK}Administrate
+STR_SUBSIDIARIES_SEND_MONEY                                     :{BLACK}Send Cash
+STR_SUBSIDIARIES_REQUEST_MONEY                                  :{BLACK}Get Cash
+STR_SUBSIDIARIES_MERGER                                         :{BLACK}Merger
+STR_SUBSIDIARIES_ADMINISTRATE_E                                 :{BLACK}Administrate (play as) the selected subsidiary
+STR_SUBSIDIARIES_SEND_MONEY_E                                   :{BLACK}Send Cash to the selected subsidiary, banks will keep 6% of the transaction amount as service charge
+STR_SUBSIDIARIES_REQUEST_MONEY_E                                :{BLACK}Get Cash from the selected subsidiary, banks will keep 6% of the transaction amount as service charge
+STR_SUBSIDIARIES_MERGER_E                                       :{BLACK}Perform a full merger of the current subsidiary and the selected one
+STR_SUBSIDIARY_OF                                               :{WHITE}(Subsidiary of {STRING})
+STR_SUBSIDIARY_CREATE                                           :{BLACK}Create
+STR_SUBSIDIARY_CREATE_E                                         :{BLACK}Create a new subsidiary company from scratch
+STR_SUBSIDIARY_ADD_CASH                                         :{BLACK}Add {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_ADD_CASH_E                                       :{BLACK}Increase the amount to be transfered
+STR_SUBSIDIARY_SUB_CASH                                         :{BLACK}Subtract {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_SUB_CASH_E                                       :{BLACK}Decrease the amount to be transfered
+STR_SUBSIDIARY_SEND_TO                                          :{WHITE}Send cash to {STRING}
+STR_SUBSIDIARY_REQUEST_FROM                                     :{WHITE}Request cash from {STRING}
+STR_SUBSIDIARY_SEND_AMOUNT                                      :{WHITE}Amount to be sent:
+STR_SUBSIDIARY_REQUEST_AMOUNT                                   :{WHITE}Amount which will be recieved:
+STR_SUBSIDIARY_AMOUNT_SEND                                      :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_GET                                       :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_TARGET                                    :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_GET_ERROR                                        :{WHITE}Impossible to retrieve this amount...
+STR_SUBSIDIARY_SEND_ERROR                                       :{WHITE}Impossible to send this amount...
+STR_SUBSIDIARY_PLAYER_ERROR                                     :{WHITE}Cannot create subsidiary...
+STR_SUBSIDIARY_ASK_MERGER                                       :{YELLOW}Are you sure you want to merge {STRING} into {STRING}?
+STR_SUBSIDIARY_ASK_MERGER_TITLE                                 :{WHITE}Perform Merger
+STR_SUBSIDIARY_TARGET_HAS                                       :{WHITE}Target subsidiary current bank balance:
+STR_SUBSIDIARY_TOGGLE                                           :{BLACK}Toggle this subsidiary
+STR_SUBSIDIARY_CASH_REQUEST                                     :{WHITE}Incoming cash request
+STR_SUBSIDIARY_CASH_REQUESTED                                   :{WHITE}{STRING} Requested {CURRENCY64}. Do you accept sending this amount?
+STR_SUBSIDIARY_CASH_REQUEST_DENIED                              :{WHITE}Your cash request was denied
+STR_SUBSIDIARY_CASH_REQUEST_GRANTED                             :{WHITE}Your cash request was granted
+STR_SUBSIDIARY_SELL_SHARE_TITLE                                 :{WHITE}Incomming request
+STR_SUBSIDIARY_SELL_SHARE                                       :{WHITE}{STRING} would like to buy 25% of your shares. Do you accept selling those shares?
+STR_SUBSIDIARY_SELL_SHARE_GRANTED                               :{WHITE}Your offer was accepted
+STR_SUBSIDIARY_SELL_SHARE_DENIED                                :{WHITE}Your offer was denied
+STR_TOO_MANY_PLAYERS                                            :{WHITE}Too many players
+
+STR_CONFIG_PATCHES_SUBSIDIARIES                                 :{LTBLUE}Enable susidiaries management: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_ST_TAX                                :{LTBLUE}Tax vehicles stopping in a subsidiary's station: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_SUB_CONFIG        :{LTBLUE}Base tax for subsidiaries shared tracks usage: {ORANGE}{STRING} per tile
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_CONFIG            :{LTBLUE}Allow track sharing for everyone: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_OTHER_CONFIG      :{LTBLUE}Base tax for shared tracks usage: {ORANGE}{STRING} per tile
+STR_CONFIG_PATCHES_SUBS_ALLOW_REMOVE                            :{LTBLUE}Allow subsidiaries to remove each others tracks and roads: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_COOP                                         :{BLACK}Cooperation
+STR_CONFIG_PATCHES_SHARED_STATIONS                              :{LTBLUE}Allow station sharing for everyone: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_STATIONS_SUBS_CARGOTAX                :{LTBLUE}Base tax for subsidiaries cargo pickup: {ORANGE}{STRING} per unit
+STR_CONFIG_PATCHES_SHARED_STATIONS_OTHERS_CARGOTAX              :{LTBLUE}Base tax for cargo pickup: {ORANGE}{STRING} per unit
+STR_CONFIG_PATCHES_SHARED_ST_TAX_OTHERS                         :{LTBLUE}Tax vehicles stopping in another company's station: {ORANGE}{STRING}%
+STR_CONFIG_PATCHES_YEARS_OF_PROTECTION                          :{LTBLUE}Years of shares protection:{ORANGE}{STRING} year(s)
+
+STR_703A_TRAIN_SUB                                              :{WHITE}{COMMA16} train out of {COMMA16} ({COMMA16}%)
+STR_703B_TRAINS_SUB                                             :{WHITE}{COMMA16} trains out of {COMMA16} ({COMMA16}%)
+STR_703C_ROAD_VEHICLE_SUB                                       :{WHITE}{COMMA16} road vehicle out of {COMMA16} ({COMMA16}%)
+STR_703D_ROAD_VEHICLES_SUB                                      :{WHITE}{COMMA16} road vehicles out of {COMMA16} ({COMMA16}%)
+STR_703E_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} aircraft out of {COMMA16} ({COMMA16}%)
+STR_703F_AIRCRAFT_SUB                                           :{WHITE}{COMMA16} aircraft out of {COMMA16} ({COMMA16}%)
+STR_7040_SHIP_SUB                                               :{WHITE}{COMMA16} ship out of {COMMA16} ({COMMA16}%)
+STR_7041_SHIPS_SUB                                              :{WHITE}{COMMA16} ships out of {COMMA16} ({COMMA16}%)
+############ end of subsidiaries strings
+
 ############ Lists rail types
 
 STR_RAIL_VEHICLES                                               :Rail Vehicles
Index: lang/czech.txt
===================================================================
--- lang/czech.txt	(revision 2447)
+++ lang/czech.txt	(working copy)
@@ -2799,10 +2799,55 @@
 STR_REPLACE_HELP_RAILTYPE                                       :{BLACK}Vyber typ kolejí, pro které chces vybírat lokomotivy na zamenu
 STR_REPLACE_HELP_REPLACE_INFO_TAB                               :{BLACK}Tady je zobrazeno, za jakou lokomotivu se ta v levém seznamu zamenuje
 STR_REPLACE_HELP                                                :{BLACK}Tato moznost hry ti umoznuje vybrat typ lokomotivy, který nechá vymenit za jiný. To se bude automaticky provadet, kdyz lokomotiva zajede do depa.
-
 STR_SHORT_DATE                                                  :{WHITE}{DATE_TINY}
 STR_SIGN_LIST_CAPTION                                           :{WHITE}Seznam popisku - {COMMA16} popisku
 
+############ Subsidiaries strings
+STR_CONFIG_PATCHES_SUBSIDIARIES			                :{LTBLUE}Povolit spravu dcerinych spolecnosti: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_SHARED_ST_TAX		                :{LTBLUE}Poplatek za komercni pouziti stanice: {ORANGE}{STRING}%
+STR_SUBSIDIARIES						:{BLACK}Podspolecnosti
+STR_SUBSIDIARIES_MANAGEMENT				        :{BLACK}Spravovat dcerine spolecnosti
+STR_YOUR_SUBSIDIARIES                                           :{WHITE}Tvoje dcerine spolecnosti
+STR_SUBSIDIARIES_ADMINISTRATE			                :{BLACK}Spravovat
+STR_SUBSIDIARIES_SEND_MONEY			                :{BLACK}Odeslat penize
+STR_SUBSIDIARIES_REQUEST_MONEY			                :{BLACK}Vyzadat penize
+STR_SUBSIDIARIES_MERGER			                        :{BLACK}Slouceni
+STR_SUBSIDIARIES_ADMINISTRATE_E			                :{BLACK}Spravovat (hrat za) vybranou spolecnost
+STR_SUBSIDIARIES_SEND_MONEY_E			                :{BLACK}Odeslat penize zvolene spolecnosti, bankovni poplatky maji hodnotu 6% z prevadene castky
+STR_SUBSIDIARIES_REQUEST_MONEY_E			        :{BLACK}Ziskat penize ze zvolene spolecnosti, bankovni poplatky maji hodnotu 6% z prevadene castky
+STR_SUBSIDIARIES_MERGER_E			                :{BLACK}Provést kompletní sloucení teto spolecnsti s vybranou
+STR_SUBSIDIARY_OF                                               :{WHITE}(Dcerina spolecnost pod {STRING})
+STR_SUBSIDIARY_CREATE                                           :{BLACK}Vytvorit
+STR_SUBSIDIARY_CREATE_E                                         :{BLACK}Vytvori novou dcerinou spolecnost na zelene louce
+STR_SUBSIDIARY_ADD_CASH                                         :{BLACK}Pridat {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_ADD_CASH_E                                       :{BLACK}Pridat castku urcenou k prevodu
+STR_SUBSIDIARY_SUB_CASH                                         :{BLACK}Odebrat {SKIP}{SKIP}{SKIP}{CURRENCY64}
+STR_SUBSIDIARY_SUB_CASH_E                                       :{BLACK}Odebrat castku urcenou k prevodu
+STR_SUBSIDIARY_SEND_TO                                          :{WHITE}Zaslat peniza pro {STRING}
+STR_SUBSIDIARY_REQUEST_FROM                                     :{WHITE}Vyzadat penize od {STRING}
+STR_SUBSIDIARY_SEND_AMOUNT                                      :{WHITE}Castka k odeslani:
+STR_SUBSIDIARY_REQUEST_AMOUNT                                   :{WHITE}Castka pripsana na ucet:
+STR_SUBSIDIARY_AMOUNT_SEND                                      :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_GET                                       :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_AMOUNT_TARGET                                    :{YELLOW}{CURRENCY64}
+STR_SUBSIDIARY_GET_ERROR                                        :{WHITE}Neni mozne ziskat takovou castku...
+STR_SUBSIDIARY_SEND_ERROR                                       :{WHITE}Neni mozne odeslat takovou castku...
+STR_SUBSIDIARY_PLAYER_ERROR                                     :{WHITE}Neni mozne vytvorit dcerinou spolecnost...
+STR_SUBSIDIARY_ASK_MERGER                                       :{YELLOW}Opravdu chces sloucit {STRING} do {STRING}?
+STR_SUBSIDIARY_ASK_MERGER_TITLE                                 :{WHITE}Provest spojeni
+STR_SUBSIDIARY_TARGET_HAS                                       :{WHITE}Bank. bilance prijemce:
+STR_SUBSIDIARY_TOGGLE                                           :{BLACK}Prepnout na tuto spolecnost
+STR_TOO_MANY_PLAYERS                                            :{WHITE}Prilis mnoho hracu
+STR_SUBSIDIARY_CASH_REQUEST                                     :{WHITE}Prichozi zadost o financni vypomoc
+STR_SUBSIDIARY_CASH_REQUESTED                                   :{WHITE}{STRING} Pozaduje {CURRENCY64}. Souhlasis s odeslanim takove cestky?
+STR_SUBSIDIARY_CASH_REQUEST_DENIED                              :{WHITE}Pozadavek na financni hotovost byl zamitnut
+STR_SUBSIDIARY_CASH_REQUEST_GRANTED                             :{WHITE}Penize byly prislibeny
+STR_SUBSIDIARY_SELL_SHARE_TITLE                                 :{WHITE}Prichozi zadost
+STR_SUBSIDIARY_SELL_SHARE                                       :{WHITE}{STRING} si chce koupit 25% podil ve tve spolecnosti. Povolis odkup tohoto podilu?
+STR_SUBSIDIARY_SELL_SHARE_GRANTED                               :{WHITE}Tvoje nabidka byla zamitnuta
+STR_SUBSIDIARY_SELL_SHARE_DENIED                                :{WHITE}Tvoje nabidka byla prijata
+################### end of subs strings
+
 ############ Lists rail types
 
 STR_RAIL_VEHICLES                                               :Zeleznicni lokomotivy
Index: variables.h
===================================================================
--- variables.h	(revision 2447)
+++ variables.h	(working copy)
@@ -193,6 +193,18 @@
 	byte drag_signals_density; // many signals density
 	bool ainew_active;  // Is the new AI active?
 
+	bool subsidiaries;
+	bool allow_track_removal;
+	byte shared_stations_tax;
+	int32 shared_tracks_tax_subsidiary;
+	bool shared_tracks;
+	int32 shared_tracks_tax_others;
+	bool shared_stations;
+	byte shared_stations_tax_others;
+	int32 shared_stations_pickuptax_subsidiary;
+	int32 shared_stations_pickuptax_others;
+	byte years_of_protection;
+
 	/*
 	 * New Path Finding
 	 */
@@ -243,6 +255,7 @@
 	Cheat switch_climate;
 	Cheat change_date;				//changes date ingame
 	Cheat setup_prod;				//setup raw-material production in game
+	Cheat reset_station;		// allow resetting of Stations
 } Cheats;
 
 VARDEF Cheats _cheats;
@@ -342,6 +355,9 @@
 
 VARDEF bool _cache_sprites;
 
+VARDEF bool _show_average_stats; // show Average Stats for Station-Stats?
+VARDEF bool _show_yearly_stats; // show Yearly Stats for Waypoints?
+
 // debug features
 VARDEF char _savedump_path[64];
 VARDEF uint _savedump_first, _savedump_freq, _savedump_last;
Index: players.c
===================================================================
--- players.c	(revision 2447)
+++ players.c	(working copy)
@@ -17,6 +17,7 @@
 #include "command.h"
 #include "ai.h"
 #include "sound.h"
+#include "economy.h"
 #include "network.h"
 
 extern void StartupEconomy(void);
@@ -271,8 +272,7 @@
 bool CheckOwnership(byte owner)
 {
 	assert(owner <= OWNER_WATER);
-
-	if (owner == _current_player)
+	if (IsSisterCompany(owner, _current_player))
 		return true;
 	_error_message = STR_013B_OWNED_BY;
 	GetNameOfOwner(owner, 0);
@@ -287,6 +287,7 @@
 
 	if (owner == _current_player)
 		return true;
+
 	_error_message = STR_013B_OWNED_BY;
 
 	// no need to get the name of the owner unless we're the local player (saves some time)
@@ -295,6 +296,23 @@
 	return false;
 }
 
+bool CheckSubsidiaryTileOwnership(uint tile)
+{
+	byte owner = GetTileOwner(tile);
+
+	assert(owner <= OWNER_WATER);
+
+	if (IsSisterCompany(owner, _current_player))
+		return true;
+
+	_error_message = STR_013B_OWNED_BY;
+
+	// no need to get the name of the owner unless we're the local player (saves some time)
+	if (_current_player == _local_player)
+		GetNameOfOwner(owner, tile);
+	return false;
+}
+
 static void GenerateCompanyName(Player *p)
 {
 	uint tile;
@@ -577,7 +595,7 @@
 StringID GetPlayerNameString(byte player, byte index)
 {
 	if (IS_HUMAN_PLAYER(player) && player < MAX_PLAYERS) {
-		SetDParam(index, player+1);
+		SetDParam(index, (_patches.subsidiaries && !_networking) ? GetMotherCompany(DEREF_PLAYER(player))+1 : player +1);
 		return STR_7002_PLAYER;
 	}
 	return STR_EMPTY;
Index: gui.h
===================================================================
--- gui.h	(revision 2447)
+++ gui.h	(working copy)
@@ -46,7 +46,7 @@
 /* road_gui.c */
 void ShowBuildRoadToolbar(void);
 void ShowBuildRoadScenToolbar(void);
-void ShowPlayerRoadVehicles(int player, int station);
+void ShowPlayerRoadVehicles(int player, int station, uint32 cargomask);
 
 /* dock_gui.c */
 void ShowBuildDocksToolbar(void);
Index: aystar.c
===================================================================
--- aystar.c	(revision 2447)
+++ aystar.c	(working copy)
@@ -230,6 +230,10 @@
 	else if (r == AYSTAR_LIMIT_REACHED)
 		printf("[AyStar] Exceeded search_nodes, no path found\n");
 #endif
+
+	if (aystar->BeforeExit != NULL)
+		aystar->BeforeExit(aystar);
+
 	if (r != AYSTAR_STILL_BUSY)
 		/* We're done, clean up */
 		aystar->clear(aystar);
Index: tunnelbridge_cmd.c
===================================================================
--- tunnelbridge_cmd.c	(revision 2447)
+++ tunnelbridge_cmd.c	(working copy)
@@ -10,6 +10,9 @@
 #include "player.h"
 #include "town.h"
 #include "sound.h"
+#include "pbs.h"
+#include "debug.h"
+#include "economy.h"
 
 extern void DrawCanalWater(uint tile);
 
@@ -627,7 +630,7 @@
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
 	// in scenario editor you can always destroy tunnels
-	if (_game_mode != GM_EDITOR && !CheckTileOwnership(tile)) {
+	if (_game_mode != GM_EDITOR && !(CheckTileOwnership(tile) || (_patches.allow_track_removal && IsSisterCompany(_current_player, GetTileOwner(tile)))) && DEREF_PLAYER(GetTileOwner(tile))->is_active) {
 		if (!(_patches.extra_dynamite || _cheats.magic_bulldozer.value) || !IsTileOwner(tile, OWNER_TOWN))
 			return CMD_ERROR;
 	}
@@ -704,7 +707,8 @@
 		int32 cost;
 
 		// check if we own the tile below the bridge..
-		if (_current_player != OWNER_WATER && (!CheckTileOwnership(tile) || !EnsureNoVehicleZ(tile, TilePixelHeight(tile))))
+		
+		if (_current_player != OWNER_WATER && ((!(CheckTileOwnership(tile) || (_patches.allow_track_removal && IsSisterCompany(_current_player, GetTileOwner(tile))))&& DEREF_PLAYER(GetTileOwner(tile))->is_active) || !EnsureNoVehicleZ(tile, TilePixelHeight(tile))))
 			return CMD_ERROR;
 
 		cost = (_map5[tile] & 8) ? _price.remove_road * 2 : _price.remove_rail;
@@ -735,7 +739,7 @@
 	tile = FindEdgesOfBridge(tile, &endtile);
 
 	// floods, scenario editor can always destroy bridges
-	if (_current_player != OWNER_WATER && _game_mode != GM_EDITOR && !CheckTileOwnership(tile)) {
+	if (_current_player != OWNER_WATER && _game_mode != GM_EDITOR && !(CheckTileOwnership(tile) || (_patches.allow_track_removal && IsSisterCompany(_current_player, GetTileOwner(tile))))) {
 		if (!(_patches.extra_dynamite || _cheats.magic_bulldozer.value) || !IsTileOwner(tile, OWNER_TOWN))
 			return CMD_ERROR;
 	}
@@ -772,6 +776,7 @@
 		byte m5;
 		uint c = tile;
 		uint16 new_data;
+		byte pbs;
 
 		//checks if the owner is town then decrease town rating by RATING_TUNNEL_BRIDGE_DOWN_STEP until
 		// you have a "Poor" (0) town rating
@@ -780,6 +785,7 @@
 
 		do {
 			m5 = _map5[c];
+			pbs = PBSTileReserved(c);
 
 			if (m5 & 0x40) {
 				if (m5 & 0x20) {
@@ -793,6 +799,9 @@
 				SetTileType(c, new_data >> 12);
 				_map5[c] = (byte)new_data;
 				_map2[c] = 0;
+				_map3_hi[c] &= 0x0F;
+				if (direction ? HASBIT(pbs,0) : HASBIT(pbs,1))
+					PBSReserveTrack(c, direction ? 0 : 1);
 
 				MarkTileDirtyByTile(c);
 
@@ -1145,7 +1154,19 @@
 			}
 		}
 	}
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & RAIL_BIT_DIAG1) DrawGroundSprite((0x3ED) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_DIAG2) DrawGroundSprite((0x3EE) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_UPPER) DrawGroundSprite((0x3EF) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LOWER) DrawGroundSprite((0x3F0) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LEFT)  DrawGroundSprite((0x3F2) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_RIGHT) DrawGroundSprite((0x3F1) | PALETTE_CRASH);
 }
+#endif
+}
 
 static uint GetSlopeZ_TunnelBridge(TileInfo *ti) {
 	uint z = ti->z;
@@ -1428,6 +1449,8 @@
 					return 0;
 				}
 				if (fc == _tunnel_fractcoord_2[dir]) {
+					if (v->next == NULL)
+						PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 					v->tile = tile;
 					v->u.rail.track = 0x40;
 					v->vehstatus |= VS_HIDDEN;
Index: aystar.h
===================================================================
--- aystar.h	(revision 2447)
+++ aystar.h	(working copy)
@@ -96,6 +96,11 @@
  */
 typedef void AyStar_FoundEndNode(AyStar *aystar, OpenListNode *current);
 
+/*
+ * Is called when aystar ends it pathfinding, but before cleanup.
+ */
+typedef void AyStar_BeforeExit(AyStar *aystar);
+
 // For internal use, see aystar.c
 typedef void AyStar_AddStartNode(AyStar *aystar, AyStarNode* start_node, uint g);
 typedef int AyStar_Main(AyStar *aystar);
@@ -115,6 +120,7 @@
 	AyStar_GetNeighbours* GetNeighbours;
 	AyStar_EndNodeCheck* EndNodeCheck;
 	AyStar_FoundEndNode* FoundEndNode;
+	AyStar_BeforeExit* BeforeExit;
 
 	/* These are completely untouched by AyStar, they can be accesed by
 	 * the application specific routines to input and output data.
Index: roadveh_cmd.c
===================================================================
--- roadveh_cmd.c	(revision 2447)
+++ roadveh_cmd.c	(working copy)
@@ -14,9 +14,11 @@
 #include "npf.h"
 #include "player.h"
 #include "sound.h"
+#include "economy.h"
 #include "depot.h"
 #include "vehicle_gui.h"
 
+
 void ShowRoadVehViewWindow(Vehicle *v);
 
 static const uint16 _roadveh_images[63] = {
@@ -133,7 +135,7 @@
 	/* The ai_new queries the vehicle cost before building the route,
 	 * so we must check against cheaters no sooner than now. --pasky */
 	if (!IsTileDepotType(tile, TRANSPORT_ROAD)) return CMD_ERROR;
-	if (!IsTileOwner(tile, _current_player)) return CMD_ERROR;
+	if (!IsSisterCompany(GetTileOwner(tile),_current_player)) return CMD_ERROR;
 
 	v = AllocateVehicle();
 	if (v == NULL || IsOrderPoolFull())
@@ -297,8 +299,7 @@
 
 	if (IsTileType(tile, MP_STREET) &&
 			(_map5[tile] & 0xF0) == 0x20 &&
-			IsTileOwner(tile, rfdd->owner)) {
-
+			(IsSisterCompany(GetTileOwner(tile), rfdd->owner) || _patches.shared_stations)){
 		if (length < rfdd->best_length) {
 			rfdd->best_length = length;
 			rfdd->tile = tile;
@@ -808,6 +809,14 @@
 
 static void RoadVehArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_ROAD].this_month++;
+    if (st->months_counted == 0) st->months_counted = 1;
+	if (v->cargo_type == CT_PASSENGERS)
+		st->vehicles[STS_VEH_BUS].this_month++;
+	else
+		st->vehicles[STS_VEH_TRUCK].this_month++;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	if (v->engine_type < 123) {
 		/* Check if station was ever visited before */
 		if (!(st->had_vehicle_of_type & HVOT_BUS)) {
@@ -1047,11 +1056,12 @@
 	}
 
 	if (IsTileType(tile, MP_STREET)) {
-		if ((_map5[tile]&0xF0) == 0x20 && IsTileOwner(tile, v->owner))
+		if ((_map5[tile]&0xF0) == 0x20 && IsSisterCompany(GetTileOwner(tile), v->owner))
+
 			/* Road crossing */
 			bitmask |= _road_veh_fp_ax_or[_map5[tile]&3];
 	} else if (IsTileType(tile, MP_STATION)) {
-		if (IsTileOwner(tile, OWNER_NONE) || IsTileOwner(tile, v->owner)) {
+		if (GetTileOwner(tile) == OWNER_NONE || IsSisterCompany(GetTileOwner(tile), v->owner) || _patches.shared_stations){
 			/* Our station */
 			Station *st = GetStation(_map2[tile]);
 			byte val = _map5[tile];
@@ -1104,7 +1114,7 @@
 		trackdir = _dir_to_diag_trackdir[enterdir];
 		//debug("Finding path. Enterdir: %d, Trackdir: %d", enterdir, trackdir);
 
-		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_ROAD, v->owner);
+		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_ROAD, v->owner, PBS_MODE_NONE);
 		if (ftd.best_trackdir == 0xff) {
 			/* We are already at our target. Just do something */
 			//TODO: maybe display error?
@@ -1181,7 +1191,7 @@
   fstd.dest_coords = tile;
   fstd.station_index = -1;	// indicates that the destination is a tile, not a station
 
-  return NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_ROAD, v->owner).best_path_dist;
+  return NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_ROAD, v->owner, PBS_MODE_NONE).best_path_dist;
 }
 
 typedef struct RoadDriveEntry {
Index: openttd.h
===================================================================
--- openttd.h	(revision 2447)
+++ openttd.h	(working copy)
@@ -265,7 +265,7 @@
 
 	NUM_CARGO = 12,
 
-	CT_INVALID = 0xFF
+	CT_INVALID = 0xFF,
 };
 
 typedef uint AcceptedCargo[NUM_CARGO];
@@ -441,6 +441,11 @@
 	WC_HIGHSCORE = 0x4D,
 	WC_ENDSCREEN = 0x4E,
 	WC_SIGN_LIST = 0x4F,
+	WC_STATION_STATS = 0x50,
+	WC_WAYPOINT_STATS = 0x51,
+ 	WC_SUBSIDIARIES = 0x50,
+ 	WC_SUBSIDIARIES_MONEY = 0x51,
+ 	WC_SUBSIDIARIES_ASK_MERGER = 0x52, 	
 };
 
 
@@ -527,6 +532,7 @@
 #define INVALID_UINT_TILE (uint)0xFFFFFFFF
 #define INVALID_STRING_ID 0xFFFF
 
+
 enum {
 	MAX_SCREEN_WIDTH = 2048,
 	MAX_SCREEN_HEIGHT = 1200,
Index: station_gui.c
===================================================================
--- station_gui.c	(revision 2447)
+++ station_gui.c	(working copy)
@@ -10,6 +10,7 @@
 #include "player.h"
 #include "town.h"
 #include "command.h"
+#include "engine.h"
 
 static void StationsWndShowStationRating(int x, int y, int type, uint acceptance, int rating)
 {
@@ -286,9 +287,31 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    64,   248,   210,   221, 0x0,					STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_expanded_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,					STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,					STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,					STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,   197, 0x0,					STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   198,   209, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   198,   209, STR_3033_ACCEPTS,	STR_3056_SHOW_LIST_OF_ACCEPTED_CARGO},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   198,   209, STR_0130_RENAME,		STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,   198,   209, STR_TRAIN, STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   248,   210,   221, STR_RESET_STATION, 0x0},
+{   WIDGETS_END},
+};
+
 static const Widget _station_view_widgets[] = {
 {    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -304,9 +327,31 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    64,   248,   110,   121, 0x0,					STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,					STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,					STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,    97, 0x0,					STR_NULL},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,					STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,    98,   109, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,    98,   109, STR_3032_RATINGS,	STR_3054_SHOW_STATION_RATINGS},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,    98,   109, STR_0130_RENAME,		STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,    98,   109, STR_TRAIN, STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   248,   110,   121, STR_RESET_STATION, 0x0},
+{   WIDGETS_END},
+};
+
 static void DrawStationViewWindow(Window *w)
 {
 	Station *st;
@@ -331,7 +376,10 @@
 	}
 	SetVScrollCount(w, num);
 
-	w->disabled_state = st->owner == _local_player ? 0 : (1 << 9);
+	if (_cheats.reset_station.value)
+        w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 14) | (1 << 15);
+	else
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 14);
 
 	if (!(st->facilities & FACIL_TRAIN)) SETBIT(w->disabled_state,  10);
 	if (!(st->facilities & FACIL_TRUCK_STOP) &&
@@ -454,12 +502,19 @@
 			SetWindowDirty(w);
 
 			/* toggle height/widget set */
-			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)) {
-				AssignWidgetToWindow(w, _station_view_widgets);
-				w->height = 110;
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_widgets);
+				w->height = 122;
 			} else {
-				AssignWidgetToWindow(w, _station_view_expanded_widgets);
-				w->height = 210;
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+				w->height = 222;
 			}
 
 			SetWindowDirty(w);
@@ -480,7 +535,7 @@
 
 		case 11: { /* Show a list of scheduled road-vehicles to this station */
 			const Station *st = GetStation(w->window_number);
-			ShowPlayerRoadVehicles(st->owner, w->window_number);
+			ShowPlayerRoadVehicles(st->owner, w->window_number, CARGO_MASK_ALL);
 			break;
 		}
 
@@ -499,7 +554,37 @@
 			ShowPlayerShips(owner, w->window_number);
 			break;
 		}
+
+		case 14: {
+			ShowStationStatsWindow(w->window_number);
+			break;
 		}
+		case 15: {
+			if (_cheats.reset_station.value) {
+				Station *st = GetStation(w->window_number);
+				GoodsEntry *ge;
+
+				for(ge = st->goods; ge != endof(st->goods); ge++) {
+					ge->last_speed = 0;
+					ge->waiting_acceptance = 0;
+					ge->days_since_pickup = 0;
+					ge->enroute_from = 0xFFFF;
+					ge->rating = 175;
+					ge->last_speed = 0;
+					ge->last_age = 0xFF;
+					ge->feeder_profit = 0;
+				}
+				InitializeStationStats(st);
+				st->had_vehicle_of_type = 0;
+				st->time_since_load = 255;
+				st->time_since_unload = 255;
+				st->last_vehicle = INVALID_VEHICLE;
+
+				SetWindowDirty(w);
+			}
+			break;
+ 		}
+		}
 		break;
 
 	case WE_ON_EDIT_TEXT: {
@@ -520,6 +605,7 @@
 		DeleteWindowById(WC_ROADVEH_LIST, wno);
 		DeleteWindowById(WC_SHIPS_LIST, wno);
 		DeleteWindowById(WC_AIRCRAFT_LIST, wno);
+		DeleteWindowById(WC_STATION_STATS, w->window_number);
 		break;
 	}
 	}
@@ -527,19 +613,30 @@
 
 
 static const WindowDesc _station_view_desc = {
-	-1, -1, 249, 110,
+	-1, -1, 249, 122,
 	WC_STATION_VIEW,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
 	_station_view_widgets,
 	StationViewWndProc
 };
 
+static const WindowDesc _station_view_cheat_desc = {
+	-1, -1, 249, 122,
+	WC_STATION_VIEW,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_view_cheat_widgets,
+	StationViewWndProc
+};
+
 void ShowStationViewWindow(int station)
 {
 	Window *w;
 	byte color;
 
-	w = AllocateWindowDescFront(&_station_view_desc, station);
+	if (_cheats.reset_station.value)
+		w = AllocateWindowDescFront(&_station_view_cheat_desc, station);
+	else
+		w = AllocateWindowDescFront(&_station_view_desc, station);
 	if (w) {
 		color = GetStation(w->window_number)->owner;
 		if (color != 0x10)
@@ -547,3 +644,244 @@
 		w->vscroll.cap = 5;
 	}
 }
+
+void StationStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _station_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   398,     0,    13, STR_300A_0, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   399,   410,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    91,   410,    14,    25, STR_TOGGLE_MINMAX, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,    90,    26,    37, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    38,    49, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    50,    61, STR_RVS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    62,    73, STR_BUSSES, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    74,    85, STR_TRUCKS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    85,    97, STR_SHIPS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    98,   109, STR_AIRCRAFT, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    91,   410,    26,   109, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,   110,   135, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   398,   136,   191, 0x0,0x0},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   399,   410,   136,   191, 0x0, STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WIDGETS_END},
+};
+
+WindowDesc _station_view_stats = {
+	-1, -1, 411, 192,
+	WC_STATION_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_stats_widgets,
+	StationStatsWndProc
+};
+
+void DrawStationStatWindow(Window *w, Station *st)
+{
+	int i, y, numcargo=0, pos;
+	GoodsEntry *ge;
+	
+	// count number of goods at station (months_counted will be 0 if good not delivered/picked up)
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		if (ge->months_counted != 0) numcargo++;
+	}
+	SetVScrollCount(w, numcargo);
+		
+	//Get the Station name
+	SetDParam(0, st->index);
+	
+	//and the little carrier type images
+	SetDParam(1, st->facilities);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawStringCentered(45, 28, STR_VEHICLES, 0);
+
+	//Part 1:       Find the number of carriers on the station
+	y = 27;
+	if (_show_average_stats) {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(275, y, STR_VEHICLES_MONTHS_AVERAGE, 0);
+		SetDParam(0, max(st->months_counted - 1,0));
+		DrawStringRightAligned(405, y, STR_MONTHS_COUNTED_NUM, 0);
+	} else {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(295, y, STR_VEHICLES_MONTH, 0);
+		DrawStringRightAligned(395, y, STR_VEHICLES_CURRENT, 0);	
+	}
+
+	y = 38;
+	for (i = 0; i < STS_VEH_TYPES; i++) {
+		if (w->custom[i] != 0) {
+			SetDParam(0, w->custom[i]);
+			DrawStringRightAligned(150, y+i*12, STR_NUMBER, 0);
+			CLRBIT(w->disabled_state, i+7);
+		} else {
+			SETBIT(w->disabled_state, i+7);
+		}
+		if (_show_average_stats) {
+			if (st->vehicles[i].average != 0 || st->vehicles[i].month_max !=0) {
+				SetDParam(0, st->vehicles[i].average / STS_MULTIPLIER);
+				DrawStringRightAligned(235, y+i*12, STR_SILVER_NUMBER, 0);
+				DrawStringRightAligned(245, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_min);
+				DrawStringRightAligned(290, y+i*12, STR_ORANGE_NUMBER, 0);
+				DrawStringRightAligned(300, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_max);
+				DrawStringRightAligned(350, y+i*12, STR_LTBLUE_NUMBER, 0);
+			}
+		} else {
+			if (st->vehicles[i].last_month != 0) {
+				SetDParam(0, st->vehicles[i].last_month);
+				DrawStringRightAligned(295, y+i*12, STR_NUMBER, 0);
+			}
+			if (st->vehicles[i].this_month) {
+				SetDParam(0, st->vehicles[i].this_month);
+				DrawStringRightAligned(395, y+i*12, STR_WHITE_NUMBER, 0);
+			}
+		}
+	}
+	
+	y = 124;
+	if (_show_average_stats) {
+		DrawString(5, y-10, STR_STATION_MONTHS_AVERAGE, 0);
+		DrawStringRightAligned(100, y+2, STR_MONTHS_TINY, 0);
+	} else {
+        DrawString(5, y-10, STR_STATION_MONTHS, 0);
+	}
+	DrawStringRightAligned(200, y, STR_STATION_GOODS_IN, 0);
+	DrawStringRightAligned(305, y, STR_STATION_GOODS_OUT, 0);
+	DrawStringRightAligned(395, y, STR_STATION_GOODS_TRANSFER, 0);
+	
+	y += 5;
+	pos = w->vscroll.pos;
+	for (i = 0; i < NUM_CARGO; i++) {
+		ge = &st->goods[i];
+		if (ge->months_counted != 0 && ((--pos < 0) && (pos >= -4)) )
+		{
+			StationStats *sts = ge->cargo_amount;
+			//Print the cargo name
+			y += 12;
+			SetDParam(0, _cargoc.names_p[i]);
+			DrawString(3, y, STR_02BD, 0);
+			if (_show_average_stats) {
+				SetDParam(0, ge->months_counted - 1);
+				DrawStringRightAligned(100, y, STR_TINY_GOLD_NUMBER, 0);
+				if (sts[STS_AMOUNT_IN].average != 0 || sts[STS_AMOUNT_IN].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].average / STS_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_IN].month_min);
+					SetDParam(2, sts[STS_AMOUNT_IN].month_max);
+					DrawStringRightAligned(200, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].average != 0 || sts[STS_AMOUNT_OUT].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].average / STS_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_OUT].month_min);
+					SetDParam(2, sts[STS_AMOUNT_OUT].month_max);
+					DrawStringRightAligned(305, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].average != 0 || sts[STS_AMOUNT_TRANSFER].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].average / STS_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].month_min);
+					SetDParam(2, sts[STS_AMOUNT_TRANSFER].month_max);
+					DrawStringRightAligned(395, y, STR_AVERAGENUMBERS, 0);
+				}
+			} else {
+				if (sts[STS_AMOUNT_IN].this_month != 0 || sts[STS_AMOUNT_IN].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].this_month);
+					SetDParam(1, sts[STS_AMOUNT_IN].last_month);
+					DrawStringRightAligned(200, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].this_month != 0 || sts[STS_AMOUNT_OUT].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].this_month);
+					SetDParam(1, sts[STS_AMOUNT_OUT].last_month);
+					DrawStringRightAligned(305, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].this_month != 0 || sts[STS_AMOUNT_TRANSFER].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].this_month);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].last_month);
+					DrawStringRightAligned(395, y, STR_CNUMBERS, 0);
+				}
+			}
+		}
+	}
+}
+
+void StationStatsWndProc(Window *w, WindowEvent *e)
+{
+	Station *st = GetStation(w->window_number);
+	switch(e->event)
+	{
+	case WE_TICK: {
+//		static int counter = 0;
+//		if (++counter % 40) return;
+		int i;
+		
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+		InvalidateWindow(WC_STATION_STATS, w->window_number);
+		break;
+	}
+	case WE_PAINT: {
+		DrawStationStatWindow(w, st);
+		break;
+		}
+	case WE_CLICK: {
+		switch (e->click.widget)
+		{
+			case 4:			// Reset Statistics
+				if (st->owner == _current_player) {
+					InitializeStationStats(st);
+					InvalidateWindow(WC_STATION_STATS, w->window_number);
+				}
+				break;
+			case 5:			// Toggle Average and This Month
+				_show_average_stats ^= 1;
+				InvalidateWindow(WC_STATION_STATS, w->window_number);
+				break;
+			case 7:			//Trains
+				ShowPlayerTrains(st->owner, st->index);
+				break;
+			case 8: 		//Road Vehicles
+				ShowPlayerRoadVehicles(st->owner, st->index, CARGO_MASK_ALL);
+				break;
+			case 9:			// Buses
+				ShowPlayerRoadVehicles(st->owner, st->index, 1 << GC_PASSENGERS);
+				break;
+			case 10:		// Trucks
+				ShowPlayerRoadVehicles(st->owner, st->index, CARGO_MASK_ALL &~(1 << GC_PASSENGERS));
+				break;
+			case 11: 		//Ships
+				ShowPlayerShips(st->owner, st->index);
+				break;
+			case 12: 		//Aircraft
+				ShowPlayerAircraft(st->owner, st->index);
+				break;
+		}
+	} break;
+	case WE_DESTROY: {
+//		DeleteWindowById(WC_TRAINS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_ROADVEH_LIST, st->owner + ( (st->index + 1) << 8) + 64 + 128);
+//		DeleteWindowById(WC_SHIPS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_AIRCRAFT_LIST, st->owner + ( (st->index + 1) << 8));
+	} break;
+	}
+}
+
+void ShowStationStatsWindow(int station)
+{
+	Window *w;
+	byte color;
+
+	Station *st = GetStation(station);
+		
+	w = AllocateWindowDescFront(&_station_view_stats, st->index);
+	if (w) {
+		int i;
+		color = st->owner;
+		if (color != 0x10)
+			w->caption_color = color;
+		w->vscroll.cap = 4;
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+	}
+}
Index: ai_pathfinder.c
===================================================================
--- ai_pathfinder.c	(revision 2447)
+++ ai_pathfinder.c	(working copy)
@@ -96,6 +96,8 @@
 	result->EndNodeCheck = AyStar_AiPathFinder_EndNodeCheck;
 	result->FoundEndNode = AyStar_AiPathFinder_FoundEndNode;
 	result->GetNeighbours = AyStar_AiPathFinder_GetNeighbours;
+	
+	result->BeforeExit = NULL;
 
 	result->free = AyStar_AiPathFinder_Free;
 
Index: aircraft_gui.c
===================================================================
--- aircraft_gui.c	(revision 2447)
+++ aircraft_gui.c	(working copy)
@@ -14,6 +14,8 @@
 #include "engine.h"
 #include "viewport.h"
 #include "player.h"
+#include "economy.h"
+#include "network.h"
 #include "depot.h"
 
 /**
@@ -513,7 +515,7 @@
 						disabled = 0;
 		}
 
-		if (v->owner != _local_player)
+		if (!IsSisterCompany(v->owner,_local_player))
 			disabled |= 1<<8 | 1<<7;
 		w->disabled_state = disabled;
 
@@ -633,9 +635,8 @@
 	tile = w->window_number;
 
 	/* setup disabled buttons */
-	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7));
-
+	w->disabled_state = (IsSisterCompany(GetTileOwner(tile),_local_player)) ? 0 : ((1<<4)|(1<<7));
+	
 	/* determine amount of items for scroller */
 	num = 0;
 	FOR_ALL_VEHICLES(v) {
@@ -789,7 +790,9 @@
 		case 4:
 			if (!HASBIT(w->disabled_state, 4) &&
 					WP(w,traindepot_d).sel != INVALID_VEHICLE)	{
+
 				Vehicle *v;
+				byte backup = _current_player;
 
 				HandleButtonClick(w, 4);
 
@@ -799,8 +802,10 @@
 				_backup_orders_tile = v->tile;
 				BackupVehicleOrders(v, _backup_orders_data);
 
+				_current_player = v->owner;
 				if (!DoCommandP(v->tile, v->index, 0, NULL,  CMD_SELL_AIRCRAFT | CMD_MSG(STR_A01C_CAN_T_SELL_AIRCRAFT)))
 					_backup_orders_tile = 0;
+				_current_player = backup;
 			}
 			break;
 		default:
@@ -934,6 +939,16 @@
 		BuildVehicleList(vl, VEH_Aircraft, owner, station);
 		SortVehicleList(vl);
 
+		if (_local_player != owner){
+			if(IsWindowOfPrototype(w,_player_aircraft_widgets)){
+				w->disabled_state |= (1<<10);
+			}else{
+				w->disabled_state |= (1<<9);
+			}
+		}else{
+			w->disabled_state &= ~(1<<9);
+		}
+
 		SetVScrollCount(w, vl->list_length);
 
 		// disable 'Sort By' tooltip on Unsorted sorting criteria
@@ -1120,7 +1135,7 @@
 {
 	Window *w;
 
-	if (player == _local_player) {
+	if (IsSisterCompany(player,_local_player)) {
 		w = AllocateWindowDescFront(&_player_aircraft_desc, (station << 16) | player);
 	} else  {
 		w = AllocateWindowDescFront(&_other_player_aircraft_desc, (station << 16) | player);
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 2447)
+++ train_cmd.c	(working copy)
@@ -1,3 +1,4 @@
+
 #include "stdafx.h"
 #include "openttd.h"
 #include "debug.h"
@@ -15,7 +16,10 @@
 #include "engine.h"
 #include "player.h"
 #include "sound.h"
+#include "economy.h"
+#include "network.h"
 #include "depot.h"
+#include "debug.h"
 #include "waypoint.h"
 #include "vehicle_gui.h"
 
@@ -605,7 +609,7 @@
 	 * to the player. Doesn't matter if only the cost is queried */
 	if (!(flags & DC_QUERY_COST)) {
 		if (!IsTileDepotType(tile, TRANSPORT_RAIL)) return CMD_ERROR;
-		if (!IsTileOwner(tile, _current_player)) return CMD_ERROR;
+		if (!IsSisterCompany(GetTileOwner(tile),_current_player)) return CMD_ERROR;
 	}
 
 	_cmd_build_rail_veh_var1 = 0;
@@ -1316,14 +1320,94 @@
 	}
 }
 
+TileIndex GetVehicleTileOutOfTunnel(const Vehicle *v, bool reverse)
+{
+	TileIndex tile;
+	byte direction = (!reverse) ? v->direction >> 1 : _reverse_dir[v->direction >> 1];
+	TileIndexDiff delta = TileOffsByDir(direction);
+
+	if (v->u.rail.track != 0x40)
+		return v->tile;
+
+	for (tile = v->tile;; tile += delta) {
+		if (IsTileType(tile, MP_TUNNELBRIDGE) &&
+				(_map5[tile] & 0xF3) != (direction) &&
+				GetTileZ(tile) == v->z_pos)
+ 			break;
+ 	}
+ 	return tile;
+
+};
+
 static void ReverseTrainDirection(Vehicle *v)
 {
 	int l = 0, r = -1;
 	Vehicle *u;
+	TileIndex tile;
+	byte trackdir;
 
+	u = GetLastVehicleInChain(v);
+	tile = GetVehicleTileOutOfTunnel(u, false);
+	trackdir = _reverse_trackdir[GetVehicleTrackdir(u)];
+
+	if (PBSTileReserved(tile) & (1 << (trackdir&7))) {
+		NPFFindStationOrTileData fstd;
+		NPFFoundTargetData ftd;
+		
+		NPFFillWithOrderData(&fstd, v);
+
+		tile = GetVehicleTileOutOfTunnel(u, true);
+
+		DEBUG(pbs, 2) ("pbs: (%i) choose reverse (RV), tile:%x, trackdir:%i",v->unitnumber,  u->tile, trackdir);
+		ftd = NPFRouteToStationOrTile(tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+	
+		if (ftd.best_trackdir == 0xFF) {
+			DEBUG(pbs, 0) ("pbs: (%i) no nodes encountered (RV)", v->unitnumber);
+			CLRBIT(v->u.rail.flags, VRF_REVERSING);
+			return;
+		}
+
+    // we found a way out of the pbs block
+		if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED)) {
+				CLRBIT(v->u.rail.flags, VRF_REVERSING);
+				return;
+			}
+		}/* else {
+			CLRBIT(v->u.rail.flags, VRF_REVERSING);
+			return;
+		};*/
+	}/* else if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH) {
+		CLRBIT(v->u.rail.flags, VRF_REVERSING);
+		return;
+	}*/
+
+	tile = GetVehicleTileOutOfTunnel(v, false);
+	trackdir = GetVehicleTrackdir(v);
+
+	if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH) {
+		byte trackdir = GetVehicleTrackdir(v);
+		TileIndex tile = AddTileIndexDiffCWrap(v->tile, TileIndexDiffCByDir(_trackdir_to_exitdir[trackdir]));
+		uint32 ts;
+		assert(tile != INVALID_TILE);
+		ts = GetTileTrackStatus(tile, TRANSPORT_RAIL);
+		ts &= _trackdir_reaches_trackdirs[trackdir];
+		assert(ts != 0 && KillFirstBit2x64(ts) == 0);
+		trackdir = FindFirstBit2x64(ts); 
+		PBSClearPath(tile, trackdir);
+//		if (PBSTileReserved(v->tile) & v->u.rail.track)
+//			PBSReserveTrack(tile, trackdir & 7);
+		v->u.rail.pbs_status = PBS_STAT_NONE;
+	} else if (PBSTileReserved(tile) & (1 << (trackdir&7))) {
+		PBSClearPath(tile, trackdir);
+		if (v->u.rail.track != 0x40)
+			PBSReserveTrack(tile, trackdir & 7);
+	};
+
 	if (IsTileDepotType(v->tile, TRANSPORT_RAIL))
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
 
+
 	/* Check if we were approaching a rail/road-crossing */
 	{
 		TileIndex tile = v->tile;
@@ -1514,7 +1598,7 @@
 
 static bool TrainFindDepotEnumProc(uint tile, TrainFindDepotData *tfdd, int track, uint length, byte *state)
 {
-	if (IsTileType(tile, MP_RAILWAY) && IsTileOwner(tile, tfdd->owner)) {
+	if (IsTileType(tile, MP_RAILWAY) && (IsSisterCompany(GetTileOwner(tile), tfdd->owner) || _patches.shared_stations)) {
 		if ((_map5[tile] & ~0x3) == 0xC0) {
 			if (length < tfdd->best_length) {
 				tfdd->best_length = length;
@@ -1767,13 +1851,37 @@
 		}
 
 		v->load_unload_time_rem = 0;
+		
+		if (PBSIsPbsSegment(v->tile, v->direction)) {
+			byte trackdir = GetVehicleTrackdir(v);
+					//_track_direction_to_trackdir[FIND_FIRST_BIT(v->u.rail.track)][v->direction];
+			NPFFindStationOrTileData fstd;
+			NPFFoundTargetData ftd;
+			
+			if (PBSTileUnavail(v->tile) & (1 << trackdir))
+				return true;
 
+			NPFFillWithOrderData(&fstd, v);
+
+			DEBUG(pbs, 2) ("pbs: (%i) choose depot (DP), tile:%x, trackdir:%i",v->unitnumber,  v->tile, trackdir);
+			ftd = NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+
+			// we found a way out of the pbs block
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+				if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+					return true;
+				else
+					goto green;
+			}
+		}
+			
+		
 		if (UpdateSignalsOnSegment(v->tile, v->direction)) {
 			InvalidateWindowClasses(WC_TRAINS_LIST);
 			return true;
 		}
 	}
-
+green:
 	VehicleServiceInDepot(v);
 	InvalidateWindowClasses(WC_TRAINS_LIST);
 	TrainPlayLeaveStationSound(v);
@@ -1924,14 +2032,33 @@
 		NPFFindStationOrTileData fstd;
 		NPFFoundTargetData ftd;
 		byte trackdir;
+		uint16 pbs_tracks;
 
 		NPFFillWithOrderData(&fstd, v);
 		/* The enterdir for the new tile, is the exitdir for the old tile */
 		trackdir = GetVehicleTrackdir(v);
 		assert(trackdir != 0xff);
 
-		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner);
+		pbs_tracks = PBSTileReserved(tile);
+		pbs_tracks |= pbs_tracks << 8;
+		pbs_tracks &= _trackdir_reaches_trackdirs[trackdir];
+		if (pbs_tracks || (v->u.rail.pbs_status == PBS_STAT_NEED_PATH)) {
+			DEBUG(pbs, 2) ("pbs: (%i) choosefromblock, tile_org:%x tile_dst:%x  trackdir:%i  pbs_tracks:%i",v->unitnumber, tile,tile - TileOffsByDir(enterdir), trackdir, pbs_tracks);
 
+			// clear the currently planned path
+			if (v->u.rail.pbs_status != PBS_STAT_NEED_PATH) PBSClearPath(tile, FindFirstBit2x64(pbs_tracks));
+
+			// try to find a route to a green exit signal
+			ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+
+			// if no route found, find one to any exit signal
+/*			if (ftd.best_bird_dist != 0 || ftd.best_trackdir == 0xff) {
+				ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+				DEBUG(pbs, 1) ("pbs: (%i) no green sig found, PBS_MODE_ANY result:%i%i", v->index, ftd.best_bird_dist, ftd.best_trackdir);
+		}*/
+		} else
+			ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_NONE);
+
 		if (ftd.best_trackdir == 0xff) {
 			/* We are already at our target. Just do something */
 			//TODO: maybe display error?
@@ -2068,7 +2195,7 @@
 		assert(trackdir != 0xff);
 		assert(trackdir_rev != 0xff);
 
-		ftd = NPFRouteToStationOrTileTwoWay(v->tile, trackdir, last->tile, trackdir_rev, &fstd, TRANSPORT_RAIL, v->owner);
+		ftd = NPFRouteToStationOrTileTwoWay(v->tile, trackdir, last->tile, trackdir_rev, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_NONE);
 		if (ftd.best_bird_dist != 0) {
 			/* We didn't find anything, just keep on going straight ahead */
 			reverse_best = false;
@@ -2151,7 +2278,7 @@
 	// check if we've reached the waypoint?
 	if (v->current_order.type == OT_GOTO_WAYPOINT && v->tile == v->dest_tile) {
 		v->cur_order_index++;
-	}
+	}	
 
 	// check if we've reached a non-stop station while TTDPatch nonstop is enabled..
 	if (_patches.new_nonstop && v->current_order.flags & OF_NON_STOP &&
@@ -2320,6 +2447,9 @@
 			v->index,
 			0);
 	}
+	if (v->subtype == TS_Front_Engine) st->vehicles[STS_VEH_TRAIN].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
 
 	// Did we reach the final destination?
 	if (v->current_order.type == OT_GOTO_STATION &&
@@ -2443,7 +2573,7 @@
 		case MP_STREET:
 			// tracks over roads, do owner check of tracks (_map_owner[tile])
 			return
-				IsTileOwner(tile, v->owner) &&
+				(_patches.shared_tracks || IsSisterCompany(GetTileOwner(tile), v->owner)) &&
 				(v->subtype != TS_Front_Engine || (_map3_hi[tile] & 0xF) == v->u.rail.railtype);
 
 		default:
@@ -2451,7 +2581,7 @@
 	}
 
 	return
-		IsTileOwner(tile, v->owner) &&
+		(_patches.shared_tracks || IsSisterCompany(GetTileOwner(tile), v->owner)) &&
 		(v->subtype != TS_Front_Engine || (_map3_lo[tile] & 0xF) == v->u.rail.railtype);
 }
 
@@ -2597,6 +2727,8 @@
 			(v->u.rail.track & 0x40 && (v->direction & 2) != (realcoll->direction & 2)))
 		return;
 
+	//DEBUG(pbs,0) ("collision, %i-%i", v->index, coll->index);
+	//assert(0);
 	//two drivers + passangers killed in train v
 	num = 2 + CountPassengersInTrain(v);
 	if (!(coll->vehstatus & VS_CRASHED))
@@ -2664,7 +2796,7 @@
 				} else {
 					/* is not inside depot */
 
-					if (!TrainCheckIfLineEnds(v))
+					if ((prev == NULL) && (!TrainCheckIfLineEnds(v)))
 						return;
 
 					r = VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);
@@ -2719,11 +2851,63 @@
 				}
 
 				if (prev == NULL) {
+					byte trackdir;
 					/* Currently the locomotive is active. Determine which one of the
 					 * available tracks to choose */
 					chosen_track = 1 << ChooseTrainTrack(v, gp.new_tile, enterdir, bits);
 					assert(chosen_track & tracks);
 
+					trackdir = _track_enterdir_to_trackdir[FIND_FIRST_BIT(chosen_track)][enterdir];
+					assert(trackdir != 0xff);
+//					DEBUG(misc,0) ("chosen track (%i)  tile:%x  track:%i", v->unitnumber, gp.new_tile, chosen_track);
+					//assert(gp.new_tile < MapSize());
+					if (PBSIsPbsSignal(gp.new_tile,trackdir)) {
+						// encountered a pbs signal, and possible a pbs block
+						DEBUG(pbs, 3) ("pbs: (%i) arrive AT signal, tile:%x  pbs_stat:%i",v->unitnumber, gp.new_tile, v->u.rail.pbs_status);
+
+						if (v->u.rail.pbs_status == PBS_STAT_NONE) {
+							// we havent planned a path already, so try to find one now
+							NPFFindStationOrTileData fstd;
+							NPFFoundTargetData ftd;
+
+							NPFFillWithOrderData(&fstd, v);
+
+							if (v->unitnumber == 12) {
+								v->unitnumber--;
+								v->unitnumber++;
+							}
+
+
+							DEBUG(pbs, 2) ("pbs: (%i) choose signal (TC), tile:%x, trackdir:%i",v->unitnumber,  gp.new_tile, trackdir);
+							ftd = NPFRouteToStationOrTile(gp.new_tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+							//DEBUG(pbs, 2) ("pbs: (%i) choose signal (TC) done", v->unitnumber);
+
+							
+							if (v->u.rail.force_proceed != 0)
+								goto green_light;
+
+							if (ftd.best_trackdir == 0xFF)
+								goto red_light;
+							
+							// we found a way out of the pbs block
+							if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+								if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+									goto red_light;
+								else {
+									goto green_light;
+								}
+								
+							};
+
+						} else {
+							// we have already planned a path through this pbs block
+							// on entering the block, we reset our status
+							v->u.rail.pbs_status = PBS_STAT_NONE;
+							goto green_light;
+						};
+						DEBUG(pbs, 3) ("pbs: (%i) no green light found, or was no pbs-block",v->unitnumber);
+					};
+
 					/* Check if it's a red signal and that force proceed is not clicked. */
 					if ( (tracks>>16)&chosen_track && v->u.rail.force_proceed == 0) goto red_light;
 				} else {
@@ -2732,6 +2916,9 @@
 					/* The wagon is active, simply follow the prev vehicle. */
 					chosen_track = (byte)(_matching_tracks[GetDirectionToVehicle(prev, gp.x, gp.y)] & bits);
 				}
+green_light:
+				if (v->next == NULL)
+					PBSClearTrack(gp.old_tile, FIND_FIRST_BIT(v->u.rail.track));
 
 				/* make sure chosen track is a valid track */
 				assert(chosen_track==1 || chosen_track==2 || chosen_track==4 || chosen_track==8 || chosen_track==16 || chosen_track==32);
@@ -2759,8 +2946,20 @@
 					assert(v->u.rail.track);
 				}
 
-				if (v->subtype == TS_Front_Engine)
- 				TrainMovedChangeSignals(gp.new_tile, enterdir);
+				if (v->subtype == TS_Front_Engine) {
+ 					TrainMovedChangeSignals(gp.new_tile, enterdir);
+					if (v->current_order.type == OT_GOTO_WAYPOINT && v->tile == v->dest_tile) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[STS_WP_ORDER].this_month++;
+						wp->vehicles[STS_WP_ORDER_YEAR].this_month++;
+					} else if (IsRailWaypoint(_map5[v->tile])) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[STS_WP_PATHFIND].this_month++;
+						wp->vehicles[STS_WP_PATHFIND_YEAR].this_month++;
+					}
+				}	
 
 				/* Signals can only change when the first
 				 * (above) or the last vehicle moves. */
@@ -2880,6 +3079,16 @@
 	EndVehicleMove(v);
 	DeleteVehicle(v);
 
+	// clear up reserved pbs tracks
+	/*
+	if (PBSTileReserved(v->tile) & v->u.rail.track) {
+		if (v->tile != u->tile) {
+			PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
+		} else if (v == u) {
+		};
+	}
+	*/
+	
 	if (!(v->u.rail.track & 0xC0))
 		SetSignalsOnBothDir(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 
@@ -3007,6 +3216,7 @@
 	uint x,y;
 	int t;
 	uint32 ts;
+	byte trackdir;
 
 	if ((uint)(t=v->breakdown_ctr) > 1) {
 		v->vehstatus |= VS_TRAIN_SLOWING;
@@ -3045,6 +3255,11 @@
 	// determine the track status on the next tile.
 	ts = GetTileTrackStatus(tile, TRANSPORT_RAIL) & _reachable_tracks[t];
 
+	if (ts & 0x3F3F)
+		trackdir = FindFirstBit2x64(ts & 0x3F3F);
+	else
+		trackdir = 0xFF;
+
 	/* Calc position within the current tile ?? */
 	x = v->x_pos & 0xF;
 	y = v->y_pos & 0xF;
@@ -3097,6 +3312,40 @@
 		return false;
 	}
 
+	if  (v->u.rail.pbs_status == PBS_STAT_HAS_PATH)
+		return true;
+
+	if ((trackdir != 0xFF) && (PBSIsPbsSignal(tile,trackdir)) && !(IsTileType(v->tile, MP_STATION) && (v->current_order.station == _map2[v->tile]))) {
+		NPFFindStationOrTileData fstd;
+		NPFFoundTargetData ftd;
+
+		NPFFillWithOrderData(&fstd, v);
+
+		if (v->unitnumber == 55) {
+			trackdir--;
+			trackdir++;
+		}
+
+		DEBUG(pbs, 2) ("pbs: (%i) choose signal (CEOL), tile:%x  trackdir:%i", v->unitnumber, tile, trackdir);
+		ftd = NPFRouteToStationOrTile(tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+		DEBUG(pbs, 2) ("pbs: (%i) choose signal (CEOL) done", v->unitnumber);
+
+//		if ((ftd.best_bird_dist == 0) && NPFGetFlag(&ftd.node, NPF_FLAG_PBS_TRACK) && !NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED) && !NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED)) {
+//			v->u.rail.pbs_status = PBS_STAT_HAS_PATH;
+//			return true;
+//		};
+
+		if (ftd.best_trackdir != 0xFF && NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+			{;}
+			else {
+				v->u.rail.pbs_status = PBS_STAT_HAS_PATH;
+				return true;
+			}
+		};
+							
+	};
+
 	// slow down
 	v->vehstatus |= VS_TRAIN_SLOWING;
 	t = _breakdown_speeds[x & 0xF];
@@ -3184,6 +3433,9 @@
 	v->tick_counter++;
 
 	if (v->subtype == TS_Front_Engine) {
+//		if (v->unitnumber != 86) {
+//			v->vehstatus= VS_STOPPED;
+//		};
 		TrainLocoHandler(v, false);
 
 		// make sure vehicle wasn't deleted.
@@ -3257,6 +3509,12 @@
 	Depot *depot;
 	TrainFindDepotData tfdd;
 
+	if (PBSTileReserved(v->tile) & v->u.rail.track)
+		return;
+
+	if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH)
+		return;
+
 	if (_patches.servint_trains == 0)
 		return;
 
Index: table/sprites.h
===================================================================
--- table/sprites.h	(revision 2447)
+++ table/sprites.h	(working copy)
@@ -42,7 +42,7 @@
 	SPR_ASCII_SPACE_BIG   = 450,
 
 	/* Extra graphic spritenumbers */
-	SPR_CANALS_BASE		= 5126,
+	SPR_CANALS_BASE		= 5382,
 	SPR_SLOPES_BASE		= SPR_CANALS_BASE + 70,
 	SPR_AUTORAIL_BASE		= SPR_SLOPES_BASE + 78,
 	SPR_OPENTTD_BASE	= SPR_AUTORAIL_BASE + 55, // can be lowered once autorail.grf is finalized
Index: table/files.h
===================================================================
--- table/files.h	(revision 2447)
+++ table/files.h	(working copy)
@@ -26,7 +26,7 @@
 		{ "TRG1.GRF", {0x93,0x11,0x67,0x62,0x80,0xe5,0xb1,0x40,0x77,0xa8,0xee,0x41,0xc1,0xb4,0x21,0x92} },     //    0 - 4792 inclusive
 		{ "TRGI.GRF", {0xda,0x6a,0x6c,0x9d,0xcc,0x45,0x1e,0xec,0x88,0xd7,0x92,0x11,0x43,0x7b,0x76,0xa8} },     // 4793 - 4889 inclusive
 		{ "dosdummy.grf", {0x07,0x01,0xe6,0xc4,0x07,0x6a,0x5b,0xc3,0xf4,0x9f,0x01,0xad,0x21,0x6c,0xa0,0xc2} }, // 4890 - 4895 inclusive
-		{ "signalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5125 inclusive
+		{ "nsignalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5381 inclusive
 		{ NULL, { 0 } }
 	},
 	{	{ "TRGC.GRF", {0xed,0x44,0x66,0x37,0xe0,0x34,0x10,0x4c,0x55,0x59,0xb3,0x2c,0x18,0xaf,0xe7,0x8d} },
@@ -39,7 +39,7 @@
 	{
 		{ "TRG1R.GRF", {0xb0,0x4c,0xe5,0x93,0xd8,0xc5,0x01,0x6e,0x07,0x47,0x3a,0x74,0x3d,0x7d,0x33,0x58} },    //    0 - 4792 inclusive
 		{ "TRGIR.GRF", {0x0c,0x24,0x84,0xff,0x6b,0xe4,0x9f,0xc6,0x3a,0x83,0xbe,0x6a,0xb5,0xc3,0x8f,0x32} },    // 4793 - 4895 inclusive
-		{ "signalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5125 inclusive
+		{ "nsignalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5381 inclusive
 		{ NULL, { 0 } },
 		{ NULL, { 0 } }
 	},
Index: road_cmd.c
===================================================================
--- road_cmd.c	(revision 2447)
+++ road_cmd.c	(working copy)
@@ -1,5 +1,6 @@
 #include "stdafx.h"
 #include "openttd.h"
+#include "table/sprites.h"
 #include "table/strings.h"
 #include "map.h"
 #include "tile.h"
@@ -11,7 +12,9 @@
 #include "gfx.h"
 #include "npf.h"
 #include "sound.h"
+#include "economy.h"
 #include "depot.h"
+#include "pbs.h"
 
 /* When true, GetTrackStatus for roads will treat roads under reconstruction
  * as normal roads instead of impassable. This is used when detecting whether
@@ -86,7 +89,19 @@
 	// Only do the special processing if the road is owned
 	// by a town
 	if (owner != OWNER_TOWN) {
-		return owner == OWNER_NONE || CheckOwnership(owner);
+		if(owner == OWNER_NONE || (!_patches.allow_track_removal && owner == _current_player)){
+			return true;
+		}
+		if(_patches.allow_track_removal && IsSisterCompany(owner,_current_player)){
+			return true;
+		}
+		if(!DEREF_PLAYER(owner)->is_active){
+			return true;
+		}
+
+		_error_message = STR_013B_OWNED_BY;
+		GetNameOfOwner(owner, 0);
+		return false;
 	}
 
 	if (_cheats.magic_bulldozer.value)
@@ -247,6 +262,7 @@
 
 			cost = _price.remove_road * 2;
 			if (flags & DC_EXEC) {
+				byte pbs_track = PBSTileReserved(tile);
 				ChangeTownRating(t, -road_remove_cost[(byte)edge_road], RATING_ROAD_MINIMUM);
 
 				ModifyTile(tile,
@@ -255,6 +271,8 @@
 					_map3_hi[tile] & 0xF, /* map3_lo */
 					c											/* map5 */
 				);
+				if (pbs_track != 0)
+					PBSReserveTrack(tile, FIND_FIRST_BIT(pbs_track));
 			}
 			return cost;
 		} else
@@ -355,6 +373,7 @@
 	int32 cost;
 	byte pieces = (byte)p1, existing = 0;
 	TileIndex tile;
+	
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
@@ -397,6 +416,7 @@
 			goto do_clear;
 
 		if (flags & DC_EXEC) {
+			byte pbs_track = PBSTileReserved(tile);
 			ModifyTile(tile,
 				MP_SETTYPE(MP_STREET) |
 				MP_MAP2 | MP_MAP3LO | MP_MAP3HI | MP_MAP5,
@@ -405,6 +425,8 @@
 				_map3_lo[tile] & 0xF, /* map3_hi */
 				m5 /* map5 */
 			);
+			if (pbs_track != 0)
+				PBSReserveTrack(tile, FIND_FIRST_BIT(pbs_track));
 		}
 		return _price.build_road * 2;
 	} else if (ti.type == MP_TUNNELBRIDGE) {
@@ -663,7 +685,7 @@
 
 static int32 RemoveRoadDepot(uint tile, uint32 flags)
 {
-	if (!CheckTileOwnership(tile) && _current_player != OWNER_WATER)
+	if ((!CheckTileOwnership(tile) && !(_patches.allow_track_removal && IsSisterCompany(_current_player, GetTileOwner(tile))))&& _current_player != OWNER_WATER)
 		return CMD_ERROR;
 
 	if (!EnsureNoVehicle(tile))
@@ -827,6 +849,20 @@
 		}
 
 		DrawGroundSprite(image + (_map3_hi[ti->tile] & 0xF) * 12);
+
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & RAIL_BIT_DIAG1) DrawGroundSprite((0x3ED) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_DIAG2) DrawGroundSprite((0x3EE) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_UPPER) DrawGroundSprite((0x3EF) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LOWER) DrawGroundSprite((0x3F0) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LEFT)  DrawGroundSprite((0x3F2) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_RIGHT) DrawGroundSprite((0x3F1) | PALETTE_CRASH);
+}
+#endif
+
 	} else {
 		uint32 ormod;
 		int player;
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 2447)
+++ rail_cmd.c	(working copy)
@@ -16,35 +16,15 @@
 #include "station.h"
 #include "sprite.h"
 #include "depot.h"
+#include "pbs.h"
 #include "waypoint.h"
+#include "npf.h"
+#include "economy.h"
 
 extern uint16 _custom_sprites_base;
 
 void ShowTrainDepotWindow(uint tile);
 
-enum { /* These values are bitmasks for the map5 byte */
-	RAIL_TYPE_NORMAL = 0,
-	RAIL_TYPE_SIGNALS = 0x40,
-	RAIL_TYPE_SPECIAL = 0x80, // If this bit is set, then it's not a regular track.
-	RAIL_TYPE_DEPOT = 0xC0,
-	RAIL_TYPE_MASK = 0xC0,
-
-	RAIL_BIT_DIAG1 = 1,  // 0
-	RAIL_BIT_DIAG2 = 2,  // 1
-	RAIL_BIT_UPPER = 4,  // 2
-	RAIL_BIT_LOWER = 8,  // 3
-	RAIL_BIT_LEFT  = 16, // 4
-	RAIL_BIT_RIGHT = 32, // 5
-	RAIL_BIT_MASK = 0x3F,
-
-	RAIL_DEPOT_TRACK_MASK = 1,
-	RAIL_DEPOT_DIR = 3,
-
-	RAIL_SUBTYPE_MASK     = 0x3C,
-	RAIL_SUBTYPE_DEPOT    = 0x00,
-	RAIL_SUBTYPE_WAYPOINT = 0x04
-};
-
 static inline bool IsRailDepot(byte m5)
 {
 	return
@@ -340,7 +320,7 @@
 				return CMD_ERROR;
 			}
 			if (m5 & RAIL_TYPE_SPECIAL ||
-					!IsTileOwner(tile, _current_player) ||
+					!(_patches.shared_tracks || IsSisterCompany(GetTileOwner(tile),_current_player)) ||
 					(_map3_lo[tile] & 0xFU) != p1) {
 				// Get detailed error message
 				return DoCommandByTile(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
@@ -443,7 +423,9 @@
 	if (!((1<<ti.type) & ((1<<MP_TUNNELBRIDGE)|(1<<MP_STREET)|(1<<MP_RAILWAY))))
 		return CMD_ERROR;
 
-	if (_current_player != OWNER_WATER && !CheckTileOwnership(tile))
+	if (_current_player != OWNER_WATER &&
+				((_patches.allow_track_removal && !CheckSubsidiaryTileOwnership(tile)) ||
+				(!_patches.allow_track_removal && !CheckTileOwnership(tile))))
 		return CMD_ERROR;
 
 	// allow building rail under bridge
@@ -779,9 +761,16 @@
 			} else {
 				if (pre_signal) {
 					// cycle between normal -> pre -> exit -> combo -> ...
-					byte type = (_map3_hi[tile] + 1) & 0x03;
-					_map3_hi[tile] &= ~0x03;
-					_map3_hi[tile] |= type;
+					// TODO: fix up this hacky mess :-p
+					byte type = (_map3_hi[tile] & 0x03) + ((_map3_hi[tile] & 0x08) >> 1);
+					DEBUG(pbs, 0) ("change signals, type:%i", type);
+					++type;
+					if (type == 5)
+						type = 0;
+					_map3_hi[tile] &= ~0x0B;
+					_map3_hi[tile] |= type & 0x03;
+					type <<= 1;
+					_map3_hi[tile] |= type & 0x08;
 				} else {
 					// cycle between two-way -> one-way -> one-way -> ...
 					switch (track) {
@@ -933,7 +922,10 @@
 		return CMD_ERROR;
 
 	/* Only water can remove signals from anyone */
-	if (_current_player != OWNER_WATER && !CheckTileOwnership(tile)) return CMD_ERROR;
+	if (_current_player != OWNER_WATER && 
+				((_patches.allow_track_removal && !CheckSubsidiaryTileOwnership(tile)) ||
+				(!_patches.allow_track_removal && !CheckTileOwnership(tile))))
+			return CMD_ERROR;
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
@@ -1069,7 +1061,8 @@
 		if (m5 & RAIL_TYPE_SPECIAL)
 			return_cmd_error(STR_2004_BUILDING_MUST_BE_DEMOLISHED);
 
-		if (!IsTileOwner(tile, _current_player))
+		if ((_patches.allow_track_removal && !IsSisterCompany(GetTileOwner(tile), _current_player)) ||
+			 (!_patches.allow_track_removal && !IsTileOwner(tile, _current_player)))
 			return_cmd_error(STR_1024_AREA_IS_OWNED_BY_ANOTHER);
 
 		return_cmd_error(STR_1008_MUST_REMOVE_RAILROAD_TRACK);
@@ -1132,7 +1125,7 @@
 #include "table/track_land.h"
 
 // used for presignals
-static const SpriteID _signal_base_sprites[16] = {
+static const SpriteID _signal_base_sprites[32] = {
 	0x4FB,
 	0x1323,
 	0x1333,
@@ -1144,16 +1137,41 @@
 	0x1373,
 	0x1383,
 
+	// pbs
+	0x1393,
+	0x13A3,  // not used (yet?)
+	0x13B3,  // not used (yet?)
+	0x13C3,  // not used (yet?)
+
+	// pbs + sema
+	0x13D3,
+	0x13E3,  // not used (yet?)
+	0x13F3,  // not used (yet?)
+	0x1403,  // not used (yet?)
+
+
 	// mirrored versions
 	0x4FB,
 	0x1323,
 	0x1333,
 	0x1343,
 
-	0x13C6,
-	0x13D6,
-	0x13E6,
-	0x13F6,
+	0x1446,
+	0x1456,
+	0x1466,
+	0x1476,
+
+	// pbs
+	0x1393,
+	0x13A3,  // not used (yet?)
+	0x13B3,  // not used (yet?)
+	0x13C3,  // not used (yet?)
+
+	// pbs + sema
+	0x14C6,
+	0x14D6,  // not used (yet?)
+	0x14E6,  // not used (yet?)
+	0x14F6,  // not used (yet?)
 };
 
 // used to determine the side of the road for the signal
@@ -1171,7 +1189,7 @@
 	uint v = _signal_position[(image_and_pos & 0xF) + (otherside ? 12 : 0)];
 	uint x = ti->x | (v&0xF);
 	uint y = ti->y | (v>>4);
-	uint sprite = _signal_base_sprites[(_map3_hi[ti->tile] & 7) + (otherside ? 8 : 0)] + (image_and_pos>>4) + ((condition != 0) ? 1 : 0);
+	uint sprite = _signal_base_sprites[(_map3_hi[ti->tile] & 15) + (otherside ? 16 : 0)] + (image_and_pos>>4) + ((condition != 0) ? 1 : 0);
 	AddSortableSpriteToDraw(sprite, x, y, 1, 1, 10, GetSlopeZ(x,y));
 }
 
@@ -1382,6 +1400,19 @@
 			if (m5 & RAIL_BIT_RIGHT) DrawGroundSprite(0x3F1 + tracktype_offs);
 		}
 
+#ifdef PBS_SHOW_RESERVED
+		{
+			byte pbs = PBSTileReserved(ti->tile);
+			assert(pbs != 0xFF);
+			if (pbs & RAIL_BIT_DIAG1) DrawGroundSprite((0x3ED + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & RAIL_BIT_DIAG2) DrawGroundSprite((0x3EE + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & RAIL_BIT_UPPER) DrawGroundSprite((0x3EF + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & RAIL_BIT_LOWER) DrawGroundSprite((0x3F0 + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & RAIL_BIT_LEFT)  DrawGroundSprite((0x3F2 + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & RAIL_BIT_RIGHT) DrawGroundSprite((0x3F1 + tracktype_offs) | PALETTE_CRASH);
+		}
+#endif
+
 		if (_display_opt & DO_FULL_DETAIL) {
 			_detailed_track_proc[_map2[ti->tile] & RAIL_MAP2LO_GROUND_MASK](ti);
 		}
@@ -1488,6 +1519,19 @@
 
 		DrawGroundSprite(image);
 
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & RAIL_BIT_DIAG1) DrawGroundSprite((0x3ED + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_DIAG2) DrawGroundSprite((0x3EE + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_UPPER) DrawGroundSprite((0x3EF + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LOWER) DrawGroundSprite((0x3F0 + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_LEFT)  DrawGroundSprite((0x3F2 + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & RAIL_BIT_RIGHT) DrawGroundSprite((0x3F1 + tracktype_offs) | PALETTE_CRASH);
+}
+#endif
+
 		while ((image=drss->image) != 0) {
 			DrawSpecialBuilding(image, type < 4 ? tracktype_offs : 0, ti,
 			                    drss->subcoord_x, drss->subcoord_y, 0,
@@ -1582,6 +1626,26 @@
 	return false;
 }
 
+static bool SetSignalsEnumProcPBS(uint tile, SetSignalsData *ssd, int track, uint length, byte *state)
+{
+	// the tile has signals?
+	if (IsTileType(tile, MP_RAILWAY)) {
+		if ((_map5[tile]&RAIL_TYPE_MASK) == RAIL_TYPE_SIGNALS) {
+			if ((_map3_lo[tile] & _signals_table_both[track]) != 0) {
+
+				if (ssd->cur != NUM_SSD_ENTRY) {
+					ssd->tile[ssd->cur] = tile; // remember the tile index
+					ssd->bit[ssd->cur] = track & 7; // and the controlling bit number
+					ssd->cur++;
+				}
+				return true;
+			}
+		} else if (IsRailDepot(_map5[tile]))
+			return true; // don't look further if the tile is a depot
+	}
+	return false;
+}
+
 /* Struct to parse data from VehicleFromPos to SignalVehicleCheckProc */
 typedef struct SignalVehicleCheckStruct {
 	TileIndex tile;
@@ -1790,6 +1854,30 @@
 	return (bool)result;
 }
 
+bool PBSIsPbsSegment(uint tile, byte direction)
+{
+	SetSignalsData ssd;
+	bool result = false;
+	int i;
+
+	ssd.cur_stack = 0;
+	direction>>=1;
+
+	ssd.cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
+	ssd.has_presignal = false;
+
+	FollowTrack(tile, 0xC000 | TRANSPORT_RAIL, direction, (TPFEnumProc*)SetSignalsEnumProcPBS, SetSignalsAfterProc, &ssd);
+	for(i=0; i!=ssd.cur; i++) {
+		uint tile = ssd.tile[i];
+		byte bit = ssd.bit[i];
+		if (!PBSIsPbsSignal(tile, bit) && !PBSIsPbsSignal(tile, bit | 8))
+			return false;
+		result = true;
+	};
+	
+	return result;
+}
+
 void SetSignalsOnBothDir(uint tile, byte track)
 {
 	static const byte _search_dir_1[6] = {1, 3, 1, 3, 5, 3};
@@ -1993,8 +2081,7 @@
 	if (IsRailDepot(_map5[tile]))
 		ShowTrainDepotWindow(tile);
 	else if (IsRailWaypoint(_map5[tile]))
-		ShowRenameWaypointWindow(GetWaypointByTile(tile));
-
+		ShowWaypointStatsWindow(GetWaypointByTile(tile));
 }
 
 static void GetTileDesc_Track(TileIndex tile, TileDesc *td)
@@ -2078,6 +2165,8 @@
 	} else if (_fractcoords_enter[dir] == fract_coord) {
 		if (_enter_directions[dir] == v->direction) {
 			/* enter the depot */
+			if (v->next == NULL)
+				PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 			v->u.rail.track = 0x80,
 			v->vehstatus |= VS_HIDDEN; /* hide it */
 			v->direction ^= 4;
Index: vehicle.c
===================================================================
--- vehicle.c	(revision 2447)
+++ vehicle.c	(working copy)
@@ -14,6 +14,7 @@
 #include "player.h"
 #include "engine.h"
 #include "sound.h"
+#include "economy.h"
 #include "debug.h"
 #include "npf.h"
 #include "vehicle_gui.h"
@@ -1416,7 +1417,7 @@
 	/* Check if there is money for the upgrade.. if not, give a nice news-item
 	    (that is needed, because this CMD is called automaticly) */
 	if ( DEREF_PLAYER(v->owner)->money64 < (int32)(autorefit_money + build_cost + rear_engine_cost - v->value)) {
-		if (( _local_player == v->owner ) && ( v->unitnumber != 0 )) {  //v->unitnumber = 0 for train cars
+		if (IsSisterCompany(v->owner,_local_player) && ( v->unitnumber != 0 )) {  //v->unitnumber = 0 for train cars
 			int message;
 			SetDParam(0, v->unitnumber);
 			switch (v->type) {
@@ -1915,8 +1916,9 @@
 	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,flags), SLE_UINT8, 2, 255),
 	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,days_since_order_progr), SLE_UINT16, 2, 255),
 
-	// reserve extra space in savegame here. (currently 13 bytes)
-	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 13, 2, 255),
+	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,pbs_status), SLE_UINT8, 2, 255),
+	// reserve extra space in savegame here. (currently 12 bytes)
+	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 12, 2, 255),
 
 	SLE_END()
 };
Index: vehicle.h
===================================================================
--- vehicle.h	(revision 2447)
+++ vehicle.h	(working copy)
@@ -67,6 +67,8 @@
 	byte railtype;
 
 	byte flags;
+
+	byte pbs_status;
 } VehicleRail;
 
 enum {
@@ -140,7 +142,7 @@
 
 struct Vehicle {
 	byte type;	// type, ie roadven,train,ship,aircraft,special
-	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)(Filled with values from EffectVehicles or TrainSubTypes)
+	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)
 
 	VehicleID index;	// NOSAVE: Index in vehicle array
 
Index: misc.c
===================================================================
--- misc.c	(revision 2447)
+++ misc.c	(working copy)
@@ -547,6 +547,7 @@
 void TownsMonthlyLoop(void);
 void IndustryMonthlyLoop(void);
 void StationMonthlyLoop(void);
+void WaypointMonthlyLoop(void);
 
 void PlayersYearlyLoop(void);
 void TrainsYearlyLoop(void);
@@ -655,6 +656,7 @@
 		TownsMonthlyLoop();
 		IndustryMonthlyLoop();
 		StationMonthlyLoop();
+		WaypointMonthlyLoop();
 #ifdef ENABLE_NETWORK
 		if (_network_server)
 			NetworkServerMonthlyLoop();
Index: player_gui.c
===================================================================
--- player_gui.c	(revision 2447)
+++ player_gui.c	(working copy)
@@ -17,9 +17,15 @@
 #include "network_client.h"
 #endif
 
+extern void DrawPlayerIcon(int p, int x, int y);
+extern Player *DoStartupNewPlayer(bool is_ai);
+
+static uint64 _subsidiaries_money_amount = 0;
+static byte _subsidiaries_money_target = 0;
+void ShowSubsidiariesManagement(void);
+
 static void DoShowPlayerFinances(int player, bool show_small, bool show_stickied);
 
-
 static void DrawPlayerEconomyStats(Player *p, byte mode)
 {
 	int x,y,i,j,year;
@@ -95,6 +101,259 @@
 	DrawStringRightAligned(182, y, STR_7028, 0);
 }
 
+static const Widget _ask_merge_subsidiaries_widgets[] = {
+{    WWT_TEXTBTN,    RESIZE_NONE,	4,     0,    10,     0,    13, STR_00C5,			STR_NULL},
+{    WWT_CAPTION,    RESIZE_NONE,	4,    11,   179,     0,    13, STR_SUBSIDIARY_ASK_MERGER_TITLE,	STR_NULL},
+{     WWT_IMGBTN,    RESIZE_NONE,	4,     0,   179,    14,    91, 0x0,						STR_NULL},
+{    WWT_TEXTBTN,    RESIZE_NONE,	12,    25,    84,    72,    83, STR_00C9_NO,		STR_NULL},
+{    WWT_TEXTBTN,    RESIZE_NONE,	12,    95,   154,    72,    83, STR_00C8_YES,	STR_NULL},
+{   WIDGETS_END},
+};
+
+static void AskMergeSubsidiariesWndProc(Window *w, WindowEvent *e) {
+	int i = 0;
+	WindowClass clss;
+	WindowNumber n;
+	Player *p;
+	Player *local;
+
+	p = DEREF_PLAYER(w->window_number);
+	local = DEREF_PLAYER(_local_player);
+
+	switch(e->event) {
+	case WE_PAINT:
+		DrawWindowWidgets(w);
+
+		if((GetMotherCompany(DEREF_PLAYER(_local_player)) == w->window_number)){
+			SetDParam(0, local->name_1);
+			SetDParam(1, local->name_2);
+
+			SetDParam(2, p->name_1);
+			SetDParam(3, p->name_2);
+		}else{
+			SetDParam(0, p->name_1);
+			SetDParam(1, p->name_2);
+
+			SetDParam(2, local->name_1);
+			SetDParam(3, local->name_2);
+		}
+
+		DrawStringMultiCenter(0x5A, 0x26, STR_SUBSIDIARY_ASK_MERGER, 178);
+		return;
+
+	case WE_CLICK:
+		switch(e->click.widget) {
+
+			case 3:
+				DeleteWindowById(WC_SUBSIDIARIES_ASK_MERGER, w->window_number);
+				break;
+
+			case 4:
+	do_merger:;
+				/* Ugly hack to go around the w pointer modification during DoAcquireCompany() calls */
+				clss = w->window_class;
+				n = w->window_number;
+
+				if((GetMotherCompany(DEREF_PLAYER(_local_player)) == w->window_number)){
+					i = _current_player;
+					_current_player = w->window_number;
+					_local_player = w->window_number;
+					DoAcquireCompany(DEREF_PLAYER(i));
+				}else{
+					DoAcquireCompany(DEREF_PLAYER(w->window_number));
+				}
+
+				DeleteWindowById(clss,n);
+				break;
+			}
+		break;
+
+	case WE_KEYPRESS: /* Perform the merger on pressing 'Enter' */
+		if (e->keypress.keycode == WKC_RETURN)
+			goto do_merger;
+		break;
+	}
+}
+
+static const Widget _ask_send_money_widgets[] = {
+{    WWT_TEXTBTN,	RESIZE_NONE,     4,     0,    10,     0,    13, STR_00C5,			STR_NULL},
+{    WWT_CAPTION,   RESIZE_NONE,	 4,    11,   179,     0,    13, STR_SUBSIDIARY_CASH_REQUEST,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,	4,     0,   179,    14,    91, 0x0,						STR_NULL},
+{    WWT_TEXTBTN,   RESIZE_NONE,	12,    25,    84,    72,    83, STR_00C9_NO,		STR_NULL},
+{    WWT_TEXTBTN,   RESIZE_NONE,	12,    95,   154,    72,    83, STR_00C8_YES,	STR_NULL},
+{   WIDGETS_END},
+};
+
+static const Widget _ask_sell_share_widgets[] = {
+{    WWT_TEXTBTN,	RESIZE_NONE,     4,     0,    10,     0,    13, STR_00C5,			STR_NULL},
+{    WWT_CAPTION,   RESIZE_NONE,	 4,    11,   179,     0,    13, STR_SUBSIDIARY_SELL_SHARE_TITLE,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,	4,     0,   179,    14,    91, 0x0,						STR_NULL},
+{    WWT_TEXTBTN,   RESIZE_NONE,	12,    25,    84,    72,    83, STR_00C9_NO,		STR_NULL},
+{    WWT_TEXTBTN,   RESIZE_NONE,	12,    95,   154,    72,    83, STR_00C8_YES,	STR_NULL},
+{   WIDGETS_END},
+};
+
+int32 _ask_send_money_amount;
+
+static void AskSellShareWndProc(Window *w, WindowEvent *e) {
+	/* Unused Variable	int i = 0;	*/
+	WindowClass clss;
+	WindowNumber n;
+	Player *p;
+	Player *local;
+
+	p = DEREF_PLAYER(w->window_number);
+	local = DEREF_PLAYER(_local_player);
+
+	/* Ugly hack to go around the w pointer modification during DoAcquireCompany() calls */
+	clss = w->window_class;
+	n = w->window_number;
+
+	switch(e->event) {
+	case WE_PAINT:
+		DrawWindowWidgets(w);
+
+		SetDParam(0, p->name_1);
+		SetDParam(1, p->name_2);
+
+		SetDParam(2, _ask_send_money_amount);
+
+		DrawStringMultiCenter(0x5A, 0x26, STR_SUBSIDIARY_SELL_SHARE, 178);
+		return;
+
+	case WE_CLICK:
+		switch(e->click.widget) {
+
+			case 3:
+				DoCommandP(0, n, 0, NULL, CMD_SUBSIDIARY_BUY_SHARE_RESPONSE | CMD_MSG(STR_SUBSIDIARY_GET_ERROR));
+				DeleteWindowById(clss, n);
+				break;
+
+			case 4:
+	do_send:;
+				DoCommandP(0, n, 1, NULL, CMD_SUBSIDIARY_BUY_SHARE_RESPONSE | CMD_MSG(STR_SUBSIDIARY_GET_ERROR));
+				DeleteWindowById(clss,n);
+				break;
+			}
+		break;
+
+	case WE_KEYPRESS: /* Perform the merger on pressing 'Enter' */
+		if (e->keypress.keycode == WKC_RETURN)
+			goto do_send;
+		break;
+	}
+}
+
+static void AskSendMoneyWndProc(Window *w, WindowEvent *e) {
+	/* Unused Variable	int i = 0;	*/
+	WindowClass clss;
+	WindowNumber n;
+	Player *p;
+	Player *local;
+
+	p = DEREF_PLAYER(w->window_number);
+	local = DEREF_PLAYER(_local_player);
+
+	/* Ugly hack to go around the w pointer modification during DoAcquireCompany() calls */
+	clss = w->window_class;
+	n = w->window_number;
+
+	switch(e->event) {
+	case WE_PAINT:
+		DrawWindowWidgets(w);
+
+		SetDParam(0, p->name_1);
+		SetDParam(1, p->name_2);
+
+		SetDParam(2, _ask_send_money_amount);
+
+		DrawStringMultiCenter(0x5A, 0x26, STR_SUBSIDIARY_CASH_REQUESTED, 178);
+		return;
+
+	case WE_CLICK:
+		switch(e->click.widget) {
+
+			case 3:
+				DoCommandP(0, n, -1, NULL, CMD_SUBSIDIARY_SEND_MONEY_ON_REQUEST | CMD_MSG(STR_SUBSIDIARY_GET_ERROR));
+				DeleteWindowById(clss, n);
+				break;
+
+			case 4:
+	do_send:;
+				DoCommandP(0, n, _ask_send_money_amount, NULL, CMD_SUBSIDIARY_SEND_MONEY_ON_REQUEST | CMD_MSG(STR_SUBSIDIARY_GET_ERROR));
+
+				DeleteWindowById(clss,n);
+				break;
+			}
+		break;
+
+	case WE_KEYPRESS: /* Perform the merger on pressing 'Enter' */
+		if (e->keypress.keycode == WKC_RETURN)
+			goto do_send;
+		break;
+	}
+}
+
+static const WindowDesc _ask_merge_subsidiaries_desc = {
+	WDP_CENTER, WDP_CENTER, 180, 92,
+	WC_SUBSIDIARIES_ASK_MERGER,0,
+	WDF_STD_TOOLTIPS | WDF_DEF_WIDGET | WDF_STD_BTN | WDF_UNCLICK_BUTTONS,
+	_ask_merge_subsidiaries_widgets,
+	AskMergeSubsidiariesWndProc
+};
+
+void AskMergeSubsidiaries(byte player)
+{
+	AllocateWindowDescFront(&_ask_merge_subsidiaries_desc, player);
+}
+
+static const WindowDesc _ask_send_money_desc = {
+	WDP_CENTER, WDP_CENTER, 180, 92,
+	WC_SUBSIDIARIES_ASK_MERGER,0,
+	WDF_STD_TOOLTIPS | WDF_DEF_WIDGET | WDF_STD_BTN | WDF_UNCLICK_BUTTONS,
+	_ask_send_money_widgets,
+	AskSendMoneyWndProc
+};
+
+void AskSendMoney(byte player, int32 amount)
+{
+	_ask_send_money_amount = amount;
+	AllocateWindowDescFront(&_ask_send_money_desc, player);
+}
+
+static const WindowDesc _ask_sell_share_desc = {
+	WDP_CENTER, WDP_CENTER, 180, 92,
+	WC_SUBSIDIARIES_ASK_MERGER,0,
+	WDF_STD_TOOLTIPS | WDF_DEF_WIDGET | WDF_STD_BTN | WDF_UNCLICK_BUTTONS,
+	_ask_sell_share_widgets,
+	AskSellShareWndProc
+};
+
+void AskSellShare(byte player)
+{
+	AllocateWindowDescFront(&_ask_sell_share_desc, player);
+}
+
+static const Widget _subsidiary_send_money[] = {
+{    WWT_TEXTBTN,    RESIZE_NONE,	14,     0,    10,     0,    13, STR_00C5,											STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,    RESIZE_NONE,	14,    11,   319,     0,    13, STR_SUBSIDIARY_SEND_TO,				STR_018C_WINDOW_TITLE_DRAG_THIS},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,		 0,   319,    14,    72, 0x0,														STR_NULL},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,     0,   159,    73,    84, STR_SUBSIDIARY_ADD_CASH,				STR_SUBSIDIARY_ADD_CASH_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   160,   319,    73,    84, STR_SUBSIDIARY_SUB_CASH,				STR_SUBSIDIARY_SUB_CASH_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   182,   317,    16,    27, STR_SUBSIDIARIES_SEND_MONEY,		STR_SUBSIDIARIES_SEND_MONEY_E},
+{   WIDGETS_END},
+};
+
+static const Widget _subsidiary_request_money[] = {
+{    WWT_TEXTBTN,    RESIZE_NONE,	14,     0,    10,     0,    13, STR_00C5,											STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,    RESIZE_NONE,	14,    11,   319,     0,    13, STR_SUBSIDIARY_REQUEST_FROM,		STR_018C_WINDOW_TITLE_DRAG_THIS},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     0,   319,    14,    72, 0x0,														STR_NULL},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,     0,   159,    73,    84, STR_SUBSIDIARY_ADD_CASH,				STR_SUBSIDIARY_ADD_CASH_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   160,   319,    73,    84, STR_SUBSIDIARY_SUB_CASH,				STR_SUBSIDIARY_SUB_CASH_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   182,   317,    16,    27, STR_SUBSIDIARIES_REQUEST_MONEY,STR_SUBSIDIARIES_REQUEST_MONEY_E},
+{   WIDGETS_END},
+};
+
 static const Widget _player_finances_widgets[] = {
 {    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,					STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   379,     0,    13, STR_700E_FINANCES,	STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -139,7 +398,103 @@
 {   WIDGETS_END},
 };
 
+static void SubsidiaryMoneyTransferWndProc(Window *w, WindowEvent *e)
+{
+	Player *p = DEREF_PLAYER(_subsidiaries_money_target);
 
+	switch(e->event){
+		case WE_PAINT:
+
+			SetDParam(0, p->name_1);
+			SetDParam(1, p->name_2);
+			SetDParam(2, GetPlayerNameString(p->index, 3));
+			SetDParam(3, 10000);
+
+			w->caption_color = _local_player;
+
+			DrawWindowWidgets(w);
+
+			DrawString(10, 32, STR_SUBSIDIARY_TARGET_HAS, 0);
+			SetDParam64(0, p->player_money);
+			DrawStringRightAligned(315, 32, STR_SUBSIDIARY_AMOUNT_TARGET, 0);
+
+			DrawString(10, 46, STR_SUBSIDIARY_SEND_AMOUNT, 0);
+			DrawString(10, 60, STR_SUBSIDIARY_REQUEST_AMOUNT, 0);
+			SetDParam64(0, _subsidiaries_money_amount);
+			DrawStringRightAligned(315, 46, STR_SUBSIDIARY_AMOUNT_SEND, 0);
+			SetDParam64(0,  _subsidiaries_money_amount - (_subsidiaries_money_amount / 16));
+			DrawStringRightAligned(315, 60, STR_SUBSIDIARY_AMOUNT_GET, 0);
+
+			break;
+
+		case WE_CLICK:
+			switch(e->click.widget){
+			case 3:{ /* Increase amount */
+					uint64 oldAmount = _subsidiaries_money_amount;
+					if(_shift_pressed){
+						_subsidiaries_money_amount += 100000;
+					}else if(_ctrl_pressed){
+						_subsidiaries_money_amount *= 2;
+					}else{
+						_subsidiaries_money_amount += 10000;
+					}
+					if(_subsidiaries_money_amount > 0x7FFFFFFFFFFFFFFFL)
+						_subsidiaries_money_amount = oldAmount;
+
+					SetWindowDirty(w);
+					}break;
+
+				case 4:{ /* Decrease amount */
+					uint64 oldAmount = _subsidiaries_money_amount;
+					if(_shift_pressed){
+						_subsidiaries_money_amount -= 100000;
+					}else if(_ctrl_pressed){
+						_subsidiaries_money_amount /= 2;
+					}else{
+						_subsidiaries_money_amount -= 10000;
+					}
+					if(_subsidiaries_money_amount > 0x7FFFFFFFFFFFFFFFL)
+						_subsidiaries_money_amount = oldAmount;
+					SetWindowDirty(w);
+					}break;
+
+				case 5:{/* Perform transaction */
+					WindowNumber wn = w->window_number;
+					Player *me = DEREF_PLAYER(_local_player);
+
+					if(IsWindowOfPrototype(w,_subsidiary_send_money)){
+						if(!DoCommandP(0,_subsidiaries_money_target,_subsidiaries_money_amount, NULL, CMD_SUBSIDIARY_SEND_MONEY | CMD_MSG(STR_SUBSIDIARY_GET_ERROR))){
+							SetDParam(0,_subsidiaries_money_amount);
+							ShowErrorMessage(STR_0003_NOT_ENOUGH_CASH_REQUIRES, STR_SUBSIDIARY_GET_ERROR, 0,0);
+						}
+					}else{
+						if(!_networking){
+							// don't ask for getting money
+							_current_player = p->index;
+							if(!DoCommandP(0, _local_player, _subsidiaries_money_amount, NULL, CMD_SUBSIDIARY_SEND_MONEY | CMD_MSG(STR_SUBSIDIARY_GET_ERROR))){
+								SetDParam(0,_subsidiaries_money_amount);
+								ShowErrorMessage(STR_0003_NOT_ENOUGH_CASH_REQUIRES, STR_SUBSIDIARY_GET_ERROR, 0,0);
+							}
+							_current_player = _local_player;
+						}else{
+							// ask target company if it allows to get money
+							DoCommandP(0, p->index, _subsidiaries_money_amount,NULL, CMD_SUBSIDIARY_GET_MONEY);
+						}
+
+					}
+					DeleteWindowById(WC_SUBSIDIARIES_MONEY, wn);
+					}break;
+			}
+			break;
+
+		case WE_MOUSELOOP:
+			/* redraw the window every now and then */
+			if ((++w->vscroll.pos & 0x1F) == 0)
+				SetWindowDirty(w);
+			break;
+	}
+}
+
 static void PlayerFinancesWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -148,10 +503,19 @@
 
 		w->disabled_state = p->current_loan != 0 ? 0 : (1 << 7);
 
+		if(( _patches.subsidiaries && !_networking && (GetMotherCompany(p) != p->index || _local_player != GetMotherCompany(p))) ||
+			(((_patches.subsidiaries && _networking) || !_patches.subsidiaries) && _local_player != p->index)){
+			w->disabled_state |= 0x1 << 6;
+			if(p->current_loan <= 0 || _local_player != p->index){
+				w->disabled_state |= 0x1 << 7;
+			}
+		}
+
 		SetDParam(0, p->name_1);
 		SetDParam(1, p->name_2);
 		SetDParam(2, GetPlayerNameString((byte)w->window_number, 3));
 		SetDParam(4, 10000);
+
 		DrawWindowWidgets(w);
 
 		DrawPlayerEconomyStats(p, (byte)WP(w,def_d).data_1);
@@ -221,7 +585,8 @@
 	Window *w;
 	int mode;
 
-	mode = ((byte)player != _local_player)*2 + show_small;
+	mode = (!IsSisterCompany((byte)player,_local_player))*2 + show_small;
+
 	w = AllocateWindowDescFront( desc_table[mode], player);
 	if (w) {
 		w->caption_color = w->window_number;
@@ -296,6 +661,30 @@
 	}
 }
 
+static const WindowDesc _subsidiary_send_money_desc = {
+	-1,-1,  320, 85,
+	WC_SUBSIDIARIES_MONEY,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_RESTORE_DPARAM | WDF_UNCLICK_BUTTONS,
+	_subsidiary_send_money,
+	SubsidiaryMoneyTransferWndProc
+};
+
+static const WindowDesc _subsidiary_request_money_desc = {
+	-1,-1,  320, 85,
+	WC_SUBSIDIARIES_MONEY,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_RESTORE_DPARAM | WDF_UNCLICK_BUTTONS,
+	_subsidiary_request_money,
+	SubsidiaryMoneyTransferWndProc
+};
+
+static void ShowSubsidiaryMoneyTransfer(byte player, bool send){
+	Window *w;
+	_subsidiaries_money_target = player;
+	_subsidiaries_money_amount = 0;
+
+	w = AllocateWindowDescFront( send ? &_subsidiary_send_money_desc : &_subsidiary_request_money_desc, GetMotherCompany(DEREF_PLAYER(player)));
+}
+
 static const Widget _select_player_color_widgets[] = {
 {    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   149,     0,    13, STR_7007_NEW_COLOR_SCHEME, STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -377,7 +766,8 @@
 {      WWT_EMPTY,   RESIZE_NONE,    14,     0,   355,    32,    43, 0x0,                     STR_NULL},
 {      WWT_EMPTY,   RESIZE_NONE,    14,     0,   355,    32,    43, 0x0,                     STR_NULL},
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   266,   355,   138,   149, STR_COMPANY_PASSWORD,    STR_COMPANY_PASSWORD_TOOLTIP},
-{   WIDGETS_END},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,	14,   266,   355,    32,    43, STR_SUBSIDIARIES,			STR_SUBSIDIARIES_MANAGEMENT},
+{WIDGETS_END},
 };
 
 static const Widget _other_player_company_widgets[] = {
@@ -408,19 +798,51 @@
 {      WWT_EMPTY,   RESIZE_NONE,    14,     0,   355,    32,    43, 0x0,                     STR_NULL},
 {      WWT_EMPTY,   RESIZE_NONE,    14,     0,   355,    32,    43, 0x0,                     STR_NULL},
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   266,   355,   138,   149, STR_COMPANY_PASSWORD,    STR_COMPANY_PASSWORD_TOOLTIP},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,	14,   266,   355,    46,    57, STR_SUBSIDIARIES,			STR_SUBSIDIARIES_MANAGEMENT},
 {   WIDGETS_END},
 };
 
+static Widget _subsidiary_management_widgets[] = {
+{    WWT_TEXTBTN,    RESIZE_NONE,	14,     0,    10,     0,    13, STR_00C5,					STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,    RESIZE_NONE,	14,    11,   379,     0,    13, STR_YOUR_SUBSIDIARIES,		STR_018C_WINDOW_TITLE_DRAG_THIS},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     0,   379,    14,   120, 0x0,								STR_NULL},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,    16,    27, 0x0,STR_SUBSIDIARY_TOGGLE},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,    35,    46, 0x0,STR_SUBSIDIARY_TOGGLE},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,    47,    58, 0x0,STR_SUBSIDIARY_TOGGLE},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,    59,    70, 0x0,STR_SUBSIDIARY_TOGGLE},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,    71,    82, 0x0,STR_SUBSIDIARY_TOGGLE},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,    83,    94, 0x0,STR_SUBSIDIARY_TOGGLE},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,    95,   106, 0x0,STR_SUBSIDIARY_TOGGLE},
+{     WWT_IMGBTN,    RESIZE_NONE,	14,     2,   247,   107,   118, 0x0,STR_SUBSIDIARY_TOGGLE},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   264,   377,    18,    29, STR_SUBSIDIARIES_ADMINISTRATE,		STR_SUBSIDIARIES_ADMINISTRATE_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   264,   377,    32,    43, STR_SUBSIDIARIES_SEND_MONEY,			STR_SUBSIDIARIES_SEND_MONEY_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   264,   377,    46,    57, STR_SUBSIDIARIES_REQUEST_MONEY,	STR_SUBSIDIARIES_REQUEST_MONEY_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   264,   377,    60,    71, STR_SUBSIDIARIES_MERGER,					STR_SUBSIDIARIES_MERGER_E},
+{ WWT_PUSHTXTBTN,    RESIZE_NONE,	14,   264,   377,   107,   118, STR_SUBSIDIARY_CREATE,						STR_SUBSIDIARY_CREATE_E},
+{   WIDGETS_END},
+};
+
+static void SubsidiaryManagementWndProc(Window *w, WindowEvent *e);
+
+static const WindowDesc _subsidiary_management_desc = {
+	-1,-1, 380, 121,
+	WC_SUBSIDIARIES,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
+	_subsidiary_management_widgets,
+	SubsidiaryManagementWndProc
+};
+
 static void DrawPlayerVehiclesAmount(int player)
 {
 	const int x = 110;
 	int y = 72;
 	Vehicle *v;
-	uint train,road,air,ship;
+	uint train,road,air,ship, subtrain, subroad, subair, subship;
 
 	DrawString(x, y, STR_7039_VEHICLES, 0);
 
 	train = road = air = ship = 0;
+	subtrain = subair = subroad = subship = 0;
 
 	FOR_ALL_VEHICLES(v) {
 		if (v->owner == player) {
@@ -436,6 +858,19 @@
 				ship++;
 			}
 		}
+		if(IsSisterCompany(v->owner, player)){
+			if (v->type == VEH_Train) {
+				if (v->subtype == TS_Front_Engine)
+					subtrain++;
+			} else if (v->type == VEH_Road) {
+				subroad++;
+			} else if (v->type == VEH_Aircraft) {
+				if (v->subtype <= 2)
+					subair++;
+			} else if (v->type == VEH_Ship) {
+				subship++;
+			}
+		}
 	}
 
 	if (train+road+air+ship == 0) {
@@ -443,25 +878,49 @@
 	} else {
 		if (train != 0) {
 			SetDParam(0, train);
-			DrawString(x + 70, y, train==1 ? STR_703A_TRAIN : STR_703B_TRAINS, 0);
+			if(_patches.subsidiaries && subtrain > 0){
+				SetDParam(1, subtrain);
+				SetDParam(2, (uint16)(((double)train / (double)subtrain) * 100 + 0.5));
+				DrawString(x + 70, y, train==1 ? STR_703A_TRAIN_SUB : STR_703B_TRAINS_SUB, 0);
+			}else{
+				DrawString(x + 70, y, train==1 ? STR_703A_TRAIN : STR_703B_TRAINS, 0);
+			}
 			y += 10;
 		}
 
 		if (road != 0) {
 			SetDParam(0, road);
-			DrawString(x + 70, y, road==1 ? STR_703C_ROAD_VEHICLE : STR_703D_ROAD_VEHICLES, 0);
+			if(_patches.subsidiaries && subroad > 0){
+				SetDParam(1, subroad);
+				SetDParam(2, (uint16)(((double)road / (double)subroad) * 100 + 0.5));
+				DrawString(x + 70, y, road==1 ? STR_703C_ROAD_VEHICLE_SUB : STR_703D_ROAD_VEHICLES_SUB, 0);
+			}else{
+				DrawString(x + 70, y, road==1 ? STR_703C_ROAD_VEHICLE : STR_703D_ROAD_VEHICLES, 0);
+			}
 			y += 10;
 		}
 
 		if (air != 0) {
 			SetDParam(0, air);
-			DrawString(x + 70, y, air==1 ? STR_703E_AIRCRAFT : STR_703F_AIRCRAFT, 0);
+			if(_patches.subsidiaries && subair > 0){
+				SetDParam(1, subair);
+				SetDParam(2, (uint16)(((double)air / (double)subair) * 100 + 0.5));
+				DrawString(x + 70, y, air==1 ? STR_703E_AIRCRAFT_SUB : STR_703F_AIRCRAFT_SUB, 0);
+			}else{
+				DrawString(x + 70, y, air==1 ? STR_703E_AIRCRAFT : STR_703F_AIRCRAFT, 0);
+			}
 			y += 10;
 		}
 
 		if (ship != 0) {
 			SetDParam(0, ship);
-			DrawString(x + 70, y, ship==1 ? STR_7040_SHIP : STR_7041_SHIPS, 0);
+			if(_patches.subsidiaries && subship > 0){
+				SetDParam(1, subship);
+				SetDParam(2, (uint16)(((double)ship / (double)subship) * 100 + 0.5));
+				DrawString(x + 70, y, ship==1 ? STR_7040_SHIP_SUB : STR_7041_SHIPS_SUB, 0);
+			}else{
+				DrawString(x + 70, y, ship==1 ? STR_7040_SHIP : STR_7041_SHIPS, 0);
+			}
 		}
 	}
 }
@@ -480,21 +939,30 @@
 	Player *p2;
 	int amt;
 
-	FOR_ALL_PLAYERS(p2) {
-		if ((amt=GetAmountOwnedBy(p, p2->index)) != 0) {
-			num++;
 
-			SetDParam(num*3+0, amt*25);
-			SetDParam(num*3+1, p2->name_1);
-			SetDParam(num*3+2, p2->name_2);
+	if(_patches.subsidiaries && GetMotherCompany(p) != p->index){
+		SetDParam(0,DEREF_PLAYER(GetMotherCompany(p))->name_1);
+		SetDParam(1,DEREF_PLAYER(GetMotherCompany(p))->name_2);
 
-			if (num != 0)
-				break;
+		DrawString(120, 124, STR_SUBSIDIARY_OF, 0);
+
+	}else{
+		FOR_ALL_PLAYERS(p2) {
+			if ((amt=GetAmountOwnedBy(p, p2->index)) != 0) {
+				num++;
+
+				SetDParam(num*3+0, amt*25);
+				SetDParam(num*3+1, p2->name_1);
+				SetDParam(num*3+2, p2->name_2);
+
+				if (num != 0)
+					break;
+			}
 		}
+
+		if (num >= 0)
+			DrawString(120, 124, STR_707D_OWNED_BY+num, 0);
 	}
-
-	if (num >= 0)
-		DrawString(120, 124, STR_707D_OWNED_BY+num, 0);
 }
 
 static void PlayerCompanyWndProc(Window *w, WindowEvent *e)
@@ -504,10 +972,19 @@
 		Player *p = DEREF_PLAYER(w->window_number);
 		uint32 dis = 0;
 
+		if (_patches.subsidiaries && IsWindowOfPrototype(w, _other_player_company_widgets) && GetMotherCompany(p) != p->index && IsSisterCompany(_local_player,p->index)){
+			DeleteWindowById(WC_COMPANY, w->window_number);
+			ShowPlayerCompany(p->index);
+			return;
+		}
+
 		if (!IsWindowOfPrototype(w, _other_player_company_widgets)) {
 			AssignWidgetToWindow(w, (p->location_of_house != 0) ? _my_player_company_bh_widgets : _my_player_company_widgets);
 
-			if (!_networking) SETBIT(w->hidden_state, 11); // hide company-password widget
+			if (!_networking || (_networking && _patches.subsidiaries && _local_player != p->index)) SETBIT(w->hidden_state, 11); // hide company-password widget
+			if (!_patches.subsidiaries) w->hidden_state |= (1 << 12); // hide subsidiairies widget
+			if (_networking && _patches.subsidiaries && _local_player != p->index) dis |= 0xF << 3;
+
 		} else {
 			if (p->location_of_house == 0) SETBIT(dis, 7);
 
@@ -515,8 +992,11 @@
 				/* If all shares are owned by someone (none by nobody), disable buy button */
 				if (GetAmountOwnedBy(p, OWNER_SPECTATOR) == 0) SETBIT(dis, 9);
 
-				/* Only 25% left to buy. If the player is human, disable buying it up.. TODO issues! */
-				if (GetAmountOwnedBy(p, OWNER_SPECTATOR) == 1 && !p->is_ai) SETBIT(dis, 9);
+				/* We can buy out real players in a network game only if subsidiairies are enabled*/
+				/* and target company isn't already part of a sub group (except if it's the mother company)*/
+				if ((GetAmountOwnedBy(p, OWNER_SPECTATOR) == 1 && !p->is_ai && !_patches.subsidiaries) ||
+					(_patches.subsidiaries && (IsSisterCompany(_local_player,p->index) || GetMotherCompany(p) != p->index)))
+					SETBIT(dis, 9);
 
 				/* If the player doesn't own any shares, disable sell button */
 				if (GetAmountOwnedBy(p, _local_player) == 0) SETBIT(dis, 10);
@@ -531,6 +1011,18 @@
 		SetDParam(1, p->name_2);
 		SetDParam(2, GetPlayerNameString((byte)w->window_number, 3));
 
+		if(_patches.subsidiaries && IsSubsidiary(p) && (DEREF_PLAYER(_local_player) != p)){
+			if(IsWindowOfPrototype(w, _my_player_company_widgets))
+				dis |= 1 << 7;
+			else
+				dis |= 1 << 8;
+			}
+
+		if(_patches.subsidiaries && (GetMotherCompany(p) != p->index)){
+			dis |= 1 <<10;
+			dis |= 1 << 9;
+		}
+
 		w->disabled_state = dis;
 		DrawWindowWidgets(w);
 
@@ -622,6 +1114,11 @@
 			}
 			#endif
 		}	break;
+
+		case 12: /* Manage Subsidiaries */
+			if(_patches.subsidiaries)
+				ShowSubsidiariesManagement();
+			break;
 		}
 
 	case WE_MOUSELOOP:
@@ -642,6 +1139,7 @@
 	case WE_DESTROY:
 		DeleteWindowById(WC_PLAYER_COLOR, w->window_number);
 		DeleteWindowById(WC_PLAYER_FACE, w->window_number);
+		DeleteWindowById(WC_SUBSIDIARIES, GetMotherCompany(DEREF_PLAYER(w->window_number)));
 		break;
 
 	case WE_ON_EDIT_TEXT: {
@@ -669,7 +1167,182 @@
 	}
 }
 
+static void SubsidiaryManagementWndProc(Window *w, WindowEvent *e)
+{
+	int i = 0;
+	int selected = -1;
+	Player *selectedPlayer;
+	Player *p;
 
+	switch(e->event) {
+	case WE_PAINT: {
+
+		w->caption_color = _local_player;
+
+		w->disabled_state = 0;
+		if((GetSubsidiariesCount() <= 1) || ((w->click_state & 0x7F8) == 0))
+			w->disabled_state = 0xF << 11;
+
+		// disable create new sub in network mode
+		if(_networking)
+			w->disabled_state |= (1 << 15) | (1 << 14) | (1 << 11);
+
+		DrawWindowWidgets(w);
+
+		// highlight commanded company
+		if(_local_player == GetMotherCompany(DEREF_PLAYER(_local_player))){
+			DrawFrameRect(2, 16, 247, 27, 5, 0x60);
+		}else{
+			FOR_ALL_PLAYERS(p) {
+				if(_local_player == p->index){
+					DrawFrameRect(2, 35+i*12, 247, 46+i*12, 5, 0x60);
+					break;
+				}
+				if(IsSubsidiary(p) && p->index != GetMotherCompany(p) && p->is_active)
+					i++;
+			}
+		}
+
+		p = DEREF_PLAYER(GetMotherCompany(DEREF_PLAYER(_local_player)));
+
+		DrawPlayerIcon(p->index, 4, 18);
+
+		SetDParam(0, p->name_1);
+		SetDParam(1, p->name_2);
+		SetDParam(2, GetPlayerNameString(p->index, 3));
+		DrawString(21,17,STR_7021, !HASBIT(w->click_state >> 3, 0) ? 0x10 : 0xC);
+
+		i = 0;
+		FOR_ALL_PLAYERS(p) {
+			if (!p->is_active || !IsSubsidiary(p) || p->index == GetMotherCompany(DEREF_PLAYER(_local_player)))
+				continue;
+
+			DrawPlayerIcon(p->index, 4, 37+i*12);
+
+			SetDParam(0, p->name_1);
+			SetDParam(1, p->name_2);
+			SetDParam(2, GetPlayerNameString(p->index, 3));
+			DrawString(21,36+i*12,STR_7021, !HASBIT(w->click_state >> 3, i+1) ? 0x10 : 0xC);
+			i++;
+		}
+
+	} break;
+
+	case WE_CLICK:
+		if (IS_INT_INSIDE(e->click.widget, 3, 3+GetSubsidiariesCount())) {
+			i = 1;
+
+			FOR_ALL_PLAYERS(p){
+				if(_local_player == p->index){
+					if(GetMotherCompany(DEREF_PLAYER(_local_player)) == _local_player)
+						i = 0;
+					break;
+				}
+				if(GetMotherCompany(DEREF_PLAYER(_local_player)) == p->index)
+					continue;
+				if(IsSubsidiary(p) && p->is_active)
+					i++;
+			}
+			if(i+3 != e->click.widget){
+				int old_state = w->click_state;
+				w->click_state &= ((0xFFFFFFFF >> 11) << 11) & 0x7;
+				w->click_state ^= (1 << (e->click.widget));
+				if(old_state == w->click_state)
+					w->click_state &= ((0xFFFFFFFF >> 11) << 11) & 0x7;
+				SetWindowDirty(w);
+			}
+
+		}else{
+			// determin selected Subsidiary, if any
+			for(i = 3; i < (3+GetSubsidiariesCount());i++){
+				if(HASBIT(w->click_state , i)){
+					selected = i-3;
+				}
+			}
+
+			//determin selected player
+			i = 0;
+			if(selected == 0){
+				selectedPlayer = DEREF_PLAYER(GetMotherCompany(DEREF_PLAYER(_local_player)));
+			}else{
+				i = 1;
+				FOR_ALL_PLAYERS(selectedPlayer) {
+					if (!selectedPlayer->is_active || !IsSubsidiary(selectedPlayer) || (GetMotherCompany(DEREF_PLAYER(_local_player)) == selectedPlayer->index))
+						continue;
+
+					if (i == selected) break;
+					i++;
+				}
+			}
+
+			switch(e->click.widget){
+				case 11: /* Administrate */
+					p = DEREF_PLAYER(_local_player);
+					w->click_state &= ((0xFFFFFFFF >> 11) << 11) & 0x7;
+					_local_player = selectedPlayer->index;
+					MarkWholeScreenDirty();
+					break;
+
+				case 12: /* Send Money */
+					DeleteWindowById(WC_SUBSIDIARIES_MONEY, w->window_number);
+					ShowSubsidiaryMoneyTransfer(selectedPlayer->index, true);
+					w->click_state &= ((0xFFFFFFFF >> 11) << 11) & 0x7;
+					SetWindowDirty(w);
+					break;
+
+				case 13: /* Request Money */
+					DeleteWindowById(WC_SUBSIDIARIES_MONEY, w->window_number);
+					ShowSubsidiaryMoneyTransfer(selectedPlayer->index, false);
+					w->click_state &= ((0xFFFFFFFF >> 11) << 11) & 0x7;
+					SetWindowDirty(w);
+					break;
+
+				case 14: /* Merger */
+					AskMergeSubsidiaries(selectedPlayer->index);
+					w->click_state &= ((0xFFFFFFFF >> 11) << 11) & 0x7;
+					SetWindowDirty(w);
+					break;
+
+				case 15:{/* Create */
+					Player *newp;
+					int i = 0;
+					newp = DoStartupNewPlayer(false);
+					if(newp == 0){
+						ShowErrorMessage(STR_SUBSIDIARY_PLAYER_ERROR, STR_TOO_MANY_PLAYERS, 0,0);
+						break;
+					}
+
+					newp->money64 = newp->player_money = newp->current_loan = 0;
+					for(i = 0; i < 4; i++){
+						newp->share_owners[i] = w->window_number;
+					}
+					ShowPlayerCompany(newp->index);
+					w->click_state &= ((0xFFFFFFFF >> 11) << 11) & 0x7;
+					MarkWholeScreenDirty();
+					}break;
+
+			}
+			//clear the selection
+		}
+
+		break;
+
+	case WE_MOUSELOOP:
+		/* redraw the window every now and then */
+		if ((++w->vscroll.pos & 0x1F) == 0)
+			SetWindowDirty(w);
+		break;
+
+	case WE_DESTROY: /* Destroy side windows */
+		DeleteWindowById(WC_SUBSIDIARIES_MONEY, w->window_number);
+		break;
+	}
+}
+
+void ShowSubsidiariesManagement(void){
+	AllocateWindowDescFront(&_subsidiary_management_desc ,  ((Player*)DEREF_PLAYER(GetMotherCompany(DEREF_PLAYER(_local_player))))->index);
+}
+
 static const WindowDesc _my_player_company_desc = {
 	-1,-1, 360, 170,
 	WC_COMPANY,0,
@@ -689,13 +1362,11 @@
 void ShowPlayerCompany(int player)
 {
 	Window *w;
-	w = AllocateWindowDescFront((byte)player == _local_player ? &_my_player_company_desc : &_other_player_company_desc,  player);
+	w = AllocateWindowDescFront(((IsSisterCompany(player, _local_player) && _patches.subsidiaries) || (!_patches.subsidiaries && (byte)player == _local_player)) ? &_my_player_company_desc : &_other_player_company_desc,  player);
 	if (w)
 		w->caption_color = w->window_number;
 }
 
-
-
 static void BuyCompanyWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
Index: water_cmd.c
===================================================================
--- water_cmd.c	(revision 2447)
+++ water_cmd.c	(working copy)
@@ -11,6 +11,7 @@
 #include "news.h"
 #include "sound.h"
 #include "depot.h"
+#include "economy.h"
 #include "vehicle_gui.h"
 
 static void FloodVehicle(Vehicle *v);
@@ -81,7 +82,7 @@
 {
 	uint tile2;
 
-	if (!CheckTileOwnership(tile))
+	if (!CheckTileOwnership(tile) && !(_patches.allow_track_removal && IsSisterCompany(_current_player, GetTileOwner(tile))))
 		return CMD_ERROR;
 
 	if (!EnsureNoVehicle(tile))
Index: economy.c
===================================================================
--- economy.c	(revision 2447)
+++ economy.c	(working copy)
@@ -73,6 +73,74 @@
 	MarkTileDirtyByTile(tile + TILE_XY(1,1));
 }
 
+int32 GetSubsidiaries(void)
+{
+	int64 list = 0;
+	int i = 0;
+	Player *p;
+
+	FOR_ALL_PLAYERS(p){
+		if(p->is_active && IsSubsidiary(p)){
+			list |= 1 << i;
+		}
+		i++;
+	}
+
+	return list;
+}
+
+/* Can be used even if _patches.subsidiaries is false */
+byte GetMotherCompany(Player *p)
+{
+	int i;
+
+	for(i=1;p->share_owners[i] == p->share_owners[0];) {
+		if (++i == 4 && p->share_owners[0] != 0xFF) {
+			return p->share_owners[0];
+		}
+	}
+
+	return p->index;
+}
+
+bool IsSisterCompanyIgnorePatch(byte c1, byte c2){
+	if(c1 > MAX_PLAYERS || c2 > MAX_PLAYERS)
+			return false;
+	return GetMotherCompany(DEREF_PLAYER(c1)) == GetMotherCompany(DEREF_PLAYER(c2));
+}
+
+bool IsSisterCompany(byte c1, byte c2)
+{
+	if (!_patches.subsidiaries){
+		return c1 == c2;
+	}else{
+		if(c1 > MAX_PLAYERS || c2 > MAX_PLAYERS)
+			return false;
+		return GetMotherCompany(DEREF_PLAYER(c1)) == GetMotherCompany(DEREF_PLAYER(c2));
+	}
+}
+
+bool IsSubsidiary(Player *p)
+{
+	byte playerOwner = GetMotherCompany(DEREF_PLAYER(_local_player));
+	byte paramOwner = GetMotherCompany(p);
+
+	return (playerOwner == paramOwner);
+}
+
+byte GetSubsidiariesCount(void)
+{
+	Player *p;
+	int count = 0;
+
+	FOR_ALL_PLAYERS(p){
+		if(p->is_active && IsSubsidiary(p))
+			count++;
+	}
+
+	return count;
+}
+
 int64 CalculateCompanyValue(Player *p) {
 	byte owner = p->index;
 	int64 value;
@@ -1362,6 +1430,9 @@
 				unloading_time += v->cargo_count; /* TTDBUG: bug in original TTD */
 				profit += DeliverGoods(v->cargo_count, v->cargo_type, v->cargo_source, last_visited, v->cargo_days);
 				result |= 1;
+				ge->cargo_amount[STS_AMOUNT_IN].this_month += v->cargo_count;
+                if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 				v->cargo_count = 0;
 			} else if (u->current_order.flags & ( OF_UNLOAD | OF_TRANSFER) ) {
 				/* unload goods and let it wait at the station */
@@ -1375,6 +1446,9 @@
 
 				v_profit_total += v_profit;
 
+				ge->cargo_amount[STS_AMOUNT_TRANSFER].this_month += v->cargo_count;
+                if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 
 				unloading_time += v->cargo_count;
 				if ((t=ge->waiting_acceptance & 0xFFF) == 0) {
@@ -1443,6 +1517,11 @@
 			ge->waiting_acceptance -= cap;
 			v->profit_this_year -= feeder_profit_share;
 			ge->feeder_profit -= feeder_profit_share;
+
+			ge->cargo_amount[STS_AMOUNT_OUT].this_month += cap;
+			if (ge->months_counted == 0) ge->months_counted = 1;
+			InvalidateWindow(WC_STATION_STATS, st->index);
+
 			unloading_time += cap;
 			st->time_since_load = 0;
 
@@ -1451,11 +1530,60 @@
 			v->cargo_days = ge->enroute_time;
 			result |= 2;
 			st->last_vehicle = v->index;
+
+			// And tax the vehicle if the cargo was picked up at another player's station
+			if(u->owner != st->owner){
+				int32 tax = 0;
+				byte backup = _current_player;
+				if(IsSisterCompany(u->owner, st->owner)){
+					tax = _patches.shared_stations_pickuptax_subsidiary;
+				}else if(_patches.shared_stations){
+					tax = _patches.shared_stations_pickuptax_others;
+				}
+
+				_current_player = u->owner;
+				switch(u->type){
+					case VEH_Train: SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN); break;
+					case VEH_Road: SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN); break;
+					case VEH_Ship: SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN); break;
+					case VEH_Aircraft: SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN); break;
+					default: SET_EXPENSES_TYPE(EXPENSES_OTHER); break;
+				}
+				u->profit_this_year -= cap * tax / 2;
+				SubtractMoneyFromPlayer(cap * tax / 2);
+
+				_current_player = st->owner;
+				SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
+				SubtractMoneyFromPlayer(-(int32)(cap * tax / 2));
+
+				if(v->owner != GetTileOwner(v->tile)){
+
+					_current_player = u->owner;
+					switch(v->type){
+						case VEH_Train: SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN); break;
+						case VEH_Road: SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN); break;
+						case VEH_Ship: SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN); break;
+						case VEH_Aircraft: SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN); break;
+						default: SET_EXPENSES_TYPE(EXPENSES_OTHER); break;
+					}
+					SubtractMoneyFromPlayer(cap * tax / 2);
+					u->profit_this_year -= cap * tax / 2;
+
+					_current_player = GetTileOwner(u->tile);
+					SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
+					SubtractMoneyFromPlayer(-(int32)(cap * tax / 2));
+				}
+
+				_current_player = backup;
+			}
 		}
 	}
 
 
 	v = u;
+	
+	if (v_profit_total > 0)
+		ShowFeederIncomeAnimation(v->x_pos, v->y_pos, v->z_pos, v_profit_total);
 
 	if (v_profit_total > 0)
 		ShowFeederIncomeAnimation(v->x_pos, v->y_pos, v->z_pos, v_profit_total);
@@ -1483,9 +1611,61 @@
 			InvalidateWindow(WC_STATION_VIEW, last_visited);
 
 		if (profit != 0) {
+			switch(v->type){
+				case VEH_Train: SET_EXPENSES_TYPE(EXPENSES_TRAIN_INC); break;
+				case VEH_Road: SET_EXPENSES_TYPE(EXPENSES_ROADVEH_INC); break;
+				case VEH_Ship: SET_EXPENSES_TYPE(EXPENSES_SHIP_INC); break;
+				case VEH_Aircraft: SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_INC); break;
+				default: SET_EXPENSES_TYPE(EXPENSES_OTHER); break;
+			}
 			v->profit_this_year += profit;
 			SubtractMoneyFromPlayer(-profit);
 
+			if(v->owner != st->owner){
+				byte curr = _current_player;
+				byte tax = 0;
+
+				if(IsSisterCompany(v->owner, st->owner)){
+					tax = _patches.shared_stations_tax;
+				}else if(_patches.shared_stations){
+					tax = _patches.shared_stations_tax_others;
+				}
+
+				switch(v->type){
+					case VEH_Train: SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN); break;
+					case VEH_Road: SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN); break;
+					case VEH_Ship: SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN); break;
+					case VEH_Aircraft: SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN); break;
+					default: SET_EXPENSES_TYPE(EXPENSES_OTHER); break;
+				}
+				SubtractMoneyFromPlayer(profit * tax / 200);
+				v->profit_this_year -= profit * tax / 200;
+
+				_current_player = st->owner;
+				SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
+				SubtractMoneyFromPlayer(-profit * tax / 200);
+				_current_player = curr;
+
+				if(v->owner != GetTileOwner(v->tile)){
+					curr = _current_player;
+
+					switch(v->type){
+						case VEH_Train: SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN); break;
+						case VEH_Road: SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN); break;
+						case VEH_Ship: SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN); break;
+						case VEH_Aircraft: SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN); break;
+						default: SET_EXPENSES_TYPE(EXPENSES_OTHER); break;
+					}
+					SubtractMoneyFromPlayer(profit * tax / 200);
+					v->profit_this_year -= profit* tax / 200;
+
+					_current_player = GetTileOwner(v->tile);
+					SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
+					SubtractMoneyFromPlayer(-profit * tax / 200);
+					_current_player = curr;
+				}
+			}
+
 			if (_current_player == _local_player)
 				SndPlayVehicleFx(SND_14_CASHTILL, v);
 
@@ -1509,7 +1689,7 @@
 	SubsidyMonthlyHandler();
 }
 
-static void DoAcquireCompany(Player *p)
+void DoAcquireCompany(Player *p)
 {
 	Player *owner;
 	int i,pi;
@@ -1545,8 +1725,128 @@
 	RebuildVehicleLists();	//Updates the open windows to add the newly acquired vehicles to the lists
 }
 
+extern void ShowErrorMessage(StringID msg_1, StringID msg_2, int x, int y);
+
+int32 CmdSubsidiaryBuyShareResponse(int x, int y, uint32 flags, uint32 p1, uint32 p2){
+
+	Player *p;
+	Player *player2;
+	int motherIndex;
+	Player *mother;
+	int64 cost;
+	byte *b;
+	int i;
+
+	p = DEREF_PLAYER(_current_player);
+	cost = CalculateCompanyValue(DEREF_PLAYER(_current_player)) >> 2;
+
+	if(flags & DC_EXEC){
+		if(p2 == 0){
+			if(p1 == _local_player){
+				ShowErrorMessage(STR_SUBSIDIARY_SELL_SHARE_DENIED, STR_NULL ,0,0);
+			}
+			return 0;
+		}
+
+		b = p->share_owners;
+		while (*b != 0xFF) b++; /* share owners is guaranteed to contain at least one 0xFF */
+		*b = GetMotherCompany(DEREF_PLAYER(p1));
+
+		for(i=0;p->share_owners[i] == GetMotherCompany(DEREF_PLAYER(p1));) {
+			if (++i == 4) {
+				// The buying company is taking over this one.
+				p->is_ai = 0;
+				motherIndex = GetMotherCompany(DEREF_PLAYER(p1));
+
+				/* The bought out company must surrender its shares into other companies, to the */
+				/* buying one. */
+				FOR_ALL_PLAYERS(player2){
+					for(i = 0; i < 4; i++){
+						if(player2->share_owners[i] == p->index)
+							player2->share_owners[i] = motherIndex;
+					}
+				}
+
+				/* At this point, due to the share exchanges, it is possible that the buying company */
+				/* holds shares of itself, clean the mess */
+				mother = DEREF_PLAYER(motherIndex);
+				for(i = 0; i < 4; i ++){
+					if(mother->share_owners[i] == motherIndex)
+						mother->share_owners[i] = 0xFF;
+				}
+
+				MarkWholeScreenDirty();
+				break;
+			}
+		}
+		InvalidateWindow(WC_COMPANY, (int)p1);
+		if(p1 == _local_player){
+			ShowErrorMessage(STR_SUBSIDIARY_SELL_SHARE_GRANTED, STR_NULL ,0,0);
+		}
+	}
+	return cost;
+}
+
+int32 CmdSubsidiarySendMoneyOnRequest(int x, int y, uint32 flags, uint32 p1, uint32 p2){
+	byte old_cp;
+	SET_EXPENSES_TYPE(EXPENSES_OTHER);
+
+	if((int32)p2 == -1){
+		// request denied
+		if(_local_player == p1){
+			ShowErrorMessage(STR_SUBSIDIARY_CASH_REQUEST_DENIED,STR_NULL,0,0);
+		}
+		return 0;
+	}
+
+	if(_local_player == p1){
+		ShowErrorMessage(STR_SUBSIDIARY_CASH_REQUEST_GRANTED,STR_NULL,0,0);
+	}
+
+	// Add money to player
+	if(flags & DC_EXEC){
+		old_cp = _current_player;
+		_current_player = p1;
+		SubtractMoneyFromPlayer(-(int32)p2 + (p2 / 16)); // don't forget to correct for tax
+		_current_player = old_cp;
+	}
+
+	// Subtract money from local-player
+	return (int32)p2;
+}
+
+// p1 = destination
+// p2 = amount
+extern void AskSendMoney(byte player,int32 amount);
+int32 CmdSubsidiaryGetMoney(int x, int y, uint32 flags, uint32 p1, uint32 p2)
+{
+	if(_local_player == p1){
+		AskSendMoney(_current_player,p2);
+	}
+	return 0;
+}
+
+// p1 = destination
+// p2 = amount
+int32 CmdSubsidiarySendMoney(int x, int y, uint32 flags, uint32 p1, uint32 p2)
+{
+	byte old_cp;
+	SET_EXPENSES_TYPE(EXPENSES_OTHER);
+
+	// Add money to player
+	if(flags & DC_EXEC){
+		old_cp = _current_player;
+		_current_player = p1;
+		SubtractMoneyFromPlayer(-(int32)p2 + (p2 / 16)); // don't forget to correct for tax
+		_current_player = old_cp;
+	}
+
+	// Subtract money from local-player
+	return (int32)p2;
+}
+
 extern int GetAmountOwnedBy(Player *p, byte owner);
-
+extern void AskSellShare(byte player);
 /** Acquire shares in an opposing company.
  * @param x,y unused
  * @param p1 player to buy the shares from
@@ -1555,6 +1855,9 @@
 int32 CmdBuyShareInCompany(int x, int y, uint32 flags, uint32 p1, uint32 p2)
 {
 	Player *p;
+	Player *player2;
+	int motherIndex;
+	Player *mother;
 	int64 cost;
 
 	/* Check if buying shares is allowed (protection against modified clients */
@@ -1564,26 +1867,70 @@
 	p = DEREF_PLAYER(p1);
 
 	/* Protect new companies from hostile takeovers */
-	if (_cur_year - p->inaugurated_year < 6) return_cmd_error(STR_7080_PROTECTED);
+	if (_cur_year - p->inaugurated_year < _patches.years_of_protection + 1 && _patches.years_of_protection > 0) {
+		_error_message = STR_7080_PROTECTED;
+		return CMD_ERROR;
+	}
 
+	/* Check if buying shares is allowed (protection against modified clients */
+	if (!_patches.allow_shares && !_patches.subsidiaries)
+		return CMD_ERROR;
+
 	/* Those lines are here for network-protection (clients can be slow) */
 	if (GetAmountOwnedBy(p, OWNER_SPECTATOR) == 0) return 0;
 
 	/* We can not buy out a real player (temporarily). TODO: well, enable it obviously */
-	if (GetAmountOwnedBy(p, OWNER_SPECTATOR) == 1 && !p->is_ai) return 0;
+	if (GetAmountOwnedBy(p, OWNER_SPECTATOR) == 1 && !p->is_ai && !_patches.subsidiaries) return 0;
 
+	// if we are networking and the subsidiaries patch is active, popup a confirmation box
+	if(_patches.subsidiaries && _networking){
+		if(_local_player == p1 && flags & DC_EXEC){
+			AskSellShare(_current_player);
+		}
+		return 0;
+	}
+
 	cost = CalculateCompanyValue(p) >> 2;
 	if (flags & DC_EXEC) {
 		int i;
 		byte *b = p->share_owners;
 
 		while (*b != 0xFF) b++; /* share owners is guaranteed to contain at least one 0xFF */
-		*b = _current_player;
+		if(_patches.subsidiaries)
+			*b = GetMotherCompany(DEREF_PLAYER(_current_player));
+		else
+			*b = _current_player;
 
 		for (i = 0; p->share_owners[i] == _current_player;) {
 			if (++i == 4) {
-				p->bankrupt_value = 0;
-				DoAcquireCompany(p);
+				// The buying company is taking over this one.
+				if(!_patches.subsidiaries){
+					p->bankrupt_value = 0;
+					DoAcquireCompany(p);
+					motherIndex = _current_player;
+				}else{
+					p->is_ai = 0;
+					motherIndex = GetMotherCompany(DEREF_PLAYER(_current_player));
+				}
+
+				/* The bought out company must surrender its shares into other companies, to the */
+				/* buying one. */
+				FOR_ALL_PLAYERS(player2){
+					for(i = 0; i < 4; i++){
+						if(player2->share_owners[i] == p->index)
+							player2->share_owners[i] = motherIndex;
+					}
+				}
+
+				/* At this point, due to the share exchanges, it is possible that the buying company */
+				/* holds shares of itself, clean the mess */
+				mother = DEREF_PLAYER(motherIndex);
+				for(i = 0; i < 4; i ++){
+					if(mother->share_owners[i] == motherIndex)
+						mother->share_owners[i] = 0xFF;
+				}
+
+				MarkWholeScreenDirty();
 				break;
 			}
 		}
@@ -1619,6 +1966,8 @@
 		byte *b = p->share_owners;
 		while (*b != _current_player) b++; /* share owners is guaranteed to contain player */
 		*b = 0xFF;
+		if(!_networking)
+			p->is_ai = true;
 		InvalidateWindow(WC_COMPANY, (int)p1);
 	}
 	return cost;
Index: economy.h
===================================================================
--- economy.h	(revision 2447)
+++ economy.h	(working copy)
@@ -72,7 +72,17 @@
 void DeleteSubsidyWithStation(uint16 index);
 void RemoteSubsidyAdd(Subsidy *s_new);
 
+void DoAcquireCompany(Player *p);
+
 int32 GetTransportedGoodsIncome(uint num_pieces, uint dist, byte transit_days, byte cargo_type);
 uint MoveGoodsToStation(uint tile, int w, int h, int type, uint amount);
 
+
+bool IsSisterCompany(byte c1, byte c2);
+bool IsSisterCompanyIgnorePatch(byte c1, byte c2);
+byte GetMotherCompany(Player *p);
+bool IsSubsidiary(Player *p);
+int32 GetSubsidiaries(void);
+byte GetSubsidiariesCount(void);
+
 #endif /* ECONOMY_H */
Index: ship_cmd.c
===================================================================
--- ship_cmd.c	(revision 2447)
+++ ship_cmd.c	(working copy)
@@ -13,6 +13,7 @@
 #include "gui.h"
 #include "player.h"
 #include "sound.h"
+#include "economy.h"
 #include "npf.h"
 #include "depot.h"
 
@@ -82,7 +83,8 @@
 	} else {
 		FOR_ALL_DEPOTS(depot) {
 			tile = depot->xy;
-			if (IsValidDepot(depot) && IsTileDepotType(tile, TRANSPORT_WATER) && IsTileOwner(tile, v->owner)) {
+			if (IsValidDepot(depot) && IsTileDepotType(tile, TRANSPORT_WATER) && (IsSisterCompany(GetTileOwner(tile),v->owner) || _patches.shared_stations)) {
+
 				dist = DistanceManhattan(tile, tile2);
 				if (dist < best_dist) {
 					best_dist = dist;
@@ -451,6 +453,10 @@
 
 static void ShipArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_SHIP].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	/* Check if station was ever visited before */
 	if (!(st->had_vehicle_of_type & HVOT_SHIP)) {
 		uint32 flags;
@@ -574,7 +580,7 @@
 
 		NPFFillWithOrderData(&fstd, v);
 
-		ftd = NPFRouteToStationOrTile(src_tile, trackdir, &fstd, TRANSPORT_WATER, v->owner);
+		ftd = NPFRouteToStationOrTile(src_tile, trackdir, &fstd, TRANSPORT_WATER, v->owner, PBS_MODE_NONE);
 
 		if (ftd.best_trackdir != 0xff)
 			/* If ftd.best_bird_dist is 0, we found our target and ftd.best_trackdir contains
@@ -876,7 +882,7 @@
 	/* The ai_new queries the vehicle cost before building the route,
 	 * so we must check against cheaters no sooner than now. --pasky */
 	if (!IsTileDepotType(tile, TRANSPORT_WATER)) return CMD_ERROR;
-	if (!IsTileOwner(tile, _current_player)) return CMD_ERROR;
+	if (!IsSisterCompany(GetTileOwner(tile),_current_player)) return CMD_ERROR;
 
 	v = AllocateVehicle();
 	if (v == NULL || IsOrderPoolFull() ||
Index: main_gui.c
===================================================================
--- main_gui.c	(revision 2447)
+++ main_gui.c	(working copy)
@@ -47,6 +47,14 @@
 extern void GenerateIndustries(void);
 extern void GenerateTowns(void);
 
+extern void ShowSubsidiariesManagement(void);
+
+extern void DrawPlayerIcon(int p, int x, int y);
+
+extern uint GetCurrentCurrencyRate(void);
+
+extern void CcTerraform(bool success, uint tile, uint32 p1, uint32 p2);
+
 void HandleOnEditTextCancel(void)
 {
 	switch(_rename_what) {
@@ -314,7 +322,7 @@
 
 static void MenuClickShowRoad(int index)
 {
-	ShowPlayerRoadVehicles(index, -1);
+	ShowPlayerRoadVehicles(index, -1, CARGO_MASK_ALL);
 }
 
 static void MenuClickShowShips(int index)
@@ -1898,7 +1906,7 @@
 		case WKC_F11: ShowCompanyLeagueTable(); break;
 		case WKC_F12: ShowBuildIndustryWindow(); break;
 		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, -1); break;
-		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, -1); break;
+		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, -1, CARGO_MASK_ALL); break;
 		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, -1); break;
 		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, -1); break;
 		case WKC_SHIFT | WKC_F5: ToolbarZoomInClick(w); break;
@@ -2195,7 +2203,7 @@
 		}
 	}
 
-	if (!FillDrawPixelInfo(&tmp_dpi, NULL, 141, 1, 358, 11))
+	if (!FillDrawPixelInfo(&tmp_dpi, NULL, 141, 1, 338, 11))
 		return true;
 
 	old_dpi = _cur_dpi;
@@ -2223,6 +2231,11 @@
 			DrawStringCentered(570, 1, p->player_money >= 0 ? STR_0004 : STR_0005, 0);
 		}
 
+		if(p){ // draw player icon
+			DrawPlayerIcon(p->index, 482, 2);
+			DrawPlayerIcon(p->index, 496, 2);
+		}
+
 		// Draw status bar
 		if (w->message.msg) { // true when saving is active
 			DrawStringCentered(320, 1, STR_SAVING_GAME, 0);
@@ -2239,7 +2252,7 @@
 				// This is the default text
 				SetDParam(0, p->name_1);
 				SetDParam(1, p->name_2);
-				DrawStringCentered(320, 1,	STR_02BA, 0);
+				DrawStringCentered(310, 1,	STR_02BA, 0);
 			}
 		}
 
@@ -2252,11 +2265,23 @@
 		break;
 
 	case WE_CLICK:
-		switch (e->click.widget) {
-			case 1: ShowLastNewsMessage(); break;
-			case 2: if (_local_player != OWNER_SPECTATOR) ShowPlayerFinances(_local_player); break;
+		switch(e->click.widget){
+			case 1:	ShowLastNewsMessage(); break;
+			case 2: 
+				if (_local_player != OWNER_SPECTATOR){
+					if(!_patches.subsidiaries)
+						ShowPlayerCompany(_local_player);
+					else
+						ShowSubsidiariesManagement();
+				}
+				break;
+
+			case 3:
+				if (_local_player != OWNER_SPECTATOR) 
+					ShowPlayerFinances(_local_player);
+				break;
 			default: ResetObjectToPlace();
-		}
+			}
 		break;
 
 	case WE_TICK: {
@@ -2281,8 +2306,9 @@
 
 static const Widget _main_status_widgets[] = {
 {     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   139,     0,    11, 0x0,	STR_NULL},
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,   140,   499,     0,    11, 0x0, STR_02B7_SHOW_LAST_MESSAGE_OR_NEWS},
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,   500,   639,     0,    11, 0x0, STR_NULL},
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,   140,   479,     0,    11, 0x0, STR_02B7_SHOW_LAST_MESSAGE_OR_NEWS},
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,	14,   480,   511,     0,    11, 0x0, STR_NULL},
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,   512,   639,     0,    11, 0x0, STR_NULL},
 {   WIDGETS_END},
 };
 
Index: Makefile
===================================================================
--- Makefile	(revision 2447)
+++ Makefile	(working copy)
@@ -644,6 +644,7 @@
 C_SOURCES += order_cmd.c
 C_SOURCES += order_gui.c
 C_SOURCES += pathfind.c
+C_SOURCES += pbs.c
 C_SOURCES += player_gui.c
 C_SOURCES += players.c
 C_SOURCES += pool.c
Index: roadveh_gui.c
===================================================================
--- roadveh_gui.c	(revision 2447)
+++ roadveh_gui.c	(working copy)
@@ -13,6 +13,8 @@
 #include "command.h"
 #include "player.h"
 #include "engine.h"
+#include "economy.h"
+#include "network.h"
 #include "depot.h"
 
 /**
@@ -233,7 +235,7 @@
 		Vehicle *v = GetVehicle(w->window_number);
 		StringID str;
 
-		w->disabled_state = (v->owner != _local_player) ? (1<<8 | 1<<7) : 0;
+		w->disabled_state = (!IsSisterCompany(v->owner,_local_player)) ? (1<<8 | 1<<7) : 0;
 
 		/* draw widgets & caption */
 		SetDParam(0, v->string_id);
@@ -534,8 +536,7 @@
 	tile = w->window_number;
 
 	/* setup disabled buttons */
-	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7));
+	w->disabled_state = (IsSisterCompany(GetTileOwner(tile),_local_player)) ? 0 : ((1<<4)|(1<<7));
 
 	/* determine amount of items for scroller */
 	num = 0;
@@ -695,6 +696,7 @@
 		case 4:
 			if (!HASBIT(w->disabled_state, 4) &&
 					WP(w,traindepot_d).sel != INVALID_VEHICLE)	{
+				byte backup = _current_player;
 				Vehicle *v;
 
 				HandleButtonClick(w, 4);
@@ -705,8 +707,10 @@
 				_backup_orders_tile = v->tile;
 				BackupVehicleOrders(v, _backup_orders_data);
 
+				_current_player = v->owner;
 				if (!DoCommandP(v->tile, v->index, 0, NULL, CMD_SELL_ROAD_VEH | CMD_MSG(STR_9014_CAN_T_SELL_ROAD_VEHICLE)))
 					_backup_orders_tile = 0;
+				_current_player = backup;
 			}
 			break;
 		default:
@@ -815,9 +819,20 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Road, owner, station);
+//		BuildVehicleList(vl, VEH_Road, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
+		if (_local_player != owner){
+			if(IsWindowOfPrototype(w,_player_roadveh_widgets)){
+				w->disabled_state |= (1<<10);
+			}else{
+				w->disabled_state |= (1<<9);
+			}
+		}else{
+			w->disabled_state &= ~(1<<9);
+		}
+
 		SetVScrollCount(w, vl->list_length);
 
 		// disable 'Sort By' tooltip on Unsorted sorting criteria
@@ -851,7 +866,7 @@
 			Vehicle *v = GetVehicle(vl->sort_list[i].index);
 			StringID str;
 
-			assert(v->type == VEH_Road && v->owner == owner);
+			assert(v->type == VEH_Road && (IsSisterCompany(v->owner, owner) || _patches.shared_stations));
 
 			DrawRoadVehImage(v, x + 22, y + 6, INVALID_VEHICLE);
 			DrawVehicleProfitButton(v, x, y + 13);
@@ -997,16 +1012,20 @@
 };
 
 
-void ShowPlayerRoadVehicles(int player, int station)
+void ShowPlayerRoadVehicles(int player, int station, uint32 cargomask)
 {
 	Window *w;
 
-	if ( player == _local_player) {
+	if (IsSisterCompany(player,_local_player)) {
 		w = AllocateWindowDescFront(&_player_roadveh_desc, (station << 16) | player);
 	} else  {
 		w = AllocateWindowDescFront(&_other_player_roadveh_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = cargomask;
+		w->listopt.veh_type_mask = 1 << VEH_Road;
+		w->listopt.xy = GetStation(station)->xy;
+
 		w->caption_color = player;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: pathfind.c
===================================================================
--- pathfind.c	(revision 2447)
+++ pathfind.c	(working copy)
@@ -4,6 +4,8 @@
 #include "tile.h"
 #include "pathfind.h"
 
+extern bool IsSisterCompany(byte c1, byte c2);
+
 // remember which tiles we have already visited so we don't visit them again.
 static bool TPFSetTileBit(TrackPathFinder *tpf, uint tile, int dir)
 {
@@ -150,7 +152,7 @@
 		if (IsTileType(tile, MP_RAILWAY) || IsTileType(tile, MP_STATION) || IsTileType(tile, MP_TUNNELBRIDGE))
 			/* Check if we are on the middle of a bridge (has no owner) */
 			if (!IsTileType(tile, MP_TUNNELBRIDGE) || (_map5[tile] & 0xC0) != 0xC0)
-				if (owner != -1 && !IsTileOwner(tile, owner))
+				if (owner != -1 && !IsSisterCompany(GetTileOwner(tile),owner) && !_patches.shared_tracks)
 					return;
 	}
 
@@ -296,7 +298,7 @@
 				/* Check if we are on a bridge (middle parts don't have an owner */
 				if (!IsTileType(tile, MP_TUNNELBRIDGE) || (_map5[tile] & 0xC0) != 0xC0)
 					if (!IsTileType(tile_org, MP_TUNNELBRIDGE) || (_map5[tile_org] & 0xC0) != 0xC0)
-						if (GetTileOwner(tile_org) != GetTileOwner(tile))
+						if (!IsSisterCompany(GetTileOwner(tile_org), GetTileOwner(tile)) && !_patches.shared_tracks)
 							return;
 	}
 
Index: order_cmd.c
===================================================================
--- order_cmd.c	(revision 2447)
+++ order_cmd.c	(working copy)
@@ -9,6 +9,7 @@
 #include "station.h"
 #include "player.h"
 #include "news.h"
+#include "economy.h"
 #include "saveload.h"
 #include "vehicle_gui.h"
 
@@ -171,7 +172,7 @@
 			st = GetStation(new_order.station);
 
 			if (!IsValidStation(st) ||
-					(st->airport_type != AT_OILRIG && !(IsBuoy(st)) && !CheckOwnership(st->owner))) {
+					(st->airport_type != AT_OILRIG && !(IsBuoy(st)) && !CheckOwnership(st->owner)&& !_patches.shared_stations)) {
 				return CMD_ERROR;
 			}
 
@@ -221,7 +222,7 @@
 				st = GetStation(new_order.station);
 
 				if (!IsValidStation(st) ||
-						(st->airport_type != AT_OILRIG && !CheckOwnership(st->owner)) ||
+						(st->airport_type != AT_OILRIG && !CheckOwnership(st->owner) && !_patches.shared_stations) ||
 						!(st->facilities & FACIL_AIRPORT) ||
 						GetAirport(st->airport_type)->nof_depots == 0) {
 					return CMD_ERROR;
@@ -233,7 +234,7 @@
 				dp = GetDepot(new_order.station);
 
 				if (!IsValidDepot(dp) ||
-						!CheckOwnership(GetTileOwner(dp->xy))) {
+						(!CheckOwnership(GetTileOwner(dp->xy)) && !_patches.shared_stations)) {
 					return CMD_ERROR;
 				}
 
@@ -274,7 +275,7 @@
 			if (!IsWaypointIndex(new_order.station)) return CMD_ERROR;
 			wp = GetWaypoint(new_order.station);
 
-			if (!CheckOwnership(GetTileOwner(wp->xy))) return CMD_ERROR;
+			if (!CheckOwnership(GetTileOwner(wp->xy)) && !_patches.shared_stations) return CMD_ERROR;
 
 			switch (new_order.flags) {
 				case 0:
@@ -348,6 +349,25 @@
 			/* Increase amount of orders */
 			u->num_orders++;
 
+			// count vehicles scheduled for station
+			if (new_order.type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(new_order.station)->veh_scheduled++;
+			} else {
+				Station *st = GetStation(new_order.station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]++;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]++;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]++;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]++;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]++;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]++;
+						break;
+				}
+			}
+
 			/* If the orderlist was empty, assign it */
 			if (u->orders == NULL) u->orders = v->orders;
 
@@ -429,12 +449,25 @@
 			GetVehicleOrder(v, sel_ord - 1)->next = order->next;
 		}
 
-		/* Give the item free */
-		order->type = OT_NOTHING;
-		order->next = NULL;
-
 		u = GetFirstVehicleFromSharedList(v);
 		while (u != NULL) {
+			if (order->type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(order->station)->veh_scheduled--;
+			} else {
+				Station *st = GetStation(order->station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]--;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]--;
+						break;
+				}
+			}
 			u->num_orders--;
 
 			if (sel_ord < u->cur_order_index)
@@ -459,6 +492,10 @@
 			u = u->next_shared;
 		}
 
+		/* Give the item free */
+		order->type = OT_NOTHING;
+		order->next = NULL;
+
 		RebuildVehicleLists();
 	}
 
@@ -601,7 +638,7 @@
 			src = GetVehicle(veh_src);
 
 			/* Sanity checks */
-			if (src->type == 0 || !CheckOwnership(src->owner) || dst->type != src->type || dst == src)
+			if (src->type == 0 || !(CheckOwnership(src->owner) || _patches.shared_stations) || dst->type != src->type || dst == src)
 				return CMD_ERROR;
 
 			/* Trucks can't share orders with busses (and visa versa) */
@@ -650,7 +687,7 @@
 			src = GetVehicle(veh_src);
 
 			/* Sanity checks */
-			if (src->type == 0 || !CheckOwnership(src->owner) || dst->type != src->type || dst == src)
+			if (src->type == 0 || !(CheckOwnership(src->owner) || _patches.shared_stations) || dst->type != src->type || dst == src)
 				return CMD_ERROR;
 
 			/* Trucks can't copy all the orders from busses (and visa versa) */
@@ -1033,6 +1070,24 @@
 
 	order = NULL;
 	while (cur != NULL) {
+		// decrease vehicles scheduled for station
+		if (cur->type == OT_GOTO_WAYPOINT) {
+			GetWaypoint(cur->station)->veh_scheduled--;
+		} else {
+			Station *st = GetStation(cur->station);
+			switch (v->type)
+			{
+				case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+				case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+				case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+				case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+					if (v->cargo_type == CT_PASSENGERS)
+						st->veh_scheduled[STS_VEH_BUS]--;
+					else
+						st->veh_scheduled[STS_VEH_TRUCK]--;
+					break;
+			}
+		}
 		if (order != NULL) {
 			order->type = OT_NOTHING;
 			order->next = NULL;
Index: openttd.vcproj
===================================================================
--- openttd.vcproj	(revision 2447)
+++ openttd.vcproj	(working copy)
@@ -28,7 +28,8 @@
 				FavorSizeOrSpeed="2"
 				OmitFramePointers="TRUE"
 				OptimizeForProcessor="1"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;WIN32_EXCEPTION_TRACKER;WIN32_ENABLE_DIRECTMUSIC_SUPPORT;WITH_ZLIB;WITH_PNG;ENABLE_NETWORK"
+				AdditionalIncludeDirectories="C:\documents\openttd\openttd_useful"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;WIN32_EXCEPTION_TRACKER;WIN32_ENABLE_DIRECTMUSIC_SUPPORT;WITH_ZLIB;WITH_PNG;ENABLE_NETWORK;WITH_REV_HACK=\&quot;Sub_2412\&quot;"
 				StringPooling="TRUE"
 				ExceptionHandling="FALSE"
 				RuntimeLibrary="4"
@@ -57,6 +58,7 @@
 				OutputFile=".\Release/openttd.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="C:\documents\openttd\openttd_useful"
 				ProgramDatabaseFile=".\Release/openttd.pdb"
 				GenerateMapFile="TRUE"
 				MapFileName=".\Release/openttd.map"
@@ -100,7 +102,8 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;WITH_ZLIB;WITH_PNG;ENABLE_NETWORK"
+				AdditionalIncludeDirectories="C:\documents\openttd\openttd_useful"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;WITH_ZLIB;WITH_PNG;ENABLE_NETWORK,WITH_REV_HACK=\&quot;Sub_2412\&quot;"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="5"
 				UsePrecompiledHeader="2"
@@ -124,6 +127,7 @@
 				OutputFile=".\Debug/openttd.exe"
 				LinkIncremental="0"
 				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="C:\documents\openttd\openttd_useful"
 				GenerateDebugInformation="TRUE"
 				ProgramDatabaseFile=".\Debug/openttd.pdb"
 				SubSystem="2"
@@ -257,6 +261,12 @@
 				RelativePath="oldloader.c">
 			</File>
 			<File
+				RelativePath="openttd.c">
+			</File>
+			<File
+				RelativePath="openttd.rc">
+			</File>
+			<File
 				RelativePath="pathfind.c">
 			</File>
 			<File
@@ -308,12 +318,6 @@
 				RelativePath=".\tile.c">
 			</File>
 			<File
-				RelativePath="openttd.c">
-			</File>
-			<File
-				RelativePath="openttd.rc">
-			</File>
-			<File
 				RelativePath="vehicle.c">
 			</File>
 			<File
@@ -436,6 +440,9 @@
 				RelativePath=".\npf.h">
 			</File>
 			<File
+				RelativePath="openttd.h">
+			</File>
+			<File
 				RelativePath="pathfind.h">
 			</File>
 			<File
@@ -475,9 +482,6 @@
 				RelativePath=".\town.h">
 			</File>
 			<File
-				RelativePath="openttd.h">
-			</File>
-			<File
 				RelativePath="variables.h">
 			</File>
 			<File
Index: settings.c
===================================================================
--- settings.c	(revision 2447)
+++ settings.c	(working copy)
@@ -903,6 +903,22 @@
 
 	{"colored_news_date",		SDT_UINT32, (void*)2000,	&_patches.colored_news_date,		NULL},
 
+	{"smooth_economy",			SDT_BOOL,		(void*)false, &_patches.smooth_economy,				NULL},
+	
+	{"subsidiaries",				           SDT_BOOL,  (void*)true,  &_patches.subsidiaries,					                NULL},
+	{"allow_track_removal",	           SDT_BOOL,  (void*)true,  &_patches.allow_track_removal,	                NULL},
+	{"shared_stations_tax",            SDT_UINT8, (void*)10,		&_patches.shared_stations_tax,	                NULL},
+	{"shared_tracks_sub_tax",          SDT_INT32, (void*)6,			&_patches.shared_tracks_tax_subsidiary,	        NULL},
+	{"shared_tracks",				           SDT_BOOL,  (void*)false,	&_patches.shared_tracks,				                NULL},
+	{"shared_tracks_other_tax",        SDT_INT32, (void*)12,	  &_patches.shared_tracks_tax_others,	            NULL},
+
+	{"shared_stations_subs_cargotax",  SDT_INT32, (void*)20,    &_patches.shared_stations_pickuptax_subsidiary, NULL},
+	{"shared_stations",			           SDT_BOOL,  (void*)false, &_patches.shared_stations,			                NULL},
+	{"shared_stations_tax_others",     SDT_UINT8, (void*)20,    &_patches.shared_stations_tax_others,           NULL},
+	{"shared_stations_other_cargotax", SDT_INT32, (void*)40,    &_patches.shared_stations_pickuptax_others,     NULL},
+	{"years_of_protection",            SDT_UINT8,	(void*)0,			&_patches.years_of_protection,	                NULL},
+
+	{"dist_local_authority",SDT_UINT8,	(void*)20,		&_patches.dist_local_authority, NULL},
 	{"extra_dynamite",			SDT_BOOL,		(void*)false, &_patches.extra_dynamite,				NULL},
 
 	{"never_expire_vehicles",SDT_BOOL,	(void*)false, &_patches.never_expire_vehicles,NULL},
Index: waypoint.c
===================================================================
--- waypoint.c	(revision 2447)
+++ waypoint.c	(working copy)
@@ -13,6 +13,7 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 #include "table/track_land.h"
+#include "gui.h"
 
 enum {
 	/* Max waypoints: 64000 (8 * 8000) */
@@ -201,6 +202,7 @@
 		wp->deleted = 0;
 		wp->xy = tile;
 		wp->build_date = _date;
+		InitializeWaypointStats(wp);
 
 		if (wp->town_index == STR_NULL)
 			MakeDefaultWaypointName(wp);
@@ -440,18 +442,33 @@
 	SLE_CONDVAR(Waypoint, build_date, SLE_UINT16, 3, 255),
 	SLE_CONDVAR(Waypoint, stat_id, SLE_UINT8, 3, 255),
 
+//	SLE_CONDVAR(Waypoint,months_counted,	SLE_UINT16, 15, 255),
+
 	SLE_END()
 };
 
+static const SaveLoad _stats_desc[] = {
+	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,average,	SLE_UINT32, 15, 255),
+	SLE_END()
+};
+
 static void Save_WAYP(void)
 {
 	Waypoint *wp;
+//	int i;
 
 	FOR_ALL_WAYPOINTS(wp) {
 		if (wp->xy != 0) {
 			SlSetArrayIndex(wp->index);
 			SlObject(wp, _waypoint_desc);
 		}
+//		for (i = 0; i < STS_VEH_TYPES; i++) 
+//			SlObject(&wp->vehicles[i], _stats_desc);
+
 	}
 }
 
@@ -467,9 +484,222 @@
 
 		wp = GetWaypoint(index);
 		SlObject(wp, _waypoint_desc);
+		InitializeWaypointStats(wp);
 	}
 }
 
 const ChunkHandler _waypoint_chunk_handlers[] = {
 	{ 'CHKP', Save_WAYP, Load_WAYP, CH_ARRAY | CH_LAST},
 };
+
+void WaypointMonthlyLoop(void)
+{
+	Waypoint *wp;
+	StationStats *sts;
+	int i;
+
+ 	FOR_ALL_WAYPOINTS(wp) {
+		// if we have stats for this station the number of counted months is >0
+		if (wp->months_counted > 0)
+		{
+			// update vehicle-counts and min/max
+			for (i = 0; i < STS_WP_TYPES / 2; i++) {
+				sts = &wp->vehicles[i];
+				if (sts->month_max == 0) sts->month_min = sts->this_month;
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, wp->months_counted - 1);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			if (wp->months_counted == (wp->months_counted /12) * 12)
+			{ // do this once a year to have yearly stats
+				for (i = STS_WP_TYPES / 2; i < STS_WP_TYPES; i++) {
+					sts = &wp->vehicles[i];
+					if (sts->month_max == 0) sts->month_min = sts->this_month;
+					sts->month_min = min(sts->month_min, sts->this_month);
+					sts->month_max = max(sts->month_max, sts->this_month);
+					sts->average = CalcNewAverage(sts->average, sts->this_month * STS_MULTIPLIER, (wp->months_counted / 12) - 1);
+					sts->last_month = sts->this_month;
+					sts->this_month = 0;
+				}
+			}
+			wp->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, wp->index);
+	}
+}
+
+void SearchVehiclesForWaypoint(Waypoint *wp)
+{
+	Vehicle *v;
+	Order* ord;
+	
+	ord = NULL;
+	if (wp->xy == 0) return;
+	wp->veh_scheduled = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+	
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (v->owner == GetTileOwner(wp->xy)) &&
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) )       //Trains (first engine, that contains the orders)
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == wp->index && ord->type == OT_GOTO_WAYPOINT) {
+					wp->veh_scheduled++;
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	} 
+}
+
+void InitializeWaypointStats(Waypoint *wp)
+{
+	StationStats *sts;
+
+	wp->months_counted = 0;
+	for (sts = wp->vehicles; sts != endof(wp->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = 65535;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForWaypoint(wp);
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _waypoint_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   288,     0,    13, STR_WAYPOINT_VIEWPORT, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   289,   300,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   150,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   151,   300,    14,    25, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   300,    26,    37, STR_STS_TOGGLE_MONTH_YEAR, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   300,    38,   140, 0x0, 0x0},
+{      WIDGETS_END},
+};
+
+WindowDesc _waypoint_view_stats = {
+	-1, -1, 301, 141,
+	WC_WAYPOINT_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_waypoint_stats_widgets,
+	WaypointStatsWndProc
+};
+
+void DrawWaypointStatWindow(Window *w, Waypoint *wp)
+{
+	int i, j, x, y;
+	
+	//Get the Station name
+	SetDParam(0, wp->index);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	x = 10;
+	y = 40;
+	DrawString(x, y,	STR_SCHEDULED, 0);
+	if (_show_yearly_stats) {
+		DrawString(x, y + 20,	STR_STS_VEHICLES_LAST_YEAR, 0);
+		DrawString(x, y + 32,	STR_STS_VEHICLES_THIS_YEAR, 0);
+		SetDParam(0, max((wp->months_counted - 1) / 12 ,0));
+		DrawString(x, y + 90,	STR_STS_YEARS_COUNTED_NUM, 0);
+	} else {
+		DrawString(x, y + 20,	STR_VEHICLES_MONTH, 0);
+		DrawString(x, y + 32,	STR_VEHICLES_CURRENT, 0);
+		SetDParam(0, max(wp->months_counted - 1,0));
+		DrawString(x, y + 90,	STR_MONTHS_COUNTED_NUM, 0);
+	}
+	DrawString(x, y + 50,	STR_AVERAGE, 0);
+	DrawString(x, y + 62,	STR_MINIMUM, 0);
+	DrawString(x, y + 74,	STR_MAXIMUM, 0);
+
+	x = 170;
+	SetDParam(0, wp->veh_scheduled);
+	DrawStringRightAligned(x, y, STR_NUMBER, 0);
+	DrawStringRightAligned(290, y, STR_STS_NOT_SCHEDULED, 0);
+	if (wp->veh_scheduled != 0) {
+		CLRBIT(w->disabled_state, 5);
+	} else {
+		SETBIT(w->disabled_state, 5);
+	}
+
+	j = _show_yearly_stats ? 2 : 0;
+	for (i = 0; i < STS_WP_TYPES / 2; i++)
+	{
+		SetDParam(0, wp->vehicles[i+j].last_month);
+		DrawStringRightAligned(x + i * 120, y + 20, STR_NUMBER, 0);
+		SetDParam(0, wp->vehicles[i+j].this_month);
+		DrawStringRightAligned(x + i * 120, y + 32, STR_WHITE_NUMBER, 0);
+
+		if (wp->months_counted > (_show_yearly_stats ? 12 : 1)) {
+			SetDParam(0, wp->vehicles[i+j].average / STS_MULTIPLIER);
+			DrawStringRightAligned(x + i * 120, y + 50, STR_SILVER_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_min);
+			DrawStringRightAligned(x + i * 120, y + 62, STR_ORANGE_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_max);
+			DrawStringRightAligned(x + i * 120, y + 74, STR_LTBLUE_NUMBER, 0);
+		}
+	}
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e)
+{
+	Waypoint *wp = GetWaypoint(w->window_number);
+	switch(e->event)
+	{
+		case WE_TICK: {
+//			static int counter = 0;
+//			if (++counter % 40) return;
+//			SearchVehiclesForWaypoint(wp, &w->custom[0]);
+			w->custom[0] = wp->veh_scheduled;
+			InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+			break;
+		}
+		case WE_PAINT: {
+			DrawWaypointStatWindow(w, wp);
+			break;
+			}
+		case WE_CLICK: {
+			switch (e->click.widget)
+			{
+				case 4:			// Reset Statistics
+					if (GetTileOwner(wp->xy) == _current_player) {
+						InitializeWaypointStats(wp);
+						InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+					}
+					break;
+				case 5:			//Trains
+					ShowWaypointTrains(_current_player, wp->index, CARGO_MASK_ALL);
+					break;
+				case 6:
+				_show_yearly_stats ^= 1;
+				InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+				break;
+			}
+		} break;
+		case WE_DESTROY: {
+			DeleteWindowById(WC_TRAINS_LIST, GetTileOwner(wp->xy) + ( (wp->index + 1) << 8));
+		} break;
+	}
+}
+
+void ShowWaypointStatsWindow(Waypoint *wp)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_waypoint_view_stats, wp->index);
+	if (w) {
+		color = GetTileOwner(wp->xy);
+		if (color != 0x10)
+			w->caption_color = color;
+	}
+}
Index: waypoint.h
===================================================================
--- waypoint.h	(revision 2447)
+++ waypoint.h	(working copy)
@@ -2,6 +2,7 @@
 #define WAYPOINT_H
 
 #include "pool.h"
+#include "station.h"
 
 struct Waypoint {
 	TileIndex xy;
@@ -11,12 +12,20 @@
 	byte town_cn;          // The Nth waypoint for this town (consecutive number)
 	StringID string;       // If this is zero, town + town_cn is used for naming
 
+	StationStats vehicles[STS_WP_TYPES];
+	uint16 veh_scheduled;
+	uint16 months_counted;
+
 	ViewportSign sign;
 	uint16 build_date;
 	byte stat_id;
 	byte deleted;          // this is a delete counter. when it reaches 0, the waypoint struct is deleted.
 };
 
+void InitializeWaypointStats(Waypoint *wp);
+void ShowWaypointStatsWindow(Waypoint *wp);
+void ShowWaypointTrains(int player, int waypoint, uint32 cargomask);
+
 enum {
 	RAIL_TYPE_WAYPOINT = 0xC4,
 	RAIL_WAYPOINT_TRACK_MASK = 1,
Index: train_gui.c
===================================================================
--- train_gui.c	(revision 2447)
+++ train_gui.c	(working copy)
@@ -13,8 +13,11 @@
 #include "command.h"
 #include "player.h"
 #include "engine.h"
+#include "economy.h"
+#include "network.h"
 #include "vehicle_gui.h"
 #include "depot.h"
+#include "waypoint.h"
 
 int _traininfo_vehicle_pitch = 0;
 
@@ -362,9 +365,8 @@
 	tile = w->window_number;
 
 	/* setup disabled buttons */
-	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 5) | (1 << 8));
-
+	w->disabled_state = (IsSisterCompany(GetTileOwner(tile),_local_player)) ? 0 : ((1<<4)|(1<<5)|(1<<8));
+	
 	/* determine amount of items for scroller */
 	num = 0;
 	hnum = 1;
@@ -630,14 +632,18 @@
 			HandleButtonClick(w, e->click.widget);
 
 			sell_cmd = (e->click.widget == 5 || _ctrl_pressed) ? 1 : 0;
-
-			if (v->subtype != TS_Front_Engine) {
-				DoCommandP(v->tile, v->index, sell_cmd, NULL, CMD_SELL_RAIL_WAGON | CMD_MSG(STR_8839_CAN_T_SELL_RAILROAD_VEHICLE));
-			} else {
-				_backup_orders_tile = v->tile;
-				BackupVehicleOrders(v, _backup_orders_data);
-				if (!DoCommandP(v->tile, v->index, sell_cmd, NULL, CMD_SELL_RAIL_WAGON | CMD_MSG(STR_8839_CAN_T_SELL_RAILROAD_VEHICLE)))
-					_backup_orders_tile = 0;
+			{
+				byte backup = _current_player;
+				_current_player = v->owner;
+				if (v->subtype != TS_Front_Engine) {
+					DoCommandP(v->tile, v->index, sell_cmd, NULL, CMD_SELL_RAIL_WAGON | CMD_MSG(STR_8839_CAN_T_SELL_RAILROAD_VEHICLE));
+				} else {
+					_backup_orders_tile = v->tile;
+					BackupVehicleOrders(v, _backup_orders_data);
+					if (!DoCommandP(v->tile, v->index, sell_cmd, NULL, CMD_SELL_RAIL_WAGON | CMD_MSG(STR_8839_CAN_T_SELL_RAILROAD_VEHICLE)))
+						_backup_orders_tile = 0;
+				}
+				_current_player = backup;
 			}
 		}	break;
 
@@ -821,7 +827,7 @@
 
 		v = GetVehicle(w->window_number);
 
-		w->disabled_state = (v->owner == _local_player) ? 0 : 0x380;
+		w->disabled_state = (IsSisterCompany(v->owner, _local_player)) ? 0 : 0x380;
 
 		SETBIT(w->disabled_state, 12);
 
@@ -1069,7 +1075,7 @@
 	SetVScrollCount(w, num);
 
 	w->disabled_state = 1 << (det_tab + 9);
-	if (v->owner != _local_player)
+	if (!IsSisterCompany(v->owner,_local_player))
 		w->disabled_state |= (1 << 2);
 
 	if (!_patches.servint_trains) // disable service-scroller when interval is set to disabled
@@ -1294,9 +1300,20 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Train, owner, station);
+//		BuildVehicleList(vl, VEH_Train, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
+		if (_local_player != owner){
+			if(IsWindowOfPrototype(w,_player_trains_widgets)){
+				w->disabled_state |= (1<<10);
+			}else{
+				w->disabled_state |= (1<<9);
+			}
+		}else{
+			w->disabled_state &= ~(1<<9);
+		}
+
 		SetVScrollCount(w, vl->list_length);
 
 		// disable 'Sort By' tooltip on Unsorted sorting criteria
@@ -1330,7 +1347,7 @@
 			Vehicle *v = GetVehicle(vl->sort_list[i].index);
 			StringID str;
 
-			assert(v->type == VEH_Train && v->owner == owner);
+			assert(v->type == VEH_Train && (IsSisterCompany(v->owner, owner) || _patches.shared_stations));
 
 			DrawTrainImage(
 				v, x + 21, y + 6 + _traininfo_vehicle_pitch, w->hscroll.cap, 0, INVALID_VEHICLE);
@@ -1384,7 +1401,7 @@
 
 				v = GetVehicle(vl->sort_list[id_v].index);
 
-				assert(v->type == VEH_Train && v->subtype == TS_Front_Engine && v->owner == owner);
+				assert(v->type == VEH_Train && v->subtype == TS_Front_Engine && IsSisterCompany(v->owner, owner));
 
 				ShowTrainViewWindow(v);
 			}
@@ -1484,12 +1501,16 @@
 {
 	Window *w;
 
-	if (player == _local_player) {
+	if (IsSisterCompany(player,_local_player)) {
 		w = AllocateWindowDescFront(&_player_trains_desc, (station << 16) | player);
 	} else {
 		w = AllocateWindowDescFront(&_other_player_trains_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.veh_type_mask = 1 << VEH_Train;
+		w->listopt.xy = GetStation(station)->xy;
+
 		w->caption_color = player;
 		w->hscroll.cap = 10;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
@@ -1499,3 +1520,27 @@
 		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
 	}
 }
+
+void ShowWaypointTrains(int player, int waypoint, uint32 cargomask)
+{
+	Window *w;
+
+	if (player == _local_player) {
+		w = AllocateWindowDescFront(&_player_trains_desc, (waypoint << 16) | player);
+	} else {
+		w = AllocateWindowDescFront(&_other_player_trains_desc, (waypoint << 16) | player);
+	}
+	if (w) {
+		w->listopt.cargo_mask = cargomask;
+		w->listopt.veh_type_mask = 1 << VEH_Train;
+		w->listopt.xy = GetWaypoint(waypoint)->xy;
+
+		w->caption_color = player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 7; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_SMALL;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
+	}
+}
Index: station.h
===================================================================
--- station.h	(revision 2447)
+++ station.h	(working copy)
@@ -6,6 +6,34 @@
 #include "tile.h"
 #include "vehicle.h"
 
+enum {
+	STS_AMOUNT_IN = 0,
+    STS_AMOUNT_OUT = 1,
+	STS_AMOUNT_TRANSFER = 2,
+	STS_VEH_TRAIN = 0,
+	STS_VEH_ROAD = 1,
+	STS_VEH_BUS = 2,
+	STS_VEH_TRUCK = 3,
+	STS_VEH_SHIP = 4,
+	STS_VEH_AIRCRAFT = 5,
+	STS_MULTIPLIER = 10000, // controls how much digits behind comma are stored for average
+	STS_VEH_TYPES = 6,
+	STS_AMNT_TYPES = 3,
+	STS_WP_TYPES = 4,
+	STS_WP_ORDER = 0, // reached WP by order
+	STS_WP_PATHFIND = 1, // reached WP by normal pathfinding
+	STS_WP_ORDER_YEAR = 2, // yearly stats by order
+	STS_WP_PATHFIND_YEAR =3 , // yearly stats by pathfinding
+};
+
+typedef struct StationStats {
+	uint16 this_month;
+	uint16 last_month;
+	uint16 month_min;
+	uint16 month_max;
+	uint32 average;
+} StationStats;
+
 typedef struct GoodsEntry {
 	uint16 waiting_acceptance;
 	byte days_since_pickup;
@@ -14,6 +42,9 @@
 	byte enroute_time;
 	byte last_speed;
 	byte last_age;
+
+	StationStats cargo_amount[STS_AMNT_TYPES];
+	uint16 months_counted;
 	int32 feeder_profit;
 } GoodsEntry;
 
@@ -78,6 +109,10 @@
 	VehicleID last_vehicle;
 	GoodsEntry goods[NUM_CARGO];
 
+	StationStats vehicles[STS_VEH_TYPES];
+	uint16 veh_scheduled[STS_VEH_TYPES];
+	uint16 months_counted;
+
 	/* Stuff that is no longer used, but needed for conversion */
 	TileIndex bus_tile_obsolete;
 	TileIndex lorry_tile_obsolete;
@@ -122,6 +157,11 @@
 
 void ModifyStationRatingAround(TileIndex tile, byte owner, int amount, uint radius);
 
+void SearchVehiclesForStation(Station *st);
+void ShowStationStatsWindow(int station);
+void InitializeStationStats(Station *st);
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted);
+
 TileIndex GetStationTileForVehicle(const Vehicle *v, const Station *st);
 
 void ShowStationViewWindow(int station);
Index: tile.h
===================================================================
--- tile.h	(revision 2447)
+++ tile.h	(working copy)
@@ -18,6 +18,29 @@
 	MP_UNMOVABLE
 } TileType;
 
+enum { /* These values are bitmasks for the map5 byte */
+	RAIL_TYPE_NORMAL = 0,
+	RAIL_TYPE_SIGNALS = 0x40,
+	RAIL_TYPE_SPECIAL = 0x80, // If this bit is set, then it's not a regular track.
+	RAIL_TYPE_DEPOT = 0xC0,
+	RAIL_TYPE_MASK = 0xC0,
+
+	RAIL_BIT_DIAG1 = 1,  // 0
+	RAIL_BIT_DIAG2 = 2,  // 1
+	RAIL_BIT_UPPER = 4,  // 2
+	RAIL_BIT_LOWER = 8,  // 3
+	RAIL_BIT_LEFT  = 16, // 4
+	RAIL_BIT_RIGHT = 32, // 5
+	RAIL_BIT_MASK = 0x3F,
+
+	RAIL_DEPOT_TRACK_MASK = 1,
+	RAIL_DEPOT_DIR = 3,
+
+	RAIL_SUBTYPE_MASK     = 0x3C,
+	RAIL_SUBTYPE_DEPOT    = 0x00,
+	RAIL_SUBTYPE_WAYPOINT = 0x04
+};
+
 /* XXX: This should be moved out to a new file (rail.h) along with some other
  * cleanups. I'll do that after 0.4) */
 typedef enum {
@@ -29,7 +52,6 @@
 	INVALID_RAILTYPE = 0xFF,
 } RailType;
 
-
 void SetMapExtraBits(TileIndex tile, byte flags);
 uint GetMapExtraBits(TileIndex tile);
 
@@ -61,9 +83,12 @@
 	return TileHeight(tile) * 8;
 }
 
-static inline TileType GetTileType(TileIndex tile)
+static TileType GetTileType(TileIndex tile)
 {
 	assert(tile < MapSize());
+	//if (!(tile < MapSize())) {
+//		return 0;
+//	}
 	return GB(_map_type_and_height[tile], 4, 4);
 }
 
Index: settings_gui.c
===================================================================
--- settings_gui.c	(revision 2447)
+++ settings_gui.c	(working copy)
@@ -11,6 +11,7 @@
 #include "engine.h"
 #include "screenshot.h"
 #include "newgrf.h"
+#include "economy.h"
 #include "network.h"
 #include "console.h"
 #include "town.h"
@@ -742,6 +743,20 @@
 	{PE_BOOL,		0, STR_CONFIG_PATCHES_AI_BUILDS_SHIPS,"ai_disable_veh_ship",&_patches.ai_disable_veh_ship,			0,  0,  0, NULL},
 };
 
+static const PatchEntry _patches_cooperation[] = {
+	{PE_BOOL,			0, STR_CONFIG_PATCHES_SUBSIDIARIES,														"subsidiaries",										&_patches.subsidiaries,													0,  0,  0, NULL},
+	{PE_BOOL,			0, STR_CONFIG_PATCHES_SUBS_ALLOW_REMOVE,											"allow_track_removal",						&_patches.allow_track_removal,									0,	0,	0, NULL},
+	{PE_UINT8,		0, STR_CONFIG_PATCHES_SHARED_ST_TAX,													"shared_stations_tax",						&_patches.shared_stations_tax,  								0,100,  1, NULL},
+	{PE_CURRENCY,	0, STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_SUB_CONFIG,	"shared_tracks_sub_tax",					&_patches.shared_tracks_tax_subsidiary,  				0,100,	1, NULL},
+	{PE_CURRENCY,	0, STR_CONFIG_PATCHES_SHARED_STATIONS_SUBS_CARGOTAX,					"shared_stations_subs_cargotax",	&_patches.shared_stations_pickuptax_subsidiary,	0,100,  1, NULL},
+	{PE_BOOL,			0, STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_CONFIG,			"shared_tracks",									&_patches.shared_tracks,  											0,	0,  0, NULL},
+	{PE_CURRENCY,	0, STR_CONFIG_PATCHES_SUBSIDIARIES_SHARED_TRACKS_OTHER_CONFIG,"shared_tracks_other_tax",				&_patches.shared_tracks_tax_others,  						0,100,  1, NULL},
+	{PE_BOOL,			0, STR_CONFIG_PATCHES_SHARED_STATIONS,												"shared_stations",								&_patches.shared_stations,  										0,	0,  0, NULL},
+	{PE_UINT8,		0, STR_CONFIG_PATCHES_SHARED_ST_TAX_OTHERS,										"shared_stations_tax_others",			&_patches.shared_stations_tax_others,  					0,100,  1, NULL},
+	{PE_CURRENCY,	0, STR_CONFIG_PATCHES_SHARED_STATIONS_OTHERS_CARGOTAX,				"shared_stations_other_cargotax",	&_patches.shared_stations_pickuptax_others,  		0,100,  1, NULL},
+	{PE_UINT8,		0, STR_CONFIG_PATCHES_YEARS_OF_PROTECTION,										"years_of_protection",						&_patches.years_of_protection,  								0,100,  1, NULL},
+};
+
 typedef struct PatchPage {
 	const PatchEntry *entries;
 	uint num;
@@ -754,6 +769,7 @@
 	{_patches_stations,			lengthof(_patches_stations) },
 	{_patches_economy,			lengthof(_patches_economy) },
 	{_patches_ai,						lengthof(_patches_ai) },
+	{_patches_cooperation,			lengthof(_patches_cooperation)},
 };
 
 
@@ -975,7 +991,7 @@
 
 			break;
 		}
-		case 4: case 5: case 6: case 7: case 8: case 9:
+		case 4: case 5: case 6: case 7: case 8: case 9: case 10:
 			WP(w,def_d).data_1 = e->click.widget - 4;
 			DeleteWindowById(WC_QUERY_STRING, 0);
 			SetWindowDirty(w);
@@ -1131,6 +1147,7 @@
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,   271,   357,    16,    27, STR_CONFIG_PATCHES_STATIONS,			STR_NULL},
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    10,    96,    28,    39, STR_CONFIG_PATCHES_ECONOMY,			STR_NULL},
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    97,   183,    28,    39, STR_CONFIG_PATCHES_AI,						STR_NULL},
+{   WWT_CLOSEBOX,   RESIZE_NONE,     3,   184,   270,    28,    39, STR_CONFIG_PATCHES_COOP,						STR_NULL},
 {   WIDGETS_END},
 };
 
Index: ship_gui.c
===================================================================
--- ship_gui.c	(revision 2447)
+++ ship_gui.c	(working copy)
@@ -12,6 +12,8 @@
 #include "command.h"
 #include "player.h"
 #include "engine.h"
+#include "economy.h"
+#include "network.h"
 #include "depot.h"
 
 /**
@@ -472,7 +474,7 @@
 				IsTileDepotType(v->tile, TRANSPORT_WATER))
 			disabled = 0;
 
-		if (v->owner != _local_player)
+		if (!IsSisterCompany(v->owner,_local_player))
 			disabled |= 1<<8 | 1<<7;
 		w->disabled_state = disabled;
 
@@ -610,9 +612,8 @@
 	tile = w->window_number;
 
 	/* setup disabled buttons */
-	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7));
-
+	w->disabled_state = (IsSisterCompany(GetTileOwner(tile),_local_player)) ? 0 : ((1<<4)|(1<<7));
+	
 	/* determine amount of items for scroller */
 	num = 0;
 	FOR_ALL_VEHICLES(v) {
@@ -771,6 +772,7 @@
 		case 4:
 			if (!HASBIT(w->disabled_state, 4) &&
 					WP(w,traindepot_d).sel != INVALID_VEHICLE)	{
+				byte backup = _current_player;
 				Vehicle *v;
 
 				HandleButtonClick(w, 4);
@@ -781,8 +783,10 @@
 				_backup_orders_tile = v->tile;
 				BackupVehicleOrders(v, _backup_orders_data);
 
+				_current_player = v->owner;
 				if (!DoCommandP(v->tile, v->index, 0, NULL, CMD_SELL_SHIP | CMD_MSG(STR_980C_CAN_T_SELL_SHIP)))
 					_backup_orders_tile = 0;
+				_current_player = backup;
 			}
 			break;
 		default:
@@ -918,6 +922,16 @@
 		BuildVehicleList(vl, VEH_Ship, owner, station);
 		SortVehicleList(vl);
 
+		if (_local_player != owner){
+			if(IsWindowOfPrototype(w,_player_ships_widgets)){
+				w->disabled_state |= (1<<10);
+			}else{
+				w->disabled_state |= (1<<9);
+			}
+		}else{
+			w->disabled_state &= ~(1<<9);
+		}
+
 		SetVScrollCount(w, vl->list_length);
 
 		// disable 'Sort By' tooltip on Unsorted sorting criteria
@@ -1104,7 +1118,7 @@
 {
 	Window *w;
 
-	if ( player == _local_player) {
+	if ( IsSisterCompany(player,_local_player)) {
 		w = AllocateWindowDescFront(&_player_ships_desc, (station << 16) | player);
 	} else  {
 		w = AllocateWindowDescFront(&_other_player_ships_desc, (station << 16) | player);
Index: window.h
===================================================================
--- window.h	(revision 2447)
+++ window.h	(working copy)
@@ -5,6 +5,16 @@
 
 typedef union WindowEvent WindowEvent;
 
+enum {
+	CARGO_MASK_ALL = 0xFFFFFFFF,
+};
+typedef struct DisplayListOptions {
+	uint32 cargo_mask;
+	uint32 veh_type_mask;
+	TileIndex xy;
+} DisplayListOptions;
+
+
 //typedef void WindowProc(Window *w, int event, int wparam, long lparam);
 
 typedef void WindowProc(Window *w, WindowEvent *e);
@@ -307,6 +317,8 @@
 
 	Message message;
 	byte custom[WINDOW_CUSTOM_SIZE];
+	
+	DisplayListOptions listopt; // Options for displaying vehicle-lists
 };
 
 typedef struct {
Index: command.c
===================================================================
--- command.c	(revision 2447)
+++ command.c	(working copy)
@@ -155,6 +155,12 @@
 
 DEF_COMMAND(CmdReplaceVehicle);
 
+DEF_COMMAND(CmdSubsidiaryGetMoney);
+DEF_COMMAND(CmdSubsidiarySendMoney);
+DEF_COMMAND(CmdSubsidiarySendMoneyOnRequest);
+DEF_COMMAND(CmdSubsidiaryBuyShareResponse);
+
+
 /* The master command table */
 static const Command _command_proc_table[] = {
 	{CmdBuildRailroadTrack,                  0}, /*   0 */
@@ -296,6 +302,11 @@
 	{CmdGiveMoney,                           0}, /* 113 */
 	{CmdChangePatchSetting,         CMD_SERVER}, /* 114 */
 	{CmdReplaceVehicle,                      0}, /* 115 */
+
+	{CmdSubsidiarySendMoney,				 0}, /* 116 */
+	{CmdSubsidiaryGetMoney,				     0}, /* 117 */
+	{CmdSubsidiarySendMoneyOnRequest,	     0}, /* 118 */
+	{CmdSubsidiaryBuyShareResponse,	         0}, /* 119 */
 };
 
 /* This function range-checks a cmd, and checks if the cmd is not NULL */
Index: order_gui.c
===================================================================
--- order_gui.c	(revision 2447)
+++ order_gui.c	(working copy)
@@ -12,6 +12,7 @@
 #include "town.h"
 #include "command.h"
 #include "viewport.h"
+#include "economy.h"
 #include "depot.h"
 #include "waypoint.h"
 
@@ -56,7 +57,7 @@
 
 	v = GetVehicle(w->window_number);
 
-	w->disabled_state = (v->owner == _local_player) ? 0 : (
+	w->disabled_state = (IsSisterCompany(v->owner,_local_player)) ? 0 : (
 		1 << 4 |   //skip
 		1 << 5 |   //delete
 		1 << 6 |   //non-stop
@@ -193,7 +194,7 @@
 	if (_patches.gotodepot) {
 		switch (GetTileType(tile)) {
 		case MP_RAILWAY:
-			if (v->type == VEH_Train && IsTileOwner(tile, _local_player)) {
+			if (v->type == VEH_Train && (IsSisterCompany(GetTileOwner(tile), _local_player) || _patches.shared_stations)) {
 				if ((_map5[tile]&0xFC)==0xC0) {
 					order.type = OT_GOTO_DEPOT;
 					order.flags = OF_PART_OF_ORDERS;
@@ -204,7 +205,7 @@
 			break;
 
 		case MP_STREET:
-			if ((_map5[tile] & 0xF0) == 0x20 && v->type == VEH_Road && IsTileOwner(tile, _local_player)) {
+			if ((_map5[tile] & 0xF0) == 0x20 && v->type == VEH_Road && (IsSisterCompany(GetTileOwner(tile), _local_player) || _patches.shared_stations)){
 				order.type = OT_GOTO_DEPOT;
 				order.flags = OF_PART_OF_ORDERS;
 				order.station = GetDepotByTile(tile)->index;
@@ -214,7 +215,7 @@
 
 		case MP_STATION:
 			if (v->type != VEH_Aircraft) break;
-			if (IsAircraftHangarTile(tile) && IsTileOwner(tile, _local_player)) {
+			if ( IsAircraftHangarTile(tile) && (IsSisterCompany(GetTileOwner(tile), _local_player) || _patches.shared_stations)){
 				order.type = OT_GOTO_DEPOT;
 				order.flags = OF_PART_OF_ORDERS | OF_NON_STOP;	//XXX - whats the nonstop stuff doing here?
 				order.station = _map2[tile];
@@ -224,8 +225,8 @@
 
 		case MP_WATER:
 			if (v->type != VEH_Ship) break;
-			if (IsTileDepotType(tile, TRANSPORT_WATER) &&
-					IsTileOwner(tile, _local_player)) {
+
+			if (IsTileDepotType(tile, TRANSPORT_WATER) && (IsSisterCompany(GetTileOwner(tile), _local_player) || _patches.shared_stations)) {
 				switch (_map5[tile]) {
 				case 0x81: tile--; break;
 				case 0x83: tile-= TILE_XY(0,1); break;
@@ -242,10 +243,10 @@
 	}
 
 	// check waypoint
-	if (IsTileType(tile, MP_RAILWAY) &&
-			v->type == VEH_Train &&
-			IsTileOwner(tile, _local_player) &&
-			(_map5[tile] & 0xFE) == 0xC4) {
+	if (IsTileType(tile, MP_RAILWAY)
+			&& v->type == VEH_Train
+			&& (IsSisterCompany(GetTileOwner(tile), _local_player) || _patches.shared_stations)
+			&& (_map5[tile]&0xFE)==0xC4) {
 		order.type = OT_GOTO_WAYPOINT;
 		order.flags = 0;
 		order.station = GetWaypointByTile(tile)->index;
@@ -255,7 +256,7 @@
 	if (IsTileType(tile, MP_STATION)) {
 		st = GetStation(st_index = _map2[tile]);
 
-		if (st->owner == _current_player || st->owner == OWNER_NONE) {
+		if (IsSisterCompany(st->owner, _current_player) || _patches.shared_stations || st->owner == OWNER_NONE) {
 			byte facil;
 			(facil=FACIL_DOCK, v->type == VEH_Ship) ||
 			(facil=FACIL_TRAIN, v->type == VEH_Train) ||
@@ -607,7 +608,7 @@
 
 	_alloc_wnd_parent_num = veh;
 
-	if (v->owner != _local_player) {
+	if (!IsSisterCompany(v->owner, _local_player)) {
 		w = AllocateWindowDesc( &_other_orders_desc);
 	} else
 		w = AllocateWindowDesc( (v->type == VEH_Train) ? &_orders_train_desc : &_orders_desc);
Index: command.h
===================================================================
--- command.h	(revision 2447)
+++ command.h	(working copy)
@@ -134,6 +134,11 @@
 	CMD_CHANGE_PATCH_SETTING = 114,
 
 	CMD_REPLACE_VEHICLE = 115,
+
+	CMD_SUBSIDIARY_SEND_MONEY = 116,
+	CMD_SUBSIDIARY_GET_MONEY = 117,
+	CMD_SUBSIDIARY_SEND_MONEY_ON_REQUEST = 118,
+	CMD_SUBSIDIARY_BUY_SHARE_RESPONSE = 119,
 };
 
 enum {
