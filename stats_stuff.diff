Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 2490)
+++ station_cmd.c	(working copy)
@@ -19,6 +19,9 @@
 #include "airport.h"
 #include "sprite.h"
 #include "depot.h"
+#include "cargo.h"
+#include "network.h"
+#include "pbs.h"
 
 enum {
 	/* Max stations: 64000 (64 * 1000) */
@@ -444,8 +447,8 @@
 	st->airport_tile = st->dock_tile = st->train_tile = 0;
 	st->bus_stops = st->truck_stops = NULL;
 	st->had_vehicle_of_type = 0;
-	st->time_since_load = 255;
-	st->time_since_unload = 255;
+	st->time_since_load = INVALID_TIME;
+	st->time_since_unload = INVALID_TIME;
 	st->delete_ctr = 0;
 	st->facilities = 0;
 
@@ -455,11 +458,14 @@
 		ge->waiting_acceptance = 0;
 		ge->days_since_pickup = 0;
 		ge->enroute_from = INVALID_STATION;
-		ge->rating = 175;
+		ge->rating = RATING_START_VALUE;
 		ge->last_speed = 0;
-		ge->last_age = 0xFF;
+		ge->last_age = INVALID_AGE;
 		ge->feeder_profit = 0;
+		ge->last_vehicle_speed = 0;
+		ge->last_vehicle_type = INVALID_VEHICLE;
 	}
+	InitializeStationStats(st);
 
 	_global_station_sort_dirty = true; // build a new station
 }
@@ -2174,6 +2180,18 @@
 		} else {
 			AddChildSpriteScreen(image, dtss->delta_x, dtss->delta_y);
 		}
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(0x3ED | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(0x3EE | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(0x3EF | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(0x3F0 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(0x3F2 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 | PALETTE_CRASH);
+}
+#endif
 	}
 }
 
@@ -2493,46 +2511,166 @@
 static void UpdateStationRating(Station *st)
 {
 	GoodsEntry *ge;
-	int rating;
+	RatingStats *rs;
 	StationID index;
-	int waiting;
+	int rating, waiting, lv_type, speed, old_rating, points, point_clamp;
 	bool waiting_changed = false;
+	byte age, days;
 
 	byte_inc_sat(&st->time_since_load);
 	byte_inc_sat(&st->time_since_unload);
 
 	ge = st->goods;
+	rs = st->rating_stats;
+
 	do {
 		if (ge->enroute_from != INVALID_STATION) {
-			byte_inc_sat(&ge->enroute_time);
-			byte_inc_sat(&ge->days_since_pickup);
-
 			rating = 0;
+			old_rating = 0;
+			points = 0;
+			lv_type = ge->last_vehicle_type;
+			if (lv_type == INVALID_VEHICLE && st->last_vehicle != INVALID_VEHICLE)
+				lv_type = GetVehicle(st->last_vehicle)->type;
 
+			speed = ge->last_speed;
+			if (_patches.nsr_speed)
 			{
-				int b = ge->last_speed;
-				if ((b-=85) >= 0)
-					rating += b >> 2;
+				points = ge->last_vehicle_speed;
+				if (points == 0)
+					points = speed;
+				rs->last_speed = points;
+				switch (lv_type)
+				{
+					case VEH_Train:
+						if (points <= RP_T_SPEED_CAP) // "normal" trains
+							points += (ge == &st->goods[CT_PASSENGERS]) ? RP_T_SPEED_PASS_BONUS : RP_T_SPEED_CARGO_BONUS;
+						else // monorail + maglev, currently too few trains to be worth more distinction
+							points /= RP_SPEED_MULT;
+						break;
+					case VEH_Road:
+						points *= 3 / 2;
+						points += (ge == &st->goods[CT_PASSENGERS]) ? RP_R_SPEED_PASS_BONUS : RP_R_SPEED_CARGO_BONUS;
+						break;
+					case VEH_Ship:
+						rs->last_speed = points / 2;
+						if (ge != &st->goods[CT_PASSENGERS])
+							points *= RP_SPEED_MULT;
+						break;
+					case VEH_Aircraft:
+						rs->last_speed = (points * 64) / 5; // * 8 * 16 / 10
+						if (ge != &st->goods[CT_PASSENGERS])
+							points *= RP_SPEED_MULT;
+						break;
+					default:	
+						points = 0;
+				}
+				// max 170 >> 2 = 42 points for speedrating
+				rating += clamp(points, 0, RP_MAX_SPEED_POINTS) >> 2;
 			}
+			else
+			{
+				if ((speed -= 85) >= 0)
+					rating += speed >> 2;
+				rs->last_speed = ge->last_speed;
+			}
+			rs->ratings[RATING_SPEED] = rating - old_rating;
+			old_rating = rating;
 
+			age = ge->last_age;
+			if (_patches.nsr_age)
 			{
-				byte age = ge->last_age;
+				if (ge == &st->goods[CT_PASSENGERS]) {
+					switch (lv_type)	// scale age to RP_MAX_AGE years
+					{
+						case VEH_Train:		point_clamp = RP_AGE_T_CLAMP;	break;
+						case VEH_Road:			point_clamp = RP_AGE_R_CLAMP;	break;
+						case VEH_Ship:			point_clamp = RP_AGE_S_CLAMP;	break;
+						case VEH_Aircraft:	point_clamp = RP_AGE_A_CLAMP;	break;
+						default:					point_clamp = RP_MAX_AGE;
+					}
+					points = clamp(points, 0, point_clamp) * RP_MAX_AGE / point_clamp;
+					switch (age) // give bonus to rating for low age
+					{ // uses real age, not scaled age
+						case 0:	rating += RP_AGE_BONUS_0;	break;
+						case 1:	rating += RP_AGE_BONUS_1;	break;
+						case 2:	rating += RP_AGE_BONUS_2;	break;
+						case 3:	rating += RP_AGE_BONUS_3;	break;
+						case 4:	rating += RP_AGE_BONUS_4;	break;
+						case 5:	rating += RP_AGE_BONUS_5;	break;
+					}
+				} else { // non passengers dont care for vehicle-age
+					rating += RP_AGE_BONUS_0;
+					points = 0;
+				}
+				rating += (RP_MAX_AGE_POINTS - points);
+			}
+			else
+			{
 				(age >= 3) ||
 				(rating += 10, age >= 2) ||
 				(rating += 10, age >= 1) ||
 				(rating += 13, true);
 			}
+			rs->last_age = age;
+			rs->ratings[RATING_AGE] = rating - old_rating;
+			old_rating = rating;
 
 			{
 				if (st->owner != OWNER_NONE && !IS_HUMAN_PLAYER(st->owner))
 							rating += _rating_boost[_opt.diff.competitor_intelligence];
 			}
 
-			if (st->owner < MAX_PLAYERS && HASBIT(st->town->statues, st->owner))
-				rating += 26;
+			if (_patches.nsr_town_rating)
+			{
+				if (st->owner < MAX_PLAYERS)
+				{
+					if (HASBIT(st->town->statues, st->owner))	rating += RP_OTHER_STATUE;
+					// if townratings are not changed this will be within -20..+20
+					rating += (st->town->ratings[st->owner] / RP_OTHER_LA_MULT);
+				} else {
+					if (st->owner == OWNER_NONE)
+						rating += 26; // oilrigs dont have owner... for now give maxpoints till i know what i want to do here ;)
+				}
+			}
+			else
+			{
+				if (st->owner < MAX_PLAYERS && HASBIT(st->town->statues, st->owner))
+					rating += 26;
+			}
+			rs->ratings[RATING_OTHER] = rating - old_rating;
+			old_rating = rating;
 
+			days = ge->days_since_pickup;
+			if (_patches.nsr_wait_days)
 			{
-				byte days = ge->days_since_pickup;
+				if (ge == &st->goods[CT_PASSENGERS])
+					points = days * 2; // double wait effect for Passengers
+				else
+					points = days;
+				switch (lv_type)	// scale waitdays to RP_MAX_DAYS days
+				{
+					case VEH_Train:		point_clamp = RP_DAYS_T_CLAMP;	break;
+					case VEH_Road:			point_clamp = RP_DAYS_R_CLAMP;	break;
+					case VEH_Ship:			point_clamp = RP_DAYS_S_CLAMP;	break;
+					case VEH_Aircraft:	point_clamp = RP_DAYS_A_CLAMP;	break;
+					default:					point_clamp = RP_MAX_DAYS;
+				}
+				points = clamp(points, 0, point_clamp) * RP_MAX_DAYS / point_clamp;
+				rating += (RP_MAX_DAYS_POINTS - points * RP_MAX_DAYS_POINTS / RP_MAX_DAYS);
+				switch (days) // give bonus for short wait-time
+				{ // uses real days, not scaled days
+					case 0:	rating += RP_DAYS_BONUS_0;	break;
+					case 1:	rating += RP_DAYS_BONUS_1;	break;
+					case 2:	rating += RP_DAYS_BONUS_2;	break;
+					case 3:	rating += RP_DAYS_BONUS_3;	break;
+					case 4:	rating += RP_DAYS_BONUS_4;	break;
+					case 5:	rating += RP_DAYS_BONUS_5;	break;
+					case 6:	rating += RP_DAYS_BONUS_6;	break;
+					case 7:	rating += RP_DAYS_BONUS_7;	break;
+				}
+			}
+			else
+			{
 				if (st->last_vehicle != INVALID_VEHICLE &&
 						GetVehicle(st->last_vehicle)->type == VEH_Ship)
 							days >>= 2;
@@ -2542,9 +2680,42 @@
 				(rating += 45, days > 3) ||
 				(rating += 35, true);
 			}
+			rs->days_since_pickup = ge->days_since_pickup;
+			rs->ratings[RATING_PICKUP] = rating - old_rating;
+			old_rating = rating;
 
+			byte_inc_sat(&ge->enroute_time);
+			byte_inc_sat(&ge->days_since_pickup);
+
+			waiting = ge->waiting_acceptance & MAX_CARGO_WAITING;
+			if (_patches.nsr_wait_cargo)
 			{
-				waiting = ge->waiting_acceptance & 0xFFF;
+				if (ge == &st->goods[CT_PASSENGERS])
+					points = waiting * 2;
+				else
+					points = waiting;
+				switch (lv_type) // scale points to RP_MAX_WAIT
+				{
+					case VEH_Train:		point_clamp = RP_WAIT_T_CLAMP;		break;
+					case VEH_Road:			point_clamp = RP_WAIT_R_CLAMP;		break;
+					case VEH_Ship:			point_clamp = RP_WAIT_S_CLAMP;		break;
+					case VEH_Aircraft:	point_clamp = RP_WAIT_A_CLAMP;		break;
+					default:					point_clamp = RP_MAX_WAIT;
+				}
+				points = clamp(points, 0, point_clamp) * RP_MAX_WAIT / point_clamp;
+				rating += RP_MAX_WAIT_POINTS - points;
+				switch (points) // give bonus for low waiting cargo
+				{ // uses scaled waiting
+					case 0: rating += RP_WAIT_BONUS_0;	break;
+					case 1: rating += RP_WAIT_BONUS_1;	break;
+					case 2: rating += RP_WAIT_BONUS_2;	break;
+					case 3: rating += RP_WAIT_BONUS_3;	break;
+					case 4: rating += RP_WAIT_BONUS_4;	break;
+					case 5: rating += RP_WAIT_BONUS_5;	break;
+				}
+			}
+			else
+			{
 				(rating -= 90, waiting > 1500) ||
 				(rating += 55, waiting > 1000) ||
 				(rating += 35, waiting > 600) ||
@@ -2552,9 +2723,13 @@
 				(rating += 20, waiting > 100) ||
 				(rating += 10, true);
 			}
+			rs->waiting = waiting;
+			rs->ratings[RATING_WAITING] = rating - old_rating;
+			old_rating = rating;
 
 			{
 				int or = ge->rating; // old rating
+				rs->ratings[RATING_TOTAL] = rating;
 
 				// only modify rating in steps of -2, -1, 0, 1 or 2
 				ge->rating = rating = or + clamp(clamp(rating, 0, 255) - or, -2, 2);
@@ -2577,9 +2752,10 @@
 				}
 
 				if (waiting_changed)
-					ge->waiting_acceptance = (ge->waiting_acceptance & ~0xFFF) + waiting;
+					ge->waiting_acceptance = (ge->waiting_acceptance & ~MAX_CARGO_WAITING) + waiting;
 			}
 		}
+		rs++;
 	} while (++ge != endof(st->goods));
 
 	index = st->index;
@@ -2588,6 +2764,8 @@
 		InvalidateWindow(WC_STATION_VIEW, index);
 	else
 		InvalidateWindowWidget(WC_STATION_VIEW, index, 5);
+
+	InvalidateWindow(WC_STATION_RATING_DETAIL, index);
 }
 
 /* called for every station each tick */
@@ -2629,8 +2807,56 @@
 
 }
 
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted)
+{
+	times_counted -= 1; // number of calculated averages till now is one less than actually counted times
+	if (times_counted == 0)
+		return lastamount;
+	average = (uint32)((uint64)(((uint64)average * (uint64)times_counted + (uint64)lastamount) / ((uint64)times_counted + 1)));
+	return average;
+}
+
 void StationMonthlyLoop(void)
 {
+	Station *st;
+	StationStats *sts;
+	GoodsEntry *ge;
+
+ 	FOR_ALL_STATIONS(st) {
+		// if we have stats for this station the number of counted months is >0
+		if (st->months_counted > 0)
+		{
+			for (ge = st->goods; ge != endof(st->goods); ge++) {
+				// if we have stats for this good, the number of months counted is >0
+				if (ge->months_counted > 0) 
+				{
+					// set current months stats to 0 after storing value for last month
+					// do this for all stats (currently In/Out/Transfer)
+					// also determine new min/max-values
+					for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+						if (sts->month_max == 0) sts->month_min = sts->this_month;
+						sts->month_min = min(sts->month_min, sts->this_month);
+						sts->month_max = max(sts->month_max, sts->this_month);
+						sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, ge->months_counted);
+						sts->last_month = sts->this_month;
+						sts->this_month = 0;
+					}
+					ge->months_counted++; // one more month counted
+				}
+			}
+			// update vehicle-counts and min/max
+			for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+				if (sts->month_max == 0) sts->month_min = sts->this_month;
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, st->months_counted);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			st->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, st->index);
+	}
 }
 
 
@@ -2662,6 +2888,7 @@
 	st->goods[type].enroute_time = 0;
 	st->goods[type].enroute_from = st->index;
 	InvalidateWindow(WC_STATION_VIEW, st->index);
+	InvalidateWindow(WC_STATION_STATS, st->index);
 }
 
 /** Rename a station
@@ -2854,7 +3081,7 @@
 			_map2[tile] = st->index;
 
 			st->owner = OWNER_NONE;
-      st->airport_flags = 0;
+			st->airport_flags = 0;
 			st->airport_type = AT_OILRIG;
 			st->xy = tile;
 			st->bus_stops = NULL;
@@ -3051,12 +3278,25 @@
 	SLE_CONDREF(Station,bus_stops,					REF_ROADSTOPS, 6, 255),
 	SLE_CONDREF(Station,truck_stops,				REF_ROADSTOPS, 6, 255),
 
+	// station stats data is stored here since savegame format 14
+//	SLE_CONDVAR(Station,months_counted,	SLE_UINT16, 14, 255),
+
 	// reserve extra space in savegame here. (currently 28 bytes)
 	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 32, 2, 255),
 
 	SLE_END()
 };
 
+// station stats data since savegame format 15
+static const SaveLoad _stats_desc[] = {
+	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,average,	SLE_UINT32, 15, 255),
+	SLE_END()
+};
+
 static const SaveLoad _goods_desc[] = {
 	SLE_VAR(GoodsEntry,waiting_acceptance,SLE_UINT16),
 	SLE_VAR(GoodsEntry,days_since_pickup,	SLE_UINT8),
@@ -3068,22 +3308,33 @@
 	SLE_VAR(GoodsEntry,last_age,					SLE_UINT8),
 	SLE_CONDVAR(GoodsEntry,feeder_profit,			SLE_INT32, 14, 255),
 
+	// station stats data is stored here since savegame format 15
+//	SLE_CONDVAR(GoodsEntry,months_counted,	SLE_UINT16, 15, 255),
+
 	SLE_END()
 };
 
 
 static void SaveLoad_STNS(Station *st)
 {
-	int i;
+	int i; //, j;
 
 	SlObject(st, _station_desc);
 	for (i = 0; i != NUM_CARGO; i++) {
 		SlObject(&st->goods[i], _goods_desc);
+//		for (j = 0; j < STS_AMNT_TYPES; j++)
+//			SlObject(&st->goods[i].cargo_amount[j], _stats_desc);
 
+		// initialize new station rating values
+		st->goods[i].last_vehicle_speed = st->goods[i].last_speed;
+		st->goods[i].last_vehicle_type = INVALID_VEHICLE;
+
 		/* In older versions, enroute_from had 0xFF as INVALID_STATION, is now 0xFFFF */
 		if (_sl.full_version < 0x700 && st->goods[i].enroute_from == 0xFF)
 			st->goods[i].enroute_from = 0xFFFF;
 	}
+//	for (i = 0; i < STS_VEH_TYPES; i++) 
+//		SlObject(&st->vehicles[i], _stats_desc);
 }
 
 static void Save_STNS(void)
@@ -3109,6 +3360,7 @@
 
 		st = GetStation(index);
 		SaveLoad_STNS(st);
+		InitializeStationStats(st);
 
 		// this means it's an oldstyle savegame without support for nonuniform stations
 		if (st->train_tile && st->trainst_h == 0) {
@@ -3175,3 +3427,110 @@
 	{ 'ROAD', Save_ROADSTOP,  Load_ROADSTOP,  CH_ARRAY | CH_LAST},
 };
 
+void SearchVehiclesForStation(Station *st)
+{
+	Vehicle *v;
+	int i;
+	Order* ord;
+	
+	ord = NULL;
+	if (st->xy == 0) return;
+	for(i = 0; i < STS_VEH_TYPES; i++) st->veh_scheduled[i] = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+	
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ||       //Trains (first engine, that contains the orders)
+			( (v->type == VEH_Road) && (v->subtype == 0) ) ||       //Road vehicles (subtype should always be 0 anyway)
+			( (v->type == VEH_Ship) && (v->subtype == 0) ) ||       //Ships, subtype should be 0 anyway)
+			( (v->type == VEH_Aircraft) && (
+				(v->subtype == 0) ||                            //Choppers
+				(v->subtype == 2) ) ) ) &&                               //Fixed-wing stuff
+			(v->owner == st->owner) ) 
+//			(v->owner == _local_player) ) 
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == st->index && ord->type == OT_GOTO_STATION) {
+					switch (v->type) {
+						case VEH_Train:
+							st->veh_scheduled[STS_VEH_TRAIN]++;
+							break;
+						case VEH_Road:
+							st->veh_scheduled[STS_VEH_ROAD]++;
+							if (v->cargo_type == CT_PASSENGERS)
+								st->veh_scheduled[STS_VEH_BUS]++;
+							else
+								st->veh_scheduled[STS_VEH_TRUCK]++;
+							break;
+						case VEH_Ship:
+							st->veh_scheduled[STS_VEH_SHIP]++;
+							break;
+						case VEH_Aircraft:
+							st->veh_scheduled[STS_VEH_AIRCRAFT]++;
+							break;
+						default:
+							NOT_REACHED();
+					}
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	}
+}
+
+int32 CmdResetStationCheat(int NOT_USED_x, int NOT_USED_y, uint32 NOT_USED_flags, uint32 station, uint32 NOT_USED_p2)
+{
+	Station *st = GetStation(station);
+	GoodsEntry *ge;
+#ifndef _DEBUG
+	if (_networking) return CMD_ERROR;
+#endif
+
+	// Reset all goods at station
+	for(ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->last_speed = 0;
+		ge->waiting_acceptance = 0;
+		ge->days_since_pickup = 0;
+		ge->enroute_from = INVALID_STATION;
+		ge->enroute_time = 0;
+		ge->rating = RATING_START_VALUE;
+		ge->last_age = INVALID_AGE;
+		ge->feeder_profit = 0;
+	}
+	st->had_vehicle_of_type = 0;
+	st->time_since_load = INVALID_TIME;
+	st->time_since_unload = INVALID_TIME;
+	st->last_vehicle = INVALID_VEHICLE;
+
+	UpdateStationAcceptance(st, false);
+	return 0;
+}
+
+void InitializeStationStats(Station *st)
+{
+	StationStats *sts;
+	GoodsEntry *ge;
+
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		ge->months_counted = 0;
+		for (sts = ge->cargo_amount; sts != endof(ge->cargo_amount); sts++) {
+			sts->average = 0;
+			sts->last_month = 0;
+			sts->month_max = 0;
+			sts->month_min = 65535;
+			sts->this_month = 0;
+		}
+	}
+	st->months_counted = 0;
+	for (sts = st->vehicles; sts != endof(st->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = 65535;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForStation(st);
+}
Index: engine.c
===================================================================
--- engine.c	(revision 2490)
+++ engine.c	(working copy)
@@ -335,9 +335,13 @@
 			int value = -1;
 
 			//debug("[%p] Having fun resolving variable %x", veh, dsg->variable);
+
 			if (dsg->variable == 0x0C) {
 				/* Callback ID */
 				value = callback_info & 0xFF;
+			} else if (dsg->variable == 0x10) {
+				/* Articulated engine Callback stage */
+				value = (callback_info >> 8) & 0xFF;
 			} else if ((dsg->variable >> 6) == 0) {
 				/* General property */
 				value = GetDeterministicSpriteValue(dsg->variable);
@@ -899,7 +903,7 @@
 	// make maglev / monorail available
 	FOR_ALL_PLAYERS(p) {
 		if (p->is_active)
-			UPDATE_PLAYER_RAILTYPE(e,p);
+			UPDATE_PLAYER_RAILTYPE(e, p);
 	}
 
 	if ((byte)index < NUM_TRAIN_ENGINES) {
@@ -1067,3 +1071,21 @@
 
 	return true;
 }
+
+/**
+ * Calculates the maximum speed of a train vehicle.
+ * @param veh The vehicle to calculate the max speed of
+ * @return The maximum speed of the vehicle, or 0xFFFF if it has no max speed
+ */
+uint16 TrainVehSpeed(const Vehicle *veh)
+{
+	const RailVehicleInfo *rvi = RailVehInfo(veh->engine_type);
+
+	if (rvi->max_speed == 0)
+		return 0xFFFF;
+
+	if ((rvi->flags & RVI_WAGON) && (!_patches.wagon_speed_limits || GetWagonOverrideSpriteSet(veh->engine_type, veh->u.rail.first_engine) != NULL))
+		return 0xFFFF;
+
+	return rvi->max_speed;
+}
Index: engine.h
===================================================================
--- engine.h	(revision 2490)
+++ engine.h	(working copy)
@@ -9,12 +9,13 @@
 	byte base_cost;
 	uint16 max_speed;
 	uint16 power;
+	byte TE_coeff;
 	byte weight;
 	byte running_cost_base;
 	byte engclass; // 0: steam, 1: diesel, 2: electric
 	byte capacity;
 	byte cargo_type;
-	byte callbackmask; // see CallbackMask enum
+	byte callbackmask;
 	uint16 pow_wag_power;
 	byte pow_wag_weight;
 	byte visual_effect; // NOTE: this is not 100% implemented yet, at the moment it is only used as a 'fallback' value
@@ -144,6 +145,11 @@
 	// Refit capacity, the passed vehicle needs to have its ->cargo_type set to
 	// the cargo we are refitting to, returns the new cargo capacity
 	CBID_REFIT_CAP = 0x15,
+
+	// Articulated engine, pass NULL as vehicle, use `build stage` as bits 8-15
+	// of callback_info, returns the engine-id of the next vehicle part to
+	// add, or 0xFF if no more parts need to be added
+	CBID_ARTIC_ENGINE = 0x16,
 };
 
 // bit positions for rvi->callbackmask, indicates which callbacks are used by an engine
@@ -152,6 +158,7 @@
 	CBM_WAGON_POWER = 0,
 	CBM_VEH_LENGTH = 1,
 	CBM_REFIT_CAP = 3,
+	CBM_ARTIC_ENGINE = 4,
 };
 
 enum {
@@ -174,6 +181,8 @@
 #define GetCustomVehicleSprite(v, direction) GetCustomEngineSprite(v->engine_type, v, direction)
 #define GetCustomVehicleIcon(et, direction) GetCustomEngineSprite(et, NULL, direction)
 
+uint16 TrainVehSpeed(const Vehicle *veh);
+
 typedef enum VehicleTrigger {
 	VEHICLE_TRIGGER_NEW_CARGO = 1,
 	// Externally triggered only for the first vehicle in chain
Index: aircraft_cmd.c
===================================================================
--- aircraft_cmd.c	(revision 2490)
+++ aircraft_cmd.c	(working copy)
@@ -342,7 +342,7 @@
 				(_map5[tile] == 32 || _map5[tile] == 65 || _map5[tile] == 86);
 }
 
-static bool CheckStoppedInHangar(Vehicle *v)
+bool CheckStoppedInHangar(Vehicle *v)
 {
 	if (!(v->vehstatus & VS_STOPPED) || !IsAircraftHangarTile(v->tile)) {
 		_error_message = STR_A01B_AIRCRAFT_MUST_BE_STOPPED;
@@ -1275,7 +1275,16 @@
 	if (v->current_order.type == OT_GOTO_DEPOT)
 		return;
 
+	//Maybe check what happens if we go Terminal => Hangar => Terminal
 	st = GetStation(v->u.air.targetairport);
+//	if (v->cargo_type != CT_MAIL) st->this_month_vehicles[5]++;
+	if ((v->subtype == 0) || (v->subtype == 2))
+	{
+		st->vehicles[STS_VEH_AIRCRAFT].this_month++;
+		if (st->months_counted == 0) st->months_counted = 1;
+	}
+	InvalidateWindow(WC_STATION_STATS, st->index);
+	
 	v->last_station_visited = v->u.air.targetairport;
 
 	/* Check if station was ever visited before */
Index: npf.c
===================================================================
--- npf.c	(revision 2490)
+++ npf.c	(working copy)
@@ -21,6 +21,56 @@
 	NPF_TILE_LENGTH, NPF_TILE_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH, NPF_STRAIGHT_LENGTH
 };
 
+/**
+ * Check if a rail track is the end of the line. Will also consider 1-way signals to be the end of a line.
+ * @param tile The tile on which the current track is.
+ * @param trackdir The (track)direction in which you want to look
+ */
+bool IsEndOfLine(TileIndex tile, Trackdir trackdir)
+{
+	byte exitdir = TrackdirToExitdir(trackdir);
+	TileIndex dst_tile;
+	uint32 ts;
+
+	// tunnel entrance?
+	if (IsTileType(tile, MP_TUNNELBRIDGE) && (_map5[tile] & 0xF0)==0 && (_map5[tile] & 3) == exitdir)
+		return false;
+
+	// depot
+	if (IsTileDepotType(tile, TRANSPORT_RAIL))
+		return false;
+
+	/* Calculate next tile */
+	dst_tile = tile + TileOffsByDir(exitdir);
+	// determine the track status on the next tile.
+	ts = GetTileTrackStatus(dst_tile, TRANSPORT_RAIL) & TrackdirReachesTrackdirs(trackdir);
+
+	if ( (uint16)ts == 0) 
+		return true;
+
+	{
+		byte src_type = GetTileRailType(tile, trackdir);
+		byte dst_type = GetTileRailType(dst_tile, TrackdirToExitdir(trackdir));
+		if (src_type != dst_type) {
+			return true;
+		}
+		if (GetTileOwner(tile) != GetTileOwner(dst_tile))
+			return true;
+
+		if (IsTileDepotType(dst_tile, TRANSPORT_RAIL) && (TrackdirToExitdir(trackdir) != ReverseDiagdir(GetDepotDirection(dst_tile, TRANSPORT_RAIL))))
+			return true;
+
+		/* Check for oneway signal against us */
+		if (IsTileType(dst_tile, MP_RAILWAY) && GetRailTileType(dst_tile) == RAIL_TYPE_SIGNALS) {
+			if (HasSignalOnTrackdir(dst_tile, ReverseTrackdir(FindFirstBit2x64(ts))) && !HasSignalOnTrackdir(dst_tile, FindFirstBit2x64(ts)))
+				// if one way signal not pointing towards us, stop going in this direction.
+				return true;
+		}
+
+		return false;
+	}
+};
+
 static uint NTPHash(uint key1, uint key2)
 {
 	/* This function uses the old hash, which is fixed on 10 bits (1024 buckets) */
@@ -76,6 +126,82 @@
 	return TileXY(x, y);
 };
 
+/* On PBS pathfinding runs, this is called before pathfinding ends (BeforeExit aystar callback), and will
+ * reserve the appropriate tracks, if needed. */
+void NPFReservePBSPath(AyStar *as)
+{
+	NPFFoundTargetData* ftd = (NPFFoundTargetData*)as->user_path;
+	bool eol_end = false;
+
+	if (ftd->best_trackdir == 0xFF)
+		return;
+
+	if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_EXIT) && IsEndOfLine(ftd->node.tile, ftd->node.direction) && !NPFGetFlag(&ftd->node, NPF_FLAG_SEEN_SIGNAL)) {
+		/* The path ends in an end of line, we'll need to reserve a path.
+		 * We treat and end of line as a red exit signal */
+		eol_end = true;
+		NPFSetFlag(&ftd->node, NPF_FLAG_PBS_EXIT, true);
+		if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_TARGET_SEEN))
+			NPFSetFlag(&ftd->node, NPF_FLAG_PBS_RED, true);
+	}
+
+	if (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_CHOICE)) {
+		/* there have been no choices to make on our path, we dont care if our end signal is red */
+		NPFSetFlag(&ftd->node, NPF_FLAG_PBS_RED, false);
+	}
+
+	if (NPFGetFlag(&ftd->node, NPF_FLAG_PBS_EXIT) && // we passed an exit signal
+		 !NPFGetFlag(&ftd->node, NPF_FLAG_PBS_BLOCKED) && // we didnt encounter reserver tracks
+		 (((as->user_data[NPF_PBS_MODE] & PBS_MODE_MASK) != PBS_MODE_GREEN) || (!NPFGetFlag(&ftd->node, NPF_FLAG_PBS_RED))) ) { // our mode permits having a red exit signal, or the signal is green
+		PathNode parent;
+		PathNode *curr;
+		PathNode *prev;
+		TileIndex start = INVALID_TILE;
+		byte trackdir = 0;
+
+		parent.node = ftd->node;
+		parent.parent = &ftd->path;
+		curr = &parent;
+		prev = NULL;
+
+		do {
+			if (!NPFGetFlag(&curr->node, NPF_FLAG_PBS_EXIT) || eol_end) {
+				/* check for already reserved track on this path, if they clash with what we
+				   currently trying to reserve, we have a self-crossing path :-( */
+				if ((PBSTileUnavail(curr->node.tile) & (1 << curr->node.direction))
+				&& !(PBSTileReserved(curr->node.tile) & (1 << (curr->node.direction & 7)))
+				&& (start != INVALID_TILE)) {
+					/* It's actually quite bad if this happens, it means the pathfinder
+					 * found a path that is intersecting with itself, which is a very bad
+					 * thing in a pbs block. Also there is not much we can do about it at
+					 * this point....
+					 * BUT, you have to have a pretty fucked up junction layout for this to happen,
+					 * so we'll just stop this train, the user will eventually notice, so he can fix it.
+					 */
+					PBSClearPath(start, trackdir);
+					NPFSetFlag(&ftd->node, NPF_FLAG_PBS_BLOCKED, true);
+					DEBUG(pbs, 1) ("PBS: Self-crossing path!!!");
+					return;
+				};
+
+				PBSReserveTrack(curr->node.tile, (curr->node.direction & 7) );
+
+				/* we want to reserve the last tile (with the signal) on the path too */
+				if (prev != NULL && start == INVALID_TILE) {
+					PBSReserveTrack(prev->node.tile, (prev->node.direction & 7) );
+					start = prev->node.tile;
+					trackdir = ReverseTrackdir(prev->node.direction);
+				}
+			}
+
+			prev = curr;
+			curr = curr->parent;
+		} while (curr != NULL);
+	}
+
+}
+
+
 /* Calcs the heuristic to the target station or tile. For train stations, it
  * takes into account the direction of approach.
  */
@@ -98,15 +224,28 @@
 		/* Ships and trains can also go diagonal, so the minimum distance is shorter */
 		dist = DistanceTrack(from, to) * NPF_TILE_LENGTH;
 
-	if (dist < ftd->best_bird_dist) {
+	DEBUG(npf, 4)("Calculating H for: (%d, %d). Result: %d", TileX(current->tile), TileY(current->tile), dist);
+
+	/* for pbs runs, we ignore tiles not out of the pbs block for the tracking
+	   of the 'closest' tile */
+	if ((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE)
+	&&  (!NPFGetFlag(current , NPF_FLAG_SEEN_SIGNAL))
+	&&  (!IsEndOfLine(current->tile, current->direction)))
+		return dist;
+
+	if ((dist < ftd->best_bird_dist) ||
+		/* for pbs runs, prefer tiles that pass a green exit signal to the pbs blocks */
+		((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE) && !NPFGetFlag(current, NPF_FLAG_PBS_RED) && NPFGetFlag(&ftd->node, NPF_FLAG_PBS_RED))
+) {
 		ftd->best_bird_dist = dist;
 		ftd->best_trackdir = current->user_data[NPF_TRACKDIR_CHOICE];
+		ftd->path = parent->path;
+		ftd->node = *current;
+		//debug("new low tile: %x", ftd->node.tile);
 	}
-	DEBUG(npf, 4)("Calculating H for: (%d, %d). Result: %d", TileX(current->tile), TileY(current->tile), dist);
 	return dist;
 }
 
-
 /* Fills AyStarNode.user_data[NPF_TRACKDIRCHOICE] with the chosen direction to
  * get here, either getting it from the current choice or from the parent's
  * choice */
@@ -297,6 +436,11 @@
 	}
 
 	/* Determine extra costs */
+	
+	/* Check for reserved tracks (PBS) */
+	if (((as->user_data[NPF_PBS_MODE]&PBS_MODE_MASK) != PBS_MODE_NONE) && !(NPFGetFlag(current, NPF_FLAG_PBS_EXIT)) && !(NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) && (PBSTileUnavail(tile) & (1<<trackdir))) {
+		NPFSetFlag(current, NPF_FLAG_PBS_BLOCKED, true);
+	};
 
 	/* Check for signals */
 	if (IsTileType(tile, MP_RAILWAY) && HasSignalOnTrackdir(tile, trackdir)) {
@@ -314,6 +458,10 @@
 					cost += _patches.npf_rail_firstred_exit_penalty;
 				else
 					cost += _patches.npf_rail_firstred_penalty;
+
+				/* for pbs runs, store the fact that the exit signal to the pbs block was red */
+				if (!(NPFGetFlag(current, NPF_FLAG_PBS_EXIT)) && !(NPFGetFlag(current, NPF_FLAG_PBS_RED)) && NPFGetFlag(current, NPF_FLAG_PBS_CHOICE))
+					NPFSetFlag(current, NPF_FLAG_PBS_RED, true);
 			}
 			/* Record the state of this signal */
 			NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, true);
@@ -321,6 +469,15 @@
 			/* Record the state of this signal */
 			NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, false);
 		}
+		
+		if (!NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL) && NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) {
+			/* penalise a path through the pbs block if it crosses reserved tracks */
+			cost += 1000;
+		}
+		if ((PBSIsPbsSignal(tile, trackdir)) && !NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL)) {
+			/* we've encountered an exit signal to the pbs block */
+			NPFSetFlag(current, NPF_FLAG_PBS_EXIT, true);
+		}
 		NPFSetFlag(current, NPF_FLAG_SEEN_SIGNAL, true);
 	}
 
@@ -341,12 +498,25 @@
 	//TODO, with realistic acceleration, also the amount of straight track between
 	//      curves should be taken into account, as this affects the speed limit.
 
-	/* Check for reverse in depot */
-	if (IsTileDepotType(tile, TRANSPORT_RAIL) && !as->EndNodeCheck(as, &new_node)==AYSTAR_FOUND_END_NODE)
+
+	/* Check for depots */
+		if (IsTileDepotType(tile, TRANSPORT_RAIL)) {
 		/* Penalise any depot tile that is not the last tile in the path. This
 		 * _should_ penalise every occurence of reversing in a depot (and only
 		 * that) */
-		cost += _patches.npf_rail_depot_reverse_penalty;
+		if (!as->EndNodeCheck(as, &new_node)==AYSTAR_FOUND_END_NODE) 
+			cost += _patches.npf_rail_depot_reverse_penalty;
+		/* Treat depot as pbs signal? */
+		if (!NPFGetFlag(current, NPF_FLAG_SEEN_SIGNAL)) {
+			if (NPFGetFlag(current, NPF_FLAG_PBS_BLOCKED)) {
+				cost += 1000;
+			}
+			if (PBSIsPbsSegment(tile, TrackdirToExitdir(ReverseTrackdir(trackdir))*2+1)) { // TODO: fix hack?
+				NPFSetFlag(current, NPF_FLAG_PBS_EXIT, true);
+			}
+		}
+		NPFSetFlag(current, NPF_FLAG_LAST_SIGNAL_RED, false);
+	}
 
 	/* Check for occupied track */
 	//TODO
@@ -380,8 +550,13 @@
 	 * is correct */
 	if (
 		(fstd->station_index == -1 && tile == fstd->dest_coords) || /* We've found the tile, or */
-		(IsTileType(tile, MP_STATION) && _map2[tile] == fstd->station_index) /* the station */
+		(IsTileType(tile, MP_STATION) && _map2[tile] == fstd->station_index) || /* the station */
+		(NPFGetFlag(node, NPF_FLAG_PBS_TARGET_SEEN)) /* or, we've passed it already (for pbs) */
 	) {
+		NPFSetFlag(&current->path.node, NPF_FLAG_PBS_TARGET_SEEN, true);
+		/* for pbs runs, only accept we've found the target if we've also found a way out of the block */
+		if ((as->user_data[NPF_PBS_MODE] != PBS_MODE_NONE) && !NPFGetFlag(node, NPF_FLAG_SEEN_SIGNAL) && !IsEndOfLine(node->tile, node->direction))
+			return AYSTAR_DONE;
 		return AYSTAR_FOUND_END_NODE;
 	} else {
 		return AYSTAR_DONE;
@@ -399,6 +574,7 @@
 	ftd->best_path_dist = current->g;
 	ftd->best_bird_dist = 0;
 	ftd->node = current->path.node;
+	ftd->path = current->path;
 }
 
 /**
@@ -475,6 +651,8 @@
 	aystar->num_neighbours = 0;
 	DEBUG(npf, 4)("Expanding: (%d, %d, %d) [%d]", TileX(src_tile), TileY(src_tile), src_trackdir, src_tile);
 
+	aystar->EndNodeCheck(aystar, current);
+
 	/* Find dest tile */
 	if (IsTileType(src_tile, MP_TUNNELBRIDGE) && (_map5[src_tile] & 0xF0)==0 && (DiagDirection)(_map5[src_tile] & 3) == src_exitdir) {
 		/* This is a tunnel. We know this tunnel is our type,
@@ -563,7 +741,17 @@
 	/* Select only trackdirs we can reach from our current trackdir */
 	trackdirbits &= TrackdirReachesTrackdirs(src_trackdir);
 	if (_patches.forbid_90_deg && (type == TRANSPORT_RAIL || type == TRANSPORT_WATER)) /* Filter out trackdirs that would make 90 deg turns for trains */
-		trackdirbits &= ~TrackdirCrossesTrackdirs(src_trackdir);
+
+	trackdirbits &= ~TrackdirCrossesTrackdirs(src_trackdir);
+
+	if (KillFirstBit2x64(trackdirbits) != 0)
+		NPFSetFlag(&current->path.node, NPF_FLAG_PBS_CHOICE, true);
+
+	/* When looking for 'any' route, ie when already inside a pbs block, discard all tracks that would cross
+	   other reserved tracks, so we *always* will find a valid route if there is one */
+	if (!(NPFGetFlag(&current->path.node, NPF_FLAG_PBS_EXIT)) && ((aystar->user_data[NPF_PBS_MODE]&PBS_MODE_MASK) == PBS_MODE_ANY))
+		trackdirbits &= ~PBSTileUnavail(dst_tile);
+
 	DEBUG(npf,6)("After filtering: (%d, %d), possible trackdirs: %#x", TileX(dst_tile), TileY(dst_tile), trackdirbits);
 
 	i = 0;
@@ -604,7 +792,8 @@
  * multiple targets that are spread around, we should perform a breadth first
  * search by specifiying CalcZero as our heuristic.
  */
-static NPFFoundTargetData NPFRouteInternal(AyStarNode* start1, AyStarNode* start2, NPFFindStationOrTileData* target, AyStar_EndNodeCheck target_proc, AyStar_CalculateH heuristic_proc, TransportType type, Owner owner, uint reverse_penalty)
+
+static NPFFoundTargetData NPFRouteInternal(AyStarNode* start1, AyStarNode* start2, NPFFindStationOrTileData* target, AyStar_EndNodeCheck target_proc, AyStar_CalculateH heuristic_proc, TransportType type, Owner owner, uint reverse_penalty, byte pbs_mode)
 {
 	int r;
 	NPFFoundTargetData result;
@@ -623,6 +812,11 @@
 	else
 		assert(0);
 
+	if (pbs_mode != PBS_MODE_NONE)
+		_npf_aystar.BeforeExit = NPFReservePBSPath;
+	else
+		_npf_aystar.BeforeExit = NULL;
+
 	/* Initialize Start Node(s) */
 	start1->user_data[NPF_TRACKDIR_CHOICE] = INVALID_TRACKDIR;
 	start1->user_data[NPF_NODE_FLAGS] = 0;
@@ -646,6 +840,7 @@
 	/* Initialize user_data */
 	_npf_aystar.user_data[NPF_TYPE] = type;
 	_npf_aystar.user_data[NPF_OWNER] = owner;
+	_npf_aystar.user_data[NPF_PBS_MODE] = pbs_mode;
 
 	/* GO! */
 	r = AyStarMain_Main(&_npf_aystar);
@@ -663,7 +858,7 @@
 	return result;
 }
 
-NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner)
+NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode)
 {
 	AyStarNode start1;
 	AyStarNode start2;
@@ -677,12 +872,12 @@
 	start2.direction = trackdir2;
 	start2.user_data[NPF_TRACKDIR_CHOICE] = INVALID_TRACKDIR;
 
-	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), target, NPFFindStationOrTile, NPFCalcStationOrTileHeuristic, type, owner, 0);
+	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), target, NPFFindStationOrTile, NPFCalcStationOrTileHeuristic, type, owner, 0, pbs_mode);
 }
 
-NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner)
+NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode)
 {
-	return NPFRouteToStationOrTileTwoWay(tile, trackdir, INVALID_TILE, 0, target, type, owner);
+	return NPFRouteToStationOrTileTwoWay(tile, trackdir, INVALID_TILE, 0, target, type, owner, pbs_mode);
 }
 
 NPFFoundTargetData NPFRouteToDepotBreadthFirstTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, TransportType type, Owner owner, uint reverse_penalty)
@@ -701,7 +896,7 @@
 
 	/* perform a breadth first search. Target is NULL,
 	 * since we are just looking for any depot...*/
-	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), NULL, NPFFindDepot, NPFCalcZero, type, owner, reverse_penalty);
+	return NPFRouteInternal(&start1, (IsValidTile(tile2) ? &start2 : NULL), NULL, NPFFindDepot, NPFCalcZero, type, owner, reverse_penalty, PBS_MODE_NONE);
 }
 
 NPFFoundTargetData NPFRouteToDepotBreadthFirst(TileIndex tile, Trackdir trackdir, TransportType type, Owner owner)
@@ -754,6 +949,8 @@
 	else
 		assert(0);
 
+	_npf_aystar.BeforeExit = NULL;
+
 	/* Initialize target */
 	target.station_index = -1; /* We will initialize dest_coords inside the loop below */
 	_npf_aystar.user_target = &target;
@@ -761,6 +958,7 @@
 	/* Initialize user_data */
 	_npf_aystar.user_data[NPF_TYPE] = type;
 	_npf_aystar.user_data[NPF_OWNER] = owner;
+	_npf_aystar.user_data[NPF_PBS_MODE] = PBS_MODE_NONE;
 
 	/* Initialize Start Node */
 	start.tile = tile;
Index: vehicle_gui.c
===================================================================
--- vehicle_gui.c	(revision 2490)
+++ vehicle_gui.c	(working copy)
@@ -10,6 +10,9 @@
 #include "gui.h"
 #include "command.h"
 #include "gfx.h"
+#include "station.h"
+#include "waypoint.h"
+#include "depot.h"
 
 VehicleSortListingTypeFunctions * const _vehicle_sorter[] = {
 	&VehicleUnsortedSorter,
@@ -51,6 +54,7 @@
 		switch (w->window_class) {
 		case WC_TRAINS_LIST: case WC_ROADVEH_LIST:
 		case WC_SHIPS_LIST:  case WC_AIRCRAFT_LIST:
+		case WC_VEHICLES_LIST:
 			WP(w, vehiclelist_d).flags |= VL_REBUILD;
 			SetWindowDirty(w);
 			break;
@@ -66,6 +70,7 @@
 		switch (w->window_class) {
 		case WC_TRAINS_LIST: case WC_ROADVEH_LIST:
 		case WC_SHIPS_LIST:  case WC_AIRCRAFT_LIST:
+		case WC_VEHICLES_LIST:
 			WP(w, vehiclelist_d).flags |= VL_RESORT;
 			SetWindowDirty(w);
 			break;
@@ -73,61 +78,6 @@
 		}
 }
 
-void BuildVehicleList(vehiclelist_d *vl, int type, int owner, int station)
-{
-	int subtype = (type != VEH_Aircraft) ? TS_Front_Engine : 2;
-	int n = 0;
-	int i;
-
-	if (!(vl->flags & VL_REBUILD)) return;
-
-	/* Create array for sorting */
-	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
-	if (_vehicle_sort == NULL)
-		error("Could not allocate memory for the vehicle-sorting-list");
-
-	DEBUG(misc, 1) ("Building vehicle list for player %d station %d...",
-		owner, station);
-
-	if (station != -1) {
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == type && v->subtype <= subtype) {
-				const Order *order;
-
-				FOR_VEHICLE_ORDERS(v, order) {
-					if (order->type == OT_GOTO_STATION && order->station == station) {
-						_vehicle_sort[n].index = v->index;
-						_vehicle_sort[n].owner = v->owner;
-						++n;
-						break;
-					}
-				}
-			}
-		}
-	} else {
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == type && v->subtype <= subtype && v->owner == owner) {
-				_vehicle_sort[n].index = v->index;
-				_vehicle_sort[n].owner = v->owner;
-				++n;
-			}
-		}
-	}
-
-	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
-	if (n!=0 && vl->sort_list == NULL)
-		error("Could not allocate memory for the vehicle-sorting-list");
-	vl->list_length = n;
-
-	for (i = 0; i < n; ++i)
-		vl->sort_list[i] = _vehicle_sort[i];
-
-	vl->flags &= ~VL_REBUILD;
-	vl->flags |= VL_RESORT;
-}
-
 void SortVehicleList(vehiclelist_d *vl)
 {
 	if (!(vl->flags & VL_RESORT)) return;
@@ -1061,3 +1011,104 @@
 {
 	memset(&_sorting, 0, sizeof(_sorting));
 }
+
+void BuildVehicleListMasked(vehiclelist_d *vl, DisplayListOption *listopt, int owner)
+{
+	const byte landscape = _opt.landscape;
+	int i, n = 0;
+	uint64 cmask;
+
+	if (!(vl->flags & VL_REBUILD)) return;
+
+	/* Create array for sorting */
+	_vehicle_sort = realloc(_vehicle_sort, GetVehiclePoolSize() * sizeof(_vehicle_sort[0]));
+	if (_vehicle_sort == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+
+	DEBUG(misc, 1) ("Building vehicle list for player %d station at %d...",
+		owner, listopt->xy);
+	
+	if (listopt->xy != INVALID_TILE) {  // Build List for a station/waypoint/depot (other?)
+		const Vehicle *v;
+
+		assert(listopt->xy < MapSize()); // not really needed, you will get an empty list when xy is outside the mapbounds
+
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->type_mask, v->type)
+				&& ((v->subtype == TS_Front_Engine)
+					|| (v->type == VEH_Aircraft && v->subtype == SUBTYPE_AIRCRAFT))) {
+				if (listopt->cargo_mask == CARGO_MASK_ALL) {
+					cmask = CARGO_MASK_ALL;
+				} else {
+					const Vehicle *u = v;
+					cmask = 0;
+					for (u = v; u != NULL; u = u->next) { // check cargotypes of all vehicles of the consist (trains/aircraft)
+					// vehicles that cant carry any cargo may have cargotype 0 == CT_PASSENGERS,
+					// so we have to make sure we only get those that could really carry cargo
+					// think we should make them have INVALID_CARGO cargotype instead... (Asterix)
+						if (u->cargo_cap != 0)
+							cmask |= HASBIT(_landscape_global_cargo_mask[landscape], u->cargo_type);
+					}
+				}
+				if (listopt->cargo_mask & cmask) {
+					const Order *order;
+
+					FOR_VEHICLE_ORDERS(v, order) { // check if consist is scheduled for this map-position
+						if (order->type == OT_GOTO_STATION && GetStation(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						} else if (order->type == OT_GOTO_WAYPOINT && GetWaypoint(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						} else if (order->type == OT_GOTO_DEPOT && GetDepot(order->station)->xy == listopt->xy) {
+								_vehicle_sort[n].index = v->index;
+								_vehicle_sort[n].owner = v->owner;
+								++n;
+								break;
+						}
+					} // Vehicle Orders
+				}
+			}
+		} // All Vehicles
+	} else {
+		Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			if (HASBIT(listopt->type_mask, v->type) && (v->owner == owner)
+				&& ((v->subtype == TS_Front_Engine)
+					|| (v->type == VEH_Aircraft && v->subtype == SUBTYPE_AIRCRAFT))) {
+				if (listopt->cargo_mask == CARGO_MASK_ALL) {
+					_vehicle_sort[n].index = v->index;
+					_vehicle_sort[n].owner = v->owner;
+					++n;
+				} else {
+					Vehicle *u = v;
+					cmask = 0;
+					for (u = v; u != NULL; u = u->next) { // check cargotypes of all vehicles of the consist (trains/aircraft)
+						if (u->cargo_cap != 0)
+							cmask |= HASBIT(_landscape_global_cargo_mask[landscape], u->cargo_type);
+					}
+					if (listopt->cargo_mask & cmask) {
+						_vehicle_sort[n].index = v->index;
+						_vehicle_sort[n].owner = v->owner;
+						++n;
+					}
+				}
+			}
+		} // All Vehicles
+	}
+
+	vl->sort_list = realloc(vl->sort_list, n * sizeof(vl->sort_list[0]));
+	if (n != 0 && vl->sort_list == NULL)
+		error("Could not allocate memory for the vehicle-sorting-list");
+	vl->list_length = n;
+
+	for (i = 0; i < n; ++i)
+		vl->sort_list[i] = _vehicle_sort[i];
+
+	vl->flags &= ~VL_REBUILD;
+	vl->flags |= VL_RESORT;
+}
Index: debug.c
===================================================================
--- debug.c	(revision 2490)
+++ debug.c	(working copy)
@@ -14,6 +14,7 @@
 int _debug_net_level;
 int _debug_spritecache_level;
 int _debug_oldloader_level;
+int _debug_pbs_level;
 int _debug_npf_level;
 
 
@@ -44,6 +45,7 @@
 	DEBUG_LEVEL(net),
 	DEBUG_LEVEL(spritecache),
 	DEBUG_LEVEL(oldloader),
+	DEBUG_LEVEL(pbs),
 	DEBUG_LEVEL(npf)
 	};
 #undef DEBUG_LEVEL
Index: rail.c
===================================================================
--- rail.c	(revision 2490)
+++ rail.c	(working copy)
@@ -75,6 +75,15 @@
 	{TRACKDIR_RIGHT_N,  TRACKDIR_RIGHT_S,  INVALID_TRACKDIR,  INVALID_TRACKDIR}
 };
 
+const Trackdir _track_enterdir_to_trackdir[6][4] = { // TODO: replace magic with enums
+	{0,    0xff, 8,    0xff},
+	{0xff, 1,    0xff, 9},
+	{0xff, 2,    10,   0xff},
+	{3,    0xff, 0xff, 11},
+	{12,   4,    0xff, 0xff},
+	{0xff, 0xff, 5,    13}
+};
+
 const Trackdir _track_direction_to_trackdir[][DIR_END] = {
 	{INVALID_TRACKDIR, TRACKDIR_DIAG1_NE, INVALID_TRACKDIR, INVALID_TRACKDIR,  INVALID_TRACKDIR, TRACKDIR_DIAG1_SW, INVALID_TRACKDIR, INVALID_TRACKDIR},
 	{INVALID_TRACKDIR, INVALID_TRACKDIR,  INVALID_TRACKDIR, TRACKDIR_DIAG2_SE, INVALID_TRACKDIR, INVALID_TRACKDIR,  INVALID_TRACKDIR, TRACKDIR_DIAG2_NW},
Index: npf.h
===================================================================
--- npf.h	(revision 2490)
+++ npf.h	(working copy)
@@ -4,6 +4,7 @@
 #include "openttd.h"
 #include "aystar.h"
 #include "vehicle.h"
+#include "pbs.h"
 #include "tile.h"
 #include "rail.h"
 
@@ -35,16 +36,23 @@
 enum { /* Indices into AyStar.userdata[] */
 	NPF_TYPE = 0, /* Contains a TransportTypes value */
 	NPF_OWNER, /* Contains an Owner value */
+	NPF_PBS_MODE, /* Contains the pbs mode, see pbs.h */
 };
 
 enum { /* Indices into AyStarNode.userdata[] */
 	NPF_TRACKDIR_CHOICE = 0, /* The trackdir chosen to get here */
 	NPF_NODE_FLAGS,
 };
+
 typedef enum { /* Flags for AyStarNode.userdata[NPF_NODE_FLAGS]. Use NPFGetBit() and NPFGetBit() to use them. */
 	NPF_FLAG_SEEN_SIGNAL, /* Used to mark that a signal was seen on the way, for rail only */
 	NPF_FLAG_REVERSE, /* Used to mark that this node was reached from the second start node, if applicable */
 	NPF_FLAG_LAST_SIGNAL_RED, /* Used to mark that the last signal on this path was red */
+	NPF_FLAG_PBS_EXIT, /* Used to mark tracks inside a pbs block, for rail only, for the end node, this is set when the path found goes through a pbs block */
+	NPF_FLAG_PBS_BLOCKED, /* Used to mark that this path crosses another pbs path */
+	NPF_FLAG_PBS_RED, /* Used to mark that this path goes through a red exit-pbs signal */
+	NPF_FLAG_PBS_CHOICE, /*  */
+	NPF_FLAG_PBS_TARGET_SEEN, /*  */
 } NPFNodeFlag;
 
 typedef struct NPFFoundTargetData { /* Meant to be stored in AyStar.userpath */
@@ -52,6 +60,7 @@
 	uint best_path_dist; /* The shortest path. Is (uint)-1 if no path is found */
 	Trackdir best_trackdir; /* The trackdir that leads to the shortest path/closest birds dist */
 	AyStarNode node; /* The node within the target the search led us to */
+	PathNode path;
 } NPFFoundTargetData;
 
 /* These functions below are _not_ re-entrant, in favor of speed! */
@@ -59,12 +68,14 @@
 /* Will search from the given tile and direction, for a route to the given
  * station for the given transport type. See the declaration of
  * NPFFoundTargetData above for the meaning of the result. */
-NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner);
+NPFFoundTargetData NPFRouteToStationOrTile(TileIndex tile, Trackdir trackdir, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode);
+
 /* Will search as above, but with two start nodes, the second being the
  * reverse. Look at the NPF_FLAG_REVERSE flag in the result node to see which
  * direction was taken (NPFGetBit(result.node, NPF_FLAG_REVERSE)) */
-NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner);
 
+NPFFoundTargetData NPFRouteToStationOrTileTwoWay(TileIndex tile1, Trackdir trackdir1, TileIndex tile2, Trackdir trackdir2, NPFFindStationOrTileData* target, TransportType type, Owner owner, byte pbs_mode);
+
 /* Will search a route to the closest depot. */
 
 /* Search using breadth first. Good for little track choice and inaccurate
Index: vehicle_gui.h
===================================================================
--- vehicle_gui.h	(revision 2490)
+++ vehicle_gui.h	(working copy)
@@ -5,6 +5,37 @@
 
 struct vehiclelist_d;
 
+enum {
+	SUBTYPE_AIRCRAFT = 2,
+	CARGO_MASK_ALL   = 0xFFFFFFFFFFFFFFFFll,
+	VEHICLE_TYPE_ALL = 0xF0000,
+};
+
+/** Options for building vehicle-lists
+  * stored in the window-struct and used in BuildVehicleList()
+  * 
+  * xy:         xy-value of the station/waypoint/depot the vehicle should be scheduled for
+  *             use INVALID_STATION if you dont want vehicles scheduled for a specific destination
+  * cargo_mask: 64-bit mask using global cargo ids
+  *             determines which vehicles should be selected by cargo-type
+  *             use CARGO_MASK_ALL if you dont want to distinguish by cargo-type
+  * type_mask:  32-bit mask that controls varios parts of the list
+  *             currently implemented:
+  *             Vehicle type: uses bits 16 to 19 (VEH_Train = 16, VEH_Aircraft = 19)
+  *                           to determine which vehicletypes should be selected
+  *                           use VEHICLE_TYPE_ALL if you dont want to distinguish by vehicletype
+  *             planned:
+  *             vehicle-age: select only yehicles older/newer/at given age
+  *             more specific vehicle type: e.g. select a specific Train-Engine to be shown only
+  *             flags: should age be same/higher/lower as given value?
+  *                    include or exclude given vehicle?
+  */
+typedef struct DisplayListOptions {
+	TileIndex xy;
+	uint64 cargo_mask;
+	uint32 type_mask;
+} DisplayListOption;
+
 void DrawVehicleProfitButton(Vehicle *v, int x, int y);
 CargoID DrawVehicleRefitWindow(const Vehicle *v, int sel);
 void InitializeVehiclesGuiList(void);
@@ -13,7 +44,15 @@
 void RebuildVehicleLists(void);
 void ResortVehicleLists(void);
 
-void BuildVehicleList(struct vehiclelist_d *vl, int type, int owner, int station);
+/** builds a list of all vehicles that comply with the criteria given
+  *
+  * @param vl: the list to be build/rebuild
+  * @param listopt: struct with the listoptions
+  * @param owner: the owner of the vehicles that are added to the list
+  *
+  * @see DisplayListOption
+  */
+void BuildVehicleListMasked(struct vehiclelist_d *vl, DisplayListOption *listopt, int owner);
 void SortVehicleList(struct vehiclelist_d *vl);
 
 int CDECL GeneralOwnerSorter(const void *a, const void *b);
@@ -58,6 +97,7 @@
 	Listing roadveh;
 	Listing ship;
 	Listing train;
+	Listing masked;
 } Sorting;
 
 VARDEF Sorting _sorting;
@@ -76,5 +116,10 @@
 void DrawAircraftPurchaseInfo(int x, int y, EngineID engine_number);
 void DrawShipPurchaseInfo(int x, int y, EngineID engine_number);
 
+void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection);
+void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection);
+void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection);
+void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection);
 
+
 #endif /* VEHICLE_GUI_H */
Index: debug.h
===================================================================
--- debug.h	(revision 2490)
+++ debug.h	(working copy)
@@ -14,6 +14,7 @@
 	extern int _debug_net_level;
 	extern int _debug_spritecache_level;
 	extern int _debug_oldloader_level;
+	extern int _debug_pbs_level;
 	extern int _debug_npf_level;
 #endif
 
Index: rail.h
===================================================================
--- rail.h	(revision 2490)
+++ rail.h	(working copy)
@@ -317,6 +317,15 @@
 }
 
 /**
+ * Maps a track and an (4-way) dir to the trackdir that represents the track
+ * with the exit in the given direction.
+ */
+static inline Trackdir TrackEnterdirToTrackdir(Track track, DiagDirection diagdir) {
+	extern const Trackdir _track_enterdir_to_trackdir[TRACK_END][DIAGDIR_END];
+	return _track_enterdir_to_trackdir[track][diagdir];
+}
+
+/**
  * Maps a track and a full (8-way) direction to the trackdir that represents
  * the track running in the given direction.
  */
Index: misc_gui.c
===================================================================
--- misc_gui.c	(revision 2490)
+++ misc_gui.c	(working copy)
@@ -1690,14 +1690,15 @@
 	{CE_BOOL, 0, STR_CHEAT_SETUP_PROD,			&_cheats.setup_prod.value,			&_cheats.setup_prod.been_used,			NULL,											0, 0, 0},
 	{CE_UINT8, 0, STR_CHEAT_SWITCH_CLIMATE, &_opt.landscape, 								&_cheats.switch_climate.been_used,	&ClickChangeClimateCheat,-1, 4, 1},
 	{CE_UINT8, 0, STR_CHEAT_CHANGE_DATE,		&_cur_year,											&_cheats.change_date.been_used,			&ClickChangeDateCheat,	 -1, 1, 1},
+	{CE_BOOL, 0, STR_CHEAT_RESET_STATION,			&_cheats.reset_station.value,			&_cheats.reset_station.been_used,			&ClickResetStationCheat,											0, 0, 0},
 };
 
 
 static const Widget _cheat_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   399,     0,    13, STR_CHEATS,	STR_018C_WINDOW_TITLE_DRAG_THIS},
-{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_NULL},
-{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   159, 0x0,					STR_CHEATS_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   399,    14,   173, 0x0,					STR_CHEATS_TIP},
 {   WIDGETS_END},
 };
 
@@ -1832,7 +1833,7 @@
 	}
 }
 static const WindowDesc _cheats_desc = {
-	240, 22, 400, 160,
+	240, 22, 400, 174,
 	WC_CHEATS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
 	_cheat_widgets,
Index: lang/english.txt
===================================================================
--- lang/english.txt	(revision 2490)
+++ lang/english.txt	(working copy)
@@ -1002,6 +1002,7 @@
 STR_CONFIG_PATCHES_EXTRADYNAMITE                                :{LTBLUE}Allow removal of more town-owned roads, bridges, etc: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_MAMMOTHTRAINS                                :{LTBLUE}Enable building very long trains: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_REALISTICACCEL                               :{LTBLUE}Enable realistic acceleration for trains: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_WAGONSPEEDLIMITS                             :{LTBLUE}Take into account speed limits of wagons: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_FORBID_90_DEG                                :{LTBLUE}Forbid trains and ships to make 90 deg turns: {ORANGE}{STRING} {LTBLUE} (requires NPF)
 STR_CONFIG_PATCHES_JOINSTATIONS                                 :{LTBLUE}Join train stations built next to each other: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_FULLLOADANY                                  :{LTBLUE}Leave station when any cargo is full, if 'full load': {ORANGE}{STRING}
@@ -1073,6 +1074,7 @@
 STR_CONFIG_PATCHES_SMOOTH_ECONOMY                               :{LTBLUE}Enable smooth economy (more, smaller changes)
 STR_CONFIG_PATCHES_ALLOW_SHARES                                 :{LTBLUE}Allow buying shares from other companies
 STR_CONFIG_PATCHES_DRAG_SIGNALS_DENSITY                         :{LTBLUE}When dragging, place signals every: {ORANGE}{STRING} tile(s)
+STR_CONFIG_AUTO_PBS_PLACEMENT                                   :{LTBLUE}Allow automatic placement of pbs signals: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_TOOLBAR_POS                                  :{LTBLUE}Position of main toolbar: {ORANGE}{STRING}
 STR_CONFIG_PATCHES_TOOLBAR_POS_LEFT                             :Left
 STR_CONFIG_PATCHES_TOOLBAR_POS_CENTER                           :Centre
@@ -1094,6 +1096,12 @@
 STR_CONFIG_PATCHES_QUERY_CAPT                                   :{WHITE}Change setting value
 STR_CONFIG_PATCHES_SERVICE_INTERVAL_INCOMPATIBLE                :{WHITE}Some or all of the default service interval(s) below are incompatible with the chosen setting! 5-90% and 30-800 days are valid
 
+STR_CONFIG_PATCHES_NSR_SPEED                                    :{LTBLUE}Enable new rating for Vehicle-Speed: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_AGE                                      :{LTBLUE}Enable new rating for Vehicle-Age: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_WAIT_DAYS                                :{LTBLUE}Enable new rating for days since last pickup: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_WAIT_CARGO                               :{LTBLUE}Enable new rating for Cargo/Passengers waiting: {ORANGE}{STRING}
+STR_CONFIG_PATCHES_NSR_TOWN_RATING                              :{LTBLUE}Enable new rating for Local Authority Acceptance: {ORANGE}{STRING}
+
 STR_TEMPERATE_LANDSCAPE                                         :Temperate landscape
 STR_SUB_ARCTIC_LANDSCAPE                                        :Sub-arctic landscape
 STR_SUB_TROPICAL_LANDSCAPE                                      :Sub-tropical landscape
@@ -1111,6 +1119,7 @@
 STR_CHEAT_SWITCH_CLIMATE                                        :{LTBLUE}Switch climate: {ORANGE} {STRING}
 STR_CHEAT_CHANGE_DATE                                           :{LTBLUE}Change date: {ORANGE} {DATE_SHORT}
 STR_CHEAT_SETUP_PROD                                            :{LTBLUE}Enable modifying production values: {ORANGE}{STRING}
+STR_CHEAT_RESET_STATION                                         :{LTBLUE}Enable Resetting of Stations: {ORANGE}{STRING}
 
 STR_HEADING_FOR_WAYPOINT                                        :{LTBLUE}Heading for {WAYPOINT}
 STR_HEADING_FOR_WAYPOINT_VEL                                    :{LTBLUE}Heading for {WAYPOINT}, {VELOCITY}
@@ -1125,6 +1134,25 @@
 STR_WAYPOINT                                                    :{WHITE}Waypoint
 STR_WAYPOINT_GRAPHICS_TIP                                       :{BLACK}Select waypoint type
 
+STR_SIGNAL_SELECTION                                            :{WHITE}Signal Type Selection
+STR_SIGNAL_PRESIG_COMBO                                         :{BLACK}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{SKIP}{STRING}
+STR_SIGNAL_NORMAL                                               :Normal Signals
+STR_SIGNAL_ENTRANCE                                             :Entrance Presignals
+STR_SIGNAL_COMBO                                                :Combo Presignals
+STR_SIGNAL_EXIT                                                 :Exit Presignals
+STR_SIGNAL_COMPLETION                                           :{BLACK}Auto Completion
+STR_SIGNAL_DENSITY_DESC                                         :{BLACK}Signal Density: 
+STR_SIGNAL_DENSITY_TILES                                        :{GOLD}{INT32} tile(s)
+############ Leave those lines in this order!!
+STR_SIGNAL_TYPE_STANDARD                                        :{GOLD}Light Signals
+STR_SIGNAL_TYPE_SEMAPHORES                                      :{GOLD}Semaphores
+############ End of leave-in-this-order
+
+STR_SIGNAL_TYPE_TIP                                             :{BLACK}Select signal type
+STR_SIGNAL_DENSITY_TIP                                          :{BLACK}Select signal density for dragging
+STR_SIGNAL_COMPLETION_TIP                                       :{BLACK}With autocompletion on, signals will be built in the direction you were dragging, following the track until a junction is encountered.
+STR_SIGNAL_PRESIG_TIP                                           :{BLACK}Select the type of presignal, if any
+
 STR_WAYPOINT_VIEWPORT                                           :{WHITE}{WAYPOINT}
 STR_WAYPOINT_VIEWPORT_TINY                                      :{TINYFONT}{WHITE}{WAYPOINT}
 STR_WAYPOINT_RAW                                                :{WAYPOINT}
@@ -2740,6 +2768,51 @@
 STR_BUILD_DATE                                                  :{BLACK}Built: {LTBLUE}{DATE_LONG}
 STR_MULTIPLAYER_PAUSED                                          :{WHITE}Game is paused.{}Command cannot be executed
 
+STR_RESET_STATION                                               :{BLACK}* RESET *
+STR_RESET_STATION_TIP                                           :{BLACK}When pressing this button the Station is reset, as if it was newly built.
+STR_CAN_T_RESET_STATION                                         :{WHITE}Can't reset station...
+
+STR_STATION_STATS                                               :{BLACK}Statistics
+STR_STATION_GOODS_IN                                            :{BLACK}In
+STR_STATION_GOODS_OUT                                           :{BLACK}Out
+STR_STATION_GOODS_TRANSFER                                      :{BLACK}Transit
+STR_VEHICLES                                                    :{BLACK}Vehicles
+STR_SCHEDULED                                                   :{BLACK}Scheduled
+STR_VEHICLES_MONTH                                              :{BLACK}Last Month
+STR_VEHICLES_CURRENT                                            :{BLACK}Current Month
+STR_TRAINS                                                      :{BLACK}Trains
+STR_RVS                                                         :{BLACK}Road Vehicles
+STR_BUSSES                                                      :{BLACK}Buses
+STR_TRUCKS                                                      :{BLACK}Trucks
+STR_SHIPS                                                       :{BLACK}Ships
+STR_AIRCRAFT                                                    :{BLACK}Aircraft
+STR_NUMBER                                                      :{YELLOW}{COMMA32}
+STR_STATION_MONTHS                                              :{BLACK}Cargo amount [This Month (Last Month) ]
+STR_CNUMBERS                                                    :{WHITE}{COMMA32} {TINYFONT}{BLACK}({YELLOW}{COMMA32}{BLACK})
+STR_VEHICLES_MONTHS_AVERAGE                                     :{BLACK}Average / Min / Max
+STR_MONTHS_COUNTED_NUM                                          :{BLACK}Months Counted: {GOLD}{COMMA32}
+STR_MONTHS_TINY                                                 :{TINYFONT}{BLACK}Months
+STR_STATION_MONTHS_AVERAGE                                      :{BLACK}Cargo amount [Average (Min/Max) per Month]
+STR_TOGGLE_MINMAX                                               :{BLACK}Toggle  -This/Last Month-   or   -Average/Min/Max-   Stats
+STR_RESET_STATISTICS                                            :{BLACK}Reset Statistics
+STR_AVERAGENUMBERS                                              :{SILVER}{COMMA32} {BLACK}{TINYFONT}({ORANGE}{COMMA32}{BLACK}/{LTBLUE}{COMMA32}{BLACK})
+STR_BLACK_SLASH                                                 :{BLACK}/
+STR_TINY_GOLD_NUMBER                                            :{TINYFONT}{GOLD}{COMMA32}
+STR_SILVER_NUMBER                                               :{SILVER}{COMMA32}
+STR_ORANGE_NUMBER                                               :{ORANGE}{COMMA32}
+STR_LTBLUE_NUMBER                                               :{LTBLUE}{COMMA32}
+STR_WHITE_NUMBER                                                :{WHITE}{COMMA32}
+STR_STS_NOT_SCHEDULED                                           :{BLACK}Not Scheduled
+STR_AVERAGE                                                     :{BLACK}Average
+STR_MINIMUM                                                     :{BLACK}Minimum
+STR_MAXIMUM                                                     :{BLACK}Maximum
+STR_STS_VEHICLES_LAST_YEAR                                      :{BLACK}Last Year
+STR_STS_VEHICLES_THIS_YEAR                                      :{BLACK}This Year
+STR_STS_YEARS_COUNTED_NUM                                       :{BLACK}Years Counted: {GOLD}{COMMA32}
+STR_STS_TOGGLE_MONTH_YEAR                                       :{BLACK}Toggle  -Monthly-   or   -Yearly-   Stats
+STR_STATION_COVERAGE                                            :{BLACK}Coverage
+STR_VEHICLE_CARGO_LIST                                          :{BLACK}Show List of Scheduled Vehicles for this Cargo-Type
+
 STR_PERFORMANCE_DETAIL                                          :{WHITE}Detailed performance rating
 STR_PERFORMANCE_DETAIL_KEY                                      :{BLACK}Detail
 STR_PERFORMANCE_DETAIL_AMOUNT_CURRENCY                          :{BLACK}({CURRCOMPACT}/{CURRCOMPACT})
@@ -2840,3 +2913,27 @@
 STR_PURCHASE_INFO_COST_SPEED                                    :{BLACK}Cost: {GOLD}{CURRENCY}{BLACK} Speed: {GOLD}{VELOCITY}
 STR_PURCHASE_INFO_AIRCRAFT_CAPACITY                             :{BLACK}Capacity: {GOLD}{COMMA16} passengers, {COMMA16} bags of mail
 STR_PURCHASE_INFO_PWAGPOWER_PWAGWEIGHT                          :{BLACK}Powered Wagons: {GOLD}+{COMMA16}hp{BLACK} Weight: {GOLD}+{COMMA8}t
+
+STR_STATION_RATING_DETAIL                                          :{WHITE}Detailed service ratings - {STATION} {STRINL 0x30D1}
+STR_STATION_RATING_DETAIL_KEY                                      :{BLACK}Detail
+STR_STATION_RATING_DETAIL_SCORES                                   :{BLACK}({INT32}/{INT32})
+STR_STATION_RATING_DETAIL_PERCENT                                  :{WHITE}{INT32}%
+STR_STATION_RATING_DETAIL_INT                                      :{BLACK}{INT32}
+STR_STATION_RATING_DETAIL_WAITING                                  :{BLACK}Waiting cargo:
+STR_STATION_RATING_DETAIL_WAITING_EX                               :{BLACK}{STRING}
+STR_STATION_RATING_DETAIL_SPEED                                    :{BLACK}Last speed:
+STR_STATION_RATING_DETAIL_SPEED_EX                                 :{BLACK}{INT32}
+STR_STATION_RATING_DETAIL_AGE                                      :{BLACK}Last age:
+STR_STATION_RATING_DETAIL_AGE_EX                                   :{BLACK}{COMMA16} year(s)
+STR_STATION_RATING_DETAIL_PICKUP                                   :{BLACK}Days since pickup:
+STR_STATION_RATING_DETAIL_PICKUP_EX                                :{BLACK}{COMMA16} day(s)
+STR_STATION_RATING_DETAIL_OTHER                                    :{BLACK}Other ratings:
+STR_STATION_RATING_DETAIL_TOTAL                                    :{BLACK}Total rating:
+STR_STATION_RATING_DETAIL_SPEED_TIP                                :{BLACK}Maximum speed of the last vehicle entering the station (internal value, clipped at 255)
+STR_STATION_RATING_DETAIL_AGE_TIP                                  :{BLACK}Age of the last vehicle entering the station
+STR_STATION_RATING_DETAIL_PICKUP_TIP                               :{BLACK}Number of days since the last cargo pickup
+STR_STATION_RATING_DETAIL_WAITING_TIP                              :{BLACK}Cargo waiting at the station
+STR_STATION_RATING_DETAIL_OTHER_TIP                                :{BLACK}Other ratings are mainly if the town of the station has a statue of the company owner
+STR_STATION_RATING_DETAIL_TOTAL_TIP                                :{BLACK}Total rating - The station rating is updated according to this value in small increments
+STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP                         :{BLACK}Click here to toggle cargo type
+STR_PURCHASE_INFO_SPEED                                         :{BLACK} Speed: {GOLD}{VELOCITY}
Index: variables.h
===================================================================
--- variables.h	(revision 2490)
+++ variables.h	(working copy)
@@ -106,6 +106,7 @@
 	bool modified_catchment;	//different-size catchment areas
 	bool vehicle_speed;			// show vehicle speed
 	bool build_on_slopes;		// allow building on slopes
+	bool auto_pbs_placement;// automatic pbs signal placement
 	bool mammoth_trains;		// allow very long trains
 	bool join_stations;			// allow joining of train stations
 	bool full_load_any;			// new full load calculation, any cargo must be full
@@ -134,6 +135,7 @@
 	bool nonuniform_stations;// allow nonuniform train stations
 	bool always_small_airport; // always allow small airports
 	bool realistic_acceleration; // realistic acceleration for trains
+	bool wagon_speed_limits; // use wagon speed limits
 	bool forbid_90_deg; // forbid trains to make 90 deg turns
 	bool invisible_trees; // don't show trees when buildings are transparent
 	bool no_servicing_if_no_breakdowns; // dont send vehicles to depot when breakdowns are disabled
@@ -218,6 +220,12 @@
 	uint32 npf_road_curve_penalty; /* The penalty for curves */
 
 	bool population_in_label; // Show the population of a town in his label?
+
+	bool nsr_speed;			// new station rating: vehicle speed
+	bool nsr_age;			// new station rating: vehicle age
+	bool nsr_wait_days;		// new station rating: days since last pickup
+	bool nsr_wait_cargo;	// new station rating: amount of cargo waiting
+	bool nsr_town_rating;	// new station rating: include local authority rating
 } Patches;
 
 VARDEF Patches _patches;
@@ -243,6 +251,7 @@
 	Cheat switch_climate;
 	Cheat change_date;				//changes date ingame
 	Cheat setup_prod;				//setup raw-material production in game
+	Cheat reset_station;		// allow resetting of Stations
 } Cheats;
 
 VARDEF Cheats _cheats;
@@ -342,6 +351,9 @@
 
 VARDEF bool _cache_sprites;
 
+VARDEF bool _show_average_stats; // show Average Stats for Station-Stats?
+VARDEF bool _show_yearly_stats; // show Yearly Stats for Waypoints?
+
 // debug features
 VARDEF char _savedump_path[64];
 VARDEF uint _savedump_first, _savedump_freq, _savedump_last;
Index: aystar.c
===================================================================
--- aystar.c	(revision 2490)
+++ aystar.c	(working copy)
@@ -230,6 +230,10 @@
 	else if (r == AYSTAR_LIMIT_REACHED)
 		printf("[AyStar] Exceeded search_nodes, no path found\n");
 #endif
+
+	if (aystar->BeforeExit != NULL)
+		aystar->BeforeExit(aystar);
+
 	if (r != AYSTAR_STILL_BUSY)
 		/* We're done, clean up */
 		aystar->clear(aystar);
Index: tunnelbridge_cmd.c
===================================================================
--- tunnelbridge_cmd.c	(revision 2490)
+++ tunnelbridge_cmd.c	(working copy)
@@ -10,6 +10,8 @@
 #include "player.h"
 #include "town.h"
 #include "sound.h"
+#include "pbs.h"
+#include "debug.h"
 
 extern void DrawCanalWater(TileIndex tile);
 
@@ -770,6 +772,7 @@
 		byte m5;
 		uint c = tile;
 		uint16 new_data;
+		byte pbs;
 
 		//checks if the owner is town then decrease town rating by RATING_TUNNEL_BRIDGE_DOWN_STEP until
 		// you have a "Poor" (0) town rating
@@ -778,6 +781,7 @@
 
 		do {
 			m5 = _map5[c];
+			pbs = PBSTileReserved(c);
 
 			if (m5 & 0x40) {
 				if (m5 & 0x20) {
@@ -791,6 +795,9 @@
 				SetTileType(c, new_data >> 12);
 				_map5[c] = (byte)new_data;
 				_map2[c] = 0;
+				_map3_hi[c] &= 0x0F;
+				if (direction ? HASBIT(pbs,0) : HASBIT(pbs,1))
+					PBSReserveTrack(c, direction ? 0 : 1);
 
 				MarkTileDirtyByTile(c);
 
@@ -1144,7 +1151,19 @@
 			}
 		}
 	}
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(0x3ED | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(0x3EE | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(0x3EF | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(0x3F0 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(0x3F2 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 | PALETTE_CRASH);
 }
+#endif
+}
 
 static uint GetSlopeZ_TunnelBridge(TileInfo *ti) {
 	uint z = ti->z;
@@ -1426,6 +1445,8 @@
 					return 0;
 				}
 				if (fc == _tunnel_fractcoord_2[dir]) {
+					if (v->next == NULL)
+						PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 					v->tile = tile;
 					v->u.rail.track = 0x40;
 					v->vehstatus |= VS_HIDDEN;
Index: aystar.h
===================================================================
--- aystar.h	(revision 2490)
+++ aystar.h	(working copy)
@@ -96,6 +96,11 @@
  */
 typedef void AyStar_FoundEndNode(AyStar *aystar, OpenListNode *current);
 
+/*
+ * Is called when aystar ends it pathfinding, but before cleanup.
+ */
+typedef void AyStar_BeforeExit(AyStar *aystar);
+
 // For internal use, see aystar.c
 typedef void AyStar_AddStartNode(AyStar *aystar, AyStarNode* start_node, uint g);
 typedef int AyStar_Main(AyStar *aystar);
@@ -115,6 +120,7 @@
 	AyStar_GetNeighbours* GetNeighbours;
 	AyStar_EndNodeCheck* EndNodeCheck;
 	AyStar_FoundEndNode* FoundEndNode;
+	AyStar_BeforeExit* BeforeExit;
 
 	/* These are completely untouched by AyStar, they can be accesed by
 	 * the application specific routines to input and output data.
Index: roadveh_cmd.c
===================================================================
--- roadveh_cmd.c	(revision 2490)
+++ roadveh_cmd.c	(working copy)
@@ -808,6 +808,14 @@
 
 static void RoadVehArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_ROAD].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	if (v->cargo_type == CT_PASSENGERS)
+		st->vehicles[STS_VEH_BUS].this_month++;
+	else
+		st->vehicles[STS_VEH_TRUCK].this_month++;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	if (v->engine_type < 123) {
 		/* Check if station was ever visited before */
 		if (!(st->had_vehicle_of_type & HVOT_BUS)) {
@@ -1104,7 +1112,7 @@
 		trackdir = DiagdirToDiagTrackdir(enterdir);
 		//debug("Finding path. Enterdir: %d, Trackdir: %d", enterdir, trackdir);
 
-		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_ROAD, v->owner);
+		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_ROAD, v->owner, PBS_MODE_NONE);
 		if (ftd.best_trackdir == 0xff) {
 			/* We are already at our target. Just do something */
 			//TODO: maybe display error?
@@ -1181,7 +1189,7 @@
   fstd.dest_coords = tile;
   fstd.station_index = -1;	// indicates that the destination is a tile, not a station
 
-  return NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_ROAD, v->owner).best_path_dist;
+  return NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_ROAD, v->owner, PBS_MODE_NONE).best_path_dist;
 }
 
 typedef struct RoadDriveEntry {
Index: openttd.h
===================================================================
--- openttd.h	(revision 2490)
+++ openttd.h	(working copy)
@@ -266,7 +266,7 @@
 
 	NUM_CARGO = 12,
 
-	CT_INVALID = 0xFF
+	CT_INVALID = 0xFF,
 };
 
 typedef uint AcceptedCargo[NUM_CARGO];
@@ -442,6 +442,11 @@
 	WC_HIGHSCORE = 0x4D,
 	WC_ENDSCREEN = 0x4E,
 	WC_SIGN_LIST = 0x4F,
+	WC_STATION_STATS = 0x50,
+	WC_WAYPOINT_STATS = 0x51,
+	WC_STATION_RATING_DETAIL = 0x52,
+	WC_VEHICLES_LIST = 0x53,
+	WC_BUILD_SIGNALS = 0x54,
 };
 
 
Index: station_gui.c
===================================================================
--- station_gui.c	(revision 2490)
+++ station_gui.c	(working copy)
@@ -10,7 +10,12 @@
 #include "player.h"
 #include "town.h"
 #include "command.h"
+#include "engine.h"
+#include "depot.h"
+#include "cargo.h"
 
+extern int _traininfo_vehicle_pitch;
+
 static void StationsWndShowStationRating(int x, int y, int type, uint acceptance, int rating)
 {
 	static const byte _rating_colors[NUM_CARGO] = {152,32,15,174,208,194,191,55,184,10,191,48};
@@ -286,9 +291,35 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   210,   221, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   129,   192,   210,   221, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   210,   221, STR_STATION_COVERAGE,	STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_expanded_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,	STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,	STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,	STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,	STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,   197, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   198,   209, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   198,   209, STR_3033_ACCEPTS,	STR_3056_SHOW_LIST_OF_ACCEPTED_CARGO},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   198,   209, STR_0130_RENAME,	STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,   198,   209, STR_TRAIN,	STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,   198,   209, STR_LORRY,	STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,   198,   209, STR_PLANE,	STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,   198,   209, STR_SHIP,	STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   210,   221, STR_STATION_STATS,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   210,   221, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   210,   221, STR_RESET_STATION,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   210,   221, STR_STATION_COVERAGE,	STR_NULL},
+{   WIDGETS_END},
+};
+
 static const Widget _station_view_widgets[] = {
 {    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,		STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
@@ -304,9 +335,35 @@
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY, STR_SCHEDULED_ROAD_VEHICLES_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE, STR_SCHEDULED_AIRCRAFT_TIP },
 { WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP, STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   110,   121, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   129,   192,   110,   121, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   110,   121, STR_STATION_COVERAGE,	STR_NULL},
 {   WIDGETS_END},
 };
 
+static const Widget _station_view_cheat_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,	STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   236,     0,    13, STR_300A_0,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   237,   248,     0,    13, 0x0,	STR_STICKY_BUTTON},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   236,    14,    65, 0x0,	STR_NULL},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   237,   248,    14,    65, 0x0,	STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   248,    66,    97, 0x0,	STR_NULL},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,    98,   109, STR_00E4_LOCATION,	STR_3053_CENTER_MAIN_VIEW_ON_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,    98,   109, STR_3032_RATINGS,	STR_3054_SHOW_STATION_RATINGS},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,    98,   109, STR_0130_RENAME,	STR_3055_CHANGE_NAME_OF_STATION},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   206,    98,   109, STR_TRAIN,	STR_SCHEDULED_TRAINS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   207,   220,    98,   109, STR_LORRY,	STR_SCHEDULED_ROAD_VEHICLES_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   221,   234,    98,   109, STR_PLANE,	STR_SCHEDULED_AIRCRAFT_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   235,   248,    98,   109, STR_SHIP,	STR_SCHEDULED_SHIPS_TIP },
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    63,   110,   121, STR_STATION_STATS,	0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    64,   128,   110,   121, STR_STATION_RATING_DETAIL_KEY,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   129,   192,   110,   121, STR_RESET_STATION,	STR_NULL},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   193,   248,   110,   121, STR_STATION_COVERAGE,	STR_NULL},
+{   WIDGETS_END},
+};
+
 static void DrawStationViewWindow(Window *w)
 {
 	Station *st;
@@ -331,7 +388,10 @@
 	}
 	SetVScrollCount(w, num);
 
-	w->disabled_state = st->owner == _local_player ? 0 : (1 << 9);
+	if (_cheats.reset_station.value)
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 14) | (1 << 15);
+	else
+		w->disabled_state = st->owner == _local_player ? 0 : (1 << 9) | (1 << 14);
 
 	if (!(st->facilities & FACIL_TRAIN)) SETBIT(w->disabled_state,  10);
 	if (!(st->facilities & FACIL_TRUCK_STOP) &&
@@ -397,7 +457,8 @@
 		}
 	} while (pos > -5 && ++i != 12);
 
-	if (IsWindowOfPrototype(w, _station_view_widgets)) {
+	if (IsWindowOfPrototype(w, _station_view_widgets) ||
+		IsWindowOfPrototype(w, _station_view_cheat_widgets) ) {
 		char *b = _userstring;
 
 		b = InlineString(b, STR_000C_ACCEPTS);
@@ -436,7 +497,38 @@
 	}
 }
 
+int32 ClickResetStationCheat(int32 cheat_activated, int32 NOT_USED)
+{ // switch all open station-view-windows to new widget-set when cheat toggled
+	Window *w;
 
+	for (w = _windows; w != _last_window; ++w) {
+		if (w->window_class == WC_STATION_VIEW) {
+			/* toggle height/widget set */
+			SetWindowDirty(w);
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (cheat_activated != 0) { // Reset button enabled?
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+					w->height = 222;
+				} else {
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+					w->height = 210;
+				}
+			} else {
+				if (cheat_activated != 0) { // Reset button enabled?
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+					w->height = 122;
+				} else {
+					AssignWidgetToWindow(w, _station_view_widgets);
+					w->height = 110;
+				}
+			}
+			SetWindowDirty(w);
+		}
+	}
+	return 0;
+}
+
 static void StationViewWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -446,44 +538,48 @@
 
 	case WE_CLICK:
 		switch(e->click.widget) {
-		case 7:
+		case 7: {
 			ScrollMainWindowToTile(GetStation(w->window_number)->xy);
 			break;
-
-		case 8:
+		}
+		case 8: {
 			SetWindowDirty(w);
 
 			/* toggle height/widget set */
-			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)) {
-				AssignWidgetToWindow(w, _station_view_widgets);
-				w->height = 110;
+			if (IsWindowOfPrototype(w, _station_view_expanded_widgets)
+				|| IsWindowOfPrototype(w, _station_view_expanded_cheat_widgets)) {
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_widgets);
+				w->height = 122;
 			} else {
-				AssignWidgetToWindow(w, _station_view_expanded_widgets);
-				w->height = 210;
+				if (_cheats.reset_station.value)
+					AssignWidgetToWindow(w, _station_view_expanded_cheat_widgets);
+				else
+					AssignWidgetToWindow(w, _station_view_expanded_widgets);
+				w->height = 222;
 			}
 
 			SetWindowDirty(w);
 			break;
-
+		}
 		case 9: {
 			Station *st = GetStation(w->window_number);
 			SetDParam(0, st->town->townnametype);
 			SetDParam(1, st->town->townnameparts);
 			ShowQueryString(st->string_id, STR_3030_RENAME_STATION_LOADING, 31, 180, w->window_class, w->window_number);
 		}	break;
-
 		case 10: { /* Show a list of scheduled trains to this station */
 			const Station *st = GetStation(w->window_number);
 			ShowPlayerTrains(st->owner, w->window_number);
 			break;
 		}
-
 		case 11: { /* Show a list of scheduled road-vehicles to this station */
 			const Station *st = GetStation(w->window_number);
 			ShowPlayerRoadVehicles(st->owner, w->window_number);
 			break;
 		}
-
 		case 12: { /* Show a list of scheduled aircraft to this station */
 			const Station *st = GetStation(w->window_number);
 			/* Since oilrigs have no owners, show the scheduled aircraft of current player */
@@ -491,7 +587,6 @@
 			ShowPlayerAircraft(owner, w->window_number);
 			break;
 		}
-
 		case 13: { /* Show a list of scheduled ships to this station */
 			const Station *st = GetStation(w->window_number);
 			/* Since oilrigs/bouys have no owners, show the scheduled ships of current player */
@@ -499,9 +594,30 @@
 			ShowPlayerShips(owner, w->window_number);
 			break;
 		}
+		case 14: { // Show Statistics for Station
+			ShowStationStatsWindow(w->window_number);
+			break;
 		}
+		case 15: { // Show Details for Station Rating
+			const Station *st = GetStation(w->window_number);
+			ShowStationRatingDetail(st->index);
+			break;
+		}
+		case 16: { // Reset Station
+			Station *st = GetStation(w->window_number);
+			if (_cheats.reset_station.value) {
+				DoCommandP(st->xy, w->window_number, 0, NULL,
+					CMD_RESET_STATION_CHEAT | CMD_MSG(STR_CAN_T_RESET_STATION));
+				SetWindowDirty(w);
+			}
+			InitializeStationStats(st);
+			break;
+ 		}
+		case 17: { //ToDo: show station coverage
+			break;
+		}
+		} // end of switch(e->click.widget)
 		break;
-
 	case WE_ON_EDIT_TEXT: {
 		if (e->edittext.str[0] != '\0') {
 			Station* st = GetStation(w->window_number);
@@ -516,30 +632,43 @@
 		WindowNumber wno =
 			(w->window_number << 16) | GetStation(w->window_number)->owner;
 
+		// Destroy vehicle-windows related to this window, too
 		DeleteWindowById(WC_TRAINS_LIST, wno);
 		DeleteWindowById(WC_ROADVEH_LIST, wno);
 		DeleteWindowById(WC_SHIPS_LIST, wno);
 		DeleteWindowById(WC_AIRCRAFT_LIST, wno);
+		DeleteWindowById(WC_STATION_STATS, w->window_number);
 		break;
 	}
 	}
 }
 
-
 static const WindowDesc _station_view_desc = {
-	-1, -1, 249, 110,
+	-1, -1, 249, 122,
 	WC_STATION_VIEW,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
 	_station_view_widgets,
 	StationViewWndProc
 };
 
+// alternate widget-set if reset-station-cheat is enabled
+static const WindowDesc _station_view_cheat_desc = {
+	-1, -1, 249, 122,
+	WC_STATION_VIEW,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_view_cheat_widgets,
+	StationViewWndProc
+};
+
 void ShowStationViewWindow(int station)
 {
 	Window *w;
 	byte color;
 
-	w = AllocateWindowDescFront(&_station_view_desc, station);
+	if (_cheats.reset_station.value)
+		w = AllocateWindowDescFront(&_station_view_cheat_desc, station);
+	else
+		w = AllocateWindowDescFront(&_station_view_desc, station);
 	if (w) {
 		color = GetStation(w->window_number)->owner;
 		if (color != 0x10)
@@ -547,3 +676,740 @@
 		w->vscroll.cap = 5;
 	}
 }
+
+void StationStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _station_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   398,     0,    13, STR_300A_0, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   399,   410,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    91,   410,    14,    25, STR_TOGGLE_MINMAX, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,    26,    37, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    38,    49, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    50,    61, STR_RVS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    62,    73, STR_BUSSES, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    74,    85, STR_TRUCKS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    85,    97, STR_SHIPS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    90,    98,   109, STR_AIRCRAFT, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    91,   410,    38,   109, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   410,   110,   135, 0x0,0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   398,   136,   191, 0x0,0x0},
+{  WWT_SCROLLBAR,   RESIZE_NONE,    14,   399,   410,   136,   191, 0x0, STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WIDGETS_END},
+};
+
+WindowDesc _station_view_stats = {
+	-1, -1, 411, 192,
+	WC_STATION_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_stats_widgets,
+	StationStatsWndProc
+};
+
+void DrawStationStatWindow(Window *w, Station *st)
+{
+	int i, y, numcargo=0, pos;
+	GoodsEntry *ge;
+	
+	// count number of goods at station (months_counted will be 0 if good not delivered/picked up)
+	for (ge = st->goods; ge != endof(st->goods); ge++) {
+		if (ge->months_counted != 0) numcargo++;
+	}
+	SetVScrollCount(w, numcargo);
+		
+	//Get the Station name
+	SetDParam(0, st->index);
+	
+	//and the little carrier type images
+	SetDParam(1, st->facilities);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawStringCentered(45, 28, STR_VEHICLES, 0);
+
+	//Part 1:       Find the number of carriers on the station
+	y = 27;
+	if (_show_average_stats) {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(275, y, STR_VEHICLES_MONTHS_AVERAGE, 0);
+		SetDParam(0, max(st->months_counted - 1,0));
+		DrawStringRightAligned(405, y, STR_MONTHS_COUNTED_NUM, 0);
+	} else {
+		DrawStringRightAligned(150, y, STR_SCHEDULED, 0);
+		DrawStringRightAligned(295, y, STR_VEHICLES_MONTH, 0);
+		DrawStringRightAligned(395, y, STR_VEHICLES_CURRENT, 0);	
+	}
+
+	y = 38;
+	for (i = 0; i < STS_VEH_TYPES; i++) {
+		if (w->custom[i] != 0) {
+			SetDParam(0, w->custom[i]);
+			DrawStringRightAligned(150, y+i*12, STR_NUMBER, 0);
+			CLRBIT(w->disabled_state, i+7);
+		} else {
+			SETBIT(w->disabled_state, i+7);
+		}
+		if (_show_average_stats) {
+			if (st->vehicles[i].average != 0 || st->vehicles[i].month_max !=0) {
+				SetDParam(0, st->vehicles[i].average / AVERAGE_MULTIPLIER);
+				DrawStringRightAligned(235, y+i*12, STR_SILVER_NUMBER, 0);
+				DrawStringRightAligned(245, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_min);
+				DrawStringRightAligned(290, y+i*12, STR_ORANGE_NUMBER, 0);
+				DrawStringRightAligned(300, y+i*12, STR_BLACK_SLASH, 0);
+				SetDParam(0, st->vehicles[i].month_max);
+				DrawStringRightAligned(350, y+i*12, STR_LTBLUE_NUMBER, 0);
+			}
+		} else {
+			if (st->vehicles[i].last_month != 0) {
+				SetDParam(0, st->vehicles[i].last_month);
+				DrawStringRightAligned(295, y+i*12, STR_NUMBER, 0);
+			}
+			if (st->vehicles[i].this_month) {
+				SetDParam(0, st->vehicles[i].this_month);
+				DrawStringRightAligned(395, y+i*12, STR_WHITE_NUMBER, 0);
+			}
+		}
+	}
+	
+	y = 124;
+	if (_show_average_stats) {
+		DrawString(5, y-10, STR_STATION_MONTHS_AVERAGE, 0);
+		DrawStringRightAligned(100, y+2, STR_MONTHS_TINY, 0);
+	} else {
+		DrawString(5, y-10, STR_STATION_MONTHS, 0);
+	}
+	DrawStringRightAligned(200, y, STR_STATION_GOODS_IN, 0);
+	DrawStringRightAligned(305, y, STR_STATION_GOODS_OUT, 0);
+	DrawStringRightAligned(395, y, STR_STATION_GOODS_TRANSFER, 0);
+	
+	y += 5;
+	pos = w->vscroll.pos;
+	for (i = 0; i < NUM_CARGO; i++) {
+		ge = &st->goods[i];
+		if (ge->months_counted != 0 && ((--pos < 0) && (pos >= -4)) )
+		{
+			StationStats *sts = ge->cargo_amount;
+			//Print the cargo name
+			y += 12;
+			SetDParam(0, _cargoc.names_p[i]);
+			DrawString(3, y, STR_02BD, 0);
+			if (_show_average_stats) {
+				SetDParam(0, ge->months_counted - 1);
+				DrawStringRightAligned(100, y, STR_TINY_GOLD_NUMBER, 0);
+				if (sts[STS_AMOUNT_IN].average != 0 || sts[STS_AMOUNT_IN].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_IN].month_min);
+					SetDParam(2, sts[STS_AMOUNT_IN].month_max);
+					DrawStringRightAligned(200, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].average != 0 || sts[STS_AMOUNT_OUT].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_OUT].month_min);
+					SetDParam(2, sts[STS_AMOUNT_OUT].month_max);
+					DrawStringRightAligned(305, y, STR_AVERAGENUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].average != 0 || sts[STS_AMOUNT_TRANSFER].month_max != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].average / AVERAGE_MULTIPLIER);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].month_min);
+					SetDParam(2, sts[STS_AMOUNT_TRANSFER].month_max);
+					DrawStringRightAligned(395, y, STR_AVERAGENUMBERS, 0);
+				}
+			} else {
+				if (sts[STS_AMOUNT_IN].this_month != 0 || sts[STS_AMOUNT_IN].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_IN].this_month);
+					SetDParam(1, sts[STS_AMOUNT_IN].last_month);
+					DrawStringRightAligned(200, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_OUT].this_month != 0 || sts[STS_AMOUNT_OUT].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_OUT].this_month);
+					SetDParam(1, sts[STS_AMOUNT_OUT].last_month);
+					DrawStringRightAligned(305, y, STR_CNUMBERS, 0);
+				}
+				if (sts[STS_AMOUNT_TRANSFER].this_month != 0 || sts[STS_AMOUNT_TRANSFER].last_month != 0) {
+					SetDParam(0, sts[STS_AMOUNT_TRANSFER].this_month);
+					SetDParam(1, sts[STS_AMOUNT_TRANSFER].last_month);
+					DrawStringRightAligned(395, y, STR_CNUMBERS, 0);
+				}
+			}
+		}
+	}
+}
+
+void StationStatsWndProc(Window *w, WindowEvent *e)
+{
+	Station *st = GetStation(w->window_number);
+	switch(e->event)
+	{
+	case WE_TICK: {
+//		static int counter = 0;
+//		if (++counter % 40) return;
+		int i;
+		
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+		InvalidateWindow(WC_STATION_STATS, w->window_number);
+		break;
+	}
+	case WE_PAINT: {
+		DrawStationStatWindow(w, st);
+		break;
+		}
+	case WE_CLICK: {
+		switch (e->click.widget)
+		{
+			case 4:			// Reset Statistics
+				if (st->owner == _current_player) {
+					InitializeStationStats(st);
+					InvalidateWindow(WC_STATION_STATS, w->window_number);
+				}
+				break;
+			case 5:			// Toggle Average and This Month
+				_show_average_stats ^= 1;
+				InvalidateWindow(WC_STATION_STATS, w->window_number);
+				break;
+			case 7:			//Trains
+				ShowPlayerTrains(st->owner, st->index);
+				break;
+			case 8: 		//Road Vehicles
+				ShowPlayerRoadVehicles(st->owner, st->index);
+				break;
+			case 9:			// Buses
+				ShowPlayerVehicles(st->owner, st->index, 1 << VEH_Road, 1 << GC_PASSENGERS, st->xy);
+				break;
+			case 10:		// Trucks
+				ShowPlayerVehicles(st->owner, st->index, 1 << VEH_Road, CARGO_MASK_ALL &~(1 << GC_PASSENGERS), st->xy);
+				break;
+			case 11: 		//Ships
+				ShowPlayerShips(st->owner, st->index);
+				break;
+			case 12: 		//Aircraft
+				ShowPlayerAircraft(st->owner, st->index);
+				break;
+		}
+	} break;
+	case WE_DESTROY: {
+//		DeleteWindowById(WC_TRAINS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_ROADVEH_LIST, st->owner + ( (st->index + 1) << 8) + 64 + 128);
+//		DeleteWindowById(WC_SHIPS_LIST, st->owner + ( (st->index + 1) << 8));
+//		DeleteWindowById(WC_AIRCRAFT_LIST, st->owner + ( (st->index + 1) << 8));
+	} break;
+	}
+}
+
+void ShowStationStatsWindow(int station)
+{
+	Window *w;
+	byte color;
+
+	Station *st = GetStation(station);
+
+	w = AllocateWindowDescFront(&_station_view_stats, st->index);
+	if (w) {
+		int i;
+		color = st->owner;
+		if (color != 0x10)
+			w->caption_color = color;
+		w->vscroll.cap = 4;
+		for (i = 0; i < STS_VEH_TYPES; i++)
+			w->custom[i] = st->veh_scheduled[i];
+	}
+}
+
+static void StationRatingDetailWndProc(Window *w, WindowEvent *e)
+{
+	// String IDs to display
+	static const uint16 rating_str[] = {
+		STR_STATION_RATING_DETAIL_WAITING,
+		STR_STATION_RATING_DETAIL_SPEED,
+		STR_STATION_RATING_DETAIL_AGE,
+		STR_STATION_RATING_DETAIL_PICKUP,
+		STR_STATION_RATING_DETAIL_OTHER,
+		STR_STATION_RATING_DETAIL_TOTAL
+	};
+	// More string IDs to display
+	static const uint16 rating_str_ex[] = {
+		STR_STATION_RATING_DETAIL_WAITING_EX,
+		STR_STATION_RATING_DETAIL_SPEED_EX,
+		STR_STATION_RATING_DETAIL_AGE_EX,
+		STR_STATION_RATING_DETAIL_PICKUP_EX,
+		STR_NULL,
+		STR_NULL
+	};
+	static const int rating_max_score[] = {40, 42, 33, 130, 26, 255};
+
+	switch(e->event) {
+	case WE_PAINT: {
+		int i, x, cur_x, val;
+		byte cargo;
+		uint16 y = 16;
+		int color_done, color_notdone;
+		int max_score;
+		Station *st = GetStation(w->window_number);
+		RatingStats *rs;
+
+		// Disable cargo types that don't have ratings and click first cargo
+		w->disabled_state = 0;
+		for (i=0; i!=NUM_CARGO; i++) {
+			if(st->goods[i].enroute_from == INVALID_STATION) {
+				SETBIT(w->disabled_state, i + 9);
+				CLRBIT(w->click_state, i + 9);
+			} else if(w->click_state == 0) {
+				SETBIT(w->click_state, i + 9);
+			}
+		}
+		if(w->click_state == 0)
+			SETBIT(w->disabled_state, 21);
+
+		// Draw standard stuff
+		SetDParam(0, st->index);
+		SetDParam(1, st->facilities);
+		DrawWindowWidgets(w);
+
+		// Paint the cargo icons
+		cur_x = 9;
+		for (i = 0; i != NUM_CARGO; i++) {
+			if(st->goods[i].enroute_from != INVALID_STATION)
+				DrawSprite(_cargoc.sprites[i], cur_x, y);
+			cur_x += 28;
+		}
+
+		// The colors used to show how the progress is going
+		color_done = _color_list[6].window_color_1b;
+		color_notdone = _color_list[4].window_color_1b;
+
+		// No cargo type selected
+		if(w->click_state == 0)
+			break;
+
+		// The type of cargo of which we check the detail service rating
+		cargo = FindFirstBit(w->click_state) - 9;
+		
+		if (cargo < NUM_CARGO) 
+			w->listopt.cargo_mask = 1 << GetGlobalCargoID(_opt_ptr->landscape, cargo);
+		else
+			w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = VEHICLE_TYPE_ALL;
+		w->listopt.xy = st->xy;
+
+		rs = &st->rating_stats[cargo];
+
+		y += 18;
+
+		for(i=0; i<NUM_RATINGS; i++) {
+			DrawString(7, y, rating_str[i], 0);
+
+			// Draw the raw values
+			switch(i) {
+				case RATING_WAITING:
+					SetDParam(1, rs->waiting);
+					SetDParam(0, _cargoc.names_long_s[cargo] + (rs->waiting == 1 ? 0 : 32));
+					break;
+				case RATING_SPEED:
+					SetDParam(0, rs->last_speed);
+					break;
+				case RATING_AGE:
+					SetDParam(0, rs->last_age);
+					break;
+				case RATING_PICKUP:
+					SetDParam(0, rs->days_since_pickup);
+					break;
+				default:
+					break;
+			}
+
+			if(rating_str_ex[i] != STR_NULL)
+				DrawStringRightAligned(205, y, rating_str_ex[i], 0);
+
+			// Calculate the %-bar
+			val = rs->ratings[i];
+
+			max_score = rating_max_score[i];
+			if (val > max_score) x = 50;
+			else if (val <= 0) x = 0;
+			else x = ((val * 50) / max_score);
+
+			// Draw the bar
+			if (x != 0)
+				GfxFillRect(210, y-2, x + 210, y+10, color_done);
+			if (x != 50)
+				GfxFillRect(x + 210, y-2, 50 + 210, y+10, color_notdone);
+
+			// Calculate the %
+			if (val > max_score) x = 100;
+			else x = ((val * 100) / max_score);
+
+			// Draw it
+			SetDParam(0, x);
+			DrawStringCentered(235, y, STR_STATION_RATING_DETAIL_PERCENT, 0);
+
+			// Draw the score and max_score
+			SetDParam(0, val);
+			SetDParam(1, max_score);
+			DrawString(265, y, STR_STATION_RATING_DETAIL_SCORES, 0);
+
+			y += 20;
+		}
+
+		break;
+	}
+
+	case WE_CLICK:
+		// Check which button is clicked
+		if (IS_INT_INSIDE(e->click.widget, 9, 21)) {
+			// Is it no on disable?
+			if ((w->disabled_state & (1 << e->click.widget)) == 0) {
+				Station *st = GetStation(w->window_number);
+				Window *w2 = FindWindowById(WC_VEHICLES_LIST, (st->index << 16) | st->owner);
+				vehiclelist_d *vl;
+				w->click_state = 1 << e->click.widget;
+				w->listopt.cargo_mask = 1 << GetGlobalCargoID(_opt_ptr->landscape, FindFirstBit(w->click_state) - 9);
+				SetWindowDirty(w);
+				if (w2) {
+					vl = &WP(w2, vehiclelist_d);
+					vl->flags |= VL_REBUILD;
+					w2->listopt.cargo_mask = w->listopt.cargo_mask;
+					SetWindowDirty(w2);
+				}
+			}
+		} else if (e->click.widget == 21) {
+			Station *st = GetStation(w->window_number);
+			ShowPlayerVehicles(st->owner, st->index, w->listopt.type_mask, w->listopt.cargo_mask, w->listopt.xy);
+			w->click_state = 1 << (GetLocalCargoID(FindFirstBit(w->listopt.cargo_mask)) + 9);
+			SetWindowDirty(w);
+		}
+		break;
+
+	case WE_CREATE:
+		{
+			w->hidden_state = 0;
+			w->disabled_state = 0;
+			w->click_state = 0;
+
+			SetWindowDirty(w);
+		}
+		break;
+	}
+}
+
+static const Widget _station_rating_detail_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   325,     0,    13, STR_STATION_RATING_DETAIL,	STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   326,   337,     0,    13, 0x0, STR_STICKY_BUTTON},
+
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    28,    47, 0x0,STR_STATION_RATING_DETAIL_WAITING_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    48,    67, 0x0,STR_STATION_RATING_DETAIL_SPEED_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    68,    87, 0x0,STR_STATION_RATING_DETAIL_AGE_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,    88,   107, 0x0,STR_STATION_RATING_DETAIL_PICKUP_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,   108,   127, 0x0,STR_STATION_RATING_DETAIL_OTHER_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   337,   128,   147, 0x0,STR_STATION_RATING_DETAIL_TOTAL_TIP},
+
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     1,    28,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    29,    56,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    57,    84,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,    85,   112,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   113,   140,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   141,   168,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   169,   196,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   197,   224,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   225,   252,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   253,   280,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   281,   308,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   309,   336,    14,    27, 0x0,STR_STATION_RATING_DETAIL_TOGGLE_CARGO_TIP},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   336,    148,   160, STR_VEHICLE_CARGO_LIST, 0x0},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _station_rating_detail_desc = {
+	-1, -1, 338, 161,
+	WC_STATION_RATING_DETAIL,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_station_rating_detail_widgets,
+	StationRatingDetailWndProc
+};
+
+void ShowStationRatingDetail(int station)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_station_rating_detail_desc, station);
+	if (w) {
+		color = GetStation(w->window_number)->owner;
+		if (color != 0x10)
+			w->caption_color = color;
+		w->vscroll.cap = 5;
+	}
+}
+
+static void PlayerVehiclesWndProc(Window *w, WindowEvent *e)
+{
+	int station = (int)w->window_number >> 16;
+	int owner = w->window_number & 0xff;
+	vehiclelist_d *vl = &WP(w, vehiclelist_d);
+
+	switch(e->event) {
+	case WE_PAINT: {
+		int x = 2;
+		int y = PLY_WND_PRC__OFFSET_TOP_WIDGET;
+		int max;
+		int i;
+
+		BuildVehicleListMasked(vl, &w->listopt, owner);
+		SortVehicleList(vl);
+
+		SetVScrollCount(w, vl->list_length);
+		// disable 'Sort By' tooltip on Unsorted sorting criteria
+		if (vl->sort_type == SORT_BY_UNSORTED)
+			w->disabled_state |= (1 << 3);
+
+		/* draw the widgets */
+		{
+			const Player *p = GetPlayer((owner != OWNER_NONE) ? owner : _current_player);
+			if (station == -1) {
+				/* Company Name -- (###) Trains */
+				SetDParam(0, p->name_1);
+				SetDParam(1, p->name_2);
+				SetDParam(2, w->vscroll.count);
+				w->widget[1].unkA = STR_VEHICLES;
+			} else {
+				/* Station Name -- (###) Trains */
+				SetDParam(0, station);
+				SetDParam(1, w->vscroll.count);
+				w->widget[1].unkA = STR_SCHEDULED;
+			}
+			DrawWindowWidgets(w);
+		}
+		/* draw sorting criteria string */
+		DrawString(85, 15, _vehicle_sort_listing[vl->sort_type], 0x10);
+		/* draw arrow pointing up/down for ascending/descending sorting */
+		DoDrawString(vl->flags & VL_DESC ? "\xAA" : "\xA0", 69, 15, 0x10);
+
+		max = min(w->vscroll.pos + w->vscroll.cap, vl->list_length);
+		for (i = w->vscroll.pos; i < max; ++i) {
+			Vehicle *v = GetVehicle(vl->sort_list[i].index);
+			StringID str;
+
+			assert(v->owner == owner || v->owner == _current_player);
+
+			switch (v->type) {
+				case VEH_Train:
+				{
+					DrawTrainImage(
+						v, x + 21, y + 6 + _traininfo_vehicle_pitch, w->hscroll.cap, 0, INVALID_VEHICLE);
+
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_RAIL) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_TRAIN_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 21, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Road:
+				{
+					DrawRoadVehImage(v, x + 22, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_ROAD) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_ROADVEH_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 24, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Aircraft:
+				{
+					DrawAircraftImage(v, x + 19, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsAircraftHangarTile(v->tile) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_AIRCRAFT_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 19, y, STR_01AB, 0);
+					}
+					break;
+				}
+				case VEH_Ship:
+				{
+					DrawShipImage(v, x + 19, y + 6, INVALID_VEHICLE);
+					SetDParam(0, v->unitnumber);
+					if (IsTileDepotType(v->tile, TRANSPORT_WATER) && (v->vehstatus & VS_HIDDEN))
+						str = STR_021F;
+					else
+						str = v->age > v->max_age - 366 ? STR_00E3 : STR_00E2;
+					DrawString(x, y + 2, str, 0);
+					if (v->string_id != STR_SV_SHIP_NAME) {
+						SetDParam(0, v->string_id);
+						DrawString(x + 12, y, STR_01AB, 0);
+					}
+					break;
+				}
+				default:
+					continue;
+			}
+			DrawVehicleProfitButton(v, x, y + 13);
+			SetDParam(0, v->profit_this_year);
+			SetDParam(1, v->profit_last_year);
+			DrawString(x + 21, y + 18, STR_0198_PROFIT_THIS_YEAR_LAST_YEAR, 0);
+
+			y += PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		}
+		break;
+	}
+
+	case WE_CLICK: {
+		switch(e->click.widget) {
+		case 3: /* Flip sorting method ascending/descending */
+			vl->flags ^= VL_DESC;
+			vl->flags |= VL_RESORT;
+			_sorting.masked.order = !!(vl->flags & VL_DESC);
+			SetWindowDirty(w);
+			break;
+
+		case 4: case 5:/* Select sorting criteria dropdown menu */
+			ShowDropDownMenu(w, _vehicle_sort_listing, vl->sort_type, 5, 0, 0);
+			return;
+
+		case 7: { /* Matrix to show vehicles */
+			uint32 id_v = (e->click.pt.y - PLY_WND_PRC__OFFSET_TOP_WIDGET) / PLY_WND_PRC__SIZE_OF_ROW_BIG;
+
+			if (id_v >= w->vscroll.cap) { return;} // click out of bounds
+
+			id_v += w->vscroll.pos;
+			{
+				Vehicle *v;
+				if (id_v >= vl->list_length) return; // click out of list bound
+				v = GetVehicle(vl->sort_list[id_v].index);
+
+				assert(v->owner == owner);
+				
+				switch (v->type)
+				{
+				case VEH_Train:
+					ShowTrainViewWindow(v);
+					break;
+				case VEH_Ship:
+					ShowShipViewWindow(v);
+					break;
+				case VEH_Road:
+					ShowRoadVehViewWindow(v);
+					break;
+				case VEH_Aircraft:
+					ShowAircraftViewWindow(v);
+					break;
+				}
+			}
+		} break;
+		}
+	}	break;
+
+	case WE_DROPDOWN_SELECT: /* we have selected a dropdown item in the list */
+		if (vl->sort_type != e->dropdown.index) {
+			// value has changed -> resort
+			vl->flags |= VL_RESORT;
+			vl->sort_type = e->dropdown.index;
+			_sorting.masked.criteria = vl->sort_type;
+
+			// enable 'Sort By' if a sorter criteria is chosen
+			if (vl->sort_type != SORT_BY_UNSORTED)
+				CLRBIT(w->disabled_state, 3);
+		}
+		SetWindowDirty(w);
+		break;
+
+	case WE_CREATE: /* set up resort timer */
+		vl->sort_list = NULL;
+		vl->flags = VL_REBUILD | (_sorting.train.order << (VL_DESC - 1));
+		vl->sort_type = _sorting.masked.criteria;
+		vl->resort_timer = DAY_TICKS * PERIODIC_RESORT_DAYS;
+		break;
+
+	case WE_DESTROY:
+		free(vl->sort_list);
+		break;
+
+	case WE_TICK: /* resort the list every 20 seconds orso (10 days) */
+		if (--vl->resort_timer == 0) {
+			DEBUG(misc, 1) ("Periodic resort trains list player %d station %d",
+				owner, station);
+			vl->resort_timer = DAY_TICKS * PERIODIC_RESORT_DAYS;
+			vl->flags |= VL_RESORT;
+			SetWindowDirty(w);
+		}
+		break;
+
+	case WE_RESIZE:
+		/* Update the scroll + matrix */
+		w->hscroll.cap += e->sizing.diff.x / 29;
+		w->vscroll.cap += e->sizing.diff.y / PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		break;
+	}
+}
+
+static const Widget _player_vehicles_widgets[] = {
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,							STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,  RESIZE_RIGHT,    14,    11,   312,     0,    13, STR_VEHICLES,				STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,     RESIZE_LR,    14,   313,   324,     0,    13, 0x0,										STR_STICKY_BUTTON},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    80,    14,    25, SRT_SORT_BY,						STR_SORT_ORDER_TIP},
+{      WWT_PANEL,   RESIZE_NONE,    14,    81,   232,    14,    25, 0x0,										STR_SORT_CRITERIA_TIP},
+{   WWT_CLOSEBOX,   RESIZE_NONE,    14,   233,   243,    14,    25, STR_0225,							STR_SORT_CRITERIA_TIP},
+{      WWT_PANEL,  RESIZE_RIGHT,    14,   244,   324,    14,    25, 0x0,										STR_NULL},
+{     WWT_MATRIX,     RESIZE_RB,    14,     0,   312,    26,   207, 0x701,									STR_883D_TRAINS_CLICK_ON_TRAIN_FOR},
+{  WWT_SCROLLBAR,    RESIZE_LRB,    14,   313,   324,    26,   207, 0x0,										STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_PANEL,    RESIZE_RTB,    14,     0,   312,   208,   219, 0x0,										STR_NULL},
+{  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   313,   324,   208,   219, 0x0,										STR_RESIZE_BUTTON},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _player_vehicles_desc = {
+	-1, -1, 325, 220,
+	WC_VEHICLES_LIST,0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE,
+	_player_vehicles_widgets,
+	PlayerVehiclesWndProc
+};
+
+void ShowPlayerVehicles(int player, int station, uint32 type_mask, uint32 cargo_mask, TileIndex xy)
+{
+	Window *w;
+
+	w = AllocateWindowDescFront(&_player_vehicles_desc, (station << 16) | player);
+	if (w) {
+		w->listopt.cargo_mask = cargo_mask;
+		w->listopt.type_mask = type_mask;
+		w->listopt.xy = xy;
+
+		w->caption_color = (player != OWNER_NONE) ? player : _current_player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 5; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_BIG;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_BIG * 3); /* Minimum of 4 vehicles */
+	} else {
+		w = FindWindowById(WC_VEHICLES_LIST, (station << 16) | player);
+		if (w) {
+			vehiclelist_d *vl;
+			vl = &WP(w, vehiclelist_d);
+			vl->flags |= VL_REBUILD;
+			w->listopt.cargo_mask = cargo_mask;
+			w->listopt.type_mask = type_mask;
+			w->listopt.xy = xy;
+			SetWindowDirty(w);
+		}
+	}
+}
Index: ai_pathfinder.c
===================================================================
--- ai_pathfinder.c	(revision 2490)
+++ ai_pathfinder.c	(working copy)
@@ -96,6 +96,8 @@
 	result->EndNodeCheck = AyStar_AiPathFinder_EndNodeCheck;
 	result->FoundEndNode = AyStar_AiPathFinder_FoundEndNode;
 	result->GetNeighbours = AyStar_AiPathFinder_GetNeighbours;
+	
+	result->BeforeExit = NULL;
 
 	result->free = AyStar_AiPathFinder_Free;
 
Index: aircraft_gui.c
===================================================================
--- aircraft_gui.c	(revision 2490)
+++ aircraft_gui.c	(working copy)
@@ -1,3 +1,4 @@
+
 #include "stdafx.h"
 #include "openttd.h"
 #include "debug.h"
@@ -57,7 +58,7 @@
 	y += 10;
 }
 
-static void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawAircraftImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetAircraftImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -85,7 +86,16 @@
 	}
 }
 
+void CcCloneAircraft(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
 
+	if (success) {
+		v = GetVehicle(_new_aircraft_id);
+		ShowAircraftViewWindow(v);
+	}
+}
+
 static void NewAircraftWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -492,11 +502,14 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  50,  67, 0x2B4,    STR_A03B_REFIT_AIRCRAFT_TO_CARRY },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B2,    STR_A028_SHOW_AIRCRAFT_S_ORDERS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B3,    STR_A02B_SHOW_AIRCRAFT_DETAILS },
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_NULL },
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 104, 103, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 104, 115, 0x0,      STR_NULL },
 { WIDGETS_END }
 };
 
+bool CheckStoppedInHangar(Vehicle *v);
+
 static void AircraftViewWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -586,6 +599,12 @@
 		case 10: /* show details */
 			ShowAircraftDetailsWindow(v);
 			break;
+		case 11: {
+			/* clone vehicle */
+			Vehicle *v;
+			v = GetVehicle(w->window_number);
+			DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, CcCloneAircraft, CMD_CLONE_VEHICLE | CMD_MSG(STR_A008_CAN_T_BUILD_AIRCRAFT));
+		} break;
 		}
 	} break;
 
@@ -601,6 +620,19 @@
 		DeleteWindowById(WC_VEHICLE_REFIT, w->window_number);
 		DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
 		break;
+		
+		       case WE_MOUSELOOP:
+               {
+                       Vehicle *v;
+                       uint32 h;
+                       v = GetVehicle(w->window_number);
+                       h = CheckStoppedInHangar(v) ? (1<< 7) : (1 << 11);
+                       if (h != w->hidden_state) {
+                               w->hidden_state = h;
+                               SetWindowDirty(w);
+                       }
+               } break;
+
 	}
 }
 
@@ -635,7 +667,7 @@
 
 	/* setup disabled buttons */
 	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7));
+		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7) | (1 << 8));
 
 	/* determine amount of items for scroller */
 	num = 0;
@@ -746,6 +778,40 @@
 	}
 }
 
+/* Clone a aircraft vehicle
+ * v is the vehicle to clone.
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	if (v->type != VEH_Aircraft) {
+		// it's not a train, Do Nothing
+		return false;
+	}
+
+
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneAircraft,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
+
 static void AircraftDepotWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -761,12 +827,43 @@
 		case 7: /* show build aircraft window */
 			ShowBuildAircraftWindow(w->window_number);
 			break;
-		case 8: /* scroll to tile */
+			
+				case 8: /* clone button */
+			InvalidateWidget(w, 8);
+				TOGGLEBIT(w->click_state, 8);
+				
+				if (HASBIT(w->click_state, 8)) {
+					_place_clicked_vehicle = NULL;
+					SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, 1, w);
+				} else {
+					ResetObjectToPlace();
+				}
+					break;
+		case 9: /* scroll to tile */
 			ScrollMainWindowToTile(w->window_number);
 			break;
 		}
 		break;
 
+
+case WE_PLACE_OBJ: {
+		ClonePlaceObj(e->place.tile, w);
+	} break;
+
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 8);
+		InvalidateWidget(w, 8);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+		if (v) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick( v, w);
+		}
+	} break;
+	
 	case WE_DESTROY:
 		DeleteWindowById(WC_BUILD_VEHICLE, w->window_number);
 		break;
@@ -829,8 +926,9 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   295,    14,    61, 0x204,										STR_A021_AIRCRAFT_CLICK_ON_AIRCRAFT},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   319,   330,    14,    61, 0x0,											STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   159,    62,    73, STR_A003_NEW_AIRCRAFT,		STR_A022_BUILD_NEW_AIRCRAFT},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   160,   318,    62,    73, STR_00E4_LOCATION,				STR_A024_CENTER_MAIN_VIEW_ON_HANGAR},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   105,    62,    73, STR_A003_NEW_AIRCRAFT,		STR_A022_BUILD_NEW_AIRCRAFT},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,   106,   212,    62,    73, STR_8815_NEW_VEHICLES,		STR_NULL},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   213,   318,    62,    73, STR_00E4_LOCATION,				STR_A024_CENTER_MAIN_VIEW_ON_HANGAR},
 {      WWT_PANEL,    RESIZE_RTB,    14,   319,   318,    62,    73, 0x0,													STR_NULL},
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   319,   330,    62,    73, 0x0,											STR_RESIZE_BUTTON},
 {   WIDGETS_END},
@@ -932,7 +1030,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Aircraft, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1128,6 +1226,13 @@
 	}
 
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Aircraft;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = w->window_number;
 		w->vscroll.cap = 4;
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 2490)
+++ train_cmd.c	(working copy)
@@ -1,3 +1,4 @@
+
 #include "stdafx.h"
 #include "openttd.h"
 #include "debug.h"
@@ -16,6 +17,7 @@
 #include "player.h"
 #include "sound.h"
 #include "depot.h"
+#include "debug.h"
 #include "waypoint.h"
 #include "vehicle_gui.h"
 
@@ -38,6 +40,7 @@
 void TrainCargoChanged(Vehicle *v) {
 	Vehicle *u;
 	uint16 weight = 0;
+	uint32 max_TE = 0;
 
 	for (u = v; u != NULL; u = u->next) {
 		const RailVehicleInfo *rvi = RailVehInfo(u->engine_type);
@@ -53,12 +56,16 @@
 		// consist weight is the sum of the weight of all vehicles in the consist
 		weight += vweight;
 
+		if (rvi->power != 0 || HASBIT(u->u.rail.flags, VRF_POWEREDWAGON))
+			max_TE += vweight * 10 * 1000 * rvi->TE_coeff / 256; // TE_max in [N]
+
 		// store vehicle weight in cache
 		u->u.rail.cached_veh_weight = vweight;
 	};
 
 	// store consist weight in cache
 	v->u.rail.cached_weight = weight;
+	v->u.rail.cached_max_TE = max_TE;
 }
 
 /**
@@ -111,7 +118,7 @@
 
 		// max speed is the minimum of the speed limits of all vehicles in the consist
 		if (rvi_u->max_speed != 0)
-			max_speed = min(rvi_u->max_speed, max_speed);
+			max_speed = min(TrainVehSpeed(u), max_speed);
 
 		// check the vehicle length (callback)
 		veh_len = CALLBACK_FAILED;
@@ -317,9 +324,13 @@
 
 	if (force <= 0) force = 10000;
 
-	if (v->u.rail.railtype != 2) force = min(force, mass * 10 * 200);
+	if (v->u.rail.railtype != 2) force = min(force, v->u.rail.cached_max_TE);
 
 	if (mode == AM_ACCEL) {
+		if (force < resistance && speed == 1)
+			return 0;
+		if (force < resistance && speed == 0)
+			return 1;
 		return (force - resistance) / (mass * 4);
 	} else {
 		return min((-force - resistance) / (mass * 4), 10000 / (mass * 4));
@@ -587,7 +598,7 @@
 /** Build a railroad vehicle.
  * @param x,y tile coordinates (depot) where rail-vehicle is built
  * @param p1 engine type id
- * @param p2 unused
+ * @param p2 build only one engine, even if it is a dualheaded engine
  */
 int32 CmdBuildRailVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2)
 {
@@ -617,6 +628,11 @@
 	if (rvi->flags & RVI_WAGON) return CmdBuildRailWagon(p1, tile, flags);
 
 	value = EstimateTrainCost(rvi);
+	
+	//make sure we only pay for half a dualheaded engine if we only requested half of it
+	if (rvi->flags&RVI_MULTIHEAD && HASBIT(p2,0))
+		value /= 2;
+	
 
 	if (!(flags & DC_QUERY_COST)) {
 		v = AllocateVehicle();
@@ -668,9 +684,53 @@
 
 			VehiclePositionChanged(v);
 
-			if (rvi->flags&RVI_MULTIHEAD && (u = AllocateVehicle()) != NULL)
-				AddRearEngineToMultiheadedTrain(v, u, true);
+			if (rvi->flags&RVI_MULTIHEAD && (u = AllocateVehicle()) != NULL && !p2) {
+					AddRearEngineToMultiheadedTrain(v, u, true);
+			}
 
+			if (HASBIT(rvi->callbackmask, CBM_ARTIC_ENGINE)) {
+				Vehicle* w = v;
+				int i;
+				uint val = 0;
+				for(i = 1;val != 0xFF; i++) {
+					val = GetCallBackResult(CBID_ARTIC_ENGINE + (i << 8), v->engine_type, NULL) ;
+					if (val != 0xFF && (u = AllocateVehicle()) != NULL) {
+						RailVehicleInfo* rvi2;
+						if (val&0x80)
+							u->spritenum = 1;
+						else
+							u->spritenum = 0;
+						val &= ~0x80;
+						rvi2 = RailVehInfo(val);
+						u->direction = v->direction;
+						u->owner = v->owner;
+						u->tile = v->tile;
+						u->x_pos = v->x_pos;
+						u->y_pos = v->y_pos;
+						u->z_pos = v->z_pos;
+						u->z_height = 6;
+						u->u.rail.track = 0x80;
+						u->u.rail.first_engine = p1;
+						u->vehstatus = v->vehstatus & ~VS_STOPPED;
+						u->spritenum += rvi2->image_index;
+						u->cargo_type = rvi2->cargo_type;
+						u->cargo_cap = rvi2->capacity;
+						u->max_speed = rvi2->max_speed;
+						u->value = value;
+						u->u.rail.railtype = v->u.rail.railtype;
+						w->next = u;
+						u->engine_type = val;
+						u->build_year = v->build_year;
+						u->value = v->value;
+						u->type = VEH_Train;
+						u->subtype = TS_Artic_Part;
+						u->cur_image = 0xAC2;
+						VehiclePositionChanged(u);
+						w = u;
+					};
+				};
+			};
+
 			TrainConsistChanged(v);
 			UpdateTrainAcceleration(v);
 			NormalizeTrainVehInDepot(v);
@@ -725,11 +785,14 @@
 // returns the new value of first
 static Vehicle *UnlinkWagon(Vehicle *v, Vehicle *first)
 {
-	Vehicle *u;
+	Vehicle *u, *w;
 
 	// unlinking the first vehicle of the chain?
 	if (v == first) {
-		v = v->next;
+		for (u = v; u->next != NULL && u->next->subtype == TS_Artic_Part; u = u->next) {};
+
+		v = u->next;
+		u->next = NULL;
 		if (v == NULL) return NULL;
 
 		v->subtype = TS_Free_Car;
@@ -737,7 +800,13 @@
 	}
 
 	for (u = first; u->next != v; u = u->next) {}
-	u->next = v->next;
+
+	for (w = v; w->next != NULL && w->next->subtype == TS_Artic_Part; w = w->next) {};
+
+	u->next = w->next;
+	w->next = NULL;
+//	u->next = v->next;
+
 	return first;
 }
 
@@ -781,6 +850,10 @@
 
 	if (src->type != VEH_Train) return CMD_ERROR;
 
+	while (src->subtype == TS_Artic_Part) {
+		src = GetPrevVehicleInChain(src);
+	}
+
 	is_loco = !(RailVehInfo(src->engine_type)->flags & RVI_WAGON) && IS_FIRSTHEAD_SPRITE(src->spritenum);
 
 	// if nothing is selected as destination, try and find a matching vehicle to drag to.
@@ -791,9 +864,6 @@
 		dst = GetVehicle((int32)p1 >> 16);
 	}
 
-	// don't move the same vehicle..
-	if (src == dst) return 0;
-
 	/* the player must be the owner */
 	if (!CheckOwnership(src->owner) || (dst!=NULL && !CheckOwnership(dst->owner)))
 		return CMD_ERROR;
@@ -802,7 +872,21 @@
 	src_head = GetFirstVehicleInChain(src);
 	dst_head = NULL;
 	if (dst != NULL) dst_head = GetFirstVehicleInChain(dst);
+	if (dst != NULL) {
+		while (dst->next != NULL && dst->next->subtype == TS_Artic_Part)
+			dst = dst->next;
+//			return CMD_ERROR;
+	}
 
+	// don't move the same vehicle..
+	{
+		Vehicle *tmp = src;
+		while (tmp->next != NULL && tmp->next->subtype == TS_Artic_Part)
+			tmp = tmp ->next;
+		if (tmp == dst) return 0;
+	}
+
+
 	/* clear the ->first cache */
 	{
 		Vehicle *u;
@@ -824,7 +908,7 @@
 			return_cmd_error(STR_8819_TRAIN_TOO_LONG);
 
 		// if it's a multiheaded vehicle we're dragging to, drag to the vehicle before..
-		while (IS_CUSTOM_SECONDHEAD_SPRITE(dst->spritenum) || (
+		while ((RailVehInfo(dst->engine_type)->flags&RVI_MULTIHEAD && IS_CUSTOM_SECONDHEAD_SPRITE(dst->spritenum)) || (
 			!is_custom_sprite(dst->spritenum) && _engine_sprite_add[dst->spritenum] != 0)
 		) {
 			Vehicle *v = GetPrevVehicleInChain(dst);
@@ -866,7 +950,6 @@
 				dst_head = NULL;
 			// unlink single wagon from linked list
 			src_head = UnlinkWagon(src, src_head);
-			src->next = NULL;
 		}
 
 		if (dst == NULL) {
@@ -1000,6 +1083,12 @@
 
 	if (v->type != VEH_Train || !CheckOwnership(v->owner)) return CMD_ERROR;
 
+	while (v->subtype == TS_Artic_Part) {
+		v = GetPrevVehicleInChain(v);
+	}
+//		return CMD_ERROR;
+
+
 	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 
 	first = GetFirstVehicleInChain(v);
@@ -1028,7 +1117,11 @@
 				cost -= v->value;
 				if (flags & DC_EXEC) {
 					v = UnlinkWagon(rear, v);
-					DeleteVehicle(rear);
+					while (rear != NULL) {
+						tmp = rear->next;
+						DeleteVehicle(rear);
+						rear = tmp;
+					}
 				}
 			}
 
@@ -1062,8 +1155,13 @@
 			cost -= v->value;
 			if (flags & DC_EXEC) {
 				first = UnlinkWagon(v, first);
-				DeleteVehicle(v);
 
+				while (v != NULL) {
+					tmp = v->next;
+					DeleteVehicle(v);
+					v = tmp;
+				}
+
 				/* 4 If the second wagon was an engine, update it to front_engine
 					* which UnlinkWagon() has changed to TS_Free_Car */
 				if (switch_engine) first->subtype = TS_Front_Engine;
@@ -1106,6 +1204,8 @@
 			* earlier in the chain (before deletion), leave it alone */
 			for (; v != NULL; v = tmp) {
 				tmp = v->next;
+				while (tmp != NULL && tmp->subtype == TS_Artic_Part)
+					tmp = tmp->next;
 
 				if (RailVehInfo(v->engine_type)->flags & RVI_MULTIHEAD) {
 					/* Always delete newly encountered front-engines */
@@ -1119,9 +1219,15 @@
 				}
 
 				cost -= v->value;
+
 				if (flags & DC_EXEC) {
 					first = UnlinkWagon(v, first);
-					DeleteVehicle(v);
+					while (v != NULL) {
+						Vehicle* tmp2 = v->next;
+						DeleteVehicle(v);
+						v = tmp2;
+					}
+
 				}
 			}
 
@@ -1319,14 +1425,94 @@
 	}
 }
 
+TileIndex GetVehicleTileOutOfTunnel(const Vehicle *v, bool reverse)
+{
+	TileIndex tile;
+	byte direction = (!reverse) ? v->direction >> 1 : ReverseDiagdir(v->direction >> 1);
+	TileIndexDiff delta = TileOffsByDir(direction);
+
+	if (v->u.rail.track != 0x40)
+		return v->tile;
+
+	for (tile = v->tile;; tile += delta) {
+		if (IsTileType(tile, MP_TUNNELBRIDGE) &&
+				(_map5[tile] & 0xF3) != (direction) &&
+				GetTileZ(tile) == v->z_pos)
+ 			break;
+ 	}
+ 	return tile;
+
+};
+
 static void ReverseTrainDirection(Vehicle *v)
 {
 	int l = 0, r = -1;
 	Vehicle *u;
+	TileIndex tile;
+	byte trackdir;
 
+	u = GetLastVehicleInChain(v);
+	tile = GetVehicleTileOutOfTunnel(u, false);
+	trackdir = ReverseTrackdir(GetVehicleTrackdir(u));
+
+	if (PBSTileReserved(tile) & (1 << (trackdir&7))) {
+		NPFFindStationOrTileData fstd;
+		NPFFoundTargetData ftd;
+		
+		NPFFillWithOrderData(&fstd, v);
+
+		tile = GetVehicleTileOutOfTunnel(u, true);
+
+		DEBUG(pbs, 2) ("pbs: (%i) choose reverse (RV), tile:%x, trackdir:%i",v->unitnumber,  u->tile, trackdir);
+		ftd = NPFRouteToStationOrTile(tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+	
+		if (ftd.best_trackdir == 0xFF) {
+			DEBUG(pbs, 0) ("pbs: (%i) no nodes encountered (RV)", v->unitnumber);
+			CLRBIT(v->u.rail.flags, VRF_REVERSING);
+			return;
+		}
+
+    // we found a way out of the pbs block
+		if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED)) {
+				CLRBIT(v->u.rail.flags, VRF_REVERSING);
+				return;
+			}
+		}/* else {
+			CLRBIT(v->u.rail.flags, VRF_REVERSING);
+			return;
+		};*/
+	}/* else if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH) {
+		CLRBIT(v->u.rail.flags, VRF_REVERSING);
+		return;
+	}*/
+
+	tile = GetVehicleTileOutOfTunnel(v, false);
+	trackdir = GetVehicleTrackdir(v);
+
+	if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH) {
+		byte trackdir = GetVehicleTrackdir(v);
+		TileIndex tile = AddTileIndexDiffCWrap(v->tile, TileIndexDiffCByDir(TrackdirToExitdir(trackdir)));
+		uint32 ts;
+		assert(tile != INVALID_TILE);
+		ts = GetTileTrackStatus(tile, TRANSPORT_RAIL);
+		ts &= TrackdirReachesTrackdirs(trackdir);
+		assert(ts != 0 && KillFirstBit2x64(ts) == 0);
+		trackdir = FindFirstBit2x64(ts); 
+		PBSClearPath(tile, trackdir);
+//		if (PBSTileReserved(v->tile) & v->u.rail.track)
+//			PBSReserveTrack(tile, trackdir & 7);
+		v->u.rail.pbs_status = PBS_STAT_NONE;
+	} else if (PBSTileReserved(tile) & (1 << (trackdir&7))) {
+		PBSClearPath(tile, trackdir);
+		if (v->u.rail.track != 0x40)
+			PBSReserveTrack(tile, trackdir & 7);
+	};
+
 	if (IsTileDepotType(v->tile, TRANSPORT_RAIL))
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
 
+
 	/* Check if we were approaching a rail/road-crossing */
 	{
 		TileIndex tile = v->tile;
@@ -1770,13 +1956,37 @@
 		}
 
 		v->load_unload_time_rem = 0;
+		
+		if (PBSIsPbsSegment(v->tile, v->direction)) {
+			byte trackdir = GetVehicleTrackdir(v);
+					//_track_direction_to_trackdir[FIND_FIRST_BIT(v->u.rail.track)][v->direction];
+			NPFFindStationOrTileData fstd;
+			NPFFoundTargetData ftd;
+			
+			if (PBSTileUnavail(v->tile) & (1 << trackdir))
+				return true;
 
+			NPFFillWithOrderData(&fstd, v);
+
+			DEBUG(pbs, 2) ("pbs: (%i) choose depot (DP), tile:%x, trackdir:%i",v->unitnumber,  v->tile, trackdir);
+			ftd = NPFRouteToStationOrTile(v->tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+
+			// we found a way out of the pbs block
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+				if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+					return true;
+				else
+					goto green;
+			}
+		}
+			
+		
 		if (UpdateSignalsOnSegment(v->tile, v->direction)) {
 			InvalidateWindowClasses(WC_TRAINS_LIST);
 			return true;
 		}
 	}
-
+green:
 	VehicleServiceInDepot(v);
 	InvalidateWindowClasses(WC_TRAINS_LIST);
 	TrainPlayLeaveStationSound(v);
@@ -1927,14 +2137,33 @@
 		NPFFindStationOrTileData fstd;
 		NPFFoundTargetData ftd;
 		Trackdir trackdir;
+		uint16 pbs_tracks;
 
 		NPFFillWithOrderData(&fstd, v);
 		/* The enterdir for the new tile, is the exitdir for the old tile */
 		trackdir = GetVehicleTrackdir(v);
 		assert(trackdir != 0xff);
 
-		ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner);
+		pbs_tracks = PBSTileReserved(tile);
+		pbs_tracks |= pbs_tracks << 8;
+		pbs_tracks &= TrackdirReachesTrackdirs(trackdir);
+		if (pbs_tracks || (v->u.rail.pbs_status == PBS_STAT_NEED_PATH)) {
+			DEBUG(pbs, 2) ("pbs: (%i) choosefromblock, tile_org:%x tile_dst:%x  trackdir:%i  pbs_tracks:%i",v->unitnumber, tile,tile - TileOffsByDir(enterdir), trackdir, pbs_tracks);
 
+			// clear the currently planned path
+			if (v->u.rail.pbs_status != PBS_STAT_NEED_PATH) PBSClearPath(tile, FindFirstBit2x64(pbs_tracks));
+
+			// try to find a route to a green exit signal
+			ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+
+			// if no route found, find one to any exit signal
+/*			if (ftd.best_bird_dist != 0 || ftd.best_trackdir == 0xff) {
+				ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_ANY);
+				DEBUG(pbs, 1) ("pbs: (%i) no green sig found, PBS_MODE_ANY result:%i%i", v->index, ftd.best_bird_dist, ftd.best_trackdir);
+		}*/
+		} else
+			ftd = NPFRouteToStationOrTile(tile - TileOffsByDir(enterdir), trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_NONE);
+
 		if (ftd.best_trackdir == 0xff) {
 			/* We are already at our target. Just do something */
 			//TODO: maybe display error?
@@ -2071,7 +2300,7 @@
 		assert(trackdir != 0xff);
 		assert(trackdir_rev != 0xff);
 
-		ftd = NPFRouteToStationOrTileTwoWay(v->tile, trackdir, last->tile, trackdir_rev, &fstd, TRANSPORT_RAIL, v->owner);
+		ftd = NPFRouteToStationOrTileTwoWay(v->tile, trackdir, last->tile, trackdir_rev, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_NONE);
 		if (ftd.best_bird_dist != 0) {
 			/* We didn't find anything, just keep on going straight ahead */
 			reverse_best = false;
@@ -2323,6 +2552,9 @@
 			v->index,
 			0);
 	}
+	if (v->subtype == TS_Front_Engine) st->vehicles[STS_VEH_TRAIN].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
 
 	// Did we reach the final destination?
 	if (v->current_order.type == OT_GOTO_STATION &&
@@ -2667,7 +2899,7 @@
 				} else {
 					/* is not inside depot */
 
-					if (!TrainCheckIfLineEnds(v))
+					if ((prev == NULL) && (!TrainCheckIfLineEnds(v)))
 						return;
 
 					r = VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);
@@ -2722,11 +2954,63 @@
 				}
 
 				if (prev == NULL) {
+					byte trackdir;
 					/* Currently the locomotive is active. Determine which one of the
 					 * available tracks to choose */
 					chosen_track = 1 << ChooseTrainTrack(v, gp.new_tile, enterdir, bits);
 					assert(chosen_track & tracks);
 
+					trackdir = TrackEnterdirToTrackdir(FIND_FIRST_BIT(chosen_track), enterdir);
+					assert(trackdir != 0xff);
+//					DEBUG(misc,0) ("chosen track (%i)  tile:%x  track:%i", v->unitnumber, gp.new_tile, chosen_track);
+					//assert(gp.new_tile < MapSize());
+					if (PBSIsPbsSignal(gp.new_tile,trackdir)) {
+						// encountered a pbs signal, and possible a pbs block
+						DEBUG(pbs, 3) ("pbs: (%i) arrive AT signal, tile:%x  pbs_stat:%i",v->unitnumber, gp.new_tile, v->u.rail.pbs_status);
+
+						if (v->u.rail.pbs_status == PBS_STAT_NONE) {
+							// we havent planned a path already, so try to find one now
+							NPFFindStationOrTileData fstd;
+							NPFFoundTargetData ftd;
+
+							NPFFillWithOrderData(&fstd, v);
+
+							if (v->unitnumber == 12) {
+								v->unitnumber--;
+								v->unitnumber++;
+							}
+
+
+							DEBUG(pbs, 2) ("pbs: (%i) choose signal (TC), tile:%x, trackdir:%i",v->unitnumber,  gp.new_tile, trackdir);
+							ftd = NPFRouteToStationOrTile(gp.new_tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+							//DEBUG(pbs, 2) ("pbs: (%i) choose signal (TC) done", v->unitnumber);
+
+							
+							if (v->u.rail.force_proceed != 0)
+								goto green_light;
+
+							if (ftd.best_trackdir == 0xFF)
+								goto red_light;
+							
+							// we found a way out of the pbs block
+							if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+								if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+									goto red_light;
+								else {
+									goto green_light;
+								}
+								
+							};
+
+						} else {
+							// we have already planned a path through this pbs block
+							// on entering the block, we reset our status
+							v->u.rail.pbs_status = PBS_STAT_NONE;
+							goto green_light;
+						};
+						DEBUG(pbs, 3) ("pbs: (%i) no green light found, or was no pbs-block",v->unitnumber);
+					};
+
 					/* Check if it's a red signal and that force proceed is not clicked. */
 					if ( (tracks>>16)&chosen_track && v->u.rail.force_proceed == 0) goto red_light;
 				} else {
@@ -2735,6 +3019,9 @@
 					/* The wagon is active, simply follow the prev vehicle. */
 					chosen_track = (byte)(_matching_tracks[GetDirectionToVehicle(prev, gp.x, gp.y)] & bits);
 				}
+green_light:
+				if (v->next == NULL)
+					PBSClearTrack(gp.old_tile, FIND_FIRST_BIT(v->u.rail.track));
 
 				/* make sure chosen track is a valid track */
 				assert(chosen_track==1 || chosen_track==2 || chosen_track==4 || chosen_track==8 || chosen_track==16 || chosen_track==32);
@@ -2762,8 +3049,20 @@
 					assert(v->u.rail.track);
 				}
 
-				if (v->subtype == TS_Front_Engine)
- 				TrainMovedChangeSignals(gp.new_tile, enterdir);
+				if (v->subtype == TS_Front_Engine) {
+ 					TrainMovedChangeSignals(gp.new_tile, enterdir);
+					if (v->current_order.type == OT_GOTO_WAYPOINT && v->tile == v->dest_tile) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[WPS_ORDER_MONTH].this_month++;
+						wp->vehicles[WPS_ORDER_YEAR].this_month++;
+					} else if (IsRailWaypoint(_map5[v->tile])) {
+						Waypoint *wp = GetWaypointByTile(v->tile);
+						if (wp->months_counted == 0) wp->months_counted = 1;
+						wp->vehicles[WPS_PATHFIND_MONTH].this_month++;
+						wp->vehicles[WPS_PATHFIND_YEAR].this_month++;
+					}
+				}	
 
 				/* Signals can only change when the first
 				 * (above) or the last vehicle moves. */
@@ -2883,6 +3182,18 @@
 	EndVehicleMove(v);
 	DeleteVehicle(v);
 
+	// clear up reserved pbs tracks
+	if (PBSTileReserved(v->tile) & v->u.rail.track) {
+		if (v == u) {
+			PBSClearPath(v->tile, FIND_FIRST_BIT(v->u.rail.track));
+			PBSClearPath(v->tile, FIND_FIRST_BIT(v->u.rail.track) + 8);
+		};
+		if (v->tile != u->tile) {
+			PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
+		} else if (v == u) {
+		};
+	}
+
 	if (!(v->u.rail.track & 0xC0))
 		SetSignalsOnBothDir(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 
@@ -3010,6 +3321,7 @@
 	uint x,y;
 	int t;
 	uint32 ts;
+	byte trackdir;
 
 	if ((uint)(t=v->breakdown_ctr) > 1) {
 		v->vehstatus |= VS_TRAIN_SLOWING;
@@ -3025,6 +3337,10 @@
 	if (v->u.rail.track & 0x40)
 		return true;
 
+	// exit if inside a depot
+	if (v->u.rail.track & 0x80)
+		return true;
+
 	tile = v->tile;
 
 	// tunnel entrance?
@@ -3048,6 +3364,11 @@
 	// determine the track status on the next tile.
 	ts = GetTileTrackStatus(tile, TRANSPORT_RAIL) & _reachable_tracks[t];
 
+	if (ts & 0x3F3F)
+		trackdir = FindFirstBit2x64(ts & 0x3F3F);
+	else
+		trackdir = 0xFF;
+
 	/* Calc position within the current tile ?? */
 	x = v->x_pos & 0xF;
 	y = v->y_pos & 0xF;
@@ -3100,6 +3421,40 @@
 		return false;
 	}
 
+	if  (v->u.rail.pbs_status == PBS_STAT_HAS_PATH)
+		return true;
+
+	if ((trackdir != 0xFF) && (PBSIsPbsSignal(tile,trackdir)) && !(IsTileType(v->tile, MP_STATION) && (v->current_order.station == _map2[v->tile]))) {
+		NPFFindStationOrTileData fstd;
+		NPFFoundTargetData ftd;
+
+		NPFFillWithOrderData(&fstd, v);
+
+		if (v->unitnumber == 55) {
+			trackdir--;
+			trackdir++;
+		}
+
+		DEBUG(pbs, 2) ("pbs: (%i) choose signal (CEOL), tile:%x  trackdir:%i", v->unitnumber, tile, trackdir);
+		ftd = NPFRouteToStationOrTile(tile, trackdir, &fstd, TRANSPORT_RAIL, v->owner, PBS_MODE_GREEN);
+		DEBUG(pbs, 2) ("pbs: (%i) choose signal (CEOL) done", v->unitnumber);
+
+//		if ((ftd.best_bird_dist == 0) && NPFGetFlag(&ftd.node, NPF_FLAG_PBS_TRACK) && !NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED) && !NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED)) {
+//			v->u.rail.pbs_status = PBS_STAT_HAS_PATH;
+//			return true;
+//		};
+
+		if (ftd.best_trackdir != 0xFF && NPFGetFlag(&ftd.node, NPF_FLAG_PBS_EXIT)) {
+			if (NPFGetFlag(&ftd.node, NPF_FLAG_PBS_BLOCKED) || NPFGetFlag(&ftd.node, NPF_FLAG_PBS_RED))
+			{;}
+			else {
+				v->u.rail.pbs_status = PBS_STAT_HAS_PATH;
+				return true;
+			}
+		};
+							
+	};
+
 	// slow down
 	v->vehstatus |= VS_TRAIN_SLOWING;
 	t = _breakdown_speeds[x & 0xF];
@@ -3187,6 +3542,9 @@
 	v->tick_counter++;
 
 	if (v->subtype == TS_Front_Engine) {
+//		if (v->unitnumber != 86) {
+//			v->vehstatus= VS_STOPPED;
+//		};
 		TrainLocoHandler(v, false);
 
 		// make sure vehicle wasn't deleted.
@@ -3260,6 +3618,12 @@
 	Depot *depot;
 	TrainFindDepotData tfdd;
 
+	if (PBSTileReserved(v->tile) & v->u.rail.track)
+		return;
+
+	if (v->u.rail.pbs_status == PBS_STAT_HAS_PATH)
+		return;
+
 	if (_patches.servint_trains == 0)
 		return;
 
Index: table/sprites.h
===================================================================
--- table/sprites.h	(revision 2490)
+++ table/sprites.h	(working copy)
@@ -42,7 +42,7 @@
 	SPR_ASCII_SPACE_BIG   = 450,
 
 	/* Extra graphic spritenumbers */
-	SPR_CANALS_BASE		= 5126,
+	SPR_CANALS_BASE		= 5382,
 	SPR_SLOPES_BASE		= SPR_CANALS_BASE + 70,
 	SPR_AUTORAIL_BASE		= SPR_SLOPES_BASE + 78,
 	SPR_OPENTTD_BASE	= SPR_AUTORAIL_BASE + 55, // can be lowered once autorail.grf is finalized
@@ -60,6 +60,7 @@
 
 
 	/* Network GUI sprites */
+	SPR_SEMA = SPR_OPENTTD_BASE + 24,				// semaphore icon
 	SPR_SQUARE = SPR_OPENTTD_BASE + 23,     // colored square (used for newgrf compatibility)
 	SPR_LOCK = SPR_OPENTTD_BASE + 22,       // lock icon (for password protected servers)
 	SPR_FLAGS_BASE = SPR_OPENTTD_BASE + 90, // start of the flags block (in same order as enum NetworkLanguage)
Index: table/files.h
===================================================================
--- table/files.h	(revision 2490)
+++ table/files.h	(working copy)
@@ -26,7 +26,7 @@
 		{ "TRG1.GRF", {0x93,0x11,0x67,0x62,0x80,0xe5,0xb1,0x40,0x77,0xa8,0xee,0x41,0xc1,0xb4,0x21,0x92} },     //    0 - 4792 inclusive
 		{ "TRGI.GRF", {0xda,0x6a,0x6c,0x9d,0xcc,0x45,0x1e,0xec,0x88,0xd7,0x92,0x11,0x43,0x7b,0x76,0xa8} },     // 4793 - 4889 inclusive
 		{ "dosdummy.grf", {0x07,0x01,0xe6,0xc4,0x07,0x6a,0x5b,0xc3,0xf4,0x9f,0x01,0xad,0x21,0x6c,0xa0,0xc2} }, // 4890 - 4895 inclusive
-		{ "signalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5125 inclusive
+		{ "nsignalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5381 inclusive
 		{ NULL, { 0 } }
 	},
 	{	{ "TRGC.GRF", {0xed,0x44,0x66,0x37,0xe0,0x34,0x10,0x4c,0x55,0x59,0xb3,0x2c,0x18,0xaf,0xe7,0x8d} },
@@ -39,7 +39,7 @@
 	{
 		{ "TRG1R.GRF", {0xb0,0x4c,0xe5,0x93,0xd8,0xc5,0x01,0x6e,0x07,0x47,0x3a,0x74,0x3d,0x7d,0x33,0x58} },    //    0 - 4792 inclusive
 		{ "TRGIR.GRF", {0x0c,0x24,0x84,0xff,0x6b,0xe4,0x9f,0xc6,0x3a,0x83,0xbe,0x6a,0xb5,0xc3,0x8f,0x32} },    // 4793 - 4895 inclusive
-		{ "signalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5125 inclusive
+		{ "nsignalsw.grf", {0x76,0x1b,0x42,0x25,0x44,0x0d,0x21,0xc7,0xe0,0xb4,0x25,0xd8,0x2f,0xc8,0x52,0x38} }, // 4896 - 5381 inclusive
 		{ NULL, { 0 } },
 		{ NULL, { 0 } }
 	},
Index: table/engines.h
===================================================================
--- table/engines.h	(revision 2490)
+++ table/engines.h	(working copy)
@@ -266,127 +266,127 @@
 };
 
 RailVehicleInfo _rail_vehicle_info[NUM_TRAIN_ENGINES] = {
-	// image_index  max_speed (kph)      running_cost_base                 callbackmask    shortened factor
-	// |  flags     |        power (hp)  |    running_cost_class           |   powered wagons power
-	// |  |    base_cost     |    weight      |    capacity                |   |   powered wagons weight
-	// |  |    |    |        |    |      |    |    |    cargo_type         |   |   |   visual effects
-	// |  |    |    |        |    |      |    |    |    |                  |   |   |   |   |
-	{  2, 0,   7,  64,     300,  47,    50,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   0 */
-	{ 19, 0,   8,  80,     600,  65,    65,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   1 */
-	{  2, 0,  10,  72,     400,  85,    90,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   2 */
-	{  0, 0,  15,  96,     900, 130,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   3 */
-	{  1, 0,  19, 112,    1000, 140,   145,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   4 */
-	{ 12, 0,  16, 120,    1400,  95,   125,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   5 */
-	{ 14, 0,  20, 152,    2000, 120,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   6 */
-	{  3, 0,  14,  88,    1100, 145,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   7 */
-	{  0, 0,  13, 112,    1000, 131,   120,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   8 */
-	{  1, 0,  19, 128,    1200, 162,   140,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   9 */
-	{  0, 0,  22, 144,    1600, 170,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*  10 */
-	{  8, 1,  11, 112,   600/2,32/2,  85/2,   1,  38,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  11 */
-	{ 10, 1,  14, 120,   700/2,38/2,  70/2,   1,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  12 */
-	{  4, 0,  15, 128,    1250,  72,    95,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  13 */
-	{  5, 0,  17, 144,    1750, 101,   120,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  14 */
-	{  4, 0,  18, 160,    2580, 112,   140,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  15 */
-	{ 14, 0,  23,  96,    4000, 150,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  16 */
-	{ 12, 0,  16, 112,    2400, 120,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  17 */
-	{ 13, 0,  30, 112,    6600, 207,   155,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  18 */
-	{ 15, 0,  18, 104,    1500, 110,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  19 */
-	{ 16, 1,  35, 160,  3500/2,95/2, 205/2,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  20 */
-	{ 18, 0,  21, 104,    2200, 120,   145,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  21 */
-	{  6, 1,  20, 200,  4500/2,70/2, 190/2,   1,   4,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  22 */
-	{ 20, 0,  26, 160,    3600,  84,   180,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  23 */
-	{ 20, 0,  30, 176,    5000,  82,   205,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  24 */
-	{ 21, 1,  40, 240,  7000/2,90/2, 240/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  25 */
-	{ 23, 1,  43, 264,  8000/2,95/2, 250/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  26 */
-	{ 33, 2, 247,   0,       0,  25,     0,   0,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  27 */
-	{ 35, 2, 228,   0,       0,  21,     0,   0,  30,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  28 */
-	{ 34, 2, 176,   0,       0,  18,     0,   0,  30,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  29 */
-	{ 36, 2, 200,   0,       0,  24,     0,   0,  30,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  30 */
-	{ 37, 2, 192,   0,       0,  20,     0,   0,  25,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  31 */
-	{ 38, 2, 190,   0,       0,  21,     0,   0,  25,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  32 */
-	{ 39, 2, 182,   0,       0,  19,     0,   0,  30,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  33 */
-	{ 40, 2, 181,   0,       0,  16,     0,   0,  30,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  34 */
-	{ 41, 2, 179,   0,       0,  19,     0,   0,  30,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  35 */
-	{ 42, 2, 196,   0,       0,  18,     0,   0,  20,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  36 */
-	{ 43, 2, 255,   0,       0,  30,     0,   0,  20,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  37 */
-	{ 44, 2, 191,   0,       0,  22,     0,   0,  25,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  38 */
-	{ 45, 2, 196,   0,       0,  18,     0,   0,  20,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  39 */
-	{ 46, 2, 179,   0,       0,  19,     0,   0,  30,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  40 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  25,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  41 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  25,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  42 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  21,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  43 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  30,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  44 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  30,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  45 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  30,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  46 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  20,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  47 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  25,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  48 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  25,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  49 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  20,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  50 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  22,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  51 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  25,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  52 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  30,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  53 */
-	{ 25, 0,  52, 304,    9000,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  54 */
-	{ 26, 1,  60, 336, 10000/2,85/2, 240/2,   2,  25,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  55 */
-	{ 26, 0,  53, 320,    5000,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  56 */
-	{ 60, 2, 247,   0,       0,  25,     0,   0,  45,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  57 */
-	{ 62, 2, 228,   0,       0,  21,     0,   0,  35,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  58 */
-	{ 61, 2, 176,   0,       0,  18,     0,   0,  35,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  59 */
-	{ 63, 2, 200,   0,       0,  24,     0,   0,  35,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  60 */
-	{ 64, 2, 192,   0,       0,  20,     0,   0,  30,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  61 */
-	{ 65, 2, 190,   0,       0,  21,     0,   0,  30,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  62 */
-	{ 66, 2, 182,   0,       0,  19,     0,   0,  35,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  63 */
-	{ 67, 2, 181,   0,       0,  16,     0,   0,  35,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  64 */
-	{ 68, 2, 179,   0,       0,  19,     0,   0,  35,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  65 */
-	{ 69, 2, 196,   0,       0,  18,     0,   0,  25,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  66 */
-	{ 70, 2, 255,   0,       0,  30,     0,   0,  25,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  67 */
-	{ 71, 2, 191,   0,       0,  22,     0,   0,  30,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  68 */
-	{ 72, 2, 196,   0,       0,  18,     0,   0,  25,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  69 */
-	{ 73, 2, 179,   0,       0,  19,     0,   0,  35,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  70 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  30,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  71 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  30,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  72 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  26,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  73 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  35,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  74 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  35,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  75 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  35,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  76 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  25,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  77 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  30,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  78 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  30,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  79 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  25,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  80 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  27,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  81 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  30,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  82 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  35,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  83 */
-	{ 28, 0,  70, 400,   10000, 105,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  84 */
-	{ 29, 0,  74, 448,   12000, 120,   253,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  85 */
-	{ 30, 0,  82, 480,   15000, 130,   254,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  86 */
-	{ 31, 1,  95, 640, 20000/2,150/2,255/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  87 */
-	{ 28, 0,  70, 480,   10000, 120,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  88 */
-	{ 60, 2, 247,   0,       0,  25,     0,   0,  47,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  89 */
-	{ 62, 2, 228,   0,       0,  21,     0,   0,  37,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  90 */
-	{ 61, 2, 176,   0,       0,  18,     0,   0,  37,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  91 */
-	{ 63, 2, 200,   0,       0,  24,     0,   0,  37,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  92 */
-	{ 64, 2, 192,   0,       0,  20,     0,   0,  32,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  93 */
-	{ 65, 2, 190,   0,       0,  21,     0,   0,  32,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  94 */
-	{ 66, 2, 182,   0,       0,  19,     0,   0,  37,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  95 */
-	{ 67, 2, 181,   0,       0,  16,     0,   0,  37,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  96 */
-	{ 68, 2, 179,   0,       0,  19,     0,   0,  37,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  97 */
-	{ 69, 2, 196,   0,       0,  18,     0,   0,  27,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  98 */
-	{ 70, 2, 255,   0,       0,  30,     0,   0,  27,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  99 */
-	{ 71, 2, 191,   0,       0,  22,     0,   0,  32,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /* 100 */
-	{ 72, 2, 196,   0,       0,  18,     0,   0,  27,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /* 101 */
-	{ 73, 2, 179,   0,       0,  19,     0,   0,  37,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /* 102 */
-	{ 47, 2, 199,   0,       0,  25,     0,   0,  32,   CT_WATER        ,  0,  0,  0,  0,  0 }, /* 103 */
-	{ 48, 2, 182,   0,       0,  18,     0,   0,  32,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /* 104 */
-	{ 49, 2, 185,   0,       0,  19,     0,   0,  28,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /* 105 */
-	{ 50, 2, 176,   0,       0,  19,     0,   0,  37,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /* 106 */
-	{ 51, 2, 178,   0,       0,  20,     0,   0,  37,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /* 107 */
-	{ 52, 2, 192,   0,       0,  20,     0,   0,  37,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /* 108 */
-	{ 53, 2, 190,   0,       0,  21,     0,   0,  27,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /* 109 */
-	{ 54, 2, 182,   0,       0,  24,     0,   0,  32,   CT_COLA         ,  0,  0,  0,  0,  0 }, /* 110 */
-	{ 55, 2, 181,   0,       0,  21,     0,   0,  32,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /* 111 */
-	{ 56, 2, 183,   0,       0,  21,     0,   0,  27,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /* 112 */
-	{ 57, 2, 196,   0,       0,  18,     0,   0,  29,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /* 113 */
-	{ 58, 2, 193,   0,       0,  18,     0,   0,  32,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /* 114 */
-	{ 59, 2, 191,   0,       0,  18,     0,   0,  37,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /* 115 */
+	// image_index  max_speed (kph)           running_cost_base                 callbackmask    shortened factor
+	// |  flags     |        power (hp)       |    running_cost_class           |   powered wagons power
+	// |  |    base_cost     |    max-TE-coeff|    |    capacity                |   |   powered wagons weight
+	// |  |    |    |        |    |    weight |    |    |    cargo_type         |   |   |   visual effects
+	// |  |    |    |        |    |    |      |    |    |    |                  |   |   |   |   |
+	{  2, 0,   7,  64,     300,  76,  47,    50,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   0 */
+	{ 19, 0,   8,  80,     600,  76,  65,    65,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   1 */
+	{  2, 0,  10,  72,     400,  76,  85,    90,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   2 */
+	{  0, 0,  15,  96,     900,  76, 130,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   3 */
+	{  1, 0,  19, 112,    1000,  76, 140,   145,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   4 */
+	{ 12, 0,  16, 120,    1400,  76,  95,   125,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   5 */
+	{ 14, 0,  20, 152,    2000,  76, 120,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*   6 */
+	{  3, 0,  14,  88,    1100,  76, 145,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   7 */
+	{  0, 0,  13, 112,    1000,  76, 131,   120,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   8 */
+	{  1, 0,  19, 128,    1200,  76, 162,   140,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*   9 */
+	{  0, 0,  22, 144,    1600,  76, 170,   130,   0,   0,   0               ,  0,  0,  0,  0,  0 }, /*  10 */
+	{  8, 1,  11, 112,   600/2,  76,32/2,  85/2,   1,  38,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  11 */
+	{ 10, 1,  14, 120,   700/2,  76,38/2,  70/2,   1,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  12 */
+	{  4, 0,  15, 128,    1250,  76,  72,    95,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  13 */
+	{  5, 0,  17, 144,    1750,  76, 101,   120,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  14 */
+	{  4, 0,  18, 160,    2580,  76, 112,   140,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  15 */
+	{ 14, 0,  23,  96,    4000,  76, 150,   135,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  16 */
+	{ 12, 0,  16, 112,    2400,  76, 120,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  17 */
+	{ 13, 0,  30, 112,    6600,  76, 207,   155,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  18 */
+	{ 15, 0,  18, 104,    1500,  76, 110,   105,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  19 */
+	{ 16, 1,  35, 160,  3500/2,  76,95/2, 205/2,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  20 */
+	{ 18, 0,  21, 104,    2200,  76, 120,   145,   1,   0,   0               ,  0,  0,  0,  0,  0 }, /*  21 */
+	{  6, 1,  20, 200,  4500/2,  76,70/2, 190/2,   1,   4,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  22 */
+	{ 20, 0,  26, 160,    3600,  76,  84,   180,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  23 */
+	{ 20, 0,  30, 176,    5000,  76,  82,   205,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  24 */
+	{ 21, 1,  40, 240,  7000/2,  76,90/2, 240/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  25 */
+	{ 23, 1,  43, 264,  8000/2,  76,95/2, 250/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  26 */
+	{ 33, 2, 247,   0,       0,  76,  25,     0,   0,  40,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  27 */
+	{ 35, 2, 228,   0,       0,  76,  21,     0,   0,  30,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  28 */
+	{ 34, 2, 176,   0,       0,  76,  18,     0,   0,  30,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  29 */
+	{ 36, 2, 200,   0,       0,  76,  24,     0,   0,  30,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  30 */
+	{ 37, 2, 192,   0,       0,  76,  20,     0,   0,  25,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  31 */
+	{ 38, 2, 190,   0,       0,  76,  21,     0,   0,  25,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  32 */
+	{ 39, 2, 182,   0,       0,  76,  19,     0,   0,  30,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  33 */
+	{ 40, 2, 181,   0,       0,  76,  16,     0,   0,  30,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  34 */
+	{ 41, 2, 179,   0,       0,  76,  19,     0,   0,  30,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  35 */
+	{ 42, 2, 196,   0,       0,  76,  18,     0,   0,  20,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  36 */
+	{ 43, 2, 255,   0,       0,  76,  30,     0,   0,  20,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  37 */
+	{ 44, 2, 191,   0,       0,  76,  22,     0,   0,  25,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  38 */
+	{ 45, 2, 196,   0,       0,  76,  18,     0,   0,  20,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  39 */
+	{ 46, 2, 179,   0,       0,  76,  19,     0,   0,  30,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  40 */
+	{ 47, 2, 199,   0,       0,  76,  25,     0,   0,  25,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  41 */
+	{ 48, 2, 182,   0,       0,  76,  18,     0,   0,  25,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  42 */
+	{ 49, 2, 185,   0,       0,  76,  19,     0,   0,  21,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  43 */
+	{ 50, 2, 176,   0,       0,  76,  19,     0,   0,  30,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  44 */
+	{ 51, 2, 178,   0,       0,  76,  20,     0,   0,  30,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  45 */
+	{ 52, 2, 192,   0,       0,  76,  20,     0,   0,  30,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  46 */
+	{ 53, 2, 190,   0,       0,  76,  21,     0,   0,  20,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  47 */
+	{ 54, 2, 182,   0,       0,  76,  24,     0,   0,  25,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  48 */
+	{ 55, 2, 181,   0,       0,  76,  21,     0,   0,  25,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  49 */
+	{ 56, 2, 183,   0,       0,  76,  21,     0,   0,  20,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  50 */
+	{ 57, 2, 196,   0,       0,  76,  18,     0,   0,  22,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  51 */
+	{ 58, 2, 193,   0,       0,  76,  18,     0,   0,  25,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  52 */
+	{ 59, 2, 191,   0,       0,  76,  18,     0,   0,  30,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  53 */
+	{ 25, 0,  52, 304,    9000,  76,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  54 */
+	{ 26, 1,  60, 336, 10000/2,  76,85/2, 240/2,   2,  25,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  55 */
+	{ 26, 0,  53, 320,    5000,  76,  95,   230,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  56 */
+	{ 60, 2, 247,   0,       0,  76,  25,     0,   0,  45,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  57 */
+	{ 62, 2, 228,   0,       0,  76,  21,     0,   0,  35,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  58 */
+	{ 61, 2, 176,   0,       0,  76,  18,     0,   0,  35,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  59 */
+	{ 63, 2, 200,   0,       0,  76,  24,     0,   0,  35,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  60 */
+	{ 64, 2, 192,   0,       0,  76,  20,     0,   0,  30,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  61 */
+	{ 65, 2, 190,   0,       0,  76,  21,     0,   0,  30,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  62 */
+	{ 66, 2, 182,   0,       0,  76,  19,     0,   0,  35,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  63 */
+	{ 67, 2, 181,   0,       0,  76,  16,     0,   0,  35,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  64 */
+	{ 68, 2, 179,   0,       0,  76,  19,     0,   0,  35,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  65 */
+	{ 69, 2, 196,   0,       0,  76,  18,     0,   0,  25,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  66 */
+	{ 70, 2, 255,   0,       0,  76,  30,     0,   0,  25,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  67 */
+	{ 71, 2, 191,   0,       0,  76,  22,     0,   0,  30,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /*  68 */
+	{ 72, 2, 196,   0,       0,  76,  18,     0,   0,  25,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /*  69 */
+	{ 73, 2, 179,   0,       0,  76,  19,     0,   0,  35,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /*  70 */
+	{ 47, 2, 199,   0,       0,  76,  25,     0,   0,  30,   CT_WATER        ,  0,  0,  0,  0,  0 }, /*  71 */
+	{ 48, 2, 182,   0,       0,  76,  18,     0,   0,  30,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /*  72 */
+	{ 49, 2, 185,   0,       0,  76,  19,     0,   0,  26,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /*  73 */
+	{ 50, 2, 176,   0,       0,  76,  19,     0,   0,  35,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /*  74 */
+	{ 51, 2, 178,   0,       0,  76,  20,     0,   0,  35,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /*  75 */
+	{ 52, 2, 192,   0,       0,  76,  20,     0,   0,  35,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /*  76 */
+	{ 53, 2, 190,   0,       0,  76,  21,     0,   0,  25,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /*  77 */
+	{ 54, 2, 182,   0,       0,  76,  24,     0,   0,  30,   CT_COLA         ,  0,  0,  0,  0,  0 }, /*  78 */
+	{ 55, 2, 181,   0,       0,  76,  21,     0,   0,  30,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /*  79 */
+	{ 56, 2, 183,   0,       0,  76,  21,     0,   0,  25,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /*  80 */
+	{ 57, 2, 196,   0,       0,  76,  18,     0,   0,  27,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /*  81 */
+	{ 58, 2, 193,   0,       0,  76,  18,     0,   0,  30,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /*  82 */
+	{ 59, 2, 191,   0,       0,  76,  18,     0,   0,  35,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /*  83 */
+	{ 28, 0,  70, 400,   10000,  76, 105,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  84 */
+	{ 29, 0,  74, 448,   12000,  76, 120,   253,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  85 */
+	{ 30, 0,  82, 480,   15000,  76, 130,   254,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  86 */
+	{ 31, 1,  95, 640, 20000/2,  76,150/2,255/2,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  87 */
+	{ 28, 0,  70, 480,   10000,  76, 120,   250,   2,   0,   0               ,  0,  0,  0,  0,  0 }, /*  88 */
+	{ 60, 2, 247,   0,       0,  76,  25,     0,   0,  47,   CT_PASSENGERS   ,  0,  0,  0,  0,  0 }, /*  89 */
+	{ 62, 2, 228,   0,       0,  76,  21,     0,   0,  37,   CT_MAIL         ,  0,  0,  0,  0,  0 }, /*  90 */
+	{ 61, 2, 176,   0,       0,  76,  18,     0,   0,  37,   CT_COAL         ,  0,  0,  0,  0,  0 }, /*  91 */
+	{ 63, 2, 200,   0,       0,  76,  24,     0,   0,  37,   CT_OIL          ,  0,  0,  0,  0,  0 }, /*  92 */
+	{ 64, 2, 192,   0,       0,  76,  20,     0,   0,  32,   CT_LIVESTOCK    ,  0,  0,  0,  0,  0 }, /*  93 */
+	{ 65, 2, 190,   0,       0,  76,  21,     0,   0,  32,   CT_GOODS        ,  0,  0,  0,  0,  0 }, /*  94 */
+	{ 66, 2, 182,   0,       0,  76,  19,     0,   0,  37,   CT_GRAIN        ,  0,  0,  0,  0,  0 }, /*  95 */
+	{ 67, 2, 181,   0,       0,  76,  16,     0,   0,  37,   CT_WOOD         ,  0,  0,  0,  0,  0 }, /*  96 */
+	{ 68, 2, 179,   0,       0,  76,  19,     0,   0,  37,   CT_IRON_ORE     ,  0,  0,  0,  0,  0 }, /*  97 */
+	{ 69, 2, 196,   0,       0,  76,  18,     0,   0,  27,   CT_STEEL        ,  0,  0,  0,  0,  0 }, /*  98 */
+	{ 70, 2, 255,   0,       0,  76,  30,     0,   0,  27,   CT_VALUABLES    ,  0,  0,  0,  0,  0 }, /*  99 */
+	{ 71, 2, 191,   0,       0,  76,  22,     0,   0,  32,   CT_FOOD         ,  0,  0,  0,  0,  0 }, /* 100 */
+	{ 72, 2, 196,   0,       0,  76,  18,     0,   0,  27,   CT_PAPER        ,  0,  0,  0,  0,  0 }, /* 101 */
+	{ 73, 2, 179,   0,       0,  76,  19,     0,   0,  37,   CT_COPPER_ORE   ,  0,  0,  0,  0,  0 }, /* 102 */
+	{ 47, 2, 199,   0,       0,  76,  25,     0,   0,  32,   CT_WATER        ,  0,  0,  0,  0,  0 }, /* 103 */
+	{ 48, 2, 182,   0,       0,  76,  18,     0,   0,  32,   CT_FRUIT        ,  0,  0,  0,  0,  0 }, /* 104 */
+	{ 49, 2, 185,   0,       0,  76,  19,     0,   0,  28,   CT_RUBBER       ,  0,  0,  0,  0,  0 }, /* 105 */
+	{ 50, 2, 176,   0,       0,  76,  19,     0,   0,  37,   CT_SUGAR        ,  0,  0,  0,  0,  0 }, /* 106 */
+	{ 51, 2, 178,   0,       0,  76,  20,     0,   0,  37,   CT_COTTON_CANDY ,  0,  0,  0,  0,  0 }, /* 107 */
+	{ 52, 2, 192,   0,       0,  76,  20,     0,   0,  37,   CT_TOFFEE       ,  0,  0,  0,  0,  0 }, /* 108 */
+	{ 53, 2, 190,   0,       0,  76,  21,     0,   0,  27,   CT_BUBBLES      ,  0,  0,  0,  0,  0 }, /* 109 */
+	{ 54, 2, 182,   0,       0,  76,  24,     0,   0,  32,   CT_COLA         ,  0,  0,  0,  0,  0 }, /* 110 */
+	{ 55, 2, 181,   0,       0,  76,  21,     0,   0,  32,   CT_CANDY        ,  0,  0,  0,  0,  0 }, /* 111 */
+	{ 56, 2, 183,   0,       0,  76,  21,     0,   0,  27,   CT_TOYS         ,  0,  0,  0,  0,  0 }, /* 112 */
+	{ 57, 2, 196,   0,       0,  76,  18,     0,   0,  29,   CT_BATTERIES    ,  0,  0,  0,  0,  0 }, /* 113 */
+	{ 58, 2, 193,   0,       0,  76,  18,     0,   0,  32,   CT_FIZZY_DRINKS ,  0,  0,  0,  0,  0 }, /* 114 */
+	{ 59, 2, 191,   0,       0,  76,  18,     0,   0,  37,   CT_PLASTIC      ,  0,  0,  0,  0,  0 }, /* 115 */
 };
 
 ShipVehicleInfo _ship_vehicle_info[NUM_SHIP_ENGINES] = {
Index: road_cmd.c
===================================================================
--- road_cmd.c	(revision 2490)
+++ road_cmd.c	(working copy)
@@ -1,5 +1,6 @@
 #include "stdafx.h"
 #include "openttd.h"
+#include "table/sprites.h"
 #include "table/strings.h"
 #include "map.h"
 #include "tile.h"
@@ -11,6 +12,7 @@
 #include "gfx.h"
 #include "sound.h"
 #include "depot.h"
+#include "pbs.h"
 
 /* When true, GetTrackStatus for roads will treat roads under reconstruction
  * as normal roads instead of impassable. This is used when detecting whether
@@ -246,6 +248,7 @@
 
 			cost = _price.remove_road * 2;
 			if (flags & DC_EXEC) {
+				byte pbs_track = PBSTileReserved(tile);
 				ChangeTownRating(t, -road_remove_cost[(byte)edge_road], RATING_ROAD_MINIMUM);
 
 				ModifyTile(tile,
@@ -254,6 +257,8 @@
 					_map3_hi[tile] & 0xF, /* map3_lo */
 					c											/* map5 */
 				);
+				if (pbs_track != 0)
+					PBSReserveTrack(tile, FIND_FIRST_BIT(pbs_track));
 			}
 			return cost;
 		} else
@@ -354,6 +359,7 @@
 	int32 cost;
 	byte pieces = (byte)p1, existing = 0;
 	TileIndex tile;
+	
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
@@ -396,6 +402,7 @@
 			goto do_clear;
 
 		if (flags & DC_EXEC) {
+			byte pbs_track = PBSTileReserved(tile);
 			ModifyTile(tile,
 				MP_SETTYPE(MP_STREET) |
 				MP_MAP2 | MP_MAP3LO | MP_MAP3HI | MP_MAP5,
@@ -404,6 +411,8 @@
 				_map3_lo[tile] & 0xF, /* map3_hi */
 				m5 /* map5 */
 			);
+			if (pbs_track != 0)
+				PBSReserveTrack(tile, FIND_FIRST_BIT(pbs_track));
 		}
 		return _price.build_road * 2;
 	} else if (ti.type == MP_TUNNELBRIDGE) {
@@ -827,6 +836,20 @@
 		}
 
 		DrawGroundSprite(image + (_map3_hi[ti->tile] & 0xF) * 12);
+
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite(0x3ED | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite(0x3EE | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite(0x3EF | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite(0x3F0 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite(0x3F2 | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 | PALETTE_CRASH);
+}
+#endif
+
 	} else {
 		uint32 ormod;
 		int player;
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 2490)
+++ rail_cmd.c	(working copy)
@@ -16,7 +16,9 @@
 #include "station.h"
 #include "sprite.h"
 #include "depot.h"
+#include "pbs.h"
 #include "waypoint.h"
+#include "npf.h"
 #include "rail.h"
 
 extern uint16 _custom_sprites_base;
@@ -687,8 +689,10 @@
  * pre/exit/combo-signals, and what-else not
  * @param x,y coordinates where signals is being built
  * @param p1 various bitstuffed elements
- * - p1 = (bit 0-2) - track-orientation, valid values: 0-5 (Track enum)
- * - p1 = (bit 3)   - choose semaphores/signals or cycle normal/pre/exit/combo depending on context
+ * - p1 (bit 0-2) - track-orientation, valid values: 0-5 (Track enum)
+ * - p1 (bit 3)   - cycle normal/pre/exit/combo (only applies when signals already exist)
+ * - p1 (bit 4)   - choose semaphores/light signals (only applies when no signals already exist)
+ * - p1 (bit 5-6) - choose presignal type (only aplies when no signals already exist)
  * @param p2 used for CmdBuildManySignals() to copy direction of first signal
  * TODO: p2 should be replaced by two bits for "along" and "against" the track.
  */
@@ -696,14 +700,12 @@
 {
 	TileIndex tile = TileVirtXY(x, y);
 	bool semaphore;
-	bool pre_signal;
+	bool pre_signal_cycle;
+	byte pre_signal_type;
 	Track track = (Track)(p1 & 0x7);
 	byte m5;
 	int32 cost;
 
-	// Same bit, used in different contexts
-	semaphore = pre_signal = HASBIT(p1, 3);
-
 	if (!ValParamTrackOrientation(track) || !IsTileType(tile, MP_RAILWAY) || !EnsureNoVehicle(tile))
 		return CMD_ERROR;
 
@@ -731,6 +733,12 @@
 
 	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
+	// for when signals already exist
+	pre_signal_cycle = HASBIT(p1, 3);
+	// for placing new signals
+	semaphore = HASBIT(p1, 4);
+	pre_signal_type = (p1 >> 5) & 3;
+
 	if (!HasSignalOnTrack(tile, track)) {
 		// build new signals
 		cost = _price.build_signals;
@@ -750,7 +758,7 @@
 			_map5[tile] |= RAIL_TYPE_SIGNALS; // change into signals
 			_map2[tile] |= 0xF0;              // all signals are on
 			_map3_lo[tile] &= ~0xF0;          // no signals built by default
-			_map3_hi[tile] = semaphore ? 4 : 0;
+			_map3_hi[tile] = (semaphore ? 4 : 0) + pre_signal_type;
 		}
 
 		if (p2 == 0) {
@@ -758,11 +766,23 @@
 				// build new signals
 				_map3_lo[tile] |= SignalOnTrack(track);
 			} else {
-				if (pre_signal) {
+				if (pre_signal_cycle) {
 					// cycle between normal -> pre -> exit -> combo -> ...
-					byte type = (GetSignalType(tile, track) + 1) & 0x03;
-					_map3_hi[tile] &= ~0x03;
-					_map3_hi[tile] |= type;
+//<<<<<<< .mine
+					// TODO: fix up this hacky mess :-p
+					byte type = (_map3_hi[tile] & 0x03) + ((_map3_hi[tile] & 0x08) >> 1);
+					++type;
+					if (type == 5)
+						type = 0;
+					_map3_hi[tile] &= ~0x0B;
+					_map3_hi[tile] |= type & 0x03;
+					type <<= 1;
+					_map3_hi[tile] |= type & 0x08;
+//-------
+//					byte type = (GetSignalType(tile, track) + 1) & 0x03;
+//					_map3_hi[tile] &= ~0x03;
+//					_map3_hi[tile] |= type;
+//>>>>>>> .r2456
 				} else {
 					// cycle between two-way -> one-way -> one-way -> ...
 					/* TODO: Rewrite switch into something more general */
@@ -805,13 +825,235 @@
 	return cost;
 }
 
-/**	Build many signals by dragging; AutoSignals
+static const byte _dir_from_track[14] = {
+	0,1,0,1,2,1, 0,0,
+	2,3,3,2,3,0,
+};
+
+/**  Build many signals automagically,
+ * Copy a signal along the entire length of connected rail, stopping only when a junction is reached
+ * @param x,y tile to start from
+ * @param trackdir the trackdir (direction in which to start placing signals)
+ * @param signals type of signals to copy
+ * @param p2 various bitstuffed elements
+ * - p2 (bit 0)     - 1 = remove signals, 0 = build signals
+ * - p2 (bit 3)     - 0 = signals, 1 = semaphores
+ * - p2 (bit 24-31) - user defined signals_density
+ */
+int32 BuildAutoSignals(int x, int y, Trackdir trackdir, uint32 flags, uint32 p2, byte signals)
+{
+  byte signal_density = (p2 >> 24);
+	int16 signal_ctr = signal_density * 2;
+	byte signal_dir = 0;	// direction in which signals are placed 1=forward  2=backward  3=twoway
+	byte track_mode = 0;	// 128=bridge, 64=tunnel, 192=end of tunnel/bridge, 0=normal track
+	byte track_height = 0; // height of tunnel currently in
+	int32 retr, total_cost = 0;
+	TileIndex tile = TileVirtXY(x, y);
+	byte m5 = _map5[tile];
+	byte m3 = _map3_lo[tile];
+	byte semaphores = (_map3_hi[tile] & ~3) ? 16 : 0;
+	int mode = p2 & 0x1;
+	int lx, ly;
+	byte dir;
+
+
+	// remember start position and direction
+	int sx = x, sy = y;
+	Trackdir srb = trackdir;
+
+	// get first signal mode
+	if (signals & _signals_table[trackdir]) signal_dir |= 1;
+	if (signals & _signals_table_other[trackdir]) signal_dir |= 2;
+
+	// check for semaphores
+	if (HasSignalOnTrack(tile, TrackdirToTrack(trackdir)))
+		semaphores = (HasSemaphores(tile, TrackdirToTrack(trackdir)) ? 16 : 0); // copy signal/semaphores style (independent of CTRL)
+
+		semaphores = (_map3_hi[tile] & ~3) ? 16 : 0; // copy signal/semaphores style (independent of GUI)
+
+	if (signal_dir == 0)
+		return CMD_ERROR; // no signal on start tile to copy
+
+	signals = 0;
+	lx = 0;
+	ly = 0;
+
+	for(;;) {
+		x += _railbit.xinc[trackdir];
+		y += _railbit.yinc[trackdir];
+
+		tile = TileVirtXY(x, y);
+
+		m5 = _map5[tile];
+
+		m3 = _map3_lo[tile];
+
+		dir = _dir_from_track[trackdir];
+
+		if (track_mode & 128) { // currently on bridge
+			if (IsTileType(tile, MP_TUNNELBRIDGE) && ((m5 & 192) == 128))
+				// end of bridge
+				track_mode = 192;
+		} else if (track_mode & 64) { // currently in tunnel
+			if (IsTileType(tile, MP_TUNNELBRIDGE)
+			&& ((m5 & 0xF0) == 0)
+			&& ((m5 & 3) == (dir ^ 2))
+			&& (GetSlopeZ(x+8, y+8) == track_height))
+					// end of tunnel
+					track_mode = 192;
+		} else { // currently not on bridge/in tunnel
+			if (IsTileType(tile,MP_TUNNELBRIDGE)
+			&& (((m5 >> 1) & 3) == 0)
+			&& ((m5 & 192) == 128)
+			&& ((m5 & 1) == (dir & 1)) ) {
+				// start of bridge
+				track_mode = 128;
+			} else if (IsTileType(tile, MP_TUNNELBRIDGE)
+			&& ((m5 & 0xF0) == 0)
+			&& (((m5 >> 2) & 3) == 0) ) {
+				// start of tunnel
+				track_mode = 64;
+				track_height = GetSlopeZ(x+8, y+8);
+			};
+		};
+
+		/* for pieces that we cannot build signals on but are not an end of track or a junction, we continue counting. When a signal
+			 should be placed in one of these tiles, it is instead placed on the last possible place for signals, and the counting is
+			 reset from that place. If a signal already is there, one will be placed one the first possible tile encountered.
+		   last place where a signal could be placed is remembered by lx,ly
+			 if signal==0 a signal is already on lx,ly
+		*/
+		if ( (IsTileType(tile, MP_RAILWAY) && ((m5 & ~1) == RAIL_TYPE_WAYPOINT)	&& ((m5 & 1) == (dir & 1))) // check for waypoints
+			|| (IsTileType(tile, MP_STREET) && ((m5 >> 4) == 1)										&& (!(m5 & 8) != !(dir & 1))) // check for road crossings
+			|| (IsTileType(tile,MP_TUNNELBRIDGE) && ((m5 & 0xF8) == 0xE0)					&& ((m5 & 1) != (dir & 1))) // check overhanging bridges
+			|| (track_mode != 0) // are we on a bridge/in a tunnel
+		) {
+			if (track_mode == 192) track_mode = 0; // end of tunnel/bridge
+			signal_ctr -= 2; // these pieces are always diagonal, so count faster
+			if (signal_ctr <= 0) {
+				if (signals == 0) {
+					// signal will be placed on next available tile
+					signal_ctr = 1;
+				} else {
+					// signal will be placed on last possible tile, counting will reset from there
+					signal_ctr += signal_density * 2;
+					x = lx;
+					y = ly;
+					// Place Signal
+					retr = DoCommand(x, y, TrackdirToTrack(trackdir) | semaphores, signals, flags, (mode == 1) ? CMD_REMOVE_SIGNALS : CMD_BUILD_SIGNALS);
+					if (retr == CMD_ERROR) return CMD_ERROR;
+					total_cost += retr;
+					signals = 0;
+					track_mode = 0;
+				};
+			};
+			continue;
+		};
+
+		if (!IsTileType(tile, MP_RAILWAY))
+			return total_cost;  // no more track, we are finished
+
+		if ((m5 & RAIL_TYPE_SPECIAL) || !(m5 & 0x3F))
+			return total_cost;  // no more track, we are finished
+
+		// check for valid track combination, and calculate the trackdir
+		m5 &= 0x3F;
+		switch (trackdir) {
+			case 0: case 2: case 13: { // from SW
+				if (m5 == TRACK_BIT_DIAG1) { // SW to NE track
+					trackdir = 0;
+				} else if ((m5 & ~TRACK_BIT_UPPER) == TRACK_BIT_LOWER) { // SW to SE track
+					trackdir = 3;
+				} else if ((m5 & ~TRACK_BIT_RIGHT) == TRACK_BIT_LEFT) { // SW to NW track
+					trackdir = 12;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			case 8: case 4: case 11: { // from NE
+				if (m5 == TRACK_BIT_DIAG1) { // NE to SW track
+					trackdir = 8;
+				} else if ((m5 & ~TRACK_BIT_LOWER) == TRACK_BIT_UPPER) { // NE to NW track
+					trackdir = 10;
+				} else if ((m5 & ~TRACK_BIT_LEFT) == TRACK_BIT_RIGHT) { // NE to SE track
+					trackdir = 5;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			case 9: case 10: case 12: { // from SE
+				if (m5 == TRACK_BIT_DIAG2) { // SE to NW track
+					trackdir = 9;
+				} else if ((m5 & ~TRACK_BIT_UPPER) == TRACK_BIT_LOWER ) { // SE to SW track
+					trackdir = 11;
+				} else if ((m5 & ~TRACK_BIT_LEFT) == TRACK_BIT_RIGHT) { // SE to NE track
+					trackdir = 13;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			case 1: case 3: case 5: { // from NW
+				if (m5 == TRACK_BIT_DIAG2) { // NW to SE track
+					trackdir = 1;
+				} else if ((m5 & ~TRACK_BIT_LOWER) == TRACK_BIT_UPPER) { // NW to NE track
+					trackdir = 2;
+				} else if((m5 & ~TRACK_BIT_RIGHT) == TRACK_BIT_LEFT) { // NW to SW track
+					trackdir = 4;
+				} else {
+					return total_cost; // unsuitable track for signals, we are finished
+				}
+			} break;
+			default:
+				assert(0);
+		}
+
+		// calculate signals to place
+		signals = 0;
+		if (signal_dir & 1) signals |= _signals_table[trackdir];
+		if (signal_dir & 2) signals |= _signals_table_other[trackdir];
+
+		if (x == sx && y == sy && trackdir == srb)
+			return total_cost; // back at the start, we are finished
+
+		// remember last place signals could be placed
+		lx = x;			ly = y;
+
+		m5 = _map5[tile];
+		if (mode)
+			// when removing signals, remove all signals we encounter
+			signal_ctr =( (((m5 & RAIL_TILE_TYPE_MASK) == RAIL_TYPE_SIGNALS)) && (m3 & _signals_table_both[trackdir]) ) ? 0 : 1;
+		else if (m5 & 0x3)
+			// count faster on diagonal tracks
+			signal_ctr -= 2;
+		else
+			signal_ctr -= 1;
+
+		if (signal_ctr <= 0) {
+			signal_ctr += signal_density * 2;
+			// Place Signal
+			retr = DoCommand(lx, ly, (trackdir & 7) | semaphores, signals , flags, (mode == 1) ? CMD_REMOVE_SIGNALS : CMD_BUILD_SIGNALS);
+			if (retr == CMD_ERROR) return CMD_ERROR;
+			total_cost += retr;
+			signals = 0;
+		};
+
+		// when removing signals, the last position is always handled
+		if (mode) signals = 0;
+
+	};
+
+
+};
+
+
+/** Build many signals by dragging; AutoSignals
  * @param x,y start tile of drag
  * @param p1  end tile of drag
  * @param p2 various bitstuffed elements
- * - p2 = (bit  0)    - 0 = build, 1 = remove signals
- * - p2 = (bit  3)    - 0 = signals, 1 = semaphores
- * - p2 = (bit  4- 6) - track-orientation, valid values: 0-5 (Track enum)
+ * - p2 = (bit 0)     - 0 = build, 1 = remove signals
+ * - p2 = (bit 1)     - 1 = autocompletion on, 0 = off
+ * - p2 = (bit 3)     - 0 = signals, 1 = semaphores
+ * - p2 = (bit 4- 6)  - track-orientation, valid values: 0-5 (Track enum)
  * - p2 = (bit 24-31) - user defined signals_density
  */
 static int32 CmdSignalTrackHelper(int x, int y, uint32 flags, uint32 p1, uint32 p2)
@@ -825,7 +1067,7 @@
 	int mode = p2 & 0x1;
 	Track track = (p2 >> 4) & 7;
 	Trackdir trackdir = TrackToTrackdir(track);
-	byte semaphores = (HASBIT(p2, 3)) ? 8 : 0;
+	byte semaphores = (HASBIT(p2, 3)) ? 16 : 0;
 	byte signal_density = (p2 >> 24);
 
 	if (p1 > MapSize()) return CMD_ERROR;
@@ -854,7 +1096,7 @@
 		signals = _map3_lo[tile] & SignalOnTrack(track);
 		if (signals == 0) signals = SignalOnTrack(track); /* Can this actually occur? */
 
-		semaphores = (HasSemaphores(tile, track) ? 8 : 0); // copy signal/semaphores style (independent of CTRL)
+		semaphores = (HasSemaphores(tile, track) ? 16 : 0); // copy signal/semaphores style (independent of CTRL)
 	} else // no signals exist, drag a two-way signal stretch
 		signals = SignalOnTrack(track);
 
@@ -879,6 +1121,15 @@
 			} else {
 				error = false;
 				total_cost += ret;
+
+				/* when autocompletion is on, use that to place the rest of the signals */
+				if HASBIT(p2, 1) {
+					ret = BuildAutoSignals(x, y, trackdir, flags, p2, signals);
+					if (ret == CMD_ERROR)
+						return CMD_ERROR;
+					total_cost += ret;
+					return total_cost;
+				}
 			}
 		}
 
@@ -888,7 +1139,7 @@
 		y += _railbit.yinc[trackdir];
 		signal_ctr++;
 
-		// toggle railbit for the non-diagonal tracks (|, -- tracks)
+		// toggle trackdir for the non-diagonal tracks (|, -- tracks)
 		if (!IsDiagonalTrackdir(trackdir)) trackdir ^= 1;
 	}
 
@@ -1119,7 +1370,7 @@
 #include "table/track_land.h"
 
 // used for presignals
-static const SpriteID _signal_base_sprites[16] = {
+static const SpriteID _signal_base_sprites[32] = {
 	0x4FB,
 	0x1323,
 	0x1333,
@@ -1131,16 +1382,41 @@
 	0x1373,
 	0x1383,
 
+	// pbs
+	0x1393,
+	0x13A3,  // not used (yet?)
+	0x13B3,  // not used (yet?)
+	0x13C3,  // not used (yet?)
+
+	// pbs + sema
+	0x13D3,
+	0x13E3,  // not used (yet?)
+	0x13F3,  // not used (yet?)
+	0x1403,  // not used (yet?)
+
+
 	// mirrored versions
 	0x4FB,
 	0x1323,
 	0x1333,
 	0x1343,
 
-	0x13C6,
-	0x13D6,
-	0x13E6,
-	0x13F6,
+	0x1446,
+	0x1456,
+	0x1466,
+	0x1476,
+
+	// pbs
+	0x1393,
+	0x13A3,  // not used (yet?)
+	0x13B3,  // not used (yet?)
+	0x13C3,  // not used (yet?)
+
+	// pbs + sema
+	0x14C6,
+	0x14D6,  // not used (yet?)
+	0x14E6,  // not used (yet?)
+	0x14F6,  // not used (yet?)
 };
 
 // used to determine the side of the road for the signal
@@ -1158,7 +1434,7 @@
 	uint v = _signal_position[(image_and_pos & 0xF) + (otherside ? 12 : 0)];
 	uint x = ti->x | (v&0xF);
 	uint y = ti->y | (v>>4);
-	uint sprite = _signal_base_sprites[(_map3_hi[ti->tile] & 7) + (otherside ? 8 : 0)] + (image_and_pos>>4) + ((condition != 0) ? 1 : 0);
+	uint sprite = _signal_base_sprites[(_map3_hi[ti->tile] & 15) + (otherside ? 16 : 0)] + (image_and_pos>>4) + ((condition != 0) ? 1 : 0);
 	AddSortableSpriteToDraw(sprite, x, y, 1, 1, 10, GetSlopeZ(x,y));
 }
 
@@ -1369,6 +1645,19 @@
 			if (m5 & TRACK_BIT_RIGHT) DrawGroundSprite(0x3F1 + tracktype_offs);
 		}
 
+#ifdef PBS_SHOW_RESERVED
+		{
+			byte pbs = PBSTileReserved(ti->tile);
+			assert(pbs != 0xFF);
+			if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite((0x3ED + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite((0x3EE + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_UPPER) DrawGroundSprite((0x3EF + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_LOWER) DrawGroundSprite((0x3F0 + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite((0x3F2 + tracktype_offs) | PALETTE_CRASH);
+			if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite((0x3F1 + tracktype_offs) | PALETTE_CRASH);
+		}
+#endif
+
 		if (_display_opt & DO_FULL_DETAIL) {
 			_detailed_track_proc[_map2[ti->tile] & RAIL_MAP2LO_GROUND_MASK](ti);
 		}
@@ -1478,6 +1767,19 @@
 
 		DrawGroundSprite(image);
 
+#ifdef PBS_SHOW_RESERVED
+{
+	byte pbs = PBSTileReserved(ti->tile);
+	assert(pbs != 0xFF);
+	if (pbs & TRACK_BIT_DIAG1) DrawGroundSprite((0x3ED + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_DIAG2) DrawGroundSprite((0x3EE + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_UPPER) DrawGroundSprite((0x3EF + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LOWER) DrawGroundSprite((0x3F0 + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_LEFT)  DrawGroundSprite((0x3F2 + tracktype_offs) | PALETTE_CRASH);
+	if (pbs & TRACK_BIT_RIGHT) DrawGroundSprite((0x3F1 + tracktype_offs) | PALETTE_CRASH);
+}
+#endif
+
 		while ((image=drss->image) != 0) {
 			DrawSpecialBuilding(image, type < 4 ? tracktype_offs : 0, ti,
 			                    drss->subcoord_x, drss->subcoord_y, 0,
@@ -1522,6 +1824,7 @@
 	int cur_stack;
 	bool stop;
 	bool has_presignal;
+	bool has_pbssignal;
 
 	// presignal info
 	int presignal_exits;
@@ -1531,6 +1834,10 @@
 	byte bit[NUM_SSD_ENTRY];
 	TileIndex tile[NUM_SSD_ENTRY];
 
+	int pbs_cur;
+	// these are used to keep track of the signals that change.
+	TileIndex pbs_tile[NUM_SSD_ENTRY];
+
 	// these are used to keep track of the stack that modifies presignals recursively
 	TileIndex next_tile[NUM_SSD_STACK];
 	byte next_dir[NUM_SSD_STACK];
@@ -1548,12 +1855,29 @@
 					ssd->tile[ssd->cur] = tile; // remember the tile index
 					ssd->bit[ssd->cur] = track; // and the controlling bit number
 					ssd->cur++;
+//					DEBUG(pbs, 0) ("sigstuff tile:%x  track:%i",tile,track);
 				}
 
+				ssd->has_pbssignal |= PBSIsPbsSignal(tile, ReverseTrackdir(track)) ? 1 : 0;
+
 				// remember if this block has a presignal.
 				ssd->has_presignal |= (_map3_hi[tile]&1);
 			}
 
+			if (PBSIsPbsSignal(tile, ReverseTrackdir(track)) || PBSIsPbsSignal(tile, track)) {
+				if (ssd->has_pbssignal & 4)
+					ssd->has_pbssignal |= 8;
+				ssd->has_pbssignal |= 4;
+			}
+
+			if ((_map3_lo[tile] & _signals_table_both[track]) != 0) {
+				ssd->pbs_tile[ssd->pbs_cur] = tile; // remember the tile index
+				ssd->pbs_cur++;
+			}
+
+			if (_map3_lo[tile]&_signals_table_other[track])
+				ssd->has_pbssignal |= PBSIsPbsSignal(tile, track) ? 2 : 0;
+
 			// is this an exit signal that points out from the segment?
 			if ((_map3_hi[tile]&2) && _map3_lo[tile]&_signals_table_other[track]) {
 				ssd->presignal_exits++;
@@ -1568,6 +1892,26 @@
 	return false;
 }
 
+static bool SetSignalsEnumProcPBS(uint tile, SetSignalsData *ssd, int track, uint length, byte *state)
+{
+	// the tile has signals?
+	if (IsTileType(tile, MP_RAILWAY)) {
+		if (GetRailTileType(tile) == RAIL_TYPE_SIGNALS) {
+			if ((_map3_lo[tile] & _signals_table_both[track]) != 0) {
+
+				if (ssd->cur != NUM_SSD_ENTRY) {
+					ssd->tile[ssd->cur] = tile; // remember the tile index
+					ssd->bit[ssd->cur] = track & 7; // and the controlling bit number
+					ssd->cur++;
+				}
+				return true;
+			}
+		} else if (IsTileDepotType(tile, TRANSPORT_RAIL))
+			return true; // don't look further if the tile is a depot
+	}
+	return false;
+}
+
 /* Struct to parse data from VehicleFromPos to SignalVehicleCheckProc */
 typedef struct SignalVehicleCheckStruct {
 	TileIndex tile;
@@ -1679,12 +2023,6 @@
 	}
 }
 
-static const byte _dir_from_track[14] = {
-	0,1,0,1,2,1, 0,0,
-	2,3,3,2,3,0,
-};
-
-
 static void ChangeSignalStates(SetSignalsData *ssd)
 {
 	int i;
@@ -1695,6 +2033,14 @@
 	//   there is at least one green exit signal OR
 	//   there are no exit signals in the segment
 
+	if (_patches.auto_pbs_placement && !(ssd->stop) && (ssd->has_pbssignal == 15) && !ssd->has_presignal && (ssd->presignal_exits == 0))
+	for(i=0; i!=ssd->pbs_cur; i++) {
+		TileIndex tile = ssd->pbs_tile[i];
+		_map3_hi[tile] &= ~0x0B;
+		_map3_hi[tile] |= 0x08;
+		MarkTileDirtyByTile(tile);
+	};
+
 	// then mark the signals in the segment accordingly
 	for(i=0; i!=ssd->cur; i++) {
 		TileIndex tile = ssd->tile[i];
@@ -1755,8 +2101,9 @@
 
 	for(;;) {
 		// go through one segment and update all signals pointing into that segment.
-		ssd.cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
+		ssd.cur = ssd.pbs_cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
 		ssd.has_presignal = false;
+		ssd.has_pbssignal = false;
 
 		FollowTrack(tile, 0xC000 | TRANSPORT_RAIL, direction, (TPFEnumProc*)SetSignalsEnumProc, SetSignalsAfterProc, &ssd);
 		ChangeSignalStates(&ssd);
@@ -1776,6 +2123,30 @@
 	return (bool)result;
 }
 
+bool PBSIsPbsSegment(uint tile, byte direction)
+{
+	SetSignalsData ssd;
+	bool result = false;
+	int i;
+
+	ssd.cur_stack = 0;
+	direction>>=1;
+
+	ssd.cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
+	ssd.has_presignal = false;
+
+	FollowTrack(tile, 0xC000 | TRANSPORT_RAIL, direction, (TPFEnumProc*)SetSignalsEnumProcPBS, SetSignalsAfterProc, &ssd);
+	for(i=0; i!=ssd.cur; i++) {
+		uint tile = ssd.tile[i];
+		byte bit = ssd.bit[i];
+		if (!PBSIsPbsSignal(tile, bit) && !PBSIsPbsSignal(tile, bit | 8))
+			return false;
+		result = true;
+	};
+	
+	return result;
+}
+
 void SetSignalsOnBothDir(TileIndex tile, byte track)
 {
 	static const byte _search_dir_1[6] = {1, 3, 1, 3, 5, 3};
@@ -1980,8 +2351,7 @@
 	if (IsTileDepotType(tile, TRANSPORT_RAIL))
 		ShowTrainDepotWindow(tile);
 	else if (IsRailWaypoint(_map5[tile]))
-		ShowRenameWaypointWindow(GetWaypointByTile(tile));
-
+		ShowWaypointStatsWindow(GetWaypointByTile(tile));
 }
 
 static void GetTileDesc_Track(TileIndex tile, TileDesc *td)
@@ -2065,6 +2435,8 @@
 	} else if (_fractcoords_enter[dir] == fract_coord) {
 		if (_enter_directions[dir] == v->direction) {
 			/* enter the depot */
+			if (v->next == NULL)
+				PBSClearTrack(v->tile, FIND_FIRST_BIT(v->u.rail.track));
 			v->u.rail.track = 0x80,
 			v->vehstatus |= VS_HIDDEN; /* hide it */
 			v->direction ^= 4;
Index: vehicle.c
===================================================================
--- vehicle.c	(revision 2490)
+++ vehicle.c	(working copy)
@@ -15,6 +15,8 @@
 #include "engine.h"
 #include "sound.h"
 #include "debug.h"
+#include "gui.h"
+#include "npf.h"
 #include "vehicle_gui.h"
 #include "depot.h"
 #include "station.h"
@@ -1636,6 +1638,114 @@
 	_current_player = OWNER_NONE;
 }
 
+int32 CmdCloneOrder(int x, int y, uint32 flags, uint32 veh1_veh2, uint32 mode);
+int32 CmdMoveRailVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+/*int32 BuildRailVehicle(int x, int y, uint32 flags, uint32 p1, bool build_both_dualheaded,Vehicle **return_vehicle);
+int32 BuildRoadVeh(int x, int y, uint32 flags, uint32 p1, bool build_both_dualheaded,Vehicle **return_vehicle);
+int32 BuildShip(int x, int y, uint32 flags, uint32 p1, bool build_both_dualheaded,Vehicle **return_vehicle);
+int32 BuildAircraft(int x, int y, uint32 flags, uint32 p1, bool build_both_dualheaded,Vehicle **return_vehicle);
+*/
+int32 CmdBuildRailVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+int32 CmdBuildRoadVeh(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+int32 CmdBuildShip(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+int32 CmdBuildAircraft(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+
+typedef int32 VehBuildProc(int x, int y, uint32 flags, uint32 p1, uint32 p2);
+
+static VehBuildProc * const _veh_build_proc_table[] = {
+	CmdBuildRailVehicle,
+	CmdBuildRoadVeh,
+	CmdBuildShip,
+	CmdBuildAircraft,
+};
+
+static VehicleID * _new_vehicle_id_proc_table[] = {
+	&_new_train_id,
+	&_new_roadveh_id,
+	&_new_ship_id,
+	&_new_aircraft_id,	
+};
+/*
+	clones a train
+	p1 is the original vehicle's index
+	p2: 1 = shared orders, else copied orders
+*/
+int32 CmdCloneVehicle(int x, int y, uint32 flags, uint32 p1, uint32 p2)
+{
+	Vehicle *vfront, *v;
+	Vehicle *wfront, *w1, *w2;
+	int cost, total_cost;
+	VehBuildProc *proc;
+	VehicleID *new_id;
+
+	if (!IsVehicleIndex(p1))
+		return CMD_ERROR;
+	
+	wfront = w1 = vfront = v = GetVehicle(p1);
+	
+	if (!CheckOwnership(v->owner))
+		return CMD_ERROR;
+	
+	if (v->type == VEH_Train && v->subtype != TS_Front_Engine) return CMD_ERROR;
+	
+	//no need to check if it is a depot since the build command do that
+	
+	proc = _veh_build_proc_table[v->type - VEH_Train];
+	new_id = _new_vehicle_id_proc_table[v->type - VEH_Train];
+	total_cost = proc(x, y, flags, v->engine_type, 1);
+	if (total_cost == CMD_ERROR)
+		return CMD_ERROR;
+
+	if (flags & DC_EXEC) {
+		wfront = w1 = GetVehicle(*new_id);
+		CmdCloneOrder(x, y, flags, (v->index << 16) | w1->index, p2 & 1 ? CO_SHARE : CO_COPY);
+		w1->cur_order_index = v->cur_order_index;
+		
+		if (wfront->cargo_type != v->cargo_type) {
+		//a refit is needed
+		if (wfront->type == VEH_Ship || wfront->type == VEH_Aircraft)
+			{
+			if (DoCommandByTile(wfront->tile, wfront->index, v->cargo_type, 0, v->type == VEH_Aircraft ? CMD_REFIT_AIRCRAFT : CMD_REFIT_SHIP) != CMD_ERROR)
+				DoCommandByTile(wfront->tile, wfront->index, v->cargo_type, DC_EXEC, v->type == VEH_Aircraft ? CMD_REFIT_AIRCRAFT : CMD_REFIT_SHIP);
+			}
+		}
+	}
+	if (v->type == VEH_Train) {
+		// now we handle the cars
+		v = v->next;
+		while (v != NULL) {
+			cost = proc(x, y, flags, v->engine_type, 1);
+			if (cost == CMD_ERROR)
+				return CMD_ERROR;
+			total_cost += cost;
+		
+			if (flags & DC_EXEC) {
+			// add this unit to the end of the train
+				w2 = GetVehicle(RailVehInfo(v->engine_type)->flags & RVI_WAGON ? _new_wagon_id : _new_train_id);
+				CmdMoveRailVehicle(x, y, flags, (w1->index << 16) | w2->index, 0);
+				//w2->spritenum = v->spritenum; // makes sure that multiheaded engines are facing the correct way
+				w1 = w2;
+			}
+			v = v->next;
+		}
+	}
+
+	if (flags & DC_EXEC && wfront->type == VEH_Train) {
+		_new_train_id = wfront->index;
+		v = vfront;
+		w1 = wfront;
+
+		while (w1 != NULL && v != NULL) {
+			w1->spritenum = v->spritenum; // makes sure that multiheaded engines are facing the correct way
+			w1 = w1->next;
+			v = v->next;
+		}
+	}
+
+	return total_cost;
+}
+
+
 /** Give a custom name to your vehicle
  * @param x,y unused
  * @param p1 vehicle ID to name
@@ -1916,8 +2026,9 @@
 	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,flags), SLE_UINT8, 2, 255),
 	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,days_since_order_progr), SLE_UINT16, 2, 255),
 
-	// reserve extra space in savegame here. (currently 13 bytes)
-	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 13, 2, 255),
+	SLE_CONDVARX(offsetof(Vehicle,u)+offsetof(VehicleRail,pbs_status), SLE_UINT8, 2, 255),
+	// reserve extra space in savegame here. (currently 12 bytes)
+	SLE_CONDARR(NullStruct,null,SLE_FILE_U8 | SLE_VAR_NULL, 12, 2, 255),
 
 	SLE_END()
 };
Index: vehicle.h
===================================================================
--- vehicle.h	(revision 2490)
+++ vehicle.h	(working copy)
@@ -28,6 +28,7 @@
 // 1 and 3 do not appear to be used
 typedef enum TrainSubtypes {
 	TS_Front_Engine = 0, // Leading engine of a train
+	TS_Artic_Part = 1,
 	TS_Not_First = 2,    // Wagon or additional engine
 	TS_Free_Car = 4,     // First in a wagon chain (in depot)
 } TrainSubtype;
@@ -57,6 +58,7 @@
 	uint8 cached_veh_length;  // length of this vehicle in units of 1/8 of normal length, cached because this can be set by a callback
 	// cached values, recalculated when the cargo on a train changes (in addition to the conditions above)
 	uint16 cached_weight;     // total weight of the consist.
+	uint32 cached_max_TE;     // max tractive effort of the consist
 	uint16 cached_veh_weight; // weight of the vehicle.
 
 	// NOSAVE: for wagon override - id of the first engine in train
@@ -68,6 +70,8 @@
 	byte railtype;
 
 	byte flags;
+
+	byte pbs_status;
 } VehicleRail;
 
 enum {
@@ -141,7 +145,7 @@
 
 struct Vehicle {
 	byte type;	// type, ie roadven,train,ship,aircraft,special
-	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)(Filled with values from EffectVehicles or TrainSubTypes)
+	byte subtype;     // subtype (Filled with values from EffectVehicles or TrainSubTypes)
 
 	VehicleID index;	// NOSAVE: Index in vehicle array
 
Index: misc.c
===================================================================
--- misc.c	(revision 2490)
+++ misc.c	(working copy)
@@ -547,6 +547,7 @@
 void TownsMonthlyLoop(void);
 void IndustryMonthlyLoop(void);
 void StationMonthlyLoop(void);
+void WaypointMonthlyLoop(void);
 
 void PlayersYearlyLoop(void);
 void TrainsYearlyLoop(void);
@@ -655,6 +656,7 @@
 		TownsMonthlyLoop();
 		IndustryMonthlyLoop();
 		StationMonthlyLoop();
+		WaypointMonthlyLoop();
 #ifdef ENABLE_NETWORK
 		if (_network_server)
 			NetworkServerMonthlyLoop();
Index: player_gui.c
===================================================================
--- player_gui.c	(revision 2490)
+++ player_gui.c	(working copy)
@@ -39,7 +39,7 @@
 		x = 215;
 		tbl = p->yearly_expenses + 2;
 		do {
-			if (year >= p->inaugurated_year) {
+			//if (year >= p->inaugurated_year) {
 				SetDParam(0, year + 1920);
 				DrawStringCenterUnderline(x-17, 15, STR_7010, 0);
 				sum = 0;
@@ -63,7 +63,7 @@
 
 				GfxFillRect(x - 75, 27 + 10*13, x, 27 + 10*13, 215);
 				x += 95;
-			}
+			//}
 			year++;
 			tbl--;
 		} while (--j != 0);
Index: economy.c
===================================================================
--- economy.c	(revision 2490)
+++ economy.c	(working copy)
@@ -1363,6 +1363,9 @@
 				unloading_time += v->cargo_count; /* TTDBUG: bug in original TTD */
 				profit += DeliverGoods(v->cargo_count, v->cargo_type, v->cargo_source, last_visited, v->cargo_days);
 				result |= 1;
+				ge->cargo_amount[STS_AMOUNT_IN].this_month += v->cargo_count;
+				if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 				v->cargo_count = 0;
 			} else if (u->current_order.flags & ( OF_UNLOAD | OF_TRANSFER) ) {
 				/* unload goods and let it wait at the station */
@@ -1376,6 +1379,9 @@
 
 				v_profit_total += v_profit;
 
+				ge->cargo_amount[STS_AMOUNT_TRANSFER].this_month += v->cargo_count;
+				if (ge->months_counted == 0) ge->months_counted = 1;
+				InvalidateWindow(WC_STATION_STATS, st->index);
 
 				unloading_time += v->cargo_count;
 				if ((t=ge->waiting_acceptance & 0xFFF) == 0) {
@@ -1406,14 +1412,21 @@
 
 		/* update stats */
 		ge->days_since_pickup = 0;
+		ge->last_vehicle_type = u->type;
+
+		// TODO: use max-speed of whole consist for trains
 		t = u->max_speed;
 		if (u->type == VEH_Road) t >>=1;
 		if (u->type == VEH_Train) t = u->u.rail.cached_max_speed;
 
+		
+		ge->last_vehicle_speed = t;
 		// if last speed is 0, we treat that as if no vehicle has ever visited the station.
 		ge->last_speed = t < 255 ? t : 255;
+		// TODO: use age of oldest wagon of this type
 		ge->last_age = _cur_year - v->build_year;
 
+
 		// If there's goods waiting at the station, and the vehicle
 		//  has capacity for it, load it on the vehicle.
 		if ((count=ge->waiting_acceptance & 0xFFF) != 0 &&
@@ -1444,6 +1457,11 @@
 			ge->waiting_acceptance -= cap;
 			v->profit_this_year -= feeder_profit_share;
 			ge->feeder_profit -= feeder_profit_share;
+
+			ge->cargo_amount[STS_AMOUNT_OUT].this_month += cap;
+			if (ge->months_counted == 0) ge->months_counted = 1;
+			InvalidateWindow(WC_STATION_STATS, st->index);
+
 			unloading_time += cap;
 			st->time_since_load = 0;
 
Index: ship_cmd.c
===================================================================
--- ship_cmd.c	(revision 2490)
+++ ship_cmd.c	(working copy)
@@ -454,6 +454,10 @@
 
 static void ShipArrivesAt(Vehicle *v, Station *st)
 {
+	st->vehicles[STS_VEH_SHIP].this_month++;
+	if (st->months_counted == 0) st->months_counted = 1;
+	InvalidateWindow(WC_STATION_STATS, st->index);
+
 	/* Check if station was ever visited before */
 	if (!(st->had_vehicle_of_type & HVOT_SHIP)) {
 		uint32 flags;
@@ -577,7 +581,7 @@
 
 		NPFFillWithOrderData(&fstd, v);
 
-		ftd = NPFRouteToStationOrTile(src_tile, trackdir, &fstd, TRANSPORT_WATER, v->owner);
+		ftd = NPFRouteToStationOrTile(src_tile, trackdir, &fstd, TRANSPORT_WATER, v->owner, PBS_MODE_NONE);
 
 		if (ftd.best_trackdir != 0xff)
 			/* If ftd.best_bird_dist is 0, we found our target and ftd.best_trackdir contains
Index: main_gui.c
===================================================================
--- main_gui.c	(revision 2490)
+++ main_gui.c	(working copy)
@@ -20,6 +20,7 @@
 #include "network.h"
 #include "signs.h"
 #include "waypoint.h"
+#include "station.h"
 
 #include "network_data.h"
 #include "network_client.h"
@@ -309,22 +310,22 @@
 
 static void MenuClickShowTrains(int index)
 {
-	ShowPlayerTrains(index, -1);
+	ShowPlayerTrains(index, INVALID_STATION);
 }
 
 static void MenuClickShowRoad(int index)
 {
-	ShowPlayerRoadVehicles(index, -1);
+	ShowPlayerRoadVehicles(index, INVALID_STATION);
 }
 
 static void MenuClickShowShips(int index)
 {
-	ShowPlayerShips(index, -1);
+	ShowPlayerShips(index, INVALID_STATION);
 }
 
 static void MenuClickShowAir(int index)
 {
-	ShowPlayerAircraft(index, -1);
+	ShowPlayerAircraft(index, INVALID_STATION);
 }
 
 static void MenuClickBuildRail(int index)
@@ -1897,10 +1898,10 @@
 		case WKC_F10:ShowOperatingProfitGraph(); break;
 		case WKC_F11: ShowCompanyLeagueTable(); break;
 		case WKC_F12: ShowBuildIndustryWindow(); break;
-		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, -1); break;
-		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, -1); break;
-		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, -1); break;
-		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, -1); break;
+		case WKC_SHIFT | WKC_F1: ShowPlayerTrains(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F2: ShowPlayerRoadVehicles(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F3: ShowPlayerShips(local, INVALID_STATION); break;
+		case WKC_SHIFT | WKC_F4: ShowPlayerAircraft(local, INVALID_STATION); break;
 		case WKC_SHIFT | WKC_F5: ToolbarZoomInClick(w); break;
 		case WKC_SHIFT | WKC_F6: ToolbarZoomOutClick(w); break;
 		case WKC_SHIFT | WKC_F7: ShowBuildRailToolbar(_last_built_railtype,-1); break;
Index: roadveh_gui.c
===================================================================
--- roadveh_gui.c	(revision 2490)
+++ roadveh_gui.c	(working copy)
@@ -57,7 +57,7 @@
 	y += 10;
 }
 
-static void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawRoadVehImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetRoadVehImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -226,6 +226,16 @@
 	w->caption_color = v->owner;
 }
 
+void CcCloneRoadVeh(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
+
+	if (!success) return;
+
+	v = GetVehicle(_new_roadveh_id);
+	ShowRoadVehViewWindow(v);
+}
+
 static void RoadVehViewWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -307,6 +317,12 @@
 		case 10: /* show details */
 			ShowRoadVehDetailsWindow(v);
 			break;
+		case 11: {
+			/* clone vehicle */
+			Vehicle *v;
+			v = GetVehicle(w->window_number);
+			DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, CcCloneRoadVeh, CMD_CLONE_VEHICLE | CMD_MSG(STR_9009_CAN_T_BUILD_ROAD_VEHICLE));
+			} break;
 		}
 	} break;
 
@@ -321,6 +337,18 @@
 		DeleteWindowById(WC_VEHICLE_ORDERS, w->window_number);
 		DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
 		break;
+
+	case WE_MOUSELOOP:
+		{
+			Vehicle *v;
+			uint32 h;
+			v = GetVehicle(w->window_number);
+			h = IsTileDepotType(v->tile, TRANSPORT_ROAD) && (v->vehstatus&VS_STOPPED) ? (1<< 7) : (1 << 11);
+			if (h != w->hidden_state) {
+				w->hidden_state = h;
+				SetWindowDirty(w);
+			}
+		}
 	}
 }
 
@@ -336,6 +364,7 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  50,  67, 0x2CB,    STR_9020_FORCE_VEHICLE_TO_TURN_AROUND },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B2,    STR_901D_SHOW_VEHICLE_S_ORDERS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B3,    STR_9021_SHOW_ROAD_VEHICLE_DETAILS },
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_NULL },
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 104, 103, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 104, 115, 0x0,      STR_NULL },
 { WIDGETS_END }
@@ -535,7 +564,7 @@
 
 	/* setup disabled buttons */
 	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7));
+		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 7) | (1 << 8));
 
 	/* determine amount of items for scroller */
 	num = 0;
@@ -649,6 +678,39 @@
 	}
 }
 
+/* Clone a road vehicle
+ * v is the vehicle to clone.
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	if (v->type != VEH_Road) {
+		// it's not a train, Do Nothing
+		return false;
+	}
+
+
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneRoadVeh,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
 static void RoadDepotWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -665,10 +727,40 @@
 		case 7:
 			ShowBuildRoadVehWindow(w->window_number);
 			break;
+			
+		case 8: /* clone button */
+			InvalidateWidget(w, 8);
+				TOGGLEBIT(w->click_state, 8);
+				
+				if (HASBIT(w->click_state, 8)) {
+					_place_clicked_vehicle = NULL;
+					SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, 1, w);
+				} else {
+					ResetObjectToPlace();
+				}
+					break;
+				
+			case 9: /* scroll to tile */
+				ScrollMainWindowToTile(w->window_number);
+					break;
+		}
+	} break;
+	
+		case WE_PLACE_OBJ: {
+		ClonePlaceObj(e->place.tile, w);
+	} break;
 
-		case 8: /* scroll to tile */
-			ScrollMainWindowToTile(w->window_number);
-			break;
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 8);
+		InvalidateWidget(w, 8);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+		if (v) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick( v, w);
 		}
 	} break;
 
@@ -738,8 +830,9 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   279,    14,    55, 0x305,												STR_9022_VEHICLES_CLICK_ON_VEHICLE},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   303,   314,    14,    55, 0x0,													STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   150,    56,    67, STR_9004_NEW_VEHICLES,				STR_9023_BUILD_NEW_ROAD_VEHICLE},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   151,   302,    56,    67, STR_00E4_LOCATION,						STR_9025_CENTER_MAIN_VIEW_ON_ROAD},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   100,    56,    67, STR_9004_NEW_VEHICLES,				STR_9023_BUILD_NEW_ROAD_VEHICLE},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,   101,   200,    56,    67, STR_8815_NEW_VEHICLES,		STR_NULL},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   201,   302,    56,    67, STR_00E4_LOCATION,						STR_9025_CENTER_MAIN_VIEW_ON_ROAD},
 {      WWT_PANEL,    RESIZE_RTB,    14,   303,   302,    56,    67, 0x0,													STR_NULL},
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   303,   314,    56,    67, 0x0,													STR_RESIZE_BUTTON},
 {   WIDGETS_END},
@@ -815,7 +908,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Road, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1007,6 +1100,13 @@
 		w = AllocateWindowDescFront(&_other_player_roadveh_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Road;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = player;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: Makefile
===================================================================
--- Makefile	(revision 2490)
+++ Makefile	(working copy)
@@ -650,6 +650,7 @@
 C_SOURCES += order_cmd.c
 C_SOURCES += order_gui.c
 C_SOURCES += pathfind.c
+C_SOURCES += pbs.c
 C_SOURCES += player_gui.c
 C_SOURCES += players.c
 C_SOURCES += pool.c
Index: order_cmd.c
===================================================================
--- order_cmd.c	(revision 2490)
+++ order_cmd.c	(working copy)
@@ -348,6 +348,25 @@
 			/* Increase amount of orders */
 			u->num_orders++;
 
+			// count vehicles scheduled for station
+			if (new_order.type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(new_order.station)->veh_scheduled++;
+			} else {
+				Station *st = GetStation(new_order.station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]++;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]++;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]++;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]++;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]++;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]++;
+						break;
+				}
+			}
+
 			/* If the orderlist was empty, assign it */
 			if (u->orders == NULL) u->orders = v->orders;
 
@@ -429,12 +448,25 @@
 			GetVehicleOrder(v, sel_ord - 1)->next = order->next;
 		}
 
-		/* Give the item free */
-		order->type = OT_NOTHING;
-		order->next = NULL;
-
 		u = GetFirstVehicleFromSharedList(v);
 		while (u != NULL) {
+			if (order->type == OT_GOTO_WAYPOINT) {
+				GetWaypoint(order->station)->veh_scheduled--;
+			} else {
+				Station *st = GetStation(order->station);
+				switch (u->type)
+				{
+					case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+					case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+					case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+					case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+						if (u->cargo_type == CT_PASSENGERS)
+							st->veh_scheduled[STS_VEH_BUS]--;
+						else
+							st->veh_scheduled[STS_VEH_TRUCK]--;
+						break;
+				}
+			}
 			u->num_orders--;
 
 			if (sel_ord < u->cur_order_index)
@@ -459,6 +491,10 @@
 			u = u->next_shared;
 		}
 
+		/* Give the item free */
+		order->type = OT_NOTHING;
+		order->next = NULL;
+
 		RebuildVehicleLists();
 	}
 
@@ -1033,6 +1069,24 @@
 
 	order = NULL;
 	while (cur != NULL) {
+		// decrease vehicles scheduled for station
+		if (cur->type == OT_GOTO_WAYPOINT) {
+			GetWaypoint(cur->station)->veh_scheduled--;
+		} else {
+			Station *st = GetStation(cur->station);
+			switch (v->type)
+			{
+				case VEH_Train:		st->veh_scheduled[STS_VEH_TRAIN]--;	break;
+				case VEH_Ship:		st->veh_scheduled[STS_VEH_SHIP]--;	break;
+				case VEH_Aircraft:	st->veh_scheduled[STS_VEH_AIRCRAFT]--;	break;
+				case VEH_Road:		st->veh_scheduled[STS_VEH_ROAD]--;
+					if (v->cargo_type == CT_PASSENGERS)
+						st->veh_scheduled[STS_VEH_BUS]--;
+					else
+						st->veh_scheduled[STS_VEH_TRUCK]--;
+					break;
+			}
+		}
 		if (order != NULL) {
 			order->type = OT_NOTHING;
 			order->next = NULL;
Index: openttd.vcproj
===================================================================
--- openttd.vcproj	(revision 2490)
+++ openttd.vcproj	(working copy)
@@ -361,6 +361,9 @@
 				RelativePath=".\aystar.h">
 			</File>
 			<File
+				RelativePath=".\cargo.h">
+			</File>
+			<File
 				RelativePath="command.h">
 			</File>
 			<File
Index: settings.c
===================================================================
--- settings.c	(revision 2490)
+++ settings.c	(working copy)
@@ -845,12 +845,18 @@
 // Non-static, needed in network_server.c
 const SettingDesc patch_settings[] = {
 	{"build_on_slopes",			SDT_BOOL,		(void*)true,	&_patches.build_on_slopes,			NULL},
+	{"auto_pbs_placement",	SDT_BOOL,		(void*)true,	&_patches.auto_pbs_placement,		NULL},
 	{"mammoth_trains",			SDT_BOOL,		(void*)true,	&_patches.mammoth_trains,				NULL},
 	{"join_stations",				SDT_BOOL,		(void*)true,	&_patches.join_stations,				NULL},
 	{"station_spread",			SDT_UINT8,	(void*)12,		&_patches.station_spread,				NULL},
 	{"full_load_any",				SDT_BOOL,		(void*)true,	&_patches.full_load_any,				NULL},
 	{"modified_catchment", 	SDT_BOOL,		(void*)true,	&_patches.modified_catchment,		NULL},
 
+	{"nsr_speed",	SDT_BOOL,	(void*)true,	&_patches.nsr_speed,	NULL},
+	{"nsr_age",	SDT_BOOL,	(void*)true,	&_patches.nsr_age,	NULL},
+	{"nsr_wait_days",	SDT_BOOL,	(void*)true,	&_patches.nsr_wait_days,	NULL},
+	{"nsr_wait_cargo",	SDT_BOOL,	(void*)true,	&_patches.nsr_wait_cargo,	NULL},
+	{"nsr_town_rating",	SDT_BOOL,	(void*)true,	&_patches.nsr_town_rating,	NULL},
 
 	{"inflation",						SDT_BOOL,		(void*)true,	&_patches.inflation,						NULL},
 	{"selectgoods",					SDT_BOOL,		(void*)true,	&_patches.selectgoods,					NULL},
@@ -874,6 +880,7 @@
 	{"nonuniform_stations",	SDT_BOOL,		(void*)true,	&_patches.nonuniform_stations,	NULL},
 	{"always_small_airport",SDT_BOOL,		(void*)false,	&_patches.always_small_airport,	NULL},
 	{"realistic_acceleration",SDT_BOOL, (void*)false,	&_patches.realistic_acceleration,	NULL},
+	{"wagon_speed_limits",	SDT_BOOL,		(void*)false,	&_patches.wagon_speed_limits,		NULL},
 	{"forbid_90_deg",				SDT_BOOL, 	(void*)false, &_patches.forbid_90_deg,					NULL},
 	{"improved_load",				SDT_BOOL,		(void*)false,	&_patches.improved_load,				NULL},
 
Index: callback_table.c
===================================================================
--- callback_table.c	(revision 2490)
+++ callback_table.c	(working copy)
@@ -8,6 +8,7 @@
 
 /* aircraft_gui.c */
 CommandCallback CcBuildAircraft;
+CommandCallback CcCloneAircraft;
 
 /* airport_gui.c */
 CommandCallback CcBuildAirport;
@@ -39,13 +40,16 @@
 
 /* roadveh_gui.c */
 CommandCallback CcBuildRoadVeh;
+CommandCallback CcCloneRoadVeh;
 
 /* ship_gui.c */
 CommandCallback CcBuildShip;
+CommandCallback CcCloneShip;
 
 /* train_gui.c */
 CommandCallback CcBuildWagon;
 CommandCallback CcBuildLoco;
+CommandCallback CcCloneTrain;
 
 CommandCallback *_callback_table[] = {
 	/* 0x00 */ NULL,
@@ -68,7 +72,11 @@
 	/* 0x11 */ CcPlaySound1D,
 	/* 0x12 */ CcPlaySound1E,
 	/* 0x13 */ CcStation,
-	/* 0x14 */ CcTerraform
+	/* 0x14 */ CcTerraform,
+	/* 0x15 */ CcCloneAircraft,
+	/* 0x16 */ CcCloneRoadVeh,
+	/* 0x17 */ CcCloneShip,
+	/* 0x18 */ CcCloneTrain,
 };
 
 const int _callback_table_count = lengthof(_callback_table);
Index: waypoint.c
===================================================================
--- waypoint.c	(revision 2490)
+++ waypoint.c	(working copy)
@@ -13,6 +13,7 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 #include "table/track_land.h"
+#include "gui.h"
 
 enum {
 	/* Max waypoints: 64000 (8 * 8000) */
@@ -42,7 +43,7 @@
 	Waypoint *wp;
 
 	FOR_ALL_WAYPOINTS(wp) {
-		if (wp->xy == 0) {
+		if (wp->xy == INVALID_TILE) {
 			uint index = wp->index;
 
 			memset(wp, 0, sizeof(Waypoint));
@@ -201,6 +202,7 @@
 		wp->deleted = 0;
 		wp->xy = tile;
 		wp->build_date = _date;
+		InitializeWaypointStats(wp);
 
 		if (wp->town_index == STR_NULL)
 			MakeDefaultWaypointName(wp);
@@ -440,18 +442,33 @@
 	SLE_CONDVAR(Waypoint, build_date, SLE_UINT16, 3, 255),
 	SLE_CONDVAR(Waypoint, stat_id, SLE_UINT8, 3, 255),
 
+//	SLE_CONDVAR(Waypoint,months_counted,	SLE_UINT16, 15, 255),
+
 	SLE_END()
 };
 
+static const SaveLoad _stats_desc[] = {
+	SLE_CONDVAR(StationStats,this_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,last_month,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_min,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,month_max,	SLE_UINT16, 15, 255),
+	SLE_CONDVAR(StationStats,average,	SLE_UINT32, 15, 255),
+	SLE_END()
+};
+
 static void Save_WAYP(void)
 {
 	Waypoint *wp;
+//	int i;
 
 	FOR_ALL_WAYPOINTS(wp) {
 		if (wp->xy != 0) {
 			SlSetArrayIndex(wp->index);
 			SlObject(wp, _waypoint_desc);
 		}
+//		for (i = 0; i < STS_VEH_TYPES; i++) 
+//			SlObject(&wp->vehicles[i], _stats_desc);
+
 	}
 }
 
@@ -467,9 +484,225 @@
 
 		wp = GetWaypoint(index);
 		SlObject(wp, _waypoint_desc);
+		InitializeWaypointStats(wp);
 	}
 }
 
 const ChunkHandler _waypoint_chunk_handlers[] = {
 	{ 'CHKP', Save_WAYP, Load_WAYP, CH_ARRAY | CH_LAST},
 };
+
+void WaypointMonthlyLoop(void)
+{
+	Waypoint *wp;
+	StationStats *sts;
+	int i;
+
+ 	FOR_ALL_WAYPOINTS(wp) {
+		// if we have stats for this station the number of counted months is >0
+		if (wp->months_counted > 0)
+		{
+			// update vehicle-counts and min/max
+			for (i = WPS_MONTHLY_STATS_START; i < WPS_MONTHLY_STATS_END; i++) {
+				sts = &wp->vehicles[i];
+				sts->month_min = min(sts->month_min, sts->this_month);
+				sts->month_max = max(sts->month_max, sts->this_month);
+				sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, wp->months_counted);
+				sts->last_month = sts->this_month;
+				sts->this_month = 0;
+			}
+			if (wp->months_counted == (wp->months_counted / 12) * 12)
+			{ // do this once a year to have yearly stats
+				for (i = WPS_YEARLY_STATS_START; i < WPS_YEARLY_STATS_END; i++) {
+					sts = &wp->vehicles[i];
+					sts->month_min = min(sts->month_min, sts->this_month);
+					sts->month_max = max(sts->month_max, sts->this_month);
+					sts->average = CalcNewAverage(sts->average, sts->this_month * AVERAGE_MULTIPLIER, wp->months_counted / 12);
+					sts->last_month = sts->this_month;
+					sts->this_month = 0;
+				}
+			}
+			wp->months_counted++; // one more month counted
+		}
+		InvalidateWindow(WC_STATION_STATS, wp->index);
+	}
+}
+
+void SearchVehiclesForWaypoint(Waypoint *wp)
+{
+	Vehicle *v;
+	Order* ord = NULL;
+
+	if (wp->xy == 0) return;
+	wp->veh_scheduled = 0;
+	
+	FOR_ALL_VEHICLES(v) {
+		//Now run this stuff for sane vehicles only
+		if ( (v->num_orders != 0) && (v->owner == GetTileOwner(wp->xy)) &&
+			( (v->type == VEH_Train) && (v->subtype == TS_Front_Engine) ) ) //Trains (first engine, that contains the orders)
+		{
+			ord = v->orders;
+			while(ord != NULL) {
+				if (ord->station == wp->index && ord->type == OT_GOTO_WAYPOINT) {
+					wp->veh_scheduled++;
+					break;
+				}
+				ord = ord->next;
+			}
+		}
+	} 
+}
+
+void InitializeWaypointStats(Waypoint *wp)
+{
+	StationStats *sts;
+
+	wp->months_counted = 0;
+	for (sts = wp->vehicles; sts != endof(wp->vehicles); sts++) {
+		sts->last_month = 0;
+		sts->this_month = 0;
+		sts->month_min = 65535;
+		sts->month_max = 0;
+		sts->average = 0;
+	}
+	SearchVehiclesForWaypoint(wp);
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e);
+
+Widget _waypoint_stats_widgets[] = {
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5, STR_018B_CLOSE_WINDOW},
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   288,     0,    13, STR_WAYPOINT_VIEWPORT, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,   RESIZE_NONE,    14,   289,   300,     0,    13, 0x0,         STR_STICKY_BUTTON},
+{      WWT_EMPTY,   RESIZE_NONE,     0,     0,     0,     0,     0, 0x0, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   150,    14,    25, STR_RESET_STATISTICS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   151,   300,    14,    25, STR_TRAINS, 0x0},
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   300,    26,    37, STR_STS_TOGGLE_MONTH_YEAR, 0x0},
+{     WWT_IMGBTN,   RESIZE_NONE,    14,     0,   300,    38,   140, 0x0, 0x0},
+{      WIDGETS_END},
+};
+
+WindowDesc _waypoint_view_stats = {
+	-1, -1, 301, 141,
+	WC_WAYPOINT_STATS, 0,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON,
+	_waypoint_stats_widgets,
+	WaypointStatsWndProc
+};
+
+void DrawWaypointStatWindow(Window *w, Waypoint *wp)
+{
+	int i, j;
+	enum {
+		STAT_LINE_START = 40,
+		STAT_LINE_PREVIOUS = 60,
+		STAT_LINE_THIS = 72,
+		STAT_LINE_AVERAGE = 90,
+		STAT_LINE_MIN = 102,
+		STAT_LINE_MAX = 114,
+		STAT_LINE_COUNTED = 130,
+		STAT_COLUMN_TEXT = 10,
+		STAT_COLUMN_SCHEDULED = 170,
+		STAT_COLUMN_NOT_SCHEDULED = 290,
+		COL_DIF = STAT_COLUMN_NOT_SCHEDULED - STAT_COLUMN_SCHEDULED
+	};
+
+	//Get the Station name
+	SetDParam(0, wp->index);
+	//First draw the widgets
+	DrawWindowWidgets(w);
+
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_START,	STR_SCHEDULED, 0);
+	if (_show_yearly_stats) {
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_PREVIOUS,	STR_STS_VEHICLES_LAST_YEAR, 0);
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_THIS,	STR_STS_VEHICLES_THIS_YEAR, 0);
+		SetDParam(0, max((wp->months_counted - 1) / 12 ,0));
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_COUNTED,	STR_STS_YEARS_COUNTED_NUM, 0);
+	} else {
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_PREVIOUS,	STR_VEHICLES_MONTH, 0);
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_THIS,	STR_VEHICLES_CURRENT, 0);
+		SetDParam(0, max(wp->months_counted - 1,0));
+		DrawString(STAT_COLUMN_TEXT, STAT_LINE_COUNTED,	STR_MONTHS_COUNTED_NUM, 0);
+	}
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_AVERAGE,	STR_AVERAGE, 0);
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_MIN,	STR_MINIMUM, 0);
+	DrawString(STAT_COLUMN_TEXT, STAT_LINE_MAX,	STR_MAXIMUM, 0);
+
+	SetDParam(0, wp->veh_scheduled);
+	DrawStringRightAligned(STAT_COLUMN_SCHEDULED, STAT_LINE_START, STR_NUMBER, 0);
+	DrawStringRightAligned(STAT_COLUMN_NOT_SCHEDULED, STAT_LINE_START, STR_STS_NOT_SCHEDULED, 0);
+	if (wp->veh_scheduled != 0) {
+		CLRBIT(w->disabled_state, 5);
+	} else {
+		SETBIT(w->disabled_state, 5);
+	}
+
+	j = _show_yearly_stats ? WPS_YEARLY_STATS_START : WPS_MONTHLY_STATS_START;
+	for (i = 0; i < WPS_STATS_TYPES / 2; i++)
+	{
+		SetDParam(0, wp->vehicles[i+j].last_month);
+		DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_PREVIOUS, STR_NUMBER, 0);
+		SetDParam(0, wp->vehicles[i+j].this_month);
+		DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_THIS, STR_WHITE_NUMBER, 0);
+
+		if (wp->months_counted > (_show_yearly_stats ? 12 : 1)) {
+			SetDParam(0, wp->vehicles[i+j].average / AVERAGE_MULTIPLIER);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_AVERAGE, STR_SILVER_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_min);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_MIN, STR_ORANGE_NUMBER, 0);
+			SetDParam(0, wp->vehicles[i+j].month_max);
+			DrawStringRightAligned(STAT_COLUMN_SCHEDULED + i * COL_DIF, STAT_LINE_MAX, STR_LTBLUE_NUMBER, 0);
+		}
+	}
+}
+
+void WaypointStatsWndProc(Window *w, WindowEvent *e)
+{
+	Waypoint *wp = GetWaypoint(w->window_number);
+	switch(e->event)
+	{
+		case WE_TICK: {
+			w->custom[0] = wp->veh_scheduled;
+			InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+			break;
+		}
+		case WE_PAINT: {
+			DrawWaypointStatWindow(w, wp);
+			break;
+			}
+		case WE_CLICK: {
+			switch (e->click.widget)
+			{
+				case 4:	// Reset Statistics
+					if (GetTileOwner(wp->xy) == _current_player) {
+						InitializeWaypointStats(wp);
+						InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+					}
+					break;
+				case 5:	// Show Trains
+					ShowWaypointTrains(GetTileOwner(wp->xy), wp->index, CARGO_MASK_ALL);
+					break;
+				case 6:	// Toggle Monthly/Yearly Stats
+				_show_yearly_stats ^= 1;
+				InvalidateWindow(WC_WAYPOINT_STATS, w->window_number);
+				break;
+			}
+		} break;
+		case WE_DESTROY: {
+			DeleteWindowById(WC_TRAINS_LIST, GetTileOwner(wp->xy) + ( (wp->index + 1) << 8));
+		} break;
+	}
+}
+
+void ShowWaypointStatsWindow(Waypoint *wp)
+{
+	Window *w;
+	byte color;
+
+	w = AllocateWindowDescFront(&_waypoint_view_stats, wp->index);
+	if (w) {
+		color = GetTileOwner(wp->xy);
+		if (color != 0x10)
+			w->caption_color = color;
+	}
+}
Index: waypoint.h
===================================================================
--- waypoint.h	(revision 2490)
+++ waypoint.h	(working copy)
@@ -2,7 +2,23 @@
 #define WAYPOINT_H
 
 #include "pool.h"
+#include "station.h"
 
+enum {
+	WPS_STATS_TYPES = 4,
+
+	WPS_MONTHLY_STATS_START = 0,
+	WPS_MONTHLY_STATS_END = 2,
+
+	WPS_YEARLY_STATS_START = 2,
+	WPS_YEARLY_STATS_END = 4,
+
+	WPS_ORDER_MONTH = 0, // reached WP by order
+	WPS_PATHFIND_MONTH = 1, // reached WP by normal pathfinding
+	WPS_ORDER_YEAR = 2, // yearly stats by order
+	WPS_PATHFIND_YEAR =3 , // yearly stats by pathfinding
+};
+
 struct Waypoint {
 	TileIndex xy;
 	uint16 index;
@@ -11,12 +27,20 @@
 	byte town_cn;          // The Nth waypoint for this town (consecutive number)
 	StringID string;       // If this is zero, town + town_cn is used for naming
 
+	StationStats vehicles[WPS_STATS_TYPES];
+	uint16 veh_scheduled;
+	uint16 months_counted;
+
 	ViewportSign sign;
 	uint16 build_date;
 	byte stat_id;
 	byte deleted;          // this is a delete counter. when it reaches 0, the waypoint struct is deleted.
 };
 
+void InitializeWaypointStats(Waypoint *wp);
+void ShowWaypointStatsWindow(Waypoint *wp);
+void ShowWaypointTrains(int player, int waypoint, uint32 cargomask);
+
 enum {
 	RAIL_TYPE_WAYPOINT = 0xC4,
 	RAIL_WAYPOINT_TRACK_MASK = 1,
Index: train_gui.c
===================================================================
--- train_gui.c	(revision 2490)
+++ train_gui.c	(working copy)
@@ -15,6 +15,7 @@
 #include "engine.h"
 #include "vehicle_gui.h"
 #include "depot.h"
+#include "waypoint.h"
 
 int _traininfo_vehicle_pitch = 0;
 
@@ -77,6 +78,7 @@
 	SetDParam(0, e->reliability * 100 >> 16);
 	DrawString(x,y, STR_PURCHASE_INFO_RELIABILITY, 0);
 	y += 10;
+
 }
 
 /**
@@ -106,6 +108,13 @@
 	SetDParam(2, refittable ? STR_9842_REFITTABLE : STR_EMPTY);
 	DrawString(x, y, STR_PURCHASE_INFO_CAPACITY, 0);
 	y += 10;
+
+	/* Max speed */
+	if (rvi->max_speed != 0 && _patches.wagon_speed_limits) {
+		SetDParam(0, rvi->max_speed * 10 >> 4);
+		DrawString(x,y, STR_PURCHASE_INFO_SPEED, 0);
+		y += 10;
+	}
 }
 
 void CcBuildWagon(bool success, TileIndex tile, uint32 p1, uint32 p2)
@@ -151,6 +160,17 @@
 	ShowTrainViewWindow(v);
 }
 
+void CcCloneTrain(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
+
+	if (!success)
+		return;
+
+	v = GetVehicle(_new_train_id);
+	ShowTrainViewWindow(v);
+}
+
 static void engine_drawing_loop(int *x, int *y, int *pos, int *sel,
 	int *selected_id, byte railtype, byte show_max, bool is_engine)
 {
@@ -327,7 +347,7 @@
 	}
 }
 
-static void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection)
+void DrawTrainImage(const Vehicle *v, int x, int y, int count, int skip, VehicleID selection)
 {
 	int max_x = x + count * 29;
 
@@ -363,7 +383,7 @@
 
 	/* setup disabled buttons */
 	w->disabled_state =
-		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 5) | (1 << 8));
+		IsTileOwner(tile, _local_player) ? 0 : ((1 << 4) | (1 << 5) | (1 << 8) | (1 << 9));
 
 	/* determine amount of items for scroller */
 	num = 0;
@@ -584,6 +604,46 @@
 	}
 }
 
+/* Clone a train
+ * v is the train to clone.
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	// for train vehicles: subtype 0 for locs and not zero for others
+	if (v->type == VEH_Train && v->subtype != 0) {
+		v = GetFirstVehicleInChain(v);
+		if (v->subtype != 0) // This happens when clicking on a train in depot with no loc attached
+			return false;
+	}else{
+		if (v->type != VEH_Train) {
+			// it's not a train, Do Nothing
+			return false;
+		}
+	}
+
+	//DoCommand(window, train head to clone, p2, CallBackUnit, CMD_ Stuff)
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneTrain,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
 static void TrainDepotWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -596,15 +656,46 @@
 		case 8:
 			ShowBuildTrainWindow(w->window_number);
 			break;
-		case 9:
+		case 10:
 			ScrollMainWindowToTile(w->window_number);
 			break;
 		case 6:
 			TrainDepotClickTrain(w, e->click.pt.x, e->click.pt.y);
 			break;
+		case 9: /* clone button */
+			InvalidateWidget(w, 9);
+			TOGGLEBIT(w->click_state, 9);
+
+			if (HASBIT(w->click_state, 9)) {
+				_place_clicked_vehicle = NULL;
+				SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, 1, w);
+			} else {
+				ResetObjectToPlace();
+			}
+			break;
+
+ 		}
+ 	} break;
+ 
+	case WE_PLACE_OBJ: {
+		ClonePlaceObj(e->place.tile, w);
+	} break;
+
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 9);
+		InvalidateWidget(w, 9);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+		if (v) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick( v, w);
 		}
 	} break;
 
+
 	case WE_DESTROY:
 		DeleteWindowById(WC_BUILD_VEHICLE, w->window_number);
 		break;
@@ -684,10 +775,14 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   325,    14,    97, 0x601,									STR_883F_TRAINS_CLICK_ON_TRAIN_FOR},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   349,   360,    14,   109, 0x0,										STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   167,   110,   121, STR_8815_NEW_VEHICLES,	STR_8840_BUILD_NEW_TRAIN_VEHICLE},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   168,   348,   110,   121, STR_00E4_LOCATION,			STR_8842_CENTER_MAIN_VIEW_ON_TRAIN},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   116,   110,   121, STR_8815_NEW_VEHICLES,	STR_8840_BUILD_NEW_TRAIN_VEHICLE},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,   117,   232,   110,   121, STR_8815_NEW_VEHICLES,		STR_NULL},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   233,   348,   110,   121, STR_00E4_LOCATION,			STR_8842_CENTER_MAIN_VIEW_ON_TRAIN},
+
+
 { WWT_HSCROLLBAR,    RESIZE_RTB,    14,     0,   325,    98,   109, 0x0,										STR_HSCROLL_BAR_SCROLLS_LIST},
 {      WWT_PANEL,    RESIZE_RTB,    14,   349,   348,   110,   121, 0x0,										STR_NULL},
+
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   349,   360,   110,   121, 0x0,										STR_RESIZE_BUTTON},
 {   WIDGETS_END},
 };
@@ -807,6 +902,7 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B2,    STR_8847_SHOW_TRAIN_S_ORDERS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249, 104, 121, 0x2B3,    STR_884C_SHOW_TRAIN_DETAILS },
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B4,    STR_RAIL_REFIT_VEHICLE_TO_CARRY },
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_NULL },
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 122, 121, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 122, 133, 0x0,      STR_NULL },
 { WIDGETS_END }
@@ -927,6 +1023,9 @@
 		case 12:
 			ShowRailVehicleRefitWindow(v);
 			break;
+		case 13:
+			DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, NULL, CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+			break;
 		}
 	} break;
 
@@ -949,7 +1048,7 @@
 
 		v = GetVehicle(w->window_number);
 		assert(v->type == VEH_Train);
-		h = CheckTrainStoppedInDepot(v) >= 0 ? (1 << 9) : (1 << 12);
+		h = CheckTrainStoppedInDepot(v) >= 0 ? (1 << 9)| (1 << 7) : (1 << 12) | (1 << 13);
 		if (h != w->hidden_state) {
 			w->hidden_state = h;
 			SetWindowDirty(w);
@@ -1294,7 +1393,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Train, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1490,6 +1589,13 @@
 		w = AllocateWindowDescFront(&_other_player_trains_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Train;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = player;
 		w->hscroll.cap = 10;
 		w->vscroll.cap = 7; // maximum number of vehicles shown
@@ -1499,3 +1605,27 @@
 		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
 	}
 }
+
+void ShowWaypointTrains(int player, int waypoint, uint32 cargomask)
+{
+	Window *w;
+
+	if (player == _local_player) {
+		w = AllocateWindowDescFront(&_player_trains_desc, (waypoint << 16) | player);
+	} else {
+		w = AllocateWindowDescFront(&_other_player_trains_desc, (waypoint << 16) | player);
+	}
+	if (w) {
+		w->listopt.cargo_mask = cargomask;
+		w->listopt.type_mask = 1 << VEH_Train;
+		w->listopt.xy = GetWaypoint(waypoint)->xy;
+
+		w->caption_color = player;
+		w->hscroll.cap = 10;
+		w->vscroll.cap = 7; // maximum number of vehicles shown
+		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
+		w->resize.step_height = PLY_WND_PRC__SIZE_OF_ROW_SMALL;
+		w->resize.step_width = 29;
+		w->resize.height = 220 - (PLY_WND_PRC__SIZE_OF_ROW_SMALL * 3); /* Minimum of 4 vehicles */
+	}
+}
Index: station.h
===================================================================
--- station.h	(revision 2490)
+++ station.h	(working copy)
@@ -6,6 +6,38 @@
 #include "tile.h"
 #include "vehicle.h"
 
+enum {
+	STS_AMOUNT_IN = 0,
+	STS_AMOUNT_OUT = 1,
+	STS_AMOUNT_TRANSFER = 2,
+	STS_VEH_TRAIN = 0,
+	STS_VEH_ROAD = 1,
+	STS_VEH_BUS = 2,
+	STS_VEH_TRUCK = 3,
+	STS_VEH_SHIP = 4,
+	STS_VEH_AIRCRAFT = 5,
+	STS_VEH_TYPES = 6,
+	STS_AMNT_TYPES = 3,
+	AVERAGE_MULTIPLIER = 10000, // controls how much digits behind comma are stored for average
+};
+enum {
+	RATING_WAITING = 0,
+	RATING_SPEED = 1,
+	RATING_AGE = 2,
+	RATING_PICKUP = 3,
+	RATING_OTHER = 4,
+	RATING_TOTAL = 5,
+	NUM_RATINGS = 6,
+};
+
+typedef struct StationStats {
+	uint16 this_month;
+	uint16 last_month;
+	uint16 month_min;
+	uint16 month_max;
+	uint32 average;
+} StationStats;
+
 typedef struct GoodsEntry {
 	uint16 waiting_acceptance;
 	byte days_since_pickup;
@@ -14,7 +46,12 @@
 	byte enroute_time;
 	byte last_speed;
 	byte last_age;
+
+	StationStats cargo_amount[STS_AMNT_TYPES];
+	uint16 months_counted;
 	int32 feeder_profit;
+	int last_vehicle_type;
+	uint16 last_vehicle_speed;
 } GoodsEntry;
 
 typedef enum RoadStopType {
@@ -23,10 +60,13 @@
 } RoadStopType;
 
 enum {
-	INVALID_STATION = 0xFFFF,
-	INVALID_SLOT = 0xFFFF,
-	NUM_SLOTS = 2,
-	ROAD_STOP_LIMIT = 8,
+	INVALID_STATION    = 0xFFFF,
+	INVALID_SLOT       = 0xFFFF,
+	INVALID_AGE        = 0xFF,
+	INVALID_TIME       = 0xFF,
+	NUM_SLOTS          = 2,
+	ROAD_STOP_LIMIT    = 8,
+	RATING_START_VALUE = 175,
 };
 
 typedef uint16 StationID;
@@ -43,6 +83,14 @@
 	struct RoadStop *prev;
 } RoadStop;
 
+typedef struct RatingStats {
+	uint16 last_speed;
+	byte last_age;
+	byte days_since_pickup;
+	uint16 waiting;
+	int16 ratings[NUM_RATINGS];
+} RatingStats;
+
 struct Station {
 	TileIndex xy;
 	RoadStop *bus_stops;
@@ -77,7 +125,12 @@
 
 	VehicleID last_vehicle;
 	GoodsEntry goods[NUM_CARGO];
+	RatingStats rating_stats[NUM_CARGO];
 
+	StationStats vehicles[STS_VEH_TYPES];
+	uint16 veh_scheduled[STS_VEH_TYPES];
+	uint16 months_counted;
+
 	/* Stuff that is no longer used, but needed for conversion */
 	TileIndex bus_tile_obsolete;
 	TileIndex lorry_tile_obsolete;
@@ -122,9 +175,16 @@
 
 void ModifyStationRatingAround(TileIndex tile, byte owner, int amount, uint radius);
 
+void SearchVehiclesForStation(Station *st);
+void ShowStationStatsWindow(int station);
+void InitializeStationStats(Station *st);
+uint32 CalcNewAverage(uint32 average, uint32 lastamount, uint16 times_counted);
+void ShowPlayerVehicles(int player, int station, uint32 type_mask, uint32 cargo_mask, TileIndex xy);
+
 TileIndex GetStationTileForVehicle(const Vehicle *v, const Station *st);
 
 void ShowStationViewWindow(int station);
+void ShowStationRatingDetail(int station);
 void UpdateAllStationVirtCoord(void);
 
 VARDEF SortStruct *_station_sort;
@@ -321,4 +381,6 @@
 	return (_map5[tile] - 0x43) & 3;
 }
 
+int32 ClickResetStationCheat(int32 cheat_activated, int32 NOT_USED);
+
 #endif /* STATION_H */
Index: rail_gui.c
===================================================================
--- rail_gui.c	(revision 2490)
+++ rail_gui.c	(working copy)
@@ -20,7 +20,18 @@
 static byte _build_depot_direction;
 static byte _waypoint_count=1;
 static byte _cur_waypoint_type;
+static byte _cur_signal_type;
+static byte _cur_presig_type;
+static bool _cur_autosig_compl;
 
+static const StringID _presig_types_dropdown[] = {
+	STR_SIGNAL_NORMAL,
+	STR_SIGNAL_ENTRANCE,
+	STR_SIGNAL_EXIT,
+	STR_SIGNAL_COMBO,
+	INVALID_STRING_ID
+};
+
 struct {
 	byte orientation;
 	byte numtracks;
@@ -33,6 +44,7 @@
 static void ShowBuildTrainDepotPicker(void);
 static void ShowBuildWaypointPicker(void);
 static void ShowStationBuilder(void);
+static void ShowSignalBuilder(void);
 
 typedef void OnButtonClick(Window *w);
 
@@ -168,8 +180,10 @@
 	if (trackstat != 0) {	while (!(trackstat & 1)) { i++; trackstat >>= 1; }}
 
 	if (!_remove_button_clicked) {
-		DoCommandP(tile, i + (_ctrl_pressed ? 8 : 0), 0, CcPlaySound1E,
-			CMD_BUILD_SIGNALS | CMD_AUTO | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE));
+		DoCommandP(tile, i + (_ctrl_pressed ? 8 : 0) +
+		                 (!HASBIT(_cur_signal_type, 0) != !_ctrl_pressed ? 16 : 0) +
+		                 (_cur_presig_type << 5) ,
+		                 0, CcPlaySound1E, CMD_BUILD_SIGNALS | CMD_AUTO | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE));
 	} else {
 		DoCommandP(tile, i, 0, CcPlaySound1E,
 			CMD_REMOVE_SIGNALS | CMD_AUTO | CMD_MSG(STR_1013_CAN_T_REMOVE_SIGNALS_FROM));
@@ -250,7 +264,8 @@
 
 static void BuildRailClick_Depot(Window *w)
 {
-	if (HandlePlacePushButton(w, 10, _depot_cursors[_cur_railtype], 1, PlaceRail_Depot)) ShowBuildTrainDepotPicker();
+	if (HandlePlacePushButton(w, 10, _depot_cursors[_cur_railtype], 1, PlaceRail_Depot))
+		ShowBuildTrainDepotPicker();
 }
 
 static void BuildRailClick_Waypoint(Window *w)
@@ -268,7 +283,8 @@
 
 static void BuildRailClick_AutoSignals(Window *w)
 {
-	HandlePlacePushButton(w, 13, ANIMCURSOR_BUILDSIGNALS, VHM_RECT, PlaceRail_AutoSignals);
+	if (HandlePlacePushButton(w, 13, ANIMCURSOR_BUILDSIGNALS, VHM_RECT, PlaceRail_AutoSignals))
+		ShowSignalBuilder();
 }
 
 static void BuildRailClick_Bridge(Window *w)
@@ -347,10 +363,11 @@
 	// _patches.drag_signals_density is given as a parameter such that each user in a network
 	// game can specify his/her own signal density
 	DoCommandP(TileVirtXY(thd->selstart.x, thd->selstart.y), TileVirtXY(thd->selend.x, thd->selend.y),
-	(_ctrl_pressed ? 1 << 3 : 0) | (trackstat << 4) | (_patches.drag_signals_density << 24),
-	CcPlaySound1E,
-	(_remove_button_clicked ?	CMD_REMOVE_SIGNAL_TRACK | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1013_CAN_T_REMOVE_SIGNALS_FROM) :
-	                          CMD_BUILD_SIGNAL_TRACK  | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE) ) );
+		(!HASBIT(_cur_signal_type, 0) != !_ctrl_pressed ? 1 << 3 : 0) | (trackstat << 4) |
+		(_patches.drag_signals_density << 24) | (_cur_autosig_compl ? 2 : 0),
+		CcPlaySound1E,
+		(_remove_button_clicked ?	CMD_REMOVE_SIGNAL_TRACK | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1013_CAN_T_REMOVE_SIGNALS_FROM) :
+		                          CMD_BUILD_SIGNAL_TRACK  | CMD_AUTO | CMD_NO_WATER | CMD_MSG(STR_1010_CAN_T_BUILD_SIGNALS_HERE) ) );
 }
 
 static OnButtonClick * const _build_railroad_button_proc[] = {
@@ -470,6 +487,9 @@
 		if (w != NULL) WP(w,def_d).close=true;
 		w = FindWindowById(WC_BUILD_DEPOT, 0);
 		if (w != NULL) WP(w,def_d).close=true;
+		w = FindWindowById(WC_BUILD_SIGNALS, 0);
+		if (w != NULL) WP(w,def_d).close=true;
+
 		break;
 
 	case WE_PLACE_PRESIZE: {
@@ -934,10 +954,123 @@
 }
 
 
+static void BuildSignalWndProc(Window *w, WindowEvent *e)
+{
+	switch(e->event) {
+	case WE_PAINT: {
+		/* XXX TODO: dont always hide the buttons when more than 2 signal types are available */
+		w->hidden_state = (1 << 3) | (1 << 6);
+
+		/* XXX TODO: take into account the scroll position for setting the click state */
+		w->click_state = ((1 << 4) << _cur_signal_type) | (_cur_autosig_compl ? 1 << 9 : 0);
+
+		SetDParam(10, _presig_types_dropdown[_cur_presig_type]);
+		DrawWindowWidgets(w);
+
+		// Draw the string for current signal type
+		DrawStringCentered(69, 49, STR_SIGNAL_TYPE_STANDARD + _cur_signal_type, 0);
+
+		// Draw the strings for drag density
+		DrawStringCentered(69, 60, STR_SIGNAL_DENSITY_DESC, 0);
+		SetDParam(0, _patches.drag_signals_density);
+		DrawString( 50, 71, STR_SIGNAL_DENSITY_TILES , 0);
+
+		// Draw the '<' and '>' characters for the decrease/increase buttons
+		DrawStringCentered(30, 72, STR_6819, 0);
+		DrawStringCentered(40, 72, STR_681A, 0);
+
+		break;
+		}
+	case WE_CLICK: {
+		switch(e->click.widget) {
+			case 3: case 6: // scroll signal types
+				/* XXX TODO: implement scrolling */
+				break;
+			case 4: case 5: // select signal type
+				/* XXX TODO: take into account the scroll position for changing selected type */
+				_cur_signal_type = e->click.widget - 4;
+				SndPlayFx(SND_15_BEEP);
+				SetWindowDirty(w);
+				break;
+			case 7: // decrease drag density
+				if (_patches.drag_signals_density > 1) {
+					_patches.drag_signals_density--;
+					SndPlayFx(SND_15_BEEP);
+					SetWindowDirty(w);
+				};
+				break;
+			case 8: // increase drag density
+				if (_patches.drag_signals_density < 20) {
+					_patches.drag_signals_density++;
+					SndPlayFx(SND_15_BEEP);
+					SetWindowDirty(w);
+				};
+				break;
+			case 9: // autosignal mode toggle button
+				_cur_autosig_compl ^= 1;
+				SndPlayFx(SND_15_BEEP);
+				SetWindowDirty(w);
+				break;
+			case 10: case 11: // presignal-type dropdown list
+				ShowDropDownMenu(w, _presig_types_dropdown, _cur_presig_type, 11, 0, 0);
+				break;
+		}
+		break;
+	case WE_DROPDOWN_SELECT: // change presignal type
+		_cur_presig_type = e->dropdown.index;
+		SetWindowDirty(w);
+		break;
+	}
+
+	case WE_MOUSELOOP:
+		if (WP(w,def_d).close)
+			DeleteWindow(w);
+		return;
+
+	case WE_DESTROY:
+		if (!WP(w,def_d).close)
+			ResetObjectToPlace();
+		break;
+	}
+}
+
+static const Widget _build_signal_widgets[] = {
+{   WWT_CLOSEBOX, RESIZE_NONE,    7,    0,   10,    0,   13, STR_00C5                 , STR_018B_CLOSE_WINDOW},
+{   WWT_CAPTION,  RESIZE_NONE,    7,   11,  139,    0,   13, STR_SIGNAL_SELECTION     , STR_018C_WINDOW_TITLE_DRAG_THIS},
+{   WWT_PANEL,    RESIZE_NONE,    7,    0,  139,   14,  114, 0x0                      , STR_NULL},
+{   WWT_PANEL,    RESIZE_NONE,    7,   22,   30,   29,   39, SPR_ARROW_LEFT           , STR_SIGNAL_TYPE_TIP},
+{   WWT_PANEL,    RESIZE_NONE,    7,   43,   64,   24,   45, 0x50B                    , STR_SIGNAL_TYPE_TIP},
+{   WWT_PANEL,    RESIZE_NONE,    7,   75,   96,   24,   45, SPR_SEMA                 , STR_SIGNAL_TYPE_TIP},
+{   WWT_PANEL,    RESIZE_NONE,    7,  109,  117,   29,   39, SPR_ARROW_RIGHT          , STR_SIGNAL_TYPE_TIP},
+{   WWT_IMGBTN,   RESIZE_NONE,    3,   25,   34,   72,   80, 0x0                      , STR_SIGNAL_DENSITY_TIP},
+{   WWT_IMGBTN,   RESIZE_NONE,    3,   35,   44,   72,   80, 0x0                      , STR_SIGNAL_DENSITY_TIP},
+{   WWT_TEXTBTN,  RESIZE_NONE,    7,   20,  119,   84,   95, STR_SIGNAL_COMPLETION    , STR_SIGNAL_COMPLETION_TIP},
+{   WWT_6,        RESIZE_NONE,    7,   10,  129,   99,  110, STR_SIGNAL_PRESIG_COMBO  , STR_SIGNAL_PRESIG_TIP},
+{   WWT_CLOSEBOX, RESIZE_NONE,    7,  118,  128,  100,  109, STR_0225                 , STR_SIGNAL_PRESIG_TIP},
+{   WIDGETS_END},
+};
+
+static const WindowDesc _build_signal_desc = {
+	-1,-1, 140, 115,
+	WC_BUILD_SIGNALS,WC_BUILD_TOOLBAR,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET,
+	_build_signal_widgets,
+	BuildSignalWndProc
+};
+
+static void ShowSignalBuilder(void)
+{
+	_cur_presig_type = 0;
+	AllocateWindowDesc(&_build_signal_desc);
+}
+
 void InitializeRailGui(void)
 {
 	_build_depot_direction = 3;
 	_railstation.numtracks = 1;
 	_railstation.platlength = 1;
 	_railstation.dragdrop = true;
+	_cur_signal_type = 0;
+	_cur_presig_type = 0;
+	_cur_autosig_compl = false;
 }
Index: settings_gui.c
===================================================================
--- settings_gui.c	(revision 2490)
+++ settings_gui.c	(working copy)
@@ -669,6 +669,7 @@
 
 	{PE_BOOL,		0, STR_CONFIG_PATCHES_SMALL_AIRPORTS,		"always_small_airport", &_patches.always_small_airport,			0,  0,  0, NULL},
 	{PE_UINT8,	PF_PLAYERBASED, STR_CONFIG_PATCHES_DRAG_SIGNALS_DENSITY, "drag_signals_density", &_patches.drag_signals_density, 1, 20,  1, NULL},
+	{PE_BOOL,		0, STR_CONFIG_AUTO_PBS_PLACEMENT, "auto_pbs_placement", &_patches.auto_pbs_placement, 1, 20,  1, NULL},
 
 };
 
@@ -702,6 +703,7 @@
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_AIRCRAFT, "servint_aircraft", &_patches.servint_aircraft, 5,800,  5, &InValidateDetailsWindow},
 	{PE_UINT16, PF_0ISDIS, STR_CONFIG_PATCHES_SERVINT_SHIPS,		"servint_ships",    &_patches.servint_ships,		5,800,  5, &InValidateDetailsWindow},
 	{PE_BOOL,   0,         STR_CONFIG_PATCHES_NOSERVICE,        "no_servicing_if_no_breakdowns", &_patches.no_servicing_if_no_breakdowns, 0, 0, 0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_WAGONSPEEDLIMITS,	"wagon_speed_limits", &_patches.wagon_speed_limits,		0,  0,  0, NULL},
 };
 
 static const PatchEntry _patches_stations[] = {
@@ -715,6 +717,12 @@
 	{PE_BOOL,		0, STR_CONFIG_PATCHES_SERVICEATHELIPAD, "service_at_helipad", &_patches.serviceathelipad,					0,  0,  0, NULL},
 	{PE_BOOL, 0, STR_CONFIG_PATCHES_CATCHMENT, "modified_catchment", &_patches.modified_catchment, 0, 0, 0, NULL},
 
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_SPEED, "nsr_speed", &_patches.nsr_speed,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_AGE, "nsr_age", &_patches.nsr_age,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_TOWN_RATING, "nsr_town_rating", &_patches.nsr_town_rating,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_WAIT_DAYS, "nsr_wait_days", &_patches.nsr_wait_days,					0,  0,  0, NULL},
+	{PE_BOOL,		0, STR_CONFIG_PATCHES_NSR_WAIT_CARGO, "nsr_wait_cargo", &_patches.nsr_wait_cargo,					0,  0,  0, NULL},
+
 };
 
 static const PatchEntry _patches_economy[] = {
@@ -1123,7 +1131,7 @@
 {   WWT_CLOSEBOX,   RESIZE_NONE,    10,     0,    10,     0,    13, STR_00C5,												STR_018B_CLOSE_WINDOW},
 {    WWT_CAPTION,   RESIZE_NONE,    10,    11,   369,     0,    13, STR_CONFIG_PATCHES_CAPTION,			STR_018C_WINDOW_TITLE_DRAG_THIS},
 {      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    14,    41, 0x0,															STR_NULL},
-{      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    42,   320, 0x0,															STR_NULL},
+{      WWT_PANEL,   RESIZE_NONE,    10,     0,   369,    42,   340, 0x0,															STR_NULL},
 
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    10,    96,    16,    27, STR_CONFIG_PATCHES_GUI,					STR_NULL},
 {   WWT_CLOSEBOX,   RESIZE_NONE,     3,    97,   183,    16,    27, STR_CONFIG_PATCHES_CONSTRUCTION,	STR_NULL},
@@ -1135,7 +1143,7 @@
 };
 
 static const WindowDesc _patches_selection_desc = {
-	WDP_CENTER, WDP_CENTER, 370, 321,
+	WDP_CENTER, WDP_CENTER, 370, 341,
 	WC_GAME_OPTIONS,0,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET,
 	_patches_selection_widgets,
Index: ship_gui.c
===================================================================
--- ship_gui.c	(revision 2490)
+++ ship_gui.c	(working copy)
@@ -1,6 +1,7 @@
 #include "stdafx.h"
 #include "openttd.h"
 #include "debug.h"
+#include "table/sprites.h"
 #include "table/strings.h"
 #include "map.h"
 #include "window.h"
@@ -57,7 +58,7 @@
 	y += 10;
 }
 
-static void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection)
+void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	int image = GetShipImage(v, 6);
 	uint32 ormod = SPRITE_PALETTE(PLAYER_SPRITE_COLOR(v->owner));
@@ -315,6 +316,15 @@
 	ShowShipViewWindow(v);
 }
 
+void CcCloneShip(bool success, uint tile, uint32 p1, uint32 p2)
+{
+	Vehicle *v;
+	if (!success) return;
+
+	v = GetVehicle(_new_ship_id);
+	ShowShipViewWindow(v);
+}
+
 static void NewShipWndProc(Window *w, WindowEvent *e)
 {
 	switch(e->event) {
@@ -460,107 +470,125 @@
 
 static void ShipViewWndProc(Window *w, WindowEvent *e) {
 	switch(e->event) {
-	case WE_PAINT: {
-		Vehicle *v = GetVehicle(w->window_number);
-		uint32 disabled = 1<<8;
-		StringID str;
+		case WE_PAINT: {
+			Vehicle *v = GetVehicle(w->window_number);
+			uint32 disabled = 1<<8;
+			StringID str;
 
-		// Possible to refit?
-		if (ShipVehInfo(v->engine_type)->refittable &&
+			// Possible to refit?
+			if (ShipVehInfo(v->engine_type)->refittable &&
 				v->vehstatus&VS_STOPPED &&
 				v->u.ship.state == 0x80 &&
 				IsTileDepotType(v->tile, TRANSPORT_WATER))
-			disabled = 0;
+				disabled = 0;
 
-		if (v->owner != _local_player)
-			disabled |= 1<<8 | 1<<7;
-		w->disabled_state = disabled;
+			if (v->owner != _local_player)
+				disabled |= 1<<8 | 1<<7;
+			w->disabled_state = disabled;
 
-		/* draw widgets & caption */
-		SetDParam(0, v->string_id);
-		SetDParam(1, v->unitnumber);
-		DrawWindowWidgets(w);
+			/* draw widgets & caption */
+			SetDParam(0, v->string_id);
+			SetDParam(1, v->unitnumber);
+			DrawWindowWidgets(w);
 
-		/* draw the flag */
-		DrawSprite(v->vehstatus & VS_STOPPED ? 0xC12 : 0xC13, 2,
-			w->widget[5].top + 1);
+			/* draw the flag */
+			DrawSprite(v->vehstatus & VS_STOPPED ? 0xC12 : 0xC13, 2,
+					   w->widget[5].top + 1);
 
-		if (v->breakdown_ctr == 1) {
-			str = STR_885C_BROKEN_DOWN;
-		} else if (v->vehstatus & VS_STOPPED) {
-			str = STR_8861_STOPPED;
-		} else {
-			switch (v->current_order.type) {
-			case OT_GOTO_STATION: {
-				SetDParam(0, v->current_order.station);
-				SetDParam(1, v->cur_speed * 10 >> 5);
-				str = STR_HEADING_FOR_STATION + _patches.vehicle_speed;
-			} break;
+			if (v->breakdown_ctr == 1) {
+				str = STR_885C_BROKEN_DOWN;
+			} else if (v->vehstatus & VS_STOPPED) {
+				str = STR_8861_STOPPED;
+			} else {
+				switch (v->current_order.type) {
+					case OT_GOTO_STATION: {
+						SetDParam(0, v->current_order.station);
+						SetDParam(1, v->cur_speed * 10 >> 5);
+						str = STR_HEADING_FOR_STATION + _patches.vehicle_speed;
+					} break;
 
-			case OT_GOTO_DEPOT: {
-				Depot *depot = GetDepot(v->current_order.station);
-				SetDParam(0, depot->town_index);
-				SetDParam(1, v->cur_speed * 10 >> 5);
-				str = STR_HEADING_FOR_SHIP_DEPOT + _patches.vehicle_speed;
-			} break;
+					case OT_GOTO_DEPOT: {
+						Depot *depot = GetDepot(v->current_order.station);
+						SetDParam(0, depot->town_index);
+						SetDParam(1, v->cur_speed * 10 >> 5);
+						str = STR_HEADING_FOR_SHIP_DEPOT + _patches.vehicle_speed;
+					} break;
 
-			case OT_LOADING:
-			case OT_LEAVESTATION:
-				str = STR_882F_LOADING_UNLOADING;
-				break;
-
-			default:
-				if (v->num_orders == 0) {
-					str = STR_NO_ORDERS + _patches.vehicle_speed;
-					SetDParam(0, v->cur_speed * 10 >> 5);
-				} else
-					str = STR_EMPTY;
-				break;
+					case OT_LOADING:
+					case OT_LEAVESTATION:
+						str = STR_882F_LOADING_UNLOADING;
+						break;
+						
+					default:
+						if (v->num_orders == 0) {
+							str = STR_NO_ORDERS + _patches.vehicle_speed;
+							SetDParam(0, v->cur_speed * 10 >> 5);
+						} else
+							str = STR_EMPTY;
+						break;
+				}
 			}
-		}
 
-		DrawStringCentered((w->widget[5].right - w->widget[5].left) / 2,
-			w->widget[5].top + 1, str, 0);
-		DrawWindowViewport(w);
-	} break;
+			DrawStringCentered((w->widget[5].right - w->widget[5].left) / 2,
+							   w->widget[5].top + 1, str, 0);
+			DrawWindowViewport(w);
+		} break;
 
-	case WE_CLICK: {
-		Vehicle *v = GetVehicle(w->window_number);
+		case WE_CLICK: {
+			Vehicle *v = GetVehicle(w->window_number);
 
-		switch(e->click.widget) {
-		case 5: /* start stop */
-			DoCommandP(v->tile, v->index, 0, NULL, CMD_START_STOP_SHIP | CMD_MSG(STR_9818_CAN_T_STOP_START_SHIP));
+			switch(e->click.widget) {
+				case 5: /* start stop */
+					DoCommandP(v->tile, v->index, 0, NULL, CMD_START_STOP_SHIP | CMD_MSG(STR_9818_CAN_T_STOP_START_SHIP));
+					break;
+				case 6: /* center main view */
+					ScrollMainWindowTo(v->x_pos, v->y_pos);
+					break;
+				case 7: /* goto hangar */
+					DoCommandP(v->tile, v->index, 0, NULL, CMD_SEND_SHIP_TO_DEPOT | CMD_MSG(STR_9819_CAN_T_SEND_SHIP_TO_DEPOT));
+					break;
+				case 8: /* refit */
+					ShowShipRefitWindow(v);
+					break;
+				case 9: /* show orders */
+					ShowOrdersWindow(v);
+					break;
+				case 10: /* show details */
+					ShowShipDetailsWindow(v);
+					break;
+				case 11: {
+					/* clone vehicle */
+					Vehicle *v;
+					v = GetVehicle(w->window_number);
+					DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0, CcCloneShip, CMD_CLONE_VEHICLE | CMD_MSG(STR_980D_CAN_T_BUILD_SHIP));
+				} break;
+			}
+		} break;
+
+		case WE_RESIZE:
+			w->viewport->width  += e->sizing.diff.x;
+			w->viewport->height += e->sizing.diff.y;
+			w->viewport->virtual_width  += e->sizing.diff.x;
+			w->viewport->virtual_height += e->sizing.diff.y;
 			break;
-		case 6: /* center main view */
-			ScrollMainWindowTo(v->x_pos, v->y_pos);
+
+		case WE_DESTROY:
+			DeleteWindowById(WC_VEHICLE_ORDERS, w->window_number);
+			DeleteWindowById(WC_VEHICLE_REFIT, w->window_number);
+			DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
 			break;
-		case 7: /* goto hangar */
-			DoCommandP(v->tile, v->index, 0, NULL, CMD_SEND_SHIP_TO_DEPOT | CMD_MSG(STR_9819_CAN_T_SEND_SHIP_TO_DEPOT));
-			break;
-		case 8: /* refit */
-			ShowShipRefitWindow(v);
-			break;
-		case 9: /* show orders */
-			ShowOrdersWindow(v);
-			break;
-		case 10: /* show details */
-			ShowShipDetailsWindow(v);
-			break;
+
+		case WE_MOUSELOOP:
+		{
+			Vehicle *v;
+			uint32 h;
+			v = GetVehicle(w->window_number);
+			h = IsTileDepotType(v->tile, TRANSPORT_WATER) && v->vehstatus & VS_HIDDEN ? (1<< 7) : (1 << 11);
+			if (h != w->hidden_state) {
+				w->hidden_state = h;
+				SetWindowDirty(w);
+			}
 		}
-	} break;
-
-	case WE_RESIZE:
-		w->viewport->width  += e->sizing.diff.x;
-		w->viewport->height += e->sizing.diff.y;
-		w->viewport->virtual_width  += e->sizing.diff.x;
-		w->viewport->virtual_height += e->sizing.diff.y;
-		break;
-
-	case WE_DESTROY:
-		DeleteWindowById(WC_VEHICLE_ORDERS, w->window_number);
-		DeleteWindowById(WC_VEHICLE_REFIT, w->window_number);
-		DeleteWindowById(WC_VEHICLE_DETAILS, w->window_number);
-		break;
 	}
 }
 
@@ -576,6 +604,7 @@
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  50,  67, 0x2B4,    STR_983A_REFIT_CARGO_SHIP_TO_CARRY},
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  68,  85, 0x2B2,    STR_9828_SHOW_SHIP_S_ORDERS},
 { WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  86, 103, 0x2B3,    STR_982B_SHOW_SHIP_DETAILS},
+{ WWT_PUSHIMGBTN, RESIZE_LR,    14, 232, 249,  32,  49, 0x0,      STR_NULL},
 { WWT_PANEL,      RESIZE_LRB,   14, 232, 249, 104, 103, 0x0,      STR_NULL },
 { WWT_RESIZEBOX,  RESIZE_LRTB,  14, 238, 249, 104, 115, 0x0,      STR_NULL },
 { WIDGETS_END }
@@ -726,6 +755,39 @@
 	}
 }
 
+/* Clone a road vehicle
+ * v is the vehicle to clone.
+ */
+static bool HandleCloneVehClick(Vehicle *v, Window *w)
+{
+
+	if (!v){
+		return false;
+	}
+
+	if (v->type != VEH_Ship) {
+		// it's not a train, Do Nothing
+		return false;
+	}
+
+
+    DoCommandP(w->window_number, v->index, _ctrl_pressed ? 1 : 0,CcCloneShip,CMD_CLONE_VEHICLE | CMD_MSG(STR_882B_CAN_T_BUILD_RAILROAD_VEHICLE));
+
+	ResetObjectToPlace();
+
+	return true;
+}
+
+static void ClonePlaceObj(uint tile, Window *w)
+{
+	Vehicle *v;
+
+
+	v = CheckMouseOverVehicle();
+	if (v && HandleCloneVehClick(v, w))
+		return;
+}
+
 static void ShipDepotWndProc(Window *w, WindowEvent *e) {
 	switch(e->event) {
 	case WE_PAINT:
@@ -741,13 +803,43 @@
 		case 7:
 			ShowBuildShipWindow(w->window_number);
 			break;
+			
+			case 8: /* clone button */
+			InvalidateWidget(w, 8);
+				TOGGLEBIT(w->click_state, 8);
+				
+				if (HASBIT(w->click_state, 8)) {
+					_place_clicked_vehicle = NULL;
+					SetObjectToPlaceWnd(ANIMCURSOR_PICKSTATION, 1, w);
+				} else {
+					ResetObjectToPlace();
+				}
+					break;
 
-		case 8: /* scroll to tile */
+		case 9: /* scroll to tile */
 			ScrollMainWindowToTile(w->window_number);
 			break;
 		}
 		break;
+		
+		case WE_PLACE_OBJ: {
+		ClonePlaceObj(e->place.tile, w);
+	} break;
 
+	case WE_ABORT_PLACE_OBJ: {
+		CLRBIT(w->click_state, 8);
+		InvalidateWidget(w, 8);
+	} break;
+	
+	// check if a vehicle in a depot was clicked..
+	case WE_MOUSELOOP: {
+		Vehicle *v = _place_clicked_vehicle;
+		if (v) {
+			_place_clicked_vehicle = NULL;
+			HandleCloneVehClick( v, w);
+		}
+	} break;
+
 	case WE_DESTROY:
 		DeleteWindowById(WC_BUILD_VEHICLE, w->window_number);
 		break;
@@ -810,8 +902,9 @@
 
 {     WWT_MATRIX,     RESIZE_RB,    14,     0,   269,    14,    61, 0x203,									STR_981F_SHIPS_CLICK_ON_SHIP_FOR},
 {  WWT_SCROLLBAR,    RESIZE_LRB,    14,   293,   304,    14,    61, 0x0,										STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,   146,    62,    73, STR_9804_NEW_SHIPS,			STR_9820_BUILD_NEW_SHIP},
-{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   147,   292,    62,    73, STR_00E4_LOCATION,			STR_9822_CENTER_MAIN_VIEW_ON_SHIP},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,     0,    96,    62,    73, STR_9804_NEW_SHIPS,			STR_9820_BUILD_NEW_SHIP},
+{WWT_NODISTXTBTN,     RESIZE_TB,    14,    97,   194,    62,    73, STR_8815_NEW_VEHICLES,		STR_NULL},
+{ WWT_PUSHTXTBTN,     RESIZE_TB,    14,   195,   292,    62,    73, STR_00E4_LOCATION,			STR_9822_CENTER_MAIN_VIEW_ON_SHIP},
 {      WWT_PANEL,    RESIZE_RTB,    14,   293,   292,    62,    73, 0x0,													STR_NULL},
 {  WWT_RESIZEBOX,   RESIZE_LRTB,    14,   293,   304,    62,    73, 0x0,										STR_RESIZE_BUTTON},
 {   WIDGETS_END},
@@ -915,7 +1008,7 @@
 		int max;
 		int i;
 
-		BuildVehicleList(vl, VEH_Ship, owner, station);
+		BuildVehicleListMasked(vl, &w->listopt, owner);
 		SortVehicleList(vl);
 
 		SetVScrollCount(w, vl->list_length);
@@ -1110,6 +1203,13 @@
 		w = AllocateWindowDescFront(&_other_player_ships_desc, (station << 16) | player);
 	}
 	if (w) {
+		w->listopt.cargo_mask = CARGO_MASK_ALL;
+		w->listopt.type_mask = 1 << VEH_Ship;
+		if (station != INVALID_STATION)
+			w->listopt.xy = GetStation(station)->xy;
+		else
+			w->listopt.xy = INVALID_TILE;
+
 		w->caption_color = w->window_number;
 		w->vscroll.cap = 4;
 		w->widget[7].unkA = (w->vscroll.cap << 8) + 1;
Index: window.h
===================================================================
--- window.h	(revision 2490)
+++ window.h	(working copy)
@@ -307,6 +307,8 @@
 
 	Message message;
 	byte custom[WINDOW_CUSTOM_SIZE];
+	
+	DisplayListOption listopt; // Options for displaying vehicle-lists
 };
 
 typedef struct {
Index: command.c
===================================================================
--- command.c	(revision 2490)
+++ command.c	(working copy)
@@ -155,6 +155,11 @@
 
 DEF_COMMAND(CmdReplaceVehicle);
 
+DEF_COMMAND(CmdResetStationCheat);
+
+DEF_COMMAND(CmdCloneVehicle);
+
+
 /* The master command table */
 static const Command _command_proc_table[] = {
 	{CmdBuildRailroadTrack,                  0}, /*   0 */
@@ -296,6 +301,10 @@
 	{CmdGiveMoney,                           0}, /* 113 */
 	{CmdChangePatchSetting,         CMD_SERVER}, /* 114 */
 	{CmdReplaceVehicle,                      0}, /* 115 */
+
+	{CmdResetStationCheat,                   0}, /* 116 */
+	
+	{CmdCloneVehicle,                        0}  /* 117 */	
 };
 
 /* This function range-checks a cmd, and checks if the cmd is not NULL */
@@ -442,7 +451,12 @@
 	// road fragments still stay there and the town won't let you
 	// disconnect the road system), but the exec will succeed and this
 	// fact will trigger an assertion failure. --pasky
+	// CMD_BUILD_SIGNAL_TRACK: With autosignal completion, it could happen
+	// 2 parts of a tile with 2 signals both get changed to semaphores (or back)
+	// cause the semaphore/normal status is stored per-tile, the real run will
+	// only charge you once for changing, but the test run will charge you twice
 	notest =
+		(cmd & 0xFF) == CMD_BUILD_SIGNAL_TRACK ||
 		(cmd & 0xFF) == CMD_CLEAR_AREA ||
 		(cmd & 0xFF) == CMD_CONVERT_RAIL ||
 		(cmd & 0xFF) == CMD_LEVEL_LAND ||
Index: command.h
===================================================================
--- command.h	(revision 2490)
+++ command.h	(working copy)
@@ -134,6 +134,10 @@
 	CMD_CHANGE_PATCH_SETTING = 114,
 
 	CMD_REPLACE_VEHICLE = 115,
+
+	CMD_RESET_STATION_CHEAT = 116,
+	
+	CMD_CLONE_VEHICLE = 116,	
 };
 
 enum {
Index: newgrf.c
===================================================================
--- newgrf.c	(revision 2490)
+++ newgrf.c	(working copy)
@@ -217,8 +217,10 @@
 			FOR_EACH_OBJECT {
 				uint16 speed = grf_load_word(&buf);
 
+				// we store 'no speed limit' as a speed of 0
+				if (speed == 0xFFFF) speed = 0;
+
 				rvi[i].max_speed = speed;
-				dewagonize(speed, engine + i);
 			}
 		} break;
 		case 0x0B: { /* Power */
@@ -357,6 +359,13 @@
 				rvi[i].callbackmask = callbacks;
 			}
 		} break;
+		case 0x1F: {	/* Tractive effort */
+			FOR_EACH_OBJECT {
+				int8 TE_coeff = grf_load_byte(&buf);
+
+				rvi[i].TE_coeff = TE_coeff;
+			}
+		}	break;
 		case 0x21: { /* Shorter vehicle */
 			FOR_EACH_OBJECT {
 				byte shorten_factor = grf_load_byte(&buf);
@@ -383,7 +392,6 @@
 		/* Fall-through for unimplemented one byte long properties. */
 		case 0x1A:	/* Sort order */
 		case 0x1C:	/* Refit cost */
-		case 0x1F:	/* Tractive effort */
 		case 0x20:	/* Air drag */
 		case 0x24:	/* High byte of vehicle weight */
 		case 0x25:	/* User-defined bit mask to set when checking veh. var. 42 */
@@ -2076,7 +2084,8 @@
 
 	_ttdpatch_flags[2] = (1 << 0x0D)  /* buildonslopes */
 	                   | (1 << 0x16)  /* canals */
-	                   | (1 << 0x17); /* newstartyear */
+	                   | (1 << 0x17)  /* newstartyear */
+	                   | (_patches.wagon_speed_limits ? (1 << 0x1D) : 0); /* wagonspeedlimits */
 }
 
 void InitNewGRFFile(const char *filename, int sprite_offset)
